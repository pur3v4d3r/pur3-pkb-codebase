---
aliases:
  - Object-Level Cognition
  - object-level cognition
tags:
  - type/permanent
  - year/2025
  - type/technique
  - status/budding
  - cognitive-psychology
  - cognitive-science
  - processing-workflow
  - cognitive-science/attention
  - learning-processes
  - information-processing-theory
  - perception
  - inhibitory-control
  - concept/atomic-notes
source: claude-opus-4.1
id: "20251212234822"
created: 2025-12-12T23:48:22
modified: 2025-12-12T23:48:22
week: "[[2025-W50]]"
month: "[[2025-12]]"
quarter: "[[2025-Q4]]"
year: "[[2025]]"
type: definition
maturity: seedling
confidence: speculative
next-review: 2025-12-19
link-up:
  - "[[99-archive/05-moc's/cognitive-science-moc]]"
link-related:
  - "[[2025-12-12|Daily-Note]]"
status: active


review-last-reviewed: null
review-next-review: 2025-12-17
review-count: 0
review-interval: 3

review-priority: medium
---

> [!overview] ### <span style='color: #7200ff;'>Overview</span>
> - **Title**: [[Object-Level Cognition]]
> - **MOC**: `=this.link-up`

```dataviewjs
// SYSTEM: Enhanced Semantic Bridge Engine v2.0
// PURPOSE: Find "Sibling" notes that share the same Outlinks (Contexts) with advanced analytics

const current = dv.current();
const myOutlinks = current.file.outlinks?.map(l => l.path) || [];

// Performance optimization: Create Set for faster lookups
const myOutlinkSet = new Set(myOutlinks);
const currentPath = current.file.path;

// Advanced sibling analysis with metadata
let siblings = [];

try {
  siblings = dv.pages()
    .where(p => {
      // Safety checks
      if (!p.file?.path || p.file.path === currentPath) return false;
      // Exclude already linked notes
      if (current.file.outlinks?.some(l => l.path === p.file.path)) return false;
      return true;
    })
    .map(p => {
      try {
        // Calculate shared connections
        const shared = p.file.outlinks?.filter(l => myOutlinkSet.has(l.path)) || [];
        const sharedCount = shared.length;
        
        // Calculate similarity score (0-100%)
        const totalConnections = myOutlinks.length + (p.file.outlinks?.length || 0);
        const similarityScore = totalConnections > 0 ? Math.round((sharedCount * 2 / totalConnections) * 100) : 0;
        
        return { 
          link: p.file.link, 
          sharedCount, 
          sharedLinks: shared,
          similarityScore,
          maturity: p.maturity || "unset",
          type: p.type || "unknown",
          lastModified: p.file.mtime
        };
      } catch (e) {
        console.warn("Error processing page:", p.file?.path, e);
        return null;
      }
    })
    .where(p => p && p.sharedCount > 0)
    .sort(p => p.similarityScore, "desc")
    .limit(8);
    
  // Ensure siblings is an array
  if (!Array.isArray(siblings)) {
    siblings = [];
  }
} catch (e) {
  console.error("Error building siblings:", e);
  siblings = [];
}

// Render enhanced semantic bridges
if (siblings.length > 0) {
  dv.header(3, "üîó Semantic Bridges (Missing Connections)");
  
  // Add summary statistics with error handling
  try {
    const totalSharedConnections = siblings.reduce((sum, s) => sum + (s.sharedCount || 0), 0);
    const avgSimilarity = siblings.length > 0 ? 
      Math.round(siblings.reduce((sum, s) => sum + (s.similarityScore || 0), 0) / siblings.length) : 0;
    
    dv.paragraph(`**Found ${siblings.length} semantic siblings** ‚Ä¢ Total shared: ${totalSharedConnections} connections ‚Ä¢ Avg. similarity: ${avgSimilarity}%`);
  } catch (e) {
    console.warn("Error calculating sibling statistics:", e);
    dv.paragraph(`**Found ${siblings.length} semantic siblings**`);
  }
  
  dv.table(
    ["Note", "Similarity", "Strength", "Maturity", "Type", "Shared Context"], 
    siblings.map(s => [
      s.link, 
      `üìä${s.similarityScore || 0}%`,
      "üîó" + (s.sharedCount || 0), 
      s.maturity === "evergreen" ? "üå≥" + s.maturity : 
      s.maturity === "budding" ? "üåø" + s.maturity :
      s.maturity === "developing" ? "üå±" + s.maturity :
      s.maturity === "seedling" ? "Â§ßË±Ü" + s.maturity : "‚ùìunset",
      s.type || "unknown",
      s.sharedLinks?.slice(0, 2).map(l => l.displayName || l.path).join(", ") + ((s.sharedLinks?.length || 0) > 2 ? "‚Ä¶" : "") || ""
    ])
  );
} else {
  dv.paragraph("*No semantic siblings found. This note is unique in its connections.*");
}

// DOMAIN COVERAGE: Advanced domain analysis
const myTags = current.tags || [];
const primaryDomain = myTags.find(t => typeof t === "string" && t.includes("/"))?.split("/")[0] 
                   || myTags.find(t => typeof t === "string");

if (primaryDomain) {
  let domainNotes = [];
  try {
    domainNotes = dv.pages()
      .where(p => 
        p.tags && 
        Array.isArray(p.tags) && 
        p.tags.some(t => 
          typeof t === "string" && 
          (t.startsWith(primaryDomain) || t === primaryDomain)
        )
      );
  } catch (e) {
    console.warn("Error filtering domain notes:", e);
    domainNotes = [];
  }
   
  const maturityDistribution = {
    evergreen: domainNotes.filter(p => p.maturity === "evergreen").length,
    budding: domainNotes.filter(p => p.maturity === "budding").length,
    developing: domainNotes.filter(p => p.maturity === "developing").length,
    seedling: domainNotes.filter(p => p.maturity === "seedling").length,
    unset: domainNotes.filter(p => !p.maturity).length
  };

  // Advanced domain health metrics
  const totalNotes = domainNotes.length;
  const matureNotes = maturityDistribution.evergreen + maturityDistribution.budding;
  const coverage = totalNotes > 0 ? Math.round((matureNotes / totalNotes) * 100) : 0;
  
  // Domain activity score (based on recent modifications)
  const recentNotes = domainNotes.filter(p => {
    try {
      const daysOld = (new Date() - new Date(p.file.mtime)) / (1000 * 60 * 60 * 24);
      return daysOld < 30;
    } catch (e) {
      return false;
    }
  }).length;
  const activityScore = totalNotes > 0 ? Math.round((recentNotes / totalNotes) * 100) : 0;

  dv.header(3, `üìÇ Domain Analysis: ${primaryDomain}`);
  dv.paragraph(`**Total notes**: ${totalNotes} | **Recent activity**: ${activityScore}% (30d)`);
  dv.paragraph(`**Maturity breakdown**: üå≥${maturityDistribution.evergreen} | üåø${maturityDistribution.budding} | üå±${maturityDistribution.developing} | üå∞${maturityDistribution.seedling} | ‚ùì${maturityDistribution.unset}`);
  dv.paragraph(`**Domain health**: ${coverage}% mature (evergreen + budding)`);
  
  // Domain health indicator
  const healthIndicator = coverage >= 80 ? "üü¢ Excellent" : 
                         coverage >= 60 ? "üü° Good" : 
                         coverage >= 40 ? "üü† Fair" : "üî¥ Poor";
  dv.paragraph(`**Health status**: ${healthIndicator}`);
}

// NETWORK INTELLIGENCE: Advanced connectivity analysis
const inlinks = current.file.inlinks || [];
const outlinks = current.file.outlinks || [];

dv.header(3, "üï∏Ô∏è Network Intelligence");
const networkMetrics = [
  ["**Metric**", "**Value**", "**Insight**"],
  ["In-links", inlinks.length, inlinks.length > 10 ? "‚ö° Hub" : inlinks.length > 0 ? "üå± Node" : "üï∏Ô∏è Orphan"],
  ["Out-links", outlinks.length, outlinks.length > 15 ? "üó∫Ô∏è Explorer" : outlinks.length > 5 ? "üß≠ Navigator" : "üéØ Focused"],
  ["Link Ratio", outlinks.length > 0 ? (inlinks.length / outlinks.length).toFixed(1) : "‚àû", 
   outlinks.length > 0 && inlinks.length / outlinks.length > 2 ? "üìà High authority" : "üìä Balanced"]
];

dv.table(networkMetrics[0], networkMetrics.slice(1));

// TEMPORAL ANALYSIS: Content aging and review patterns
dv.header(3, "‚è∞ Temporal Intelligence");
try {
  const created = current.file.ctime;
  const modified = current.file.mtime;
  const ageDays = Math.floor((new Date() - new Date(created)) / (1000 * 60 * 60 * 24));
  const stalenessDays = Math.floor((new Date() - new Date(modified)) / (1000 * 60 * 60 * 24));

  const reviewInsights = [];
  if (current["review-count"] > 5) reviewInsights.push("üîÅ Well-reviewed");
  if (stalenessDays > 180) reviewInsights.push("‚è∞ Needs refresh");
  if (ageDays < 30) reviewInsights.push("üÜï New content");

  dv.paragraph(`**Age**: ${ageDays} days | **Staleness**: ${stalenessDays} days`);
  dv.paragraph(`**Review status**: ${current["review-count"] || 0} reviews | ${reviewInsights.join(" ‚Ä¢ ") || "üìù Standard"}`);
} catch (e) {
  console.warn("Error in temporal analysis:", e);
  dv.paragraph("*Temporal analysis unavailable*");
}
```
> [!abstract] ### üè∑Ô∏è Tag Intelligence
> **Tag Count**: `= length(this.tags)` | **Unique Domains**: `= length(filter(this.tags, (t) => contains(t, "/")))` hierarchical tags
> **Tag Density**: `= choice(length(this.tags) < 3, "‚ö†Ô∏èSparse", choice(length(this.tags) > 10, "üìöRich", "‚úÖBalanced"))`
> > 
> > ---
> 
> ```dataviewjs
> // TAG CO-OCCURRENCE: Find notes sharing the most tags with this note
> const current = dv.current();
> 
> // Safely get tags from current note
> let myTags = [];
> if (current.tags) {
>     if (Array.isArray(current.tags)) {
>         myTags = current.tags;
>     } else if (typeof current.tags === 'string') {
>         myTags = [current.tags];
>     }
> }
> 
> if (myTags.length > 0) {
>     const tagSiblings = dv.pages()
>         .where(p => p.file.path !== current.file.path)
>         .where(p => {
>             // Safely check if page has tags
>             if (!p.tags) return false;
>             // Convert tags to array if needed
>             let pageTags = [];
>             if (Array.isArray(p.tags)) {
>                 pageTags = p.tags;
>             } else if (typeof p.tags === 'string') {
>                 pageTags = [p.tags];
>             }
>             return pageTags.length > 0;
>         })
>         .map(p => {
>             // Safely convert page tags to array
>             let pageTags = [];
>             if (p.tags) {
>                 if (Array.isArray(p.tags)) {
>                     pageTags = p.tags;
>                 } else if (typeof p.tags === 'string') {
>                     pageTags = [p.tags];
>                 }
>             }
>             
>             // Find shared tags
>             const sharedTags = pageTags.filter(t => {
>                 if (typeof t === 'string') {
>                     return myTags.includes(t);
>                 } else if (t && typeof t === 'object' && t.path) {
>                     // Handle tag objects
>                     return myTags.some(myTag => {
>                         if (typeof myTag === 'string') {
>                             return myTag === t.path;
>                         }
>                         return false;
>                     });
>                 }
>                 return false;
>             });
>             
>             return {
>                 link: p.file.link,
>                 sharedCount: sharedTags.length,
>                 sharedTags: sharedTags,
>                 totalTags: pageTags.length
>             };
>         })
>         .where(p => p.sharedCount >= 2) // At least 2 shared tags
>         .sort(p => p.sharedCount, "desc")
>         .limit(5);
> 
>     if (tagSiblings.length > 0) {
>         dv.header(5, "üè∑Ô∏è Tag Siblings (Shared Taxonomy)");
>         dv.table(
>             ["Note", "Overlap", "Shared Tags"],
>             tagSiblings.map(s => {
>                 // Safely extract tag names for display
>                 let displayTags = s.sharedTags.map(t => {
>                     if (typeof t === 'string') {
>                         return t;
>                     } else if (t && typeof t === 'object' && t.path) {
>                         return t.path;
>                     }
>                     return String(t);
>                 });
>                 
>                 return [
>                     s.link,
>                     s.sharedCount + "/" + s.totalTags,
>                     displayTags.slice(0, 3).join(", ") + (s.sharedCount > 3 ? "‚Ä¶" : "")
>                 ];
>             })
>         );
>     } else {
>         dv.paragraph("*No tag siblings with 2+ shared tags found.*");
>     }
> } else {
>     dv.paragraph("*No tags on this note to analyze.*");
> }
> ```

---
# Foundational Understanding
> [!definition] # Definition
> [**Object-Level Cognition**:refers to the direct processing of information and engagement with the subject matter itself. It involves thinking *about* the content, details, facts, and immediate operations related to a task or problem. This is the "doing" of cognitive work, where attention is focused on the specifics of the task at hand rather than on the process of thinking itself.]
> 
> ##### [‚úÖ`= dateformat(this.file.ctime, "MMMM dd, yyyy")` - Initial Creation]
>

> [! ] # Outline
> 
> ### Object-Level Cognition
> - **Definition**
>     - Directly processing information about specific objects, entities, or phenomena
>     - Focus on the "what" and "how" of a concrete situation
>     - Involves immediate sensory input and direct interpretation
> - **Characteristics**
>     - **Concrete:** Deals with specific, observable instances
>     - **Contextual:** Heavily influenced by the immediate environment and current task
>     - **Action-Oriented:** Often precedes or accompanies direct interaction with the environment
>     - **Domain-Specific:** Operates within a particular field of knowledge or activity
>     - **Fast/Automatic (often):** Can be very rapid, especially with practice or familiar stimuli
> - **Distinction from Meta-Level Cognition**
>     - **Object-Level:** Cognition *about* the task/information itself (e.g., solving a math problem)
>     - **Meta-Level:** Cognition *about your own cognition* of the task/information (e.g., monitoring your understanding of the math problem, choosing a strategy)
> - **Examples**
>     - **Perception:**
>         - Recognizing a face
>         - Identifying an object's color or shape
>         - Hearing a specific sound
>     - **Problem Solving:**
>         - Calculating the sum of two numbers
>         - Identifying the next move in a chess game
>         - Debugging a line of code
>     - **Language Processing:**
>         - Understanding the meaning of a sentence
>         - Recalling a specific word
>     - **Motor Skills:**
>         - Gripping a pen
>         - Stepping over an obstacle
> - **Role in Learning and Performance**
>     - Foundation for acquiring new skills and knowledge
>     - Essential for successful execution of tasks
>     - Precedes and informs meta-cognitive regulation
> - **Applications**
>     - **Artificial Intelligence:** AI systems often operate at an object level when performing tasks like image recognition, natural language understanding, or robotic control.
>     - **Human-Computer Interaction:** Designing interfaces that facilitate clear object-level processing for users.
>     - **Education:** Focusing on direct instruction and practice of specific skills.

>[! ]  ## Distinction from Meta-Cognition
> Object-level cognition is often contrasted with **meta-cognition**, which is "thinking about thinking." While object-level cognition focuses on *what* to do or *what* to understand, meta-cognition focuses on *how* to do it, *how* to learn, and *how* to monitor one's own cognitive processes.
> 
> | Feature             | Object-Level Cognition                                | Meta-Cognition                                             |
> | :------------------ | :---------------------------------------------------- | :--------------------------------------------------------- |
> | **Focus**           | The task, problem, or content itself                  | One's own cognitive processes, strategies, and understanding |
> | **Question Asked**  | "What is the answer?" "What does this mean?"         | "How should I approach this?" "Am I understanding this?"   |
> | **Activity**        | Calculating, reading, writing, solving, analyzing     | Planning, monitoring, evaluating, reflecting, strategizing   |
> | **Example Scenario**| Solving a Sudoku puzzle                               | Deciding which Sudoku strategy to use and tracking progress |
> 
> Both are crucial for effective learning and problem-solving, often working in tandem. Object-level cognition provides the raw material and direct engagement, while meta-cognition guides and optimizes the process.
> >[! ]  #### Examples
> > *   **Solving a Math Problem**: Calculating the sum of two numbers, deriving an equation, or applying a specific formula.
> > *   **Writing Code**: Implementing a function, debugging a specific line of code, or structuring data.
> > *   **Reading Comprehension**: Understanding the meaning of a sentence, identifying the main argument of a paragraph, or recalling specific facts from a text.
> > *   **Playing Chess**: Deciding the next move based on board position, piece values, and immediate tactical considerations.
> > *   **Diagnosing a Mechanical Issue**: Identifying a faulty component in an engine, following a diagnostic checklist, or interpreting sensor readings.
> > *   **Learning a Language**: Memorizing vocabulary, conjugating verbs, or constructing a grammatically correct sentence.
> >  
>
> ### Characteristics
> *   **Direct Engagement**: Focused on the actual content, data, or subject.
> *   **Task-Oriented**: Concentrates on completing a specific task or solving a particular problem.
> *   **Specific Details**: Deals with the concrete elements, facts, rules, and procedures relevant to the immediate situation.
> *   **Execution**: Involves the application of knowledge, skills, and strategies to manipulate the information directly.
> *   **Immediate Output**: Aims to produce a direct result or understanding related to the task's content.


> [! ] # Importance and Benefits
> *   **Execution**: Essential for carrying out tasks and achieving direct results.
> *   **Foundation**: Forms the basis for knowledge acquisition and skill development.
> *   **Problem-Solving**: Enables direct engagement with problems to find solutions.
> *   **Efficiency**: Allows for focused attention on immediate tasks without distraction by self-monitoring, when appropriate.
> 
> >[! ] ## Cultivating Object-Level Cognition
> *   **Deep Work**: Dedicate uninterrupted time to intensely focus on a single task.
> *   **Active Learning**: Engage directly with material through summarization, explanation, or problem-solving without external aids.
> *   **Practice and Repetition**: Regularly engage in tasks that require direct application of skills and knowledge.
> *   **Mindfulness of Task**: Consciously direct attention to the specific details and operations required by the task.
>
> >[! ] ## Challenges and Limitations
> Relying solely on object-level cognition can lead to:
> *   **Getting Stuck**: Without meta-cognitive reflection, one might repeatedly try the same unsuccessful approach.
> *   **Lack of Self-Correction**: Difficulty recognizing when a strategy is ineffective or when understanding is incomplete.
> *   **Inefficient Learning**: Without planning or evaluation, learning might be less strategic and more haphazard.
> *   **Missing the Bigger Picture**: Over-focus on details can obscure broader goals or alternative perspectives.

>[! ] # Conclusion
> Object-level cognition is the fundamental mode of thinking that allows us to interact directly with the world, process information, and execute tasks. While powerful and indispensable, its effectiveness is often maximized when integrated with meta-cognitive strategies that allow for planning, monitoring, and evaluation, thereby creating a robust and adaptive cognitive system.


>[! ] ### üîóBacklinks & Connections
> ```dataview
> TABLE 
>     type AS "Type",
>     maturity AS "Maturity",
>     created AS "Created"
> FROM [[#]]
> SORT created DESC
> LIMIT 15
> ```

> [!warning] ### üìÖ Review Intelligence
> **Next Review**: `= this.next-review` | **Review Count**: `= this.review-count`
> **Review Status**: `= choice(this.next-review < date(today), "üî¥ OVERDUE", choice(this.next-review = date(today), "üü° Due Today", choice(dateformat(this.next-review, "yyyy-MM-dd") <= dateformat(date(today) + dur(7 days), "yyyy-MM-dd"), "üü¢ This Week", "‚ö™ Scheduled")))`
> **Days Until Review**: `= choice(this.next-review, (this.next-review - date(today)).days + " days", "Not scheduled")

> [!abstract] ### üè∑Ô∏è Tag Intelligence
> **Tag Count**: `= length(this.tags)` | **Unique Domains**: `= length(filter(this.tags, (t) => contains(t, "/")))` hierarchical tags
> **Tag Density**: `= choice(length(this.tags) < 3, "‚ö†Ô∏èSparse", choice(length(this.tags) > 10, "üìöRich", "‚úÖBalanced"))`
> 
> ---
> 
> ```dataviewjs
> // TAG CO-OCCURRENCE: Find notes sharing the most tags with this note
> const current = dv.current();
> 
> // Safely get tags from current note
> let myTags = [];
> if (current.tags) {
>     if (Array.isArray(current.tags)) {
>         myTags = current.tags;
>     } else if (typeof current.tags === 'string') {
>         myTags = [current.tags];
>     }
> }
> 
> if (myTags.length > 0) {
>     const tagSiblings = dv.pages()
>         .where(p => p.file.path !== current.file.path)
>         .where(p => {
>             // Safely check if page has tags
>             if (!p.tags) return false;
>             // Convert tags to array if needed
>             let pageTags = [];
>             if (Array.isArray(p.tags)) {
>                 pageTags = p.tags;
>             } else if (typeof p.tags === 'string') {
>                 pageTags = [p.tags];
>             }
>             return pageTags.length > 0;
>         })
>         .map(p => {
>             // Safely convert page tags to array
>             let pageTags = [];
>             if (p.tags) {
>                 if (Array.isArray(p.tags)) {
>                     pageTags = p.tags;
>                 } else if (typeof p.tags === 'string') {
>                     pageTags = [p.tags];
>                 }
>             }
>             
>             // Find shared tags
>             const sharedTags = pageTags.filter(t => {
>                 if (typeof t === 'string') {
>                     return myTags.includes(t);
>                 } else if (t && typeof t === 'object' && t.path) {
>                     // Handle tag objects
>                     return myTags.some(myTag => {
>                         if (typeof myTag === 'string') {
>                             return myTag === t.path;
>                         }
>                         return false;
>                     });
>                 }
>                 return false;
>             });
>             
>             return {
>                 link: p.file.link,
>                 sharedCount: sharedTags.length,
>                 sharedTags: sharedTags,
>                 totalTags: pageTags.length
>             };
>         })
>         .where(p => p.sharedCount >= 2) // At least 2 shared tags
>         .sort(p => p.sharedCount, "desc")
>         .limit(5);
> 
>     if (tagSiblings.length > 0) {
>         dv.header(5, "üè∑Ô∏è Tag Siblings (Shared Taxonomy)");
>         dv.table(
>             ["Note", "Overlap", "Shared Tags"],
>             tagSiblings.map(s => {
>                 // Safely extract tag names for display
>                 let displayTags = s.sharedTags.map(t => {
>                     if (typeof t === 'string') {
>                         return t;
>                     } else if (t && typeof t === 'object' && t.path) {
>                         return t.path;
>                     }
>                     return String(t);
>                 });
>                 
>                 return [
>                     s.link,
>                     s.sharedCount + "/" + s.totalTags,
>                     displayTags.slice(0, 3).join(", ") + (s.sharedCount > 3 ? "‚Ä¶" : "")
>                 ];
>             })
>         );
>     } else {
>         dv.paragraph("*No tag siblings with 2+ shared tags found.*");
>     }
> } else {
>     dv.paragraph("*No tags on this note to analyze.*");
> }
> ```
---

### üìñ Extracted Definitions From Cognitive Science
```dataviewjs
try {
  // Configuration
  const folderPath = "03-notes/01_permanent-notes/01_cognitive-development"; // Change this to your folder
  
  // Get all pages from the specified folder
  const pages = dv.pages(`"${folderPath}"`);
  
  // Storage for all definitions across files
  let allDefinitions = [];
  
  // Process each file
  for (let page of pages) {
    try {
      const content = await dv.io.load(page.file.path);
      const bracketedFieldRegex = /\[\*\*([^*]+?)\*\*::\s*([^\]]+?)\]/g;
       
      let match;
      while ((match = bracketedFieldRegex.exec(content)) !== null) {
        allDefinitions.push({
          source: page.file.link,
          key: match[1].trim(), // This is the clean term without ** markdown
          value: match[2].trim()
        });
      }
    } catch (e) {
      console.warn(`Error processing file ${page.file.path}:`, e);
      continue;
    }
  }
  
  // Display aggregated results
  if (allDefinitions.length > 0) {
    dv.header(3, `üìö All Definitions Across ${folderPath} (${allDefinitions.length} total)`);
    
    // Group by first letter (using the clean key)
    const grouped = {};
    allDefinitions.forEach(d => {
      const firstLetter = d.key[0].toUpperCase();
      if (!grouped[firstLetter]) grouped[firstLetter] = [];
      grouped[firstLetter].push(d);
    });
    
    // Sort letters alphabetically
    const sortedLetters = Object.keys(grouped).sort();
    
    // Display grouped results
    for (let letter of sortedLetters) {
      dv.header(4, `${letter} (${grouped[letter].length} terms)`);
      dv.table(
        ["üìÑ Source", "üîë Term", "üìù Definition"],
        grouped[letter].map(d => [
          d.source,
          `**${d.key}**`,
          d.value
        ])
      );
      dv.paragraph(""); // Add spacing between groups
    }
    
  } else {
    dv.paragraph(`*No bracketed inline fields found in "${folderPath}".*`);
  }
  
} catch (error) {
  console.error("Error in definitions aggregation script:", error);
  dv.paragraph("*Error loading definitions. Check console for details.*");
}
```


---
