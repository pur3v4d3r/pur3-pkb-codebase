var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __commonJS = (cb, mod) => function __require() {
return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
for (var name in all)
__defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
if (from && typeof from === "object" || typeof from === "function") {
for (let key of __getOwnPropNames(from))
if (!__hasOwnProp.call(to, key) && key !== except)
__defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
}
return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

var require_base64_js = __commonJS({
"node_modules/obsidian-smart-env/node_modules/base64-js/index.js"(exports2) {
"use strict";
exports2.byteLength = byteLength;
exports2.toByteArray = toByteArray;
exports2.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (i = 0, len = code.length; i < len; ++i) {
lookup[i] = code[i];
revLookup[code.charCodeAt(i)] = i;
}
var i;
var len;
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
var len2 = b64.length;
if (len2 % 4 > 0) {
throw new Error("Invalid string. Length must be a multiple of 4");
}
var validLen = b64.indexOf("=");
if (validLen === -1) validLen = len2;
var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
return [validLen, placeHoldersLen];
}
__name(getLens, "getLens");
function byteLength(b64) {
var lens = getLens(b64);
var validLen = lens[0];
var placeHoldersLen = lens[1];
return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
__name(byteLength, "byteLength");
function _byteLength(b64, validLen, placeHoldersLen) {
return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
__name(_byteLength, "_byteLength");
function toByteArray(b64) {
var tmp;
var lens = getLens(b64);
var validLen = lens[0];
var placeHoldersLen = lens[1];
var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
var curByte = 0;
var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
var i2;
for (i2 = 0; i2 < len2; i2 += 4) {
tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
arr[curByte++] = tmp >> 16 & 255;
arr[curByte++] = tmp >> 8 & 255;
arr[curByte++] = tmp & 255;
}
if (placeHoldersLen === 2) {
tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
arr[curByte++] = tmp & 255;
}
if (placeHoldersLen === 1) {
tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
arr[curByte++] = tmp >> 8 & 255;
arr[curByte++] = tmp & 255;
}
return arr;
}
__name(toByteArray, "toByteArray");
function tripletToBase64(num) {
return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
__name(tripletToBase64, "tripletToBase64");
function encodeChunk(uint8, start, end) {
var tmp;
var output = [];
for (var i2 = start; i2 < end; i2 += 3) {
tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
output.push(tripletToBase64(tmp));
}
return output.join("");
}
__name(encodeChunk, "encodeChunk");
function fromByteArray(uint8) {
var tmp;
var len2 = uint8.length;
var extraBytes = len2 % 3;
var parts = [];
var maxChunkLength = 16383;
for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
}
if (extraBytes === 1) {
tmp = uint8[len2 - 1];
parts.push(
lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
);
} else if (extraBytes === 2) {
tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
parts.push(
lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
);
}
return parts.join("");
}
__name(fromByteArray, "fromByteArray");
}
});

var require_base64_js2 = __commonJS({
"node_modules/obsidian-smart-env-pro/node_modules/obsidian-smart-env/node_modules/base64-js/index.js"(exports2) {
"use strict";
exports2.byteLength = byteLength;
exports2.toByteArray = toByteArray;
exports2.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (i = 0, len = code.length; i < len; ++i) {
lookup[i] = code[i];
revLookup[code.charCodeAt(i)] = i;
}
var i;
var len;
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
var len2 = b64.length;
if (len2 % 4 > 0) {
throw new Error("Invalid string. Length must be a multiple of 4");
}
var validLen = b64.indexOf("=");
if (validLen === -1) validLen = len2;
var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
return [validLen, placeHoldersLen];
}
__name(getLens, "getLens");
function byteLength(b64) {
var lens = getLens(b64);
var validLen = lens[0];
var placeHoldersLen = lens[1];
return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
__name(byteLength, "byteLength");
function _byteLength(b64, validLen, placeHoldersLen) {
return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
__name(_byteLength, "_byteLength");
function toByteArray(b64) {
var tmp;
var lens = getLens(b64);
var validLen = lens[0];
var placeHoldersLen = lens[1];
var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
var curByte = 0;
var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
var i2;
for (i2 = 0; i2 < len2; i2 += 4) {
tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
arr[curByte++] = tmp >> 16 & 255;
arr[curByte++] = tmp >> 8 & 255;
arr[curByte++] = tmp & 255;
}
if (placeHoldersLen === 2) {
tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
arr[curByte++] = tmp & 255;
}
if (placeHoldersLen === 1) {
tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
arr[curByte++] = tmp >> 8 & 255;
arr[curByte++] = tmp & 255;
}
return arr;
}
__name(toByteArray, "toByteArray");
function tripletToBase64(num) {
return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
__name(tripletToBase64, "tripletToBase64");
function encodeChunk(uint8, start, end) {
var tmp;
var output = [];
for (var i2 = start; i2 < end; i2 += 3) {
tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
output.push(tripletToBase64(tmp));
}
return output.join("");
}
__name(encodeChunk, "encodeChunk");
function fromByteArray(uint8) {
var tmp;
var len2 = uint8.length;
var extraBytes = len2 % 3;
var parts = [];
var maxChunkLength = 16383;
for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
}
if (extraBytes === 1) {
tmp = uint8[len2 - 1];
parts.push(
lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
);
} else if (extraBytes === 2) {
tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
parts.push(
lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
);
}
return parts.join("");
}
__name(fromByteArray, "fromByteArray");
}
});

var require_base64_js3 = __commonJS({
"node_modules/base64-js/index.js"(exports2) {
"use strict";
exports2.byteLength = byteLength;
exports2.toByteArray = toByteArray;
exports2.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (i = 0, len = code.length; i < len; ++i) {
lookup[i] = code[i];
revLookup[code.charCodeAt(i)] = i;
}
var i;
var len;
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
var len2 = b64.length;
if (len2 % 4 > 0) {
throw new Error("Invalid string. Length must be a multiple of 4");
}
var validLen = b64.indexOf("=");
if (validLen === -1) validLen = len2;
var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
return [validLen, placeHoldersLen];
}
__name(getLens, "getLens");
function byteLength(b64) {
var lens = getLens(b64);
var validLen = lens[0];
var placeHoldersLen = lens[1];
return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
__name(byteLength, "byteLength");
function _byteLength(b64, validLen, placeHoldersLen) {
return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
__name(_byteLength, "_byteLength");
function toByteArray(b64) {
var tmp;
var lens = getLens(b64);
var validLen = lens[0];
var placeHoldersLen = lens[1];
var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
var curByte = 0;
var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
var i2;
for (i2 = 0; i2 < len2; i2 += 4) {
tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
arr[curByte++] = tmp >> 16 & 255;
arr[curByte++] = tmp >> 8 & 255;
arr[curByte++] = tmp & 255;
}
if (placeHoldersLen === 2) {
tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
arr[curByte++] = tmp & 255;
}
if (placeHoldersLen === 1) {
tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
arr[curByte++] = tmp >> 8 & 255;
arr[curByte++] = tmp & 255;
}
return arr;
}
__name(toByteArray, "toByteArray");
function tripletToBase64(num) {
return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
__name(tripletToBase64, "tripletToBase64");
function encodeChunk(uint8, start, end) {
var tmp;
var output = [];
for (var i2 = start; i2 < end; i2 += 3) {
tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
output.push(tripletToBase64(tmp));
}
return output.join("");
}
__name(encodeChunk, "encodeChunk");
function fromByteArray(uint8) {
var tmp;
var len2 = uint8.length;
var extraBytes = len2 % 3;
var parts = [];
var maxChunkLength = 16383;
for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
}
if (extraBytes === 1) {
tmp = uint8[len2 - 1];
parts.push(
lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
);
} else if (extraBytes === 2) {
tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
parts.push(
lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
);
}
return parts.join("");
}
__name(fromByteArray, "fromByteArray");
}
});

var main_exports = {};
__export(main_exports, {
default: () => SmartChatPlugin
});
module.exports = __toCommonJS(main_exports);

var import_obsidian42 = require("obsidian");

var WILDCARD_KEY = "*";
var SmartEventsAdapter = class {
static {
__name(this, "SmartEventsAdapter");
}
constructor(instance) {
this.instance = instance;
this.handlers = /* @__PURE__ */ Object.create(null);
}
/**
* Register an event handler.
* When event_key is '*', the handler subscribes to all events.
* Handlers receive (event, event_key).
* @param {string} event_key
* @param {Function} event_callback
*/
on(event_key, event_callback) {
}
/**
* Register a one-time handler.
* When event_key is '*', the handler fires once on the next emitted event of any key.
* Handlers receive (event, event_key).
* @param {string} event_key
* @param {Function} event_callback
*/
once(event_key, event_callback) {
}
/**
* Remove an event handler.
* When event_key is '*', removes from the wildcard list only.
* @param {string} event_key
* @param {Function} event_callback
*/
off(event_key, event_callback) {
}
/**
* Emit an event.
* event_key must not be '*'.
* @param {string} event_key
* @param {Object} event
*/
emit(event_key, event) {
}
};

var DefaultEventsAdapter = class extends SmartEventsAdapter {
static {
__name(this, "DefaultEventsAdapter");
}
constructor(instance) {
super(instance);
this._next_id = 1;
}
on(event_key, event_callback = () => {
}) {
const key = event_key === WILDCARD_KEY ? WILDCARD_KEY : event_key;
const list = this.handlers[key] || (this.handlers[key] = []);
const entry = { id: this._next_id++, cb: event_callback };
list.push(entry);
return () => this.off_entry(key, entry.id);
}
once(event_key, event_callback = () => {
}) {
const key = event_key === WILDCARD_KEY ? WILDCARD_KEY : event_key;
const list = this.handlers[key] || (this.handlers[key] = []);
const entry = { id: this._next_id++, cb: null };
const wrapper = /* @__PURE__ */ __name((event, emitted_key) => {
this.off_entry(key, entry.id);
event_callback(event, emitted_key);
}, "wrapper");
entry.cb = wrapper;
list.push(entry);
return () => this.off_entry(key, entry.id);
}
/**
* Public removal by function reference.
* Removes a single matching registration for the given function.
* Preference is to remove the most-recent registration (LIFO) when duplicates exist.
*/
off(event_key, event_callback) {
const list = this.handlers[event_key];
if (!list || !event_callback) return;
for (let i = list.length - 1; i >= 0; i--) {
if (list[i].cb === event_callback) {
list.splice(i, 1);
break;
}
}
}
/**
* Internal precise removal by entry id.
* Used by unsubscribe closures returned from on/once.
*/
off_entry(event_key, entry_id) {
const list = this.handlers[event_key];
if (!list) return;
const idx = list.findIndex((e) => e.id === entry_id);
if (idx !== -1) list.splice(idx, 1);
}
emit(event_key, event = {}) {
if (event_key === WILDCARD_KEY) {
throw new Error('emit("*") is not allowed; "*" is reserved for wildcard listeners.');
}
const specific_list = this.handlers[event_key];
const wildcard_list = this.handlers[WILDCARD_KEY];
if (!specific_list && !wildcard_list) return;
const call_specific = specific_list ? [...specific_list] : [];
const call_wildcard = wildcard_list ? [...wildcard_list] : [];
for (let i = 0; i < call_specific.length; i++) {
call_specific[i].cb(event, event_key);
}
for (let i = 0; i < call_wildcard.length; i++) {
call_wildcard[i].cb(event, event_key);
}
}
};

var SmartEvents = class _SmartEvents {
static {
__name(this, "SmartEvents");
}
constructor(env, opts = {}) {
env.create_env_getter(this);
this.opts = opts;
}
static create(env, opts = {}) {
const smart_events = new _SmartEvents(env, opts);
if (!Object.getOwnPropertyDescriptor(env, "events")) {
Object.defineProperty(env, "events", { get: /* @__PURE__ */ __name(() => smart_events, "get") });
}
return smart_events;
}
get adapter() {
if (!this._adapter) {
this._adapter = this.opts.adapter_class ? new this.opts.adapter_class(this) : new DefaultEventsAdapter(this);
}
return this._adapter;
}
on(event_key, event_callback = (event) => {
}) {
return this.adapter.on(event_key, event_callback);
}
once(event_key, event_callback = (event) => {
}) {
return this.adapter.once(event_key, event_callback);
}
off(event_key, event_callback = (event) => {
}) {
return this.adapter.off(event_key, event_callback);
}
/**
* Emit an event.
* @param {string} event_key
* @param {Record<string, unknown>} [event]
* @returns {void}
*/
emit(event_key, event = {}) {
const payload = { ...event };
if (payload.at === void 0) {
payload.at = Date.now();
}
Object.freeze(payload);
return this.adapter.emit(event_key, payload);
}
};

async function build_html(env, opts = {}) {
const env_settings_html = Object.entries(env.settings_config).map(([setting_key, setting_config]) => {
if (!setting_config.setting) setting_config.setting = setting_key;
return this.render_setting_html(setting_config);
}).join("\n");
const env_collections_containers_html = Object.entries(env.collections).map(([collection_key, collection]) => {
return `<div data-smart-settings="${collection_key}"></div>`;
}).join("\n");
const html = `
<div class="">
${env_settings_html}
${env_collections_containers_html}
</div>
`;
return html;
}
__name(build_html, "build_html");
async function render(env, opts = {}) {
const html = await build_html.call(this, env, opts);
const frag = this.create_doc_fragment(html);
return await post_process.call(this, env, frag, opts);
}
__name(render, "render");
async function post_process(env, frag, opts = {}) {
await this.render_setting_components(frag, { scope: env });
const env_collections_containers = frag.querySelectorAll("[data-smart-settings]");
for (const env_collections_container of env_collections_containers) {
const collection_key = env_collections_container.dataset.smartSettings;
const collection = env[collection_key];
await collection.render_settings(env_collections_container);
}
return frag;
}
__name(post_process, "post_process");

var SmartSettings = class {
static {
__name(this, "SmartSettings");
}
/**
* Creates an instance of SmartEnvSettings.
* @param {Object} main - The main object to contain the instance (smart_settings) and getter (settings)
* @param {Object} [opts={}] - Configuration options.
*/
constructor(main, opts = {}) {
this.main = main;
this.opts = opts;
this._fs = null;
this._settings = {};
this._saved = false;
this.save_timeout = null;
this.save_delay_ms = typeof opts.save_delay_ms === "number" ? opts.save_delay_ms : 1e3;
}
static async create(main, opts = {}) {
const smart_settings = new this(main, opts);
await smart_settings.load();
main.smart_settings = smart_settings;
Object.defineProperty(main, "settings", {
get() {
return smart_settings.settings;
},
set(settings) {
smart_settings.settings = settings;
}
});
return smart_settings;
}
static create_sync(main, opts = {}) {
const smart_settings = new this(main, opts);
smart_settings.load_sync();
main.smart_settings = smart_settings;
Object.defineProperty(main, "settings", {
get() {
return smart_settings.settings;
},
set(settings) {
smart_settings.settings = settings;
}
});
return smart_settings;
}
/**
* Gets the current settings, wrapped with an observer to handle changes.
* @returns {Proxy} A proxy object that observes changes to the settings.
*/
get settings() {
return observe_object(this._settings, (change) => {
this.emit_settings_changed(change);
this.schedule_save();
});
}
/**
* Sets the current settings.
* @param {Object} settings - The new settings to apply.
*/
set settings(settings) {
this._settings = settings;
}
schedule_save() {
if (this.save_timeout) clearTimeout(this.save_timeout);
this.save_timeout = setTimeout(() => {
this.save(this._settings);
this.save_timeout = null;
}, this.save_delay_ms);
}
emit_settings_changed(change) {
const events_bus = this.resolve_events_bus();
if (!events_bus?.emit) return;
events_bus.emit("settings:changed", build_settings_changed_event(change));
}
resolve_events_bus() {
if (this.opts.events) return this.opts.events;
if (typeof this.opts.emit === "function") {
return { emit: this.opts.emit };
}
if (this.main?.events) return this.main.events;
if (this.main?.env?.events) return this.main.env.events;
return null;
}
async save(settings = this._settings) {
if (typeof this.opts.save === "function") await this.opts.save(settings);
else await this.main.save_settings(settings);
}
async load() {
if (typeof this.opts.load === "function") this._settings = await this.opts.load();
else this._settings = await this.main.load_settings();
}
load_sync() {
if (typeof this.opts.load === "function") this._settings = this.opts.load();
else this._settings = this.main.load_settings();
}
};
function observe_object(obj, on_change) {
const proxy_cache = /* @__PURE__ */ new WeakMap();
const proxy_targets = /* @__PURE__ */ new WeakMap();
const wrap_value = /* @__PURE__ */ __name((value, path) => {
if (!is_observable(value)) return value;
if (proxy_targets.has(value)) return value;
if (proxy_cache.has(value)) return proxy_cache.get(value);
const proxy = create_proxy(value, path);
proxy_cache.set(value, proxy);
proxy_targets.set(proxy, value);
return proxy;
}, "wrap_value");
const create_proxy = /* @__PURE__ */ __name((target, path) => new Proxy(target, {
set(target2, property, value) {
const property_path = [...path, property];
const previous_snapshot = snapshot_value(target2[property]);
const next_snapshot = snapshot_value(value);
target2[property] = wrap_value(value, property_path);
if (has_changed(previous_snapshot, next_snapshot)) {
on_change({
type: "set",
path: property_path,
value: next_snapshot,
previous_value: previous_snapshot
});
}
return true;
},
get(target2, property) {
const result = target2[property];
return wrap_value(result, [...path, property]);
},
deleteProperty(target2, property) {
if (!Object.prototype.hasOwnProperty.call(target2, property)) {
return true;
}
const property_path = [...path, property];
const previous_snapshot = snapshot_value(target2[property]);
delete target2[property];
on_change({
type: "delete",
path: property_path,
previous_value: previous_snapshot
});
return true;
}
}), "create_proxy");
return wrap_value(obj, []);
}
__name(observe_object, "observe_object");
function build_settings_changed_event(change) {
const path = Array.isArray(change.path) ? change.path : [];
return {
type: change.type,
path,
path_string: path.join("."),
value: change.value,
previous_value: change.previous_value
};
}
__name(build_settings_changed_event, "build_settings_changed_event");
function snapshot_value(value) {
if (!is_observable(value)) {
return value;
}
if (typeof structuredClone === "function") {
try {
return structuredClone(value);
} catch (error) {
}
}
try {
return JSON.parse(JSON.stringify(value));
} catch (error) {
return value;
}
}
__name(snapshot_value, "snapshot_value");
function has_changed(previous_snapshot, next_snapshot) {
return serialize_value(previous_snapshot) !== serialize_value(next_snapshot);
}
__name(has_changed, "has_changed");
function serialize_value(value) {
if (value === void 0) return "undefined";
if (Number.isNaN(value)) return "number:NaN";
if (value === Infinity) return "number:Infinity";
if (value === -Infinity) return "number:-Infinity";
if (!is_observable(value)) {
return `${typeof value}:${String(value)}`;
}
try {
return `object:${JSON.stringify(value)}`;
} catch (error) {
return `object:${String(value)}`;
}
}
__name(serialize_value, "serialize_value");
function is_observable(value) {
return typeof value === "object" && value !== null;
}
__name(is_observable, "is_observable");

function deep_merge(target = {}, source = {}) {
for (const key in source) {
if (!Object.prototype.hasOwnProperty.call(source, key)) continue;
if (is_plain_object(source[key]) && is_plain_object(target[key])) {
deep_merge(target[key], source[key]);
} else {
target[key] = source[key];
}
}
return target;
}
__name(deep_merge, "deep_merge");
function is_plain_object(o) {
return o && typeof o === "object" && !Array.isArray(o);
}
__name(is_plain_object, "is_plain_object");

function camel_case_to_snake_case(str = "") {
return str.replace(/([A-Z])/g, (m) => `_${m.toLowerCase()}`).replace(/^_/, "").replace(/2$/, "");
}
__name(camel_case_to_snake_case, "camel_case_to_snake_case");

function normalize_opts(opts) {
if (!opts.collections) opts.collections = {};
if (!opts.modules) opts.modules = {};
if (!opts.items) opts.items = {};
Object.entries(opts.collections).forEach(([key, val]) => {
if (typeof val === "function") {
opts.collections[key] = { class: val };
}
const new_key = camel_case_to_snake_case(key);
if (new_key !== key) {
opts.collections[new_key] = opts.collections[key];
delete opts.collections[key];
}
if (!opts.collections[new_key].collection_key) opts.collections[new_key].collection_key = new_key;
if (val.item_type) {
opts.items[val.item_type.key || camel_case_to_snake_case(val.item_type.name)] = {
class: val.item_type
};
}
});
Object.entries(opts.modules).forEach(([key, val]) => {
if (typeof val === "function") {
opts.modules[key] = { class: val };
}
const new_key = camel_case_to_snake_case(key);
if (new_key !== key) {
opts.modules[new_key] = opts.modules[key];
delete opts.modules[key];
}
});
if (!opts.item_types) opts.item_types = {};
if (!opts.items) opts.items = {};
Object.entries(opts.item_types).forEach(([key, val]) => {
if (typeof val === "function") {
const new_key = camel_case_to_snake_case(key);
opts.items[new_key] = {
class: val,
actions: {},
...opts.items[new_key] || {}
};
}
});
return opts;
}
__name(normalize_opts, "normalize_opts");

function is_plain_object2(value) {
if (!value || typeof value !== "object") return false;
const proto = Object.getPrototypeOf(value);
return proto === Object.prototype || proto === null;
}
__name(is_plain_object2, "is_plain_object");
function deep_clone_config(input) {
if (Array.isArray(input)) {
return input.map((item) => deep_clone_config(item));
}
if (is_plain_object2(input)) {
const output = {};
for (const [k, v] of Object.entries(input)) {
output[k] = deep_clone_config(v);
}
return output;
}
return input;
}
__name(deep_clone_config, "deep_clone_config");

function compare_versions(new_value, cur_value) {
const a = normalize_version_value(new_value);
const b = normalize_version_value(cur_value);
const len = Math.max(a.parts.length, b.parts.length);
for (let i = 0; i < len; i++) {
const av = a.parts[i] !== void 0 ? a.parts[i] : 0;
const bv = b.parts[i] !== void 0 ? b.parts[i] : 0;
if (av > bv) return 1;
if (av < bv) return -1;
}
if (a.type === b.type) return 0;
if (a.type === "semver" && b.type !== "semver") return 1;
if (b.type === "semver" && a.type !== "semver") return -1;
if (a.type === "number" && b.type === "none") {
return a.parts[0] === 0 ? 0 : 1;
}
if (b.type === "number" && a.type === "none") {
return b.parts[0] === 0 ? 0 : -1;
}
return 0;
}
__name(compare_versions, "compare_versions");
function normalize_version_value(value) {
if (value === null || value === void 0) {
return { type: "none", parts: [0, 0, 0] };
}
if (typeof value === "number") {
if (!Number.isFinite(value)) {
return { type: "none", parts: [0, 0, 0] };
}
const major = Math.floor(value);
const minor = Math.floor((value - major) * 10);
return { type: "number", parts: [major, minor, 0] };
}
if (typeof value === "string") {
const trimmed = value.trim();
if (!trimmed) {
return { type: "none", parts: [0, 0, 0] };
}
const raw_parts = trimmed.split(".");
const parts = raw_parts.map((part) => {
const match = part.match(/^\d+/);
if (!match) return 0;
const num = Number.parseInt(match[0], 10);
return Number.isNaN(num) ? 0 : num;
});
while (parts.length < 3) {
parts.push(0);
}
return {
type: "semver",
parts
};
}
return { type: "none", parts: [0, 0, 0] };
}
__name(normalize_version_value, "normalize_version_value");

function is_plain_object3(o) {
if (o === null) return false;
if (typeof o !== "object") return false;
if (Array.isArray(o)) return false;
if (o instanceof Function) return false;
if (o instanceof Date) return false;
return Object.getPrototypeOf(o) === Object.prototype;
}
__name(is_plain_object3, "is_plain_object");

function deep_merge_no_overwrite(target, source, path = []) {
if (!is_plain_object3(target) || !is_plain_object3(source)) {
return target;
}
if (path.includes(source)) {
return target;
}
path.push(source);
for (const key of Object.keys(source)) {
if (!Object.prototype.hasOwnProperty.call(source, key)) {
continue;
}
const val = source[key];
if (Array.isArray(target[key]) && Array.isArray(val)) {
for (const item of val) {
if (typeof item === "function") {
const item_name = item.name;
const has_same_fn = target[key].some(
(el) => typeof el === "function" && el.name === item_name
);
if (!has_same_fn) {
target[key].push(item);
}
} else if (item === null || ["string", "number", "boolean", "undefined"].includes(typeof item)) {
if (!target[key].includes(item)) {
target[key].push(item);
}
} else {
target[key].push(item);
}
}
} else if (is_plain_object3(val)) {
if (!is_plain_object3(target[key])) {
target[key] = {};
}
deep_merge_no_overwrite(target[key], val, [...path]);
} else if (!Object.prototype.hasOwnProperty.call(target, key)) {
target[key] = val;
}
}
return target;
}
__name(deep_merge_no_overwrite, "deep_merge_no_overwrite");

function merge_env_config(target, incoming) {
const CUR_VER = target.version;
const NEW_VER = incoming.version;
for (const [key, value] of Object.entries(incoming)) {
if (key === "collections" && value && typeof value === "object") {
if (!target.collections) target.collections = {};
for (const [col_key, col_def] of Object.entries(value)) {
const existing_def = target.collections[col_key];
if (!existing_def) {
target.collections[col_key] = { ...col_def };
continue;
}
const new_version_raw = col_def && col_def.version !== void 0 ? col_def.version : col_def?.class?.version;
const cur_version_raw = existing_def && existing_def.version !== void 0 ? existing_def.version : existing_def?.class?.version;
const cmp = compare_versions(new_version_raw, cur_version_raw);
if (cmp > 0) {
const replaced = { ...col_def };
deep_merge_no_overwrite(replaced, existing_def);
target.collections[col_key] = replaced;
} else {
deep_merge_no_overwrite(existing_def, col_def);
}
}
continue;
}
if (["actions", "collections", "components", "item_types", "modules"].includes(key) && value && typeof value === "object") {
if (!target[key]) target[key] = {};
for (const [comp_key, comp_def] of Object.entries(value)) {
if (!target[key][comp_key]) {
target[key][comp_key] = { ...comp_def };
continue;
}
const target_comp = target[key][comp_key];
const incoming_ver = comp_def && comp_def.version;
const target_ver = target_comp && target_comp.version;
const cmp = compare_versions(incoming_ver, target_ver);
if (cmp > 0) {
target[key][comp_key] = comp_def;
target[key][comp_key].version = incoming_ver || -1;
} else {
deep_merge_no_overwrite(target_comp, comp_def);
}
}
continue;
}
if (Array.isArray(value)) {
if (Array.isArray(target[key])) {
if (value.length > 0 && (typeof value[0] === "string" || typeof value[0] === "number" || typeof value[0] === "boolean")) {
target[key] = Array.from(/* @__PURE__ */ new Set([...target[key], ...value]));
} else {
target[key] = [...target[key], ...value];
}
} else {
if (value.length > 0 && (typeof value[0] === "string" || typeof value[0] === "number" || typeof value[0] === "boolean")) {
target[key] = Array.from(new Set(value));
} else {
target[key] = [...value];
}
}
} else if (value && typeof value === "object") {
if (!target[key]) target[key] = {};
deep_merge_no_overwrite(target[key], value);
} else {
target[key] = value;
}
}
return target;
}
__name(merge_env_config, "merge_env_config");

function migrate_exclusion_settings_2025_08_22(settings = {}) {
const { file_exclusions: file_exclusions2, folder_exclusions: folder_exclusions3, excluded_headings } = settings;
if (file_exclusions2 !== void 0 || folder_exclusions3 !== void 0 || excluded_headings !== void 0) {
settings.smart_sources = settings.smart_sources || {};
if (file_exclusions2 !== void 0) {
if (file_exclusions2.length && file_exclusions2 !== "Untitled" && (!settings.smart_sources?.file_exclusions?.length || settings.smart_sources?.file_exclusions === "Untitled")) {
settings.smart_sources.file_exclusions = file_exclusions2;
}
}
if (folder_exclusions3 !== void 0) {
if (folder_exclusions3.length && !settings.smart_sources.folder_exclusions?.length) {
settings.smart_sources.folder_exclusions = folder_exclusions3;
}
}
if (excluded_headings !== void 0) {
if (excluded_headings.length && !settings.smart_sources.excluded_headings?.length) {
settings.smart_sources.excluded_headings = excluded_headings;
}
}
}
delete settings.file_exclusions;
delete settings.folder_exclusions;
delete settings.excluded_headings;
return settings;
}
__name(migrate_exclusion_settings_2025_08_22, "migrate_exclusion_settings_2025_08_22");

var ROOT_SCOPE = typeof globalThis !== "undefined" ? globalThis : Function("return this")();
var SmartEnv = class {
static {
__name(this, "SmartEnv");
}
static version = "2.2.8";
scope_name = "smart_env";
static global_ref = ROOT_SCOPE;
global_ref = this.constructor.global_ref;
constructor(opts = {}) {
this.state = "init";
this._components = {};
this.collections = {};
this.load_timeout = null;
this._collections_version_signature = null;
this._events = SmartEvents.create(this, build_events_opts(this.config?.modules?.smart_events));
if (opts.primary_main_key) this.primary_main_key = opts.primary_main_key;
}
/**
* Builds or returns the cached configuration object.
* The cache is invalidated automatically whenever the “version signature”
* of any collection class changes (controlled by its static `version`).
*
* @returns {Object} the merged, up-to-date environment config
*/
get config() {
const signature = this.compute_collections_version_signature();
if (this._config && signature === this._collections_version_signature) {
return this._config;
}
this._collections_version_signature = signature;
this._config = {};
const sorted_configs = Object.entries(this.smart_env_configs).sort(([main_key]) => {
if (!this.primary_main_key) return 0;
return main_key === this.primary_main_key ? -1 : 0;
});
for (const [key, rec] of sorted_configs) {
if (!rec?.main) {
console.warn(`SmartEnv: '${key}' unloaded, skipping`);
delete this.smart_env_configs[key];
continue;
}
if (!rec?.opts) {
console.warn(`SmartEnv: '${key}' opts missing, skipping`);
continue;
}
merge_env_config(
this._config,
deep_clone_config(normalize_opts(rec.opts))
);
}
return this._config;
}
/**
* Produces a deterministic string representing the current versions of every
* collection class across all mains.  When any collection ships a higher
* `static version`, the signature changes – automatically invalidating the
* cached `config`.
*
* @returns {string} pipe-delimited version signature
*/
compute_collections_version_signature() {
const list = [];
for (const rec of Object.values(this.smart_env_configs)) {
const { opts } = rec || {};
if (!opts) continue;
for (const [collection_key, def] of Object.entries(opts.collections || {})) {
const cls = def?.class;
const v = typeof cls?.version === "number" ? cls.version : 0;
list.push(`${collection_key}:${v}`);
}
}
return list.sort().join("|");
}
get env_start_wait_time() {
if (typeof this.config.env_start_wait_time === "number") return this.config.env_start_wait_time;
return 5e3;
}
static get global_env() {
return this.global_ref.smart_env;
}
static set global_env(env) {
this.global_ref.smart_env = env;
}
static get mains() {
return Object.keys(this.global_ref.smart_env_configs || {});
}
get mains() {
return Object.keys(this.global_ref.smart_env_configs || {});
}
static get should_reload() {
if (!this.global_env) return true;
if (this.global_env.state === "loaded") return true;
if (typeof this.global_env?.constructor?.version === "undefined") return true;
if (compare_versions(this.version, this.global_env.constructor?.version) > 0) {
console.warn(
"SmartEnv: Reloading environment because of version mismatch",
`${this.version} > ${this.global_env.constructor.version}`
);
return true;
}
return false;
}
static get smart_env_configs() {
if (!this.global_ref.smart_env_configs) this.global_ref.smart_env_configs = {};
return this.global_ref.smart_env_configs;
}
get smart_env_configs() {
if (!this.global_ref.smart_env_configs) this.global_ref.smart_env_configs = {};
return this.global_ref.smart_env_configs;
}
/**
* Serializes all collection data in the environment into a plain object.
* @returns {object}
*/
to_json() {
return Object.fromEntries(
Object.entries(this).filter(([, val]) => typeof val?.collection_key !== "undefined").map(([key, collection]) => [key, collection_to_plain(collection)])
);
}
/**
* Waits for either a specific main to be registered in the environment,
* or (if `opts.main` is not specified) waits for environment collections to load.
* @param {object} opts
* @param {object} [opts.main] - if set, the function waits until that main is found.
* @returns {Promise<SmartEnv>} Resolves with the environment instance
*/
static wait_for(opts = {}) {
return new Promise((resolve) => {
if (opts.main) {
const interval = setInterval(() => {
if (this.global_env && this.global_env[opts.main]) {
clearInterval(interval);
resolve(this.global_env);
}
}, 1e3);
} else {
const interval = setInterval(() => {
if (this.global_env && this.global_env.state === "loaded") {
clearInterval(interval);
resolve(this.global_env);
}
}, 100);
}
});
}
/**
* Creates or updates a SmartEnv instance.
* - If a global environment exists and is an older version or lacks 'init_main', it is replaced.
* @param {Object} main - The main object to be added to the SmartEnv instance.
* @param {Object} [env_config] - Options for configuring the SmartEnv instance.
* @returns {SmartEnv} The SmartEnv instance.
* @throws {TypeError} If an invalid main object is provided.
* @throws {Error} If there's an error creating or updating the SmartEnv instance.
*/
static async create(main, env_config) {
if (!main || typeof main !== "object") {
throw new TypeError("SmartEnv: Invalid main object provided");
}
if (!env_config) throw new Error("SmartEnv.create: 'env_config' parameter is required.");
env_config.version = this.version;
this.add_main(main, env_config);
if (this.should_reload) {
const opts = {};
if (this.global_env && compare_versions(this.version, this.global_env.constructor?.version || 0) > 0) {
opts.primary_main_key = camel_case_to_snake_case(main.constructor.name);
}
if (this.global_env?.load_timeout) clearTimeout(this.global_env.load_timeout);
this.global_env = new this(opts);
const g = this.global_ref;
if (!g.all_envs) g.all_envs = [];
g.all_envs.push(this.global_env);
}
clearTimeout(this.global_env.load_timeout);
this.global_env.load_timeout = setTimeout(async () => {
await this.global_env.load();
this.global_env.load_timeout = null;
}, this.global_env.env_start_wait_time);
return this.global_env;
}
static add_main(main, env_config = null) {
if (this.global_env) {
this.global_env._config = null;
this.global_env._collections_version_signature = null;
}
const main_key = camel_case_to_snake_case(main.constructor.name);
this.smart_env_configs[main_key] = { main, opts: env_config };
this.create_env_getter(main);
}
/**
* Creates a dynamic environment getter on any instance object.
* The returned 'env' property will yield the global `smart_env`.
* @param {Object} instance_to_receive_getter
*/
static create_env_getter(instance_to_receive_getter) {
Object.defineProperty(instance_to_receive_getter, "env", {
configurable: true,
get: /* @__PURE__ */ __name(() => this.global_env, "get")
});
}
create_env_getter(instance_to_receive_getter) {
this.constructor.create_env_getter(instance_to_receive_getter);
}
async load() {
this.state = "loading";
await this.fs.load_files();
if (!this.settings) await SmartSettings.create(this);
if (this.config.default_settings) {
deep_merge_no_overwrite(this.settings, this.config.default_settings);
}
migrate_exclusion_settings_2025_08_22(this.settings);
this.smart_settings.save();
await this.init_collections();
for (const [main_key, { main, opts }] of Object.entries(this.smart_env_configs)) {
this[main_key] = main;
}
await this.ready_to_load_collections();
await this.load_collections();
this.state = "loaded";
}
/**
* Initializes collection classes if they have an 'init' function.
* @param {Object} [config=this.config]
*/
async init_collections(config = this.config) {
for (const key of Object.keys(config.collections || {})) {
const _class = config.collections[key]?.class;
if (!_class) continue;
if (_class.default_settings) {
deep_merge_no_overwrite(
this.settings,
{
[key]: _class.default_settings
}
);
}
if (typeof _class.init !== "function") continue;
await _class.init(this, { ...config.collections[key] });
this.collections[key] = "init";
}
}
/**
* Hook/Override this method to wait for any conditions before loading collections.
* @param {Object} main
*/
async ready_to_load_collections() {
}
/**
* Loads any available collections, processing their load queues.
* @param {Object} [collections=this.collections] - Key-value map of collection instances.
*/
async load_collections(collections = this.collections) {
const collection_keys = Object.keys(collections || {}).sort((a, b) => {
const order_a = this.config.collections?.[a]?.load_order || 0;
const order_b = this.config.collections?.[b]?.load_order || 0;
return order_a - order_b;
});
for (const key of collection_keys) {
const time_start = Date.now();
if (typeof this[key]?.process_load_queue === "function") {
await this[key].process_load_queue();
this[key].load_time_ms = Date.now() - time_start;
this.collections[key] = "loaded";
console.log(`Loaded ${this[key].collection_key} in ${this[key].load_time_ms}ms`);
}
}
}
/**
* Removes a main from the global.smart_env_configs to exclude it on reload
* @param {Class} main
* @param {Object|null} [unload_config=null]
*/
static unload_main(main) {
const main_key = camel_case_to_snake_case(main.constructor.name);
this.smart_env_configs[main_key] = null;
delete this.smart_env_configs[main_key];
}
unload_main(main) {
this.constructor.unload_main(main);
}
/**
* Triggers a save event in all known collections.
*/
save() {
for (const key of Object.keys(this.collections)) {
this[key].process_save_queue?.();
}
}
/**
* Initialize a module from the configured `this.opts.modules`.
* @param {string} module_key
* @param {object} opts
* @returns {object|null} instance of the requested module or null if not found
*/
init_module(module_key, opts = {}) {
const module_config = this.opts.modules[module_key];
if (!module_config) {
return console.warn(`SmartEnv: module ${module_key} not found`);
}
opts = {
...{ ...module_config, class: null },
...opts
};
return new module_config.class(opts);
}
get notices() {
if (!this._notices) {
const SmartNoticesClass = this.config.modules.smart_notices.class;
this._notices = new SmartNoticesClass(this, {
adapter: this.config.modules.smart_notices.adapter
});
}
return this._notices;
}
/**
* Exposes a settings template function from environment opts or defaults.
* @returns {Function}
*/
get settings_template() {
return this.opts.components?.smart_env?.settings || render;
}
/**
* Renders settings UI into a container, using the environment's `settings_template`.
* @param {HTMLElement} [container=this.settings_container]
*/
async render_settings(container = this.settings_container) {
if (!this.settings_container || container !== this.settings_container) {
this.settings_container = container;
}
if (!container) {
throw new Error("Container is required");
}
const frag = await this.render_component("settings", this, {});
this.smart_view.empty(container);
container.appendChild(frag);
return frag;
}
/**
* Renders a named component using an optional scope and options.
* @deprecated use env.smart_components.render instead (2025-10-11)
* @param {string} component_key
* @param {Object} scope
* @param {Object} [opts]
* @returns {Promise<HTMLElement>}
*/
async render_component(component_key, scope, opts = {}) {
const component_renderer = this.get_component(component_key, scope);
if (!component_renderer) {
console.warn(`SmartEnv: component ${component_key} not found for scope ${scope.constructor.name}`);
return this.smart_view.create_doc_fragment(`<div class="smart-env-component-not-found">
<h1>Component Not Found</h1>
<p>The component ${component_key} was not found for scope ${scope.constructor.name}.</p>
</div>`);
}
const frag = await component_renderer(scope, opts);
return frag;
}
/**
* Retrieves or creates a memoized component renderer function.
* @deprecated use env.smart_components instead (2025-10-11)
* @param {string} component_key
* @param {Object} scope
* @returns {Function|undefined}
*/
get_component(component_key, scope) {
const scope_name = scope.collection_key ?? scope.scope_name;
const _cache_key = scope_name ? `${scope_name}-${component_key}` : component_key;
if (!this._components[_cache_key]) {
try {
if (this.opts.components[scope_name]?.[component_key]) {
const component_config = this.opts.components[scope_name][component_key];
const component = component_config.render || component_config;
this._components[_cache_key] = component.bind(
this.init_module("smart_view")
);
} else if (this.opts.components[component_key]) {
const component_config = this.opts.components[component_key];
const component = component_config.render || component_config;
this._components[_cache_key] = component.bind(
this.init_module("smart_view")
);
} else {
console.warn(
`SmartEnv: component ${component_key} not found for scope ${scope_name}`
);
}
} catch (e) {
console.error("Error getting component", e);
console.log(
`scope_name: ${scope_name}; component_key: ${component_key}; this.opts.components: ${Object.keys(
this.opts.components || {}
).join(", ")}; this.opts.components[scope_name]: ${Object.keys(
this.opts.components[scope_name] || {}
).join(", ")}`
);
}
}
return this._components[_cache_key];
}
/**
* A built-in settings schema for this environment.
* @abstract
* @returns {Object}
*/
get settings_config() {
return {};
}
get global_prop() {
return this.opts.global_prop ?? "smart_env";
}
get item_types() {
return this.config.item_types;
}
get fs_module_config() {
return this.opts.modules.smart_fs;
}
get fs() {
if (!this.smart_fs) {
this.smart_fs = new this.fs_module_config.class(this, {
adapter: this.fs_module_config.adapter,
fs_path: this.opts.env_path || ""
});
}
return this.smart_fs;
}
get env_data_dir() {
const env_settings_files = this.fs.file_paths?.filter((path) => path.endsWith("smart_env.json")) || [];
let env_data_dir = ".smart-env";
if (env_settings_files.length > 0) {
if (env_settings_files.length > 1) {
const env_data_dir_counts = env_settings_files.map((path) => {
const dir = path.split("/").slice(-2, -1)[0];
return {
dir,
count: this.fs.file_paths.filter((p) => p.includes(dir)).length
};
});
env_data_dir = env_data_dir_counts.reduce(
(max, dirObj) => dirObj.count > max.count ? dirObj : max,
env_data_dir_counts[0]
).dir;
} else {
env_data_dir = env_settings_files[0].split("/").slice(-2, -1)[0];
}
}
return env_data_dir;
}
get data_fs() {
if (!this._fs) {
this._fs = new this.fs_module_config.class(this, {
adapter: this.fs_module_config.adapter,
fs_path: this.data_fs_path
});
}
return this._fs;
}
get data_fs_path() {
if (!this._data_fs_path) {
this._data_fs_path = (this.opts.env_path + (this.opts.env_path ? this.opts.env_path.includes("\\") ? "\\" : "/" : "") + this.env_data_dir).replace(/\\\\/g, "\\").replace(/\/\//g, "/");
}
return this._data_fs_path;
}
/**
* Saves the current settings to the file system.
* @param {Object|null} [settings=null] - Optional settings to override the current settings before saving.
* @returns {Promise<void>}
*/
async save_settings(settings) {
this._saved = false;
if (!await this.data_fs.exists("")) {
await this.data_fs.mkdir("");
}
await this.data_fs.write("smart_env.json", JSON.stringify(settings, null, 2));
this._saved = true;
}
/**
* Loads settings from the file system, merging with any `default_settings`
* @returns {Promise<Object>} the loaded settings
*/
async load_settings() {
if (!await this.data_fs.exists("smart_env.json")) await this.save_settings({});
let settings = JSON.parse(JSON.stringify(this.config.default_settings || {}));
deep_merge(settings, JSON.parse(await this.data_fs.read("smart_env.json")));
this._saved = true;
if (this.fs.auto_excluded_files) {
const existing_file_exclusions = settings.smart_sources.file_exclusions.split(",").map((s) => s.trim()).filter(Boolean);
settings.smart_sources.file_exclusions = [...existing_file_exclusions, ...this.fs.auto_excluded_files].filter((value, index, self) => self.indexOf(value) === index).join(",");
}
return settings;
}
/**
* Refreshes file-system state if exclusions changed,
* then re-renders relevant settings UI
*/
async update_exclusions() {
this.smart_sources._fs = null;
await this.smart_sources.init_fs();
}
/**
* Lazily instantiate the module 'smart_view'.
* @deprecated use env.smart_components instead (2025-09-30)
* @returns {object}
*/
get smart_view() {
if (!this._smart_view) {
this._smart_view = this.init_module("smart_view");
}
return this._smart_view;
}
/** @deprecated access `this.state` and `collection.state` directly instead */
get collections_loaded() {
return this.state === "loaded";
}
/** @deprecated Use this['main_class_name'] instead of this.main/this.plugin */
get main() {
return this.smart_env_configs[this.mains[0]]?.main;
}
/**
* @deprecated use component pattern instead
*/
get ejs() {
return this.opts.ejs;
}
/**
* @deprecated use component pattern instead
*/
get templates() {
return this.opts.templates;
}
/**
* @deprecated use component pattern instead
*/
get views() {
return this.opts.views;
}
/**
* @deprecated use this.config instead
*/
get opts() {
return this.config;
}
/**
* @deprecated Use this.main_class_name instead of this.plugin
*/
get plugin() {
return this.main;
}
};
function collection_to_plain(collection) {
return {
items: Object.fromEntries(
Object.entries(collection.items || {}).map(([key, item]) => [key, item.data])
)
};
}
__name(collection_to_plain, "collection_to_plain");
function build_events_opts(module_config) {
if (!module_config) return {};
if (typeof module_config === "function") {
return { adapter_class: module_config };
}
const adapter_class = module_config.adapter_class || module_config.adapter;
return adapter_class ? { adapter_class } : {};
}
__name(build_events_opts, "build_events_opts");

function create_regex(pattern, { case_sensitive, extended_glob, windows_paths }) {
const regex_pattern = glob_to_regex_pattern(pattern, extended_glob);
const adjusted_pattern = adjust_for_windows_paths(regex_pattern, windows_paths);
const flags = case_sensitive ? "" : "i";
return new RegExp(`^${adjusted_pattern}$`, flags);
}
__name(create_regex, "create_regex");
function adjust_for_windows_paths(pattern, windows_paths) {
return windows_paths ? pattern.replace(/\\\//g, "[\\\\/]").replace(/\\\\\\/g, "[\\\\/]") : pattern;
}
__name(adjust_for_windows_paths, "adjust_for_windows_paths");
function glob_to_regex_pattern(pattern, extended_glob) {
let in_class = false;
let in_brace = 0;
let result = "";
for (let i = 0; i < pattern.length; i++) {
const char = pattern[i];
switch (char) {
case "\\":
if (i + 1 < pattern.length) {
result += `\\${pattern[i + 1]}`;
i++;
} else {
result += "\\\\";
}
break;
case "/":
result += "\\/";
break;
case "[":
if (!in_class) {
const closingIndex = pattern.indexOf("]", i + 1);
if (closingIndex === -1) {
result += "\\[";
} else {
in_class = true;
if (pattern[i + 1] === "!") {
result += "[^";
i++;
} else {
result += "[";
}
}
} else {
result += "\\[";
}
break;
case "]":
if (in_class) {
in_class = false;
result += "]";
} else {
result += "\\]";
}
break;
case "{":
if (!in_class) {
const closingIndex = pattern.indexOf("}", i + 1);
if (closingIndex === -1) {
result += "\\{";
} else {
in_brace++;
result += "(";
}
} else {
result += "\\{";
}
break;
case "}":
if (!in_class && in_brace > 0) {
in_brace--;
result += ")";
} else {
result += "\\}";
}
break;
case ",":
if (!in_class && in_brace > 0) {
result += "|";
} else {
result += ",";
}
break;
case "*":
if (!in_class) {
if (i + 1 < pattern.length && pattern[i + 1] === "*") {
result += ".*";
i++;
} else {
result += "[^/]*";
}
} else {
result += "\\*";
}
break;
case "?":
if (!in_class) {
result += "[^/]";
} else {
result += "\\?";
}
break;
case "(":
case ")":
case "+":
case "|":
case "^":
case "$":
case ".":
result += `\\${char}`;
break;
default:
result += char;
break;
}
}
if (in_class) {
result += "]";
in_class = false;
}
if (extended_glob) {
result = result.replace(/\\\+\\\((.*?)\\\)/g, "($1)+").replace(/\\\@\\\((.*?)\\\)/g, "($1)").replace(/\\\!\\\((.*?)\\\)/g, "(?!$1).*").replace(/\\\?\\\((.*?)\\\)/g, "($1)?").replace(/\\\*\\\((.*?)\\\)/g, "($1)*");
}
return result;
}
__name(glob_to_regex_pattern, "glob_to_regex_pattern");
function glob_to_regex(pattern, options = {}) {
const default_options = {
case_sensitive: true,
extended_glob: false,
windows_paths: false
};
const merged_options = { ...default_options, ...options };
if (pattern === "") {
return /^$/;
}
if (pattern === "*" && !merged_options.windows_paths) {
return /^[^/]+$/;
}
if (pattern === "**" && !merged_options.windows_paths) {
return /^.+$/;
}
return create_regex(pattern, merged_options);
}
__name(glob_to_regex, "glob_to_regex");

function fuzzy_search(arr, search_term) {
let matches = [];
for (let i = 0; i < arr.length; i++) {
const search_chars = search_term.toLowerCase().split("");
let match = true;
let distance = 0;
const name = arr[i];
const label_name = name.toLowerCase();
for (let j = 0; j < search_chars.length; j++) {
const search_index = label_name.substring(distance).indexOf(search_chars[j]);
if (search_index >= 0) {
distance += search_index + 1;
} else {
match = false;
break;
}
}
if (match) matches.push({ name, distance });
}
matches.sort((a, b) => a.distance - b.distance);
return matches.map((match) => match.name);
}
__name(fuzzy_search, "fuzzy_search");

var SmartFs = class {
static {
__name(this, "SmartFs");
}
/**
* Create a new SmartFs instance
*
* @param {Object} env - The Smart Environment instance
* @param {Object} [opts={}] - Optional configuration
* @param {string} [opts.fs_path] - Custom environment path
*/
constructor(env, opts = {}) {
this.env = env;
this.opts = opts;
this.fs_path = opts.fs_path || opts.env_path || "";
if (!opts.adapter) throw new Error("SmartFs requires an adapter");
this.adapter = new opts.adapter(this);
this.excluded_patterns = [];
if (Array.isArray(opts.exclude_patterns)) {
opts.exclude_patterns.forEach((pattern) => this.add_ignore_pattern(pattern));
}
this.folders = {};
this.files = {};
this.file_paths = [];
this.folder_paths = [];
this.auto_excluded_files = [];
}
async refresh() {
this.files = {};
this.file_paths = [];
this.folders = {};
this.folder_paths = [];
await this.init();
}
async init() {
await this.load_exclusions();
await this.load_files();
}
async load_files() {
const all = await this.list_recursive();
this.file_paths = [];
this.folder_paths = [];
all.forEach((file) => {
if (file.type === "file") {
this.files[file.path] = file;
this.file_paths.push(file.path);
} else if (file.type === "folder") {
this.folders[file.path] = file;
this.folder_paths.push(file.path);
}
});
}
include_file(file_path) {
const file = this.adapter.get_file(file_path);
this.files[file.path] = file;
this.file_paths.push(file.path);
return file;
}
/**
* Load .gitignore patterns
*
* @returns {Promise<RegExp[]>} Array of RegExp patterns
*/
async load_exclusions() {
const gitignore_path = ".gitignore";
const gitignore_exists = await this.adapter.exists(gitignore_path);
if (gitignore_exists && !this.env.settings.skip_excluding_gitignore) {
const gitignore_content = await this.adapter.read(gitignore_path, "utf-8");
gitignore_content.split("\n").filter((line) => !line.startsWith("#")).filter(Boolean).forEach((pattern) => this.add_ignore_pattern(pattern));
}
this.add_ignore_pattern(".**");
this.add_ignore_pattern("**/.**");
this.add_ignore_pattern("**/.*/**");
this.add_ignore_pattern("**/*.ajson");
}
/**
* Add a new ignore pattern
*
* @param {string} pattern - The pattern to add
*/
add_ignore_pattern(pattern, opts = {}) {
this.excluded_patterns.push(glob_to_regex(pattern.trim(), opts));
}
/**
* Check if a path is ignored based on gitignore patterns
*
* @param {string} _path - The path to check
* @returns {boolean} True if the path is ignored, false otherwise
*/
is_excluded(_path) {
try {
if (_path.includes("#")) return true;
if (!this.excluded_patterns.length) return false;
return this.excluded_patterns.some((pattern) => pattern.test(_path));
} catch (e) {
console.error(`Error checking if path is excluded: ${e.message}`);
console.error(`Path: `, _path);
throw e;
}
}
/**
* Check if any path in an array of paths is excluded
*
* @param {string[]} paths - Array of paths to check
* @returns {boolean} True if any path is excluded, false otherwise
*/
has_excluded_patterns(paths) {
return paths.some((p) => this.is_excluded(p));
}
/**
* Pre-process an array of paths, throwing an error if any path is excluded
*
* @param {string[]} paths - Array of paths to pre-process
* @throws {Error} If any path in the array is excluded
* @returns {string[]} The array of paths
*/
pre_process(paths) {
if (this.has_excluded_patterns(paths)) {
throw new Error(`Path is excluded: ${paths.find((p) => this.is_excluded(p))}`);
}
return paths;
}
/**
* Post-process the result of an operation
*
* @param {any} returned_value - The value returned by the operation
* @returns {any} The post-processed value
*/
post_process(returned_value) {
if (this.adapter.post_process) return this.adapter.post_process(returned_value);
if (Array.isArray(returned_value)) {
returned_value = returned_value.filter((r) => {
if (typeof r === "string") return !this.is_excluded(r);
if (typeof r === "object" && r.path) return !this.is_excluded(r.path);
return true;
});
}
return returned_value;
}
/**
* Use the adapter for a method
* runs pre_process and post_process (checks exclusions)
* @param {string} method - The method to use
* @param {string[]} paths - The paths to use
* @param {...any} args - Additional arguments for the method
* @returns {Promise<any>} The result of the method
*/
async use_adapter(method, paths, ...args) {
if (!this.adapter[method]) throw new Error(`Method ${method} not found in adapter`);
paths = this.pre_process(paths ?? []);
let resp = await this.adapter[method](...paths, ...args);
return this.post_process(resp);
}
use_adapter_sync(method, paths, ...args) {
if (!this.adapter[method]) throw new Error(`Method ${method} not found in adapter`);
paths = this.pre_process(paths ?? []);
let resp = this.adapter[method](...paths, ...args);
return this.post_process(resp);
}
/**
* Append content to a file
*
* @param {string} rel_path - The relative path of the file to append to
* @param {string|Buffer} content - The content to append
* @returns {Promise<void>} A promise that resolves when the operation is complete
*/
async append(rel_path, content) {
return await this.use_adapter("append", [rel_path], content);
}
/**
* Create a new directory
*
* @param {string} rel_path - The relative path of the directory to create
* @returns {Promise<void>} A promise that resolves when the operation is complete
*/
async mkdir(rel_path, opts = { recursive: true }) {
return await this.use_adapter("mkdir", [rel_path], opts);
}
/**
* Check if a file or directory exists
*
* @param {string} rel_path - The relative path to check
* @returns {Promise<boolean>} True if the path exists, false otherwise
*/
async exists(rel_path) {
return await this.use_adapter("exists", [rel_path]);
}
exists_sync(rel_path) {
return this.use_adapter_sync("exists_sync", [rel_path]);
}
/**
* List files in a directory
*
* @param {string} rel_path - The relative path to list
* @returns {Promise<string[]>} Array of file paths
*/
async list(rel_path = "/") {
return await this.use_adapter("list", [rel_path]);
}
async list_recursive(rel_path = "/") {
return await this.use_adapter("list_recursive", [rel_path]);
}
async list_files(rel_path = "/") {
return await this.use_adapter("list_files", [rel_path]);
}
async list_files_recursive(rel_path = "/") {
return await this.use_adapter("list_files_recursive", [rel_path]);
}
async list_folders(rel_path = "/") {
return await this.use_adapter("list_folders", [rel_path]);
}
async list_folders_recursive(rel_path = "/") {
return await this.use_adapter("list_folders_recursive", [rel_path]);
}
/**
* Read the contents of a file
*
* @param {string} rel_path - The relative path of the file to read
* @returns {Promise<string|Buffer>} The contents of the file
*/
async read(rel_path, encoding = "utf-8") {
try {
const content = await this.adapter.read(rel_path, encoding);
return content;
} catch (error) {
console.warn("Error during read: " + error.message, rel_path);
if (error.code === "ENOENT") return null;
return { error: error.message };
}
}
/**
* Remove a file
*
* @param {string} rel_path - The relative path of the file to remove
* @returns {Promise<void>} A promise that resolves when the operation is complete
*/
async remove(rel_path) {
return await this.use_adapter("remove", [rel_path]);
}
/**
* Remove a directory
*
* @param {string} rel_path - The relative path of the directory to remove
* @returns {Promise<void>} A promise that resolves when the operation is complete
*/
async remove_dir(rel_path, recursive = false) {
return await this.use_adapter("remove_dir", [rel_path], recursive);
}
/**
* Rename a file or directory
*
* @param {string} rel_path - The current relative path
* @param {string} new_rel_path - The new relative path
* @returns {Promise<void>} A promise that resolves when the operation is complete
*/
async rename(rel_path, new_rel_path) {
await this.use_adapter("rename", [rel_path, new_rel_path]);
await this.refresh();
}
/**
* Get file or directory statistics
*
* @param {string} rel_path - The relative path to get statistics for
* @returns {Promise<Object>} An object containing file or directory statistics
*/
async stat(rel_path) {
return await this.use_adapter("stat", [rel_path]);
}
/**
* Write content to a file
* Should handle when target path is within a folder that doesn't exist
*
* @param {string} rel_path - The relative path of the file to write to
* @param {string|Buffer} content - The content to write
* @returns {Promise<void>} A promise that resolves when the operation is complete
*/
async write(rel_path, content) {
try {
await this.adapter.write(rel_path, content);
} catch (error) {
console.error("Error during write:", error);
throw error;
}
}
get_link_target_path(link_target, source_path) {
if (this.adapter.get_link_target_path) return this.adapter.get_link_target_path(link_target, source_path);
if (!this.file_paths) return console.warn("get_link_target_path: file_paths not found");
const matching_file_paths = this.file_paths.filter((path) => path.includes(link_target));
return fuzzy_search(matching_file_paths, link_target)[0];
}
get sep() {
return this.adapter.sep || "/";
}
get_full_path(rel_path = "") {
return this.adapter.get_full_path(rel_path);
}
get base_path() {
return this.adapter.get_base_path();
}
};

var obsidian = __toESM(require("obsidian"), 1);
var ObsidianFsAdapter = class {
static {
__name(this, "ObsidianFsAdapter");
}
/**
* Create an ObsidianFsAdapter instance
*
* @param {Object} smart_fs - The SmartFs instance
*/
constructor(smart_fs) {
this.smart_fs = smart_fs;
this.obsidian = obsidian;
this.obsidian_app = smart_fs.env.main.app;
this.obsidian_adapter = smart_fs.env.main.app.vault.adapter;
}
get fs_path() {
return this.smart_fs.fs_path;
}
get_file(file_path) {
const file = {};
file.path = file_path.replace(/\\/g, "/").replace(this.smart_fs.fs_path, "").replace(/^\//, "");
file.type = "file";
file.extension = file.path.split(".").pop().toLowerCase();
file.name = file.path.split("/").pop();
file.basename = file.name.split(".").shift();
Object.defineProperty(file, "stat", {
get: /* @__PURE__ */ __name(() => {
const tfile = this.obsidian_app.vault.getAbstractFileByPath(file_path);
if (tfile) {
return {
ctime: tfile.stat.ctime,
mtime: tfile.stat.mtime,
size: tfile.stat.size,
isDirectory: /* @__PURE__ */ __name(() => tfile instanceof this.obsidian.TFolder, "isDirectory"),
isFile: /* @__PURE__ */ __name(() => tfile instanceof this.obsidian.TFile, "isFile")
};
}
return null;
}, "get")
});
return file;
}
/**
* Append content to a file
*
* @param {string} rel_path - The relative path of the file to append to
* @param {string} data - The content to append
* @returns {Promise<void>} A promise that resolves when the operation is complete
*/
async append(rel_path, data) {
if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
return await this.obsidian_adapter.append(rel_path, data);
}
/**
* Create a new directory
*
* @param {string} rel_path - The relative path of the directory to create
* @returns {Promise<void>} A promise that resolves when the operation is complete
*/
async mkdir(rel_path) {
if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
return await this.obsidian_adapter.mkdir(rel_path);
}
/**
* Check if a file or directory exists
*
* @param {string} rel_path - The relative path to check
* @returns {Promise<boolean>} True if the path exists, false otherwise
*/
async exists(rel_path) {
if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
return await this.obsidian_adapter.exists(rel_path);
}
exists_sync(rel_path) {
return !!this.obsidian_app.vault.getAbstractFileByPath(rel_path);
}
/**
* List files in a directory (NOT up-to-date with list_recursive)
*
* @param {string} rel_path - The relative path to list
* @returns {Promise<string[]>} Array of file paths
*/
async list(rel_path, opts = {}) {
if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
if (rel_path.startsWith("/")) rel_path = rel_path.slice(1);
if (rel_path.endsWith("/")) rel_path = rel_path.slice(0, -1);
if (rel_path.includes(".")) {
const { files: file_paths } = await this.obsidian_adapter.list(rel_path);
const files2 = file_paths.map((file_path) => {
if (this.smart_fs.fs_path) file_path = file_path.replace(this.smart_fs.fs_path, "").slice(1);
const file_name = file_path.split("/").pop();
const file = {
basename: file_name.split(".")[0],
extension: file_name.split(".").pop().toLowerCase(),
name: file_name,
path: file_path
};
return file;
});
return files2;
}
const files = this.obsidian_app.vault.getAllLoadedFiles().filter((file) => {
const last_slash = file.path.lastIndexOf("/");
if (last_slash === -1 && rel_path !== "") return false;
const folder_path = file.path.slice(0, last_slash);
if (folder_path !== rel_path) return false;
return true;
});
return files;
}
async list_recursive(rel_path, opts = {}) {
if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
if (rel_path.startsWith("/")) rel_path = rel_path.slice(1);
if (rel_path.endsWith("/")) rel_path = rel_path.slice(0, -1);
const files = this.obsidian_app.vault.getAllLoadedFiles().filter((file) => {
if (file.path.length > 200) {
this.smart_fs.auto_excluded_files.push(file.path);
return false;
}
if (rel_path !== "" && !file.path.startsWith(rel_path)) return false;
if (file instanceof this.obsidian.TFile) {
if (opts.type === "folder") return false;
file.type = "file";
} else if (file instanceof this.obsidian.TFolder) {
if (opts.type === "file") return false;
delete file.basename;
delete file.extension;
file.type = "folder";
}
if (this.smart_fs.fs_path) file.path = file.path.replace(this.smart_fs.fs_path, "").slice(1);
return true;
});
return files;
}
async list_files(rel_path) {
return await this.list(rel_path, { type: "file" });
}
async list_files_recursive(rel_path) {
return await this.list_recursive(rel_path, { type: "file" });
}
async list_folders(rel_path) {
return await this.list(rel_path, { type: "folder" });
}
async list_folders_recursive(rel_path) {
return await this.list_recursive(rel_path, { type: "folder" });
}
/**
* Read the contents of a file
*
* @param {string} rel_path - The relative path of the file to read
* @returns {Promise<string>} The contents of the file
*/
async read(rel_path, encoding, opts = {}) {
if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
if (encoding === "utf-8") {
if (!opts.no_cache) {
const tfile = this.obsidian_app.vault.getFileByPath(rel_path);
if (tfile) return await this.obsidian_app.vault.cachedRead(tfile);
}
return await this.obsidian_adapter.read(rel_path);
}
if (encoding === "base64") {
const array_buffer2 = await this.obsidian_adapter.readBinary(rel_path, "base64");
const base644 = this.obsidian.arrayBufferToBase64(array_buffer2);
return base644;
}
const array_buffer = await this.obsidian_adapter.readBinary(rel_path);
return array_buffer;
}
/**
* Rename a file or directory
*
* @param {string} old_path - The current path of the file or directory
* @param {string} new_path - The new path for the file or directory
* @returns {Promise<void>} A promise that resolves when the operation is complete
*/
async rename(old_path, new_path) {
if (!old_path.startsWith(this.fs_path)) old_path = this.fs_path + "/" + old_path;
if (!new_path.startsWith(this.fs_path)) new_path = this.fs_path + "/" + new_path;
return await this.obsidian_adapter.rename(old_path, new_path);
}
/**
* Remove a file
*
* @param {string} rel_path - The relative path of the file to remove
* @returns {Promise<void>} A promise that resolves when the operation is complete
*/
async remove(rel_path) {
if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
try {
return await this.obsidian_adapter.remove(rel_path);
} catch (error) {
console.warn(`Error removing file: ${rel_path}`, error);
}
}
/**
* Remove a directory
*
* @param {string} rel_path - The relative path of the directory to remove
* @returns {Promise<void>} A promise that resolves when the operation is complete
*/
async remove_dir(rel_path, recursive = false) {
if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
return await this.obsidian_adapter.rmdir(rel_path, recursive);
}
/**
* Get file or directory information
*
* @param {string} rel_path - The relative path of the file or directory
* @returns {Promise<Object>} An object containing file or directory information
*/
async stat(rel_path) {
if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
return await this.obsidian_adapter.stat(rel_path);
}
/**
* Write content to a file
*
* @param {string} rel_path - The relative path of the file to write to
* @param {string} data - The content to write
* @returns {Promise<void>} A promise that resolves when the operation is complete
*/
async write(rel_path, data) {
if (!data) data = "";
if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
const folder_path = rel_path.split("/").slice(0, -1).join("/");
if (!await this.exists(folder_path)) {
await this.mkdir(folder_path);
console.log(`Created folder: ${folder_path}`);
}
return await this.obsidian_adapter.write(rel_path, data);
}
get_link_target_path(link_path, file_path) {
return this.obsidian_app.metadataCache.getFirstLinkpathDest(link_path, file_path)?.path;
}
get_base_path() {
return this.obsidian_adapter.basePath;
}
get_full_path(rel_path = "") {
const sep = rel_path.includes("/") ? "/" : "\\";
return this.get_base_path() + sep + rel_path;
}
/**
* Registers Obsidian vault/workspace listeners that emit Smart Environment events for Smart Sources.
* @param {import('smart-sources').SmartSources} sources_collection
* @returns {boolean}
*/
register_source_watchers(sources_collection) {
if (this._source_watchers_registered) return this._source_watchers_registered;
const plugin = this.smart_fs.env?.main;
if (!plugin?.registerEvent) {
console.warn("ObsidianFsAdapter: Unable to register source watchers without plugin context");
return false;
}
const { app } = plugin;
const emit_event = /* @__PURE__ */ __name((event_key, payload) => {
if (!payload?.path && !payload?.item_key) return;
this.smart_fs.env.events?.emit(event_key, {
collection_key: sources_collection.collection_key,
item_key: payload.item_key || payload.path,
...payload
});
}, "emit_event");
plugin.registerEvent(
app.vault.on("create", (file) => {
emit_event("sources:created", {
path: file.path,
event_source: "obsidian:vault.create"
});
})
);
plugin.registerEvent(
app.vault.on("modify", (file) => {
emit_event("sources:modified", {
path: file.path,
event_source: "obsidian:vault.modify"
});
})
);
plugin.registerEvent(
app.vault.on("rename", (file, old_path) => {
emit_event("sources:renamed", {
path: file.path,
old_path,
event_source: "obsidian:vault.rename"
});
})
);
plugin.registerEvent(
app.vault.on("delete", (file) => {
emit_event("sources:deleted", {
path: file.path,
event_source: "obsidian:vault.delete"
});
})
);
plugin.registerEvent(
app.workspace.on("editor-change", (_editor, info) => {
const file = info?.file;
if (!file) return;
emit_event("sources:modified", {
path: file.path,
event_source: "obsidian:workspace.editor-change"
});
})
);
this._source_watchers_registered = true;
return true;
}
};

function empty(elm) {
const range = document.createRange();
range.selectNodeContents(elm);
range.deleteContents();
}
__name(empty, "empty");

var replace_html = /* @__PURE__ */ (() => {
const cache = /* @__PURE__ */ new Map();
return (container, html_snippet) => {
const key = html_snippet.trim();
let tpl = cache.get(key);
if (!tpl) {
tpl = document.createElement("template");
tpl.innerHTML = key;
cache.set(key, tpl);
}
container.replaceChildren(tpl.content.cloneNode(true));
};
})();

var replace_with_fragment = /* @__PURE__ */ __name((container, html_snippet) => {
const range = document.createRange();
const frag = range.createContextualFragment(html_snippet.trim());
container.replaceChildren(frag);
}, "replace_with_fragment");

var restricted_re = /<(td|th|tr|thead|tbody|tfoot|caption|col|colgroup|option|optgroup|li|dt|dd|source|track)\b/i;
var safe_inner_html = /* @__PURE__ */ __name((container, html_snippet) => {
const trimmed = html_snippet.trim();
(restricted_re.test(trimmed) ? replace_with_fragment : replace_html)(container, trimmed);
}, "safe_inner_html");

function escape_html(str = "") {
return String(str).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}
__name(escape_html, "escape_html");

function murmur_hash_32(input_string, seed = 0) {
let remainder = input_string.length & 3;
let bytes = input_string.length - remainder;
let h1 = seed;
let c1 = 3432918353;
let c2 = 461845907;
let i = 0;
let k1 = 0;
let chunk = 0;
while (i < bytes) {
chunk = input_string.charCodeAt(i) & 255 | (input_string.charCodeAt(i + 1) & 255) << 8 | (input_string.charCodeAt(i + 2) & 255) << 16 | (input_string.charCodeAt(i + 3) & 255) << 24;
i += 4;
k1 = chunk;
k1 = multiply_32(k1, c1);
k1 = rotate_left_32(k1, 15);
k1 = multiply_32(k1, c2);
h1 ^= k1;
h1 = rotate_left_32(h1, 13);
h1 = h1 * 5 + 3864292196 | 0;
}
k1 = 0;
switch (remainder) {
case 3:
k1 ^= (input_string.charCodeAt(i + 2) & 255) << 16;
case 2:
k1 ^= (input_string.charCodeAt(i + 1) & 255) << 8;
case 1:
k1 ^= input_string.charCodeAt(i) & 255;
k1 = multiply_32(k1, c1);
k1 = rotate_left_32(k1, 15);
k1 = multiply_32(k1, c2);
h1 ^= k1;
break;
}
h1 ^= input_string.length;
h1 = fmix_32(h1);
return h1 | 0;
}
__name(murmur_hash_32, "murmur_hash_32");
function murmur_hash_32_alphanumeric(input_string, seed = 0) {
const signed_hash = murmur_hash_32(input_string, seed);
const unsigned_hash = signed_hash >>> 0;
return unsigned_hash.toString(36);
}
__name(murmur_hash_32_alphanumeric, "murmur_hash_32_alphanumeric");
function multiply_32(a, b) {
return (a & 65535) * b + ((a >>> 16) * b << 16) | 0;
}
__name(multiply_32, "multiply_32");
function rotate_left_32(value, shift) {
return value << shift | value >>> 32 - shift;
}
__name(rotate_left_32, "rotate_left_32");
function fmix_32(h) {
h ^= h >>> 16;
h = multiply_32(h, 2246822507);
h ^= h >>> 13;
h = multiply_32(h, 3266489909);
h ^= h >>> 16;
return h | 0;
}
__name(fmix_32, "fmix_32");

function convert_to_time_ago(timestamp) {
const now = Date.now();
const ms = timestamp < 1e12 ? timestamp * 1e3 : timestamp;
const diff_ms = now - ms;
const is_future = diff_ms < 0;
const seconds = Math.floor(Math.abs(diff_ms) / 1e3);
const intervals = [
{ label: "year", seconds: 31536e3 },
{ label: "month", seconds: 2592e3 },
{ label: "day", seconds: 86400 },
{ label: "hour", seconds: 3600 },
{ label: "minute", seconds: 60 },
{ label: "second", seconds: 1 }
];
for (const interval of intervals) {
const count = Math.floor(seconds / interval.seconds);
if (count >= 1) {
const suffix = `${count} ${interval.label}${count > 1 ? "s" : ""}`;
return is_future ? `in ${suffix}` : `${suffix} ago`;
}
}
return "just now";
}
__name(convert_to_time_ago, "convert_to_time_ago");

function cos_sim(vector1 = [], vector2 = []) {
if (vector1.length !== vector2.length) {
throw new Error("Vectors must have the same length");
}
let dot_product = 0;
let magnitude1 = 0;
let magnitude2 = 0;
const epsilon = 1e-8;
for (let i = 0; i < vector1.length; i++) {
dot_product += vector1[i] * vector2[i];
magnitude1 += vector1[i] * vector1[i];
magnitude2 += vector2[i] * vector2[i];
}
magnitude1 = Math.sqrt(magnitude1);
magnitude2 = Math.sqrt(magnitude2);
if (magnitude1 < epsilon || magnitude2 < epsilon) return 0;
return dot_product / (magnitude1 * magnitude2);
}
__name(cos_sim, "cos_sim");

function get_by_path(obj, path, scope = null) {
if (!path) return "";
const keys = path.split(".");
if (scope) {
keys.unshift(scope);
}
const final_key = keys.pop();
const instance = keys.reduce((acc, key) => acc && acc[key], obj);
if (instance && typeof instance[final_key] === "function") {
return instance[final_key].bind(instance);
}
return instance ? instance[final_key] : void 0;
}
__name(get_by_path, "get_by_path");

function set_by_path(obj, path, value, scope = null) {
const keys = path.split(".");
if (scope) {
keys.unshift(scope);
}
const final_key = keys.pop();
const target = keys.reduce((acc, key) => {
if (!acc[key] || typeof acc[key] !== "object") {
acc[key] = {};
}
return acc[key];
}, obj);
target[final_key] = value;
}
__name(set_by_path, "set_by_path");

function delete_by_path(obj, path, scope = null) {
const keys = path.split(".");
if (scope) {
keys.unshift(scope);
}
const final_key = keys.pop();
const instance = keys.reduce((acc, key) => acc && acc[key], obj);
if (instance) {
delete instance[final_key];
}
}
__name(delete_by_path, "delete_by_path");

function compute_centroid(points) {
if (!points || points.length === 0) {
return null;
}
const n = points.length;
const dim = points[0].length;
const sums = new Float64Array(dim);
for (let i = 0; i < n; i++) {
const p = points[i];
for (let d = 0; d < dim; d++) {
sums[d] += p[d];
}
}
for (let d = 0; d < dim; d++) {
sums[d] /= n;
}
return Array.from(sums);
}
__name(compute_centroid, "compute_centroid");
function compute_medoid(points) {
if (!points || points.length === 0) {
return null;
}
if (points.length === 1) {
return points[0];
}
const n = points.length;
const dim = points[0].length;
const sum_of_distances = new Float64Array(n);
for (let i = 0; i < n - 1; i++) {
const p_i = points[i];
for (let j = i + 1; j < n; j++) {
const p_j = points[j];
let dist_sq = 0;
for (let d = 0; d < dim; d++) {
const diff = p_i[d] - p_j[d];
dist_sq += diff * diff;
}
const dist = Math.sqrt(dist_sq);
sum_of_distances[i] += dist;
sum_of_distances[j] += dist;
}
}
let min_index = 0;
let min_sum = sum_of_distances[0];
for (let i = 1; i < n; i++) {
if (sum_of_distances[i] < min_sum) {
min_sum = sum_of_distances[i];
min_index = i;
}
}
return points[min_index];
}
__name(compute_medoid, "compute_medoid");

var element_disposers = /* @__PURE__ */ new WeakMap();
var smart_setting_listeners = /* @__PURE__ */ new WeakMap();
var SmartView = class {
static {
__name(this, "SmartView");
}
static version = 0.1;
/**
* @constructor
* @param {object} opts - Additional options or overrides for rendering.
*/
constructor(opts = {}) {
this.opts = opts;
this._adapter = null;
}
/**
* Renders all setting components within a container.
* @async
* @param {HTMLElement|DocumentFragment} container - The container element.
* @param {Object} opts - Additional options for rendering.
* @returns {Promise<void>}
*/
async render_setting_components(container, opts = {}) {
const components = container.querySelectorAll(".setting-component");
const promises = [];
for (const component of components) {
promises.push(this.render_setting_component(component, opts));
}
await Promise.all(promises);
return container;
}
/**
* Creates a document fragment from HTML string.
* @param {string} html - The HTML string.
* @returns {DocumentFragment}
*/
create_doc_fragment(html) {
return document.createRange().createContextualFragment(html);
}
/**
* Gets the adapter instance used for rendering (e.g., Obsidian or Node, etc.).
* @returns {Object} The adapter instance.
*/
get adapter() {
if (!this._adapter) {
if (!this.opts.adapter) {
throw new Error("No adapter provided to SmartView. Provide a 'smart_view.adapter' in env config.");
}
const AdapterClass = this.opts.adapter;
this._adapter = new AdapterClass(this);
}
return this._adapter;
}
/**
* Gets an icon (implemented in the adapter).
* @param {string} icon_name - Name of the icon to get.
* @returns {string} The icon HTML string.
*/
get_icon_html(icon_name) {
return this.adapter.get_icon_html(icon_name);
}
/**
* Renders a single setting component (implemented in adapter).
* @async
* @param {HTMLElement} setting_elm - The DOM element for the setting.
* @param {Object} opts - Additional options for rendering.
* @returns {Promise<*>}
*/
async render_setting_component(setting_elm, opts = {}) {
return await this.adapter.render_setting_component(setting_elm, opts);
}
/**
* Renders markdown content (implemented in adapter).
* @param {string} markdown - The markdown content.
* @param {object|null} scope - The scope to pass for rendering.
* @returns {Promise<DocumentFragment>}
*/
async render_markdown(markdown, scope = null) {
return await this.adapter.render_markdown(markdown, scope);
}
/**
* Gets a value from an object by path.
* @param {Object} obj - The object to search in.
* @param {string} path - The path to the value.
* @returns {*}
*/
get_by_path(obj, path, settings_scope = null) {
return get_by_path(obj, path, settings_scope);
}
/**
* Sets a value in an object by path.
* @param {Object} obj - The object to modify.
* @param {string} path - The path to set the value.
* @param {*} value - The value to set.
*/
set_by_path(obj, path, value, settings_scope = null) {
set_by_path(obj, path, value, settings_scope);
}
/**
* Deletes a value from an object by path.
* @param {Object} obj - The object to modify.
* @param {string} path - The path to delete the value.
*/
delete_by_path(obj, path, settings_scope = null) {
delete_by_path(obj, path, settings_scope);
}
/**
* Escapes HTML special characters in a string.
* @param {string} str - The string to escape.
* @returns {string} The escaped string.
*/
escape_html(str) {
return escape_html(str);
}
/**
* A convenience method to build a setting HTML snippet from a config object.
* @param {Object} setting_config
* @returns {string}
*/
render_setting_html(setting_config) {
if (setting_config.type === "html") {
return setting_config.value;
}
const attributes = Object.entries(setting_config).map(([attr, value]) => {
if (attr.includes("class")) return "";
if (typeof value === "number") return `data-${attr.replace(/_/g, "-")}=${value}`;
return `data-${attr.replace(/_/g, "-")}="${value}"`;
}).join("\n");
return `<div class="setting-component${setting_config.scope_class ? " " + setting_config.scope_class : ""}"
data-setting="${setting_config.setting}"
${attributes}
></div>`;
}
/**
* Renders settings from a config, returning a fragment.
* @async
* @deprecated Use render_settings_config utility in Obsidian (obsidian-smart-env)
* @param {Object} settings_config
* @param {Object} opts
* @param {Object} [opts.scope={}] - The scope to use when rendering settings (should have settings property).
* @returns {Promise<DocumentFragment>}
*/
async render_settings(settings_config40, opts = {}) {
const is_fx = typeof settings_config40 === "function";
const html = Object.entries(is_fx ? await settings_config40(opts.scope) : settings_config40).map(([setting_key, setting_config]) => {
if (!setting_config.setting) {
setting_config.setting = setting_key;
}
return this.render_setting_html(setting_config);
}).join("\n");
const frag = this.create_doc_fragment(`<div>${html}</div>`);
return await this.render_setting_components(frag, opts);
}
/**
* Scans the given container for elements that have `data-smart-setting` and attaches
* a 'change' event listener that updates the corresponding path in `scope.settings`.
*
* Listener bookkeeping is done via WeakMap, not DOM attributes, to avoid
* clone/attribute-related bugs on re-render.
*
* @param {Object} scope - An object containing a `settings` property, where new values will be stored.
* @param {HTMLElement|Document} [container=document] - The DOM element to scan. Defaults to the entire document.
*/
add_settings_listeners(scope, container = document) {
if (!container || typeof container.querySelectorAll !== "function") return;
const elements = container.querySelectorAll("[data-smart-setting]");
elements.forEach((elm) => {
const path = elm.dataset.smartSetting;
if (!path) return;
if (smart_setting_listeners.has(elm)) {
return;
}
const handler = /* @__PURE__ */ __name(() => {
let new_value;
if (elm instanceof HTMLInputElement) {
if (elm.type === "checkbox") {
new_value = elm.checked;
} else if (elm.type === "radio") {
if (elm.checked) {
new_value = elm.value;
} else {
return;
}
} else {
new_value = elm.value;
}
} else if (elm instanceof HTMLSelectElement || elm instanceof HTMLTextAreaElement) {
new_value = elm.value;
} else {
new_value = elm.value ?? elm.textContent;
}
this.set_by_path(scope.settings, path, new_value);
}, "handler");
smart_setting_listeners.set(elm, handler);
elm.addEventListener("change", handler);
if (elm instanceof HTMLElement) {
this.attach_disposer(elm, () => {
const existing = smart_setting_listeners.get(elm);
if (existing) {
elm.removeEventListener("change", existing);
smart_setting_listeners.delete(elm);
}
});
}
});
}
apply_style_sheet(sheet) {
if (typeof sheet === "string") {
const css_hash = murmur_hash_32_alphanumeric(sheet);
if (document.getElementById(`style-sheet-${css_hash}`)) {
return;
}
const styleEl = document.createElement("style");
styleEl.id = `style-sheet-${css_hash}`;
styleEl.textContent = sheet;
document.head.appendChild(styleEl);
return;
}
if ("adoptedStyleSheets" in Document.prototype) {
document.adoptedStyleSheets = [...document.adoptedStyleSheets, sheet];
} else {
const styleEl = document.createElement("style");
if (sheet.cssRules) {
styleEl.textContent = Array.from(sheet.cssRules).map((rule) => rule.cssText).join("\n");
}
document.head.appendChild(styleEl);
}
}
empty(elm) {
empty(elm);
}
safe_inner_html(elm, html) {
safe_inner_html(elm, html);
}
/**
* Attaches one or more disposer functions to an element that will be called
* when that element has been observed in the DOM and is later removed.
*
* - Multiple calls for the same element accumulate disposer functions.
* - Disposers are only invoked once, on the first removal after the
*   element has been in the DOM.
* - No DOM attributes or properties are used for bookkeeping; everything
*   is tracked via WeakMap.
*
* @param {HTMLElement} el - The element to monitor.
* @param {Function|Function[]} dispose - The disposer function or array of functions to call on removal.
*/
attach_disposer(el, dispose) {
if (!el) return;
const doc = el.ownerDocument;
const win = doc && doc.defaultView;
const MutationObserverCtor = win && win.MutationObserver;
if (!doc || !win || !MutationObserverCtor || !doc.body) return;
let dispose_fns;
if (typeof dispose === "function") {
dispose_fns = [dispose];
} else if (Array.isArray(dispose)) {
dispose_fns = dispose.filter((fn) => typeof fn === "function");
} else {
console.warn("[smart-view] attach_disposer called with invalid disposer");
return;
}
if (!dispose_fns.length) {
console.warn("[smart-view] attach_disposer called with no valid disposer functions");
return;
}
let entry = element_disposers.get(el);
if (!entry) {
entry = {
dispose_fns: /* @__PURE__ */ new Set(),
observer: null,
has_been_in_dom: false,
disposed: false
};
element_disposers.set(el, entry);
}
if (entry.disposed) {
entry.disposed = false;
entry.has_been_in_dom = false;
}
for (const fn of dispose_fns) {
entry.dispose_fns.add(fn);
}
if (!entry.observer) {
const observer = new MutationObserverCtor(() => {
const in_dom = doc.body.contains(el);
if (in_dom) {
entry.has_been_in_dom = true;
return;
}
if (!entry.has_been_in_dom || entry.disposed) {
return;
}
entry.disposed = true;
try {
for (const fn of entry.dispose_fns) {
try {
fn();
} catch (err) {
console.error("[smart-view] disposer error", err);
}
}
} finally {
try {
observer.disconnect();
} catch (e) {
}
if (element_disposers.get(el) === entry) {
element_disposers.delete(el);
}
}
});
entry.observer = observer;
observer.observe(doc.body, { childList: true, subtree: true });
}
}
};

var SmartViewAdapter = class {
static {
__name(this, "SmartViewAdapter");
}
constructor(main) {
this.main = main;
}
/**
* Retrieves the class used for settings.
* Must be overridden by subclasses to return the appropriate setting class.
* @abstract
* @returns {Function} The setting class constructor.
* @throws Will throw an error if not implemented in the subclass.
*/
get setting_class() {
throw new Error("setting_class() not implemented");
}
/**
* Generates the HTML for a specified icon.
* Must be overridden by subclasses to provide the correct icon HTML.
* @abstract
* @param {string} icon_name - The name of the icon to generate HTML for.
* @returns {string} The HTML string representing the icon.
* @throws Will throw an error if not implemented in the subclass.
*/
get_icon_html(icon_name) {
throw new Error("get_icon_html() not implemented");
}
/**
* Renders Markdown content within a specific scope.
* Must be overridden by subclasses to handle Markdown rendering appropriately.
* @abstract
* @param {string} markdown - The Markdown content to render.
* @param {object|null} [scope=null] - The scope within which to render the Markdown.
* @returns {Promise<void>} A promise that resolves when rendering is complete.
* @throws Will throw an error if not implemented in the subclass.
*/
async render_markdown(markdown, scope = null) {
throw new Error("render_markdown() not implemented");
}
/**
* Opens a specified URL.
* Should be overridden by subclasses to define how URLs are opened.
* @abstract
* @param {string} url - The URL to open.
*/
open_url(url) {
throw new Error("open_url() not implemented");
}
/**
* Handles the selection of a folder by invoking the folder selection dialog and updating the setting.
* @abstract
* @param {string} setting - The path of the setting being modified.
* @param {string} value - The current value of the setting.
* @param {HTMLElement} elm - The HTML element associated with the setting.
* @param {object} scope - The current scope containing settings and actions.
*/
handle_folder_select(path, value, elm, scope) {
throw new Error("handle_folder_select not implemented");
}
/**
* Handles the selection of a file by invoking the file selection dialog and updating the setting.
* @abstract
* @param {string} setting - The path of the setting being modified.
* @param {string} value - The current value of the setting.
* @param {HTMLElement} elm - The HTML element associated with the setting.
* @param {object} scope - The current scope containing settings and actions.
*/
handle_file_select(path, value, elm, scope) {
throw new Error("handle_file_select not implemented");
}
/**
* Performs actions before a setting is changed, such as clearing notices and updating the UI.
* @abstract
* @param {string} setting - The path of the setting being changed.
* @param {*} value - The new value for the setting.
* @param {HTMLElement} elm - The HTML element associated with the setting.
* @param {object} scope - The current scope containing settings and actions.
*/
pre_change(path, value, elm) {
}
/**
* Performs actions after a setting is changed, such as updating UI elements.
* @abstract
* @param {string} setting - The path of the setting that was changed.
* @param {*} value - The new value for the setting.
* @param {HTMLElement} elm - The HTML element associated with the setting.
* @param {object} changed - Additional information about the change.
*/
post_change(path, value, elm) {
}
/**
* Reverts a setting to its previous value in case of validation failure or error.
* @abstract
* @param {string} setting - The path of the setting to revert.
* @param {HTMLElement} elm - The HTML element associated with the setting.
* @param {object} scope - The current scope containing settings.
*/
revert_setting(path, elm, scope) {
console.warn("revert_setting() not implemented");
}
get setting_renderers() {
return {
text: this.render_text_component,
string: this.render_text_component,
password: this.render_password_component,
number: this.render_number_component,
dropdown: this.render_dropdown_component,
toggle: this.render_toggle_component,
textarea: this.render_textarea_component,
textarea_array: this.render_textarea_array_component,
button: this.render_button_component,
remove: this.render_remove_component,
folder: this.render_folder_select_component,
"text-file": this.render_file_select_component,
file: this.render_file_select_component,
slider: this.render_slider_component,
html: this.render_html_component,
button_with_confirm: this.render_button_with_confirm_component,
json: this.render_json_component,
array: this.render_array_component
};
}
async render_setting_component(elm, opts = {}) {
this.empty(elm);
const path = elm.dataset.setting;
const scope = opts.scope || this.main.main;
const settings_scope = opts.settings_scope || null;
try {
let value = elm.dataset.value ?? this.main.get_by_path(scope.settings, path, settings_scope);
if (typeof value === "undefined" && typeof elm.dataset.default !== "undefined") {
value = elm.dataset.default;
if (typeof value === "string") value = value.toLowerCase() === "true" ? true : value === "false" ? false : value;
this.main.set_by_path(scope.settings, path, value, settings_scope);
}
const renderer = this.setting_renderers[elm.dataset.type];
if (!renderer) {
console.warn(`Unsupported setting type: ${elm.dataset.type}`);
return elm;
}
const setting = renderer.call(this, elm, path, value, scope, settings_scope);
if (elm.dataset.name) setting.setName(elm.dataset.name);
if (elm.dataset.description) {
const frag = this.main.create_doc_fragment(`<span>${elm.dataset.description}</span>`);
setting.setDesc(frag);
}
if (elm.dataset.tooltip) setting.setTooltip(elm.dataset.tooltip);
this.add_button_if_needed(setting, elm, path, scope);
this.handle_disabled_and_hidden(elm);
return elm;
} catch (e) {
console.error(JSON.stringify({ path, elm }, null, 2));
console.error(JSON.stringify(e, null, 2));
}
}
render_dropdown_component(elm, path, value, scope, settings_scope) {
const smart_setting = new this.setting_class(elm);
let options;
smart_setting.addDropdown((dropdown) => {
if (elm.dataset.required) dropdown.selectEl.setAttribute("required", true);
const opts_callback = elm.dataset.optionsCallback ? this.main.get_by_path(scope, elm.dataset.optionsCallback) : null;
if (typeof opts_callback === "function") {
console.log(`getting options callback: ${elm.dataset.optionsCallback}`);
Promise.resolve(opts_callback()).then((opts) => {
opts.forEach((option) => {
const opt = dropdown.addOption(option.value, option.label ?? option.name ?? option.value);
opt.selected = option.value === value;
if (opts.length === 1 && opt.selected) dropdown.selectEl.classList.add("dropdown-no-options");
});
dropdown.setValue(value);
});
} else {
if (!options || !options.length) {
options = this.get_dropdown_options(elm);
}
options.forEach((option) => {
const opt = dropdown.addOption(option.value, option.label ?? option.name ?? option.value);
opt.selected = option.value === value;
if (options.length === 1 && opt.selected) dropdown.selectEl.classList.add("dropdown-no-options");
});
dropdown.setValue(value);
}
dropdown.onChange((value2) => {
this.handle_on_change(path, value2, elm, scope, settings_scope);
});
});
return smart_setting;
}
render_text_component(elm, path, value, scope, settings_scope) {
const smart_setting = new this.setting_class(elm);
smart_setting.addText((text) => {
text.setPlaceholder(elm.dataset.placeholder || "");
if (value) text.setValue(value);
let debounceTimer;
if (elm.dataset.button) {
smart_setting.addButton((button) => {
button.setButtonText(elm.dataset.button);
button.onClick(async () => this.handle_on_change(path, text.getValue(), elm, scope));
});
} else {
text.onChange(async (value2) => {
clearTimeout(debounceTimer);
debounceTimer = setTimeout(() => this.handle_on_change(path, value2.trim(), elm, scope, settings_scope), 2e3);
});
}
});
return smart_setting;
}
render_password_component(elm, path, value, scope, settings_scope) {
const smart_setting = new this.setting_class(elm);
smart_setting.addText((text) => {
text.inputEl.type = "password";
text.setPlaceholder(elm.dataset.placeholder || "");
if (value) text.setValue(value);
let debounceTimer;
text.onChange(async (value2) => {
clearTimeout(debounceTimer);
debounceTimer = setTimeout(() => this.handle_on_change(path, value2, elm, scope, settings_scope), 2e3);
});
});
return smart_setting;
}
render_number_component(elm, path, value, scope, settings_scope) {
const smart_setting = new this.setting_class(elm);
smart_setting.addText((number) => {
number.inputEl.type = "number";
number.setPlaceholder(elm.dataset.placeholder || "");
if (typeof value !== "undefined") number.inputEl.value = parseInt(value);
number.inputEl.min = elm.dataset.min || 0;
if (elm.dataset.max) number.inputEl.max = elm.dataset.max;
let debounceTimer;
number.onChange(async (value2) => {
clearTimeout(debounceTimer);
debounceTimer = setTimeout(() => this.handle_on_change(path, parseInt(value2), elm, scope, settings_scope), 2e3);
});
});
return smart_setting;
}
render_toggle_component(elm, path, value, scope, settings_scope) {
const smart_setting = new this.setting_class(elm);
smart_setting.addToggle((toggle) => {
let checkbox_val = value ?? false;
if (typeof checkbox_val === "string") {
checkbox_val = checkbox_val.toLowerCase() === "true";
}
toggle.setValue(checkbox_val);
toggle.onChange(async (value2) => this.handle_on_change(path, value2, elm, scope, settings_scope));
});
return smart_setting;
}
render_textarea_component(elm, path, value, scope, settings_scope) {
const smart_setting = new this.setting_class(elm);
smart_setting.addTextArea((textarea) => {
textarea.setPlaceholder(elm.dataset.placeholder || "");
textarea.setValue(value || "");
let debounceTimer;
textarea.onChange(async (value2) => {
clearTimeout(debounceTimer);
debounceTimer = setTimeout(() => this.handle_on_change(path, value2, elm, scope, settings_scope), 2e3);
});
});
return smart_setting;
}
render_textarea_array_component(elm, path, value, scope, settings_scope) {
const smart_setting = new this.setting_class(elm);
smart_setting.addTextArea((textarea) => {
textarea.setPlaceholder(elm.dataset.placeholder || "");
textarea.setValue(Array.isArray(value) ? value.join("\n") : value || "");
let debounceTimer;
textarea.onChange(async (value2) => {
value2 = value2.split("\n").map((v) => v.trim()).filter((v) => v);
clearTimeout(debounceTimer);
debounceTimer = setTimeout(() => this.handle_on_change(path, value2, elm, scope, settings_scope), 2e3);
});
});
return smart_setting;
}
render_button_component(elm, path, value, scope, settings_scope) {
const smart_setting = new this.setting_class(elm);
smart_setting.addButton((button) => {
button.setButtonText(elm.dataset.btnText || elm.dataset.name);
button.onClick(async () => {
if (elm.dataset.confirm && !confirm(elm.dataset.confirm)) return;
if (elm.dataset.href) this.open_url(elm.dataset.href);
if (elm.dataset.callback) {
const callback = this.main.get_by_path(scope, elm.dataset.callback);
if (callback) callback(path, value, elm, scope, settings_scope);
}
});
});
return smart_setting;
}
render_remove_component(elm, path, value, scope, settings_scope) {
const smart_setting = new this.setting_class(elm);
smart_setting.addButton((button) => {
button.setButtonText(elm.dataset.btnText || elm.dataset.name || "Remove");
button.onClick(async () => {
this.main.delete_by_path(scope.settings, path, settings_scope);
if (elm.dataset.callback) {
const callback = this.main.get_by_path(scope, elm.dataset.callback);
if (callback) callback(path, value, elm, scope, settings_scope);
}
});
});
return smart_setting;
}
render_folder_select_component(elm, path, value, scope, settings_scope) {
const smart_setting = new this.setting_class(elm);
smart_setting.addFolderSelect((folder_select) => {
folder_select.setPlaceholder(elm.dataset.placeholder || "");
if (value) folder_select.setValue(value);
folder_select.inputEl.closest("div").addEventListener("click", () => {
this.handle_folder_select(path, value, elm, scope);
});
folder_select.inputEl.querySelector("input").addEventListener("change", (e) => {
const folder = e.target.value;
this.handle_on_change(path, folder, elm, scope, settings_scope);
});
});
return smart_setting;
}
render_file_select_component(elm, path, value, scope, settings_scope) {
const smart_setting = new this.setting_class(elm);
smart_setting.addFileSelect((file_select) => {
file_select.setPlaceholder(elm.dataset.placeholder || "");
if (value) file_select.setValue(value);
file_select.inputEl.closest("div").addEventListener("click", () => {
this.handle_file_select(path, value, elm, scope, settings_scope);
});
});
return smart_setting;
}
render_slider_component(elm, path, value, scope, settings_scope) {
const smart_setting = new this.setting_class(elm);
smart_setting.addSlider((slider) => {
const min = parseFloat(elm.dataset.min) || 0;
const max = parseFloat(elm.dataset.max) || 100;
const step = parseFloat(elm.dataset.step) || 1;
const currentValue = typeof value !== "undefined" ? parseFloat(value) : min;
slider.setLimits(min, max, step);
slider.setValue(currentValue);
slider.onChange((newVal) => {
const numericVal = parseFloat(newVal);
this.handle_on_change(path, numericVal, elm, scope, settings_scope);
});
});
return smart_setting;
}
render_html_component(elm, path, value, scope) {
this.safe_inner_html(elm, value);
return elm;
}
/**
* Renders an array setting component for managing a list of strings.
* @param {HTMLElement} elm - Container element for the setting.
* @param {string} path - Dot-notation path to store the array.
* @param {Array<string>} value - Initial array value.
* @param {object} scope - Scope containing settings and actions.
* @param {object|null} settings_scope - Optional nested settings scope.
* @returns {object} smart_setting instance.
*/
render_array_component(elm, path, value, scope, settings_scope) {
const smart_setting = new this.setting_class(elm);
let arr = Array.isArray(value) ? [...value] : [];
const items_container = document.createElement("div");
items_container.className = "array-items-container";
const render_items = /* @__PURE__ */ __name(() => {
items_container.innerHTML = "";
arr.forEach((val, idx) => {
const row = document.createElement("div");
row.className = "array-item-row";
const input = document.createElement("input");
input.type = "text";
input.value = val;
input.placeholder = "Value";
const remove_btn = document.createElement("button");
remove_btn.textContent = "\u2715";
remove_btn.title = "Remove";
input.addEventListener("change", () => {
arr[idx] = input.value;
trigger_change();
});
remove_btn.addEventListener("click", () => {
arr.splice(idx, 1);
render_items();
trigger_change();
});
row.appendChild(input);
row.appendChild(remove_btn);
items_container.appendChild(row);
});
}, "render_items");
const add_row = document.createElement("div");
add_row.className = "array-add-row";
const new_input = document.createElement("input");
new_input.type = "text";
new_input.placeholder = "Value";
const add_btn = document.createElement("button");
add_btn.textContent = "+";
add_btn.title = "Add value";
add_btn.addEventListener("click", () => {
const v = new_input.value.trim();
if (!v) return;
arr.push(v);
new_input.value = "";
render_items();
trigger_change();
});
add_row.appendChild(new_input);
add_row.appendChild(add_btn);
smart_setting.controlEl.appendChild(items_container);
smart_setting.controlEl.appendChild(add_row);
const trigger_change = /* @__PURE__ */ __name(() => {
this.handle_on_change(path, [...arr], elm, scope, settings_scope);
}, "trigger_change");
render_items();
elm.appendChild(smart_setting.settingEl);
return smart_setting;
}
render_json_component(elm, path, value, scope, settings_scope) {
try {
const smart_setting = new this.setting_class(elm);
let obj = typeof value === "object" && value !== null ? { ...value } : {};
const pairs_container = document.createElement("div");
pairs_container.className = "json-pairs-container";
const renderPairs = /* @__PURE__ */ __name(() => {
pairs_container.innerHTML = "";
Object.entries(obj).forEach(([key, val], idx) => {
const pair_div = document.createElement("div");
pair_div.className = "json-pair-row";
const key_i = document.createElement("input");
key_i.type = "text";
key_i.value = key;
key_i.placeholder = "Property";
const value_i = document.createElement("input");
value_i.type = "text";
value_i.value = val;
value_i.placeholder = "Value";
const remove_btn = document.createElement("button");
remove_btn.textContent = "\u2715";
remove_btn.title = "Remove";
key_i.addEventListener("change", () => {
const newKey = key_i.value.trim();
if (!newKey) return;
if (newKey !== key) {
obj[newKey] = obj[key];
delete obj[key];
renderPairs();
triggerChange();
}
});
value_i.addEventListener("change", () => {
obj[key_i.value] = value_i.value;
triggerChange();
});
remove_btn.addEventListener("click", () => {
delete obj[key_i.value];
renderPairs();
triggerChange();
});
pair_div.appendChild(key_i);
pair_div.appendChild(value_i);
pair_div.appendChild(remove_btn);
pairs_container.appendChild(pair_div);
});
}, "renderPairs");
const add_div = document.createElement("div");
add_div.className = "json-add-row";
const new_key_i = document.createElement("input");
new_key_i.type = "text";
new_key_i.placeholder = "Property";
const new_val_i = document.createElement("input");
new_val_i.type = "text";
new_val_i.placeholder = "Value";
const add_btn = document.createElement("button");
add_btn.textContent = "+";
add_btn.title = "Add property";
add_btn.addEventListener("click", () => {
const k = new_key_i.value.trim();
if (!k || k in obj) return;
obj[k] = new_val_i.value;
new_key_i.value = "";
new_val_i.value = "";
renderPairs();
triggerChange();
});
add_div.appendChild(new_key_i);
add_div.appendChild(new_val_i);
add_div.appendChild(add_btn);
smart_setting.controlEl.appendChild(pairs_container);
smart_setting.controlEl.appendChild(add_div);
const triggerChange = /* @__PURE__ */ __name(() => {
this.handle_on_change(path, { ...obj }, elm, scope, settings_scope);
}, "triggerChange");
renderPairs();
elm.appendChild(smart_setting.settingEl);
return smart_setting;
} catch (e) {
console.error(e);
}
}
add_button_if_needed(smart_setting, elm, path, scope) {
if (elm.dataset.btn) {
smart_setting.addButton((button) => {
button.setButtonText(elm.dataset.btn);
if (elm.dataset.btnCallback || elm.dataset.btnHref || elm.dataset.callback || elm.dataset.href) {
button.inputEl.addEventListener("click", (e) => {
if (elm.dataset.btnCallback && typeof scope[elm.dataset.btnCallback] === "function") {
if (elm.dataset.btnCallbackArg) scope[elm.dataset.btnCallback](elm.dataset.btnCallbackArg);
else scope[elm.dataset.btnCallback](path, null, smart_setting, scope);
} else if (elm.dataset.btnHref) {
this.open_url(elm.dataset.btnHref);
} else if (elm.dataset.callback && typeof this.main.get_by_path(scope, elm.dataset.callback) === "function") {
this.main.get_by_path(scope, elm.dataset.callback)(path, null, smart_setting, scope);
} else if (elm.dataset.href) {
this.open_url(elm.dataset.href);
} else {
console.error("No callback or href found for button.");
}
});
}
if (elm.dataset.btnDisabled || elm.dataset.disabled && elm.dataset.btnDisabled !== "false") {
button.inputEl.disabled = true;
}
});
}
}
handle_disabled_and_hidden(elm) {
if (elm.dataset.disabled && elm.dataset.disabled !== "false") {
elm.classList.add("disabled");
elm.querySelector("input, select, textarea, button").disabled = true;
}
if (elm.dataset.hidden && elm.dataset.hidden !== "false") {
elm.style.display = "none";
}
}
get_dropdown_options(elm) {
return Object.entries(elm.dataset).reduce((acc, [k, v]) => {
if (!k.startsWith("option")) return acc;
const [value, name] = v.split("|");
acc.push({ value, name: name || value });
return acc;
}, []);
}
handle_on_change(path, value, elm, scope, settings_scope) {
this.pre_change(path, value, elm, scope);
if (elm.dataset.validate) {
const valid = this[elm.dataset.validate](path, value, elm, scope);
if (!valid) {
elm.querySelector(".setting-item").style.border = "2px solid red";
this.revert_setting(path, elm, scope);
return;
}
}
this.main.set_by_path(scope.settings, path, value, settings_scope);
if (elm.dataset.callback) {
const callback = this.main.get_by_path(scope, elm.dataset.callback);
if (callback) callback(path, value, elm, scope);
}
this.post_change(path, value, elm, scope);
}
render_button_with_confirm_component(elm, path, value, scope) {
const smart_setting = new this.setting_class(elm);
smart_setting.addButton((button) => {
button.setButtonText(elm.dataset.btnText || elm.dataset.name);
elm.appendChild(this.main.create_doc_fragment(`
<div class="sc-inline-confirm-row" style="
display: none;
">
<span style="margin-right: 10px;">
${elm.dataset.confirm || "Are you sure?"}
</span>
<span class="sc-inline-confirm-row-buttons">
<button class="sc-inline-confirm-yes">Yes</button>
<button class="sc-inline-confirm-cancel">Cancel</button>
</span>
</div>
`));
const confirm_row = elm.querySelector(".sc-inline-confirm-row");
const confirm_yes = confirm_row.querySelector(".sc-inline-confirm-yes");
const confirm_cancel = confirm_row.querySelector(".sc-inline-confirm-cancel");
button.onClick(async () => {
confirm_row.style.display = "block";
elm.querySelector(".setting-item").style.display = "none";
});
confirm_yes.addEventListener("click", async () => {
if (elm.dataset.href) this.open_url(elm.dataset.href);
if (elm.dataset.callback) {
const callback = this.main.get_by_path(scope, elm.dataset.callback);
if (callback) callback(path, value, elm, scope);
}
elm.querySelector(".setting-item").style.display = "block";
confirm_row.style.display = "none";
});
confirm_cancel.addEventListener("click", () => {
confirm_row.style.display = "none";
elm.querySelector(".setting-item").style.display = "block";
});
});
return smart_setting;
}
empty(elm) {
empty(elm);
}
safe_inner_html(elm, html) {
safe_inner_html(elm, html);
}
};

var import_obsidian = require("obsidian");
var SmartViewObsidianAdapter = class extends SmartViewAdapter {
static {
__name(this, "SmartViewObsidianAdapter");
}
get setting_class() {
return import_obsidian.Setting;
}
open_url(url) {
window.open(url);
}
async render_file_select_component(elm, path, value) {
return super.render_text_component(elm, path, value);
}
async render_markdown(markdown, scope) {
const component = scope.env.smart_connections_plugin?.connections_view || new import_obsidian.Component();
if (!scope) return console.warn("Scope required for rendering markdown in Obsidian adapter");
const frag = this.main.create_doc_fragment("<div><div class='inner'></div></div>");
const container = frag.querySelector(".inner");
try {
await import_obsidian.MarkdownRenderer.render(
scope.env.plugin.app,
markdown,
container,
scope?.file_path || "",
component
);
} catch (e) {
console.warn("Error rendering markdown in Obsidian adapter", e);
}
return frag;
}
get_icon_html(name) {
return (0, import_obsidian.getIcon)(name).outerHTML;
}
is_mod_event(event) {
return import_obsidian.Keymap.isModEvent(event);
}
render_folder_select_component(elm, path, value, scope, settings_scope) {
const smart_setting = new this.setting_class(elm);
const folders = scope.env.plugin.app.vault.getAllFolders().sort((a, b) => a.path.localeCompare(b.path));
smart_setting.addDropdown((dropdown) => {
if (elm.dataset.required) dropdown.inputEl.setAttribute("required", true);
dropdown.addOption("", "No folder selected");
folders.forEach((folder) => {
dropdown.addOption(folder.path, folder.path);
});
dropdown.onChange((value2) => {
this.handle_on_change(path, value2, elm, scope, settings_scope);
});
dropdown.setValue(value);
});
return smart_setting;
}
};

function collection_instance_name_from(class_name) {
if (class_name.endsWith("Item")) {
return class_name.replace(/Item$/, "").replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
}
return class_name.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase().replace(/y$/, "ie") + "s";
}
__name(collection_instance_name_from, "collection_instance_name_from");

function create_uid(data) {
const str = JSON.stringify(data);
let hash = 0;
if (str.length === 0) return hash;
for (let i = 0; i < str.length; i++) {
const char = str.charCodeAt(i);
hash = (hash << 5) - hash + char;
hash = hash & hash;
if (hash < 0) hash = hash * -1;
}
return hash.toString() + str.length;
}
__name(create_uid, "create_uid");

function deep_equal(obj1, obj2, visited = /* @__PURE__ */ new WeakMap()) {
if (obj1 === obj2) return true;
if (obj1 === null || obj2 === null || obj1 === void 0 || obj2 === void 0) return false;
if (typeof obj1 !== typeof obj2 || Array.isArray(obj1) !== Array.isArray(obj2)) return false;
if (Array.isArray(obj1)) {
if (obj1.length !== obj2.length) return false;
return obj1.every((item, index) => deep_equal(item, obj2[index], visited));
}
if (typeof obj1 === "object") {
if (visited.has(obj1)) return visited.get(obj1) === obj2;
visited.set(obj1, obj2);
const keys1 = Object.keys(obj1);
const keys2 = Object.keys(obj2);
if (keys1.length !== keys2.length) return false;
return keys1.every((key) => deep_equal(obj1[key], obj2[key], visited));
}
return obj1 === obj2;
}
__name(deep_equal, "deep_equal");

function get_item_display_name(key, show_full_path) {
if (show_full_path) {
return key.split("/").join(" > ").replace(".md", "");
}
return key.split("/").pop().replace(".md", "");
}
__name(get_item_display_name, "get_item_display_name");

function create_actions_proxy(ctx, actions_source) {
const input = actions_source || {};
const is_plain_object9 = /* @__PURE__ */ __name((val) => typeof val === "object" && val !== null && !Array.isArray(val), "is_plain_object");
const is_function = /* @__PURE__ */ __name((val) => typeof val === "function", "is_function");
const is_class_export = /* @__PURE__ */ __name((val) => is_function(val) && /^class\s/.test(Function.prototype.toString.call(val)), "is_class_export");
const is_action_object = /* @__PURE__ */ __name((val) => is_plain_object9(val) && is_function(val.action), "is_action_object");
const is_action_candidate = /* @__PURE__ */ __name((val) => is_function(val) || is_action_object(val) || is_class_export(val), "is_action_candidate");
const ignored_meta_keys = /* @__PURE__ */ new Set(["length", "name", "prototype"]);
const clone_with_descriptors = /* @__PURE__ */ __name((obj) => {
if (!is_plain_object9(obj)) return obj;
const out = Object.create(Object.getPrototypeOf(obj) || null);
for (const key of Reflect.ownKeys(obj)) {
const descriptor = Object.getOwnPropertyDescriptor(obj, key);
if (!descriptor) continue;
const next = { ...descriptor };
if ("value" in next && is_plain_object9(next.value)) {
next.value = clone_with_descriptors(next.value);
}
try {
Object.defineProperty(out, key, next);
} catch {
out[key] = next.value;
}
}
return out;
}, "clone_with_descriptors");
const should_bucket_actions = /* @__PURE__ */ __name((val) => {
if (!is_plain_object9(val)) return false;
if (is_action_object(val)) return false;
const keys = Reflect.ownKeys(val);
if (keys.length === 0) return false;
let found_candidate = false;
for (const key of keys) {
const descriptor = Object.getOwnPropertyDescriptor(val, key);
if (!descriptor) continue;
if ("value" in descriptor) {
const entry = descriptor.value;
if (is_action_candidate(entry)) {
found_candidate = true;
continue;
}
if (is_plain_object9(entry)) {
if (should_bucket_actions(entry)) {
found_candidate = true;
continue;
}
return false;
}
if (typeof entry === "undefined") continue;
return false;
}
return false;
}
return found_candidate;
}, "should_bucket_actions");
const clone_descriptor = /* @__PURE__ */ __name((descriptor) => {
if (!descriptor) return descriptor;
if (!("value" in descriptor)) return { ...descriptor };
const cloned = is_plain_object9(descriptor.value) ? clone_with_descriptors(descriptor.value) : descriptor.value;
return { ...descriptor, value: cloned };
}, "clone_descriptor");
const build_sources = /* @__PURE__ */ __name((src) => {
const global_source2 = /* @__PURE__ */ Object.create(null);
const scoped_sources2 = /* @__PURE__ */ new Map();
for (const key of Reflect.ownKeys(src)) {
const descriptor = Object.getOwnPropertyDescriptor(src, key);
if (!descriptor) continue;
if ("value" in descriptor && should_bucket_actions(descriptor.value)) {
scoped_sources2.set(key, clone_with_descriptors(descriptor.value));
continue;
}
try {
Object.defineProperty(global_source2, key, clone_descriptor(descriptor));
} catch {
global_source2[key] = descriptor.value;
}
}
return { global_source: global_source2, scoped_sources: scoped_sources2 };
}, "build_sources");
const { global_source, scoped_sources } = build_sources(input);
const has_own = /* @__PURE__ */ __name((obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop), "has_own");
const cache = /* @__PURE__ */ Object.create(null);
const copy_metadata = /* @__PURE__ */ __name((source, target, omit = []) => {
if (!source || !target) return;
const skips = /* @__PURE__ */ new Set([...ignored_meta_keys, ...omit]);
for (const key of Reflect.ownKeys(source)) {
if (skips.has(key)) continue;
const descriptor = Object.getOwnPropertyDescriptor(source, key);
if (!descriptor) continue;
try {
Object.defineProperty(target, key, descriptor);
} catch {
target[key] = descriptor.value;
}
}
}, "copy_metadata");
const instantiate_class = /* @__PURE__ */ __name((Ctor) => {
const instance = new Ctor(ctx);
const candidate = instance.action || instance.run || instance.execute || instance.call;
if (is_function(candidate)) {
const bound = candidate.bind(instance);
copy_metadata(Ctor, bound);
copy_metadata(instance, bound);
bound.instance = instance;
return bound;
}
copy_metadata(Ctor, instance);
return instance;
}, "instantiate_class");
const bind_or_clone = /* @__PURE__ */ __name((val) => {
if (is_class_export(val)) {
return instantiate_class(val);
}
if (is_action_object(val)) {
const bound = val.action.bind(ctx);
copy_metadata(val, bound, ["action"]);
return bound;
}
if (is_function(val)) {
const bound = val.bind(ctx);
copy_metadata(val, bound);
return bound;
}
if (is_plain_object9(val)) {
return clone_with_descriptors(val);
}
return val;
}, "bind_or_clone");
const scope_actions_for = /* @__PURE__ */ __name(() => {
const scope_key = ctx?.constructor?.key;
if (typeof scope_key === "undefined" || scope_key === null) return null;
const bucket = scoped_sources.get(scope_key);
return bucket && is_plain_object9(bucket) ? bucket : null;
}, "scope_actions_for");
const cache_result = /* @__PURE__ */ __name((target, prop, value) => {
target[prop] = value;
return value;
}, "cache_result");
const compute_and_cache = /* @__PURE__ */ __name((target, prop) => {
const scoped = scope_actions_for();
if (scoped && has_own(scoped, prop)) {
return cache_result(target, prop, bind_or_clone(scoped[prop]));
}
if (has_own(global_source, prop)) {
return cache_result(target, prop, bind_or_clone(global_source[prop]));
}
return cache_result(target, prop, void 0);
}, "compute_and_cache");
const union_keys = /* @__PURE__ */ __name(() => {
const scoped = scope_actions_for();
const keys = new Set(Reflect.ownKeys(cache));
for (const key of Reflect.ownKeys(global_source)) {
keys.add(key);
}
if (scoped) {
for (const key of Reflect.ownKeys(scoped)) {
keys.add(key);
}
}
return Array.from(keys);
}, "union_keys");
const descriptor_for = /* @__PURE__ */ __name((target, prop) => ({
configurable: true,
enumerable: true,
value: target[prop]
}), "descriptor_for");
return new Proxy(cache, {
get: /* @__PURE__ */ __name((target, prop) => {
if (prop === Symbol.toStringTag) return "ActionsProxy";
if (prop in target) return target[prop];
return compute_and_cache(target, prop);
}, "get"),
has: /* @__PURE__ */ __name((target, prop) => {
if (prop in target) return true;
const scoped = scope_actions_for();
if (scoped && has_own(scoped, prop)) return true;
return has_own(global_source, prop);
}, "has"),
ownKeys: /* @__PURE__ */ __name(() => union_keys(), "ownKeys"),
getOwnPropertyDescriptor: /* @__PURE__ */ __name((target, prop) => {
if (has_own(target, prop)) {
return descriptor_for(target, prop);
}
const scoped = scope_actions_for();
if (scoped && has_own(scoped, prop)) {
if (!has_own(target, prop)) {
compute_and_cache(target, prop);
}
return descriptor_for(target, prop);
}
if (has_own(global_source, prop)) {
if (!has_own(target, prop)) {
compute_and_cache(target, prop);
}
return descriptor_for(target, prop);
}
return void 0;
}, "getOwnPropertyDescriptor"),
defineProperty: /* @__PURE__ */ __name((target, prop, descriptor) => {
if ("value" in descriptor) {
target[prop] = descriptor.value;
return true;
}
return false;
}, "defineProperty"),
set: /* @__PURE__ */ __name((target, prop, value) => {
target[prop] = value;
return true;
}, "set"),
deleteProperty: /* @__PURE__ */ __name((target, prop) => {
if (has_own(target, prop)) {
delete target[prop];
}
return true;
}, "deleteProperty")
});
}
__name(create_actions_proxy, "create_actions_proxy");

var CollectionItem = class _CollectionItem {
static {
__name(this, "CollectionItem");
}
static version = 2e-3;
/**
* Default properties for an instance of CollectionItem.
* Override in subclasses to define different defaults.
* @returns {Object}
*/
static get defaults() {
return {
data: {}
};
}
/**
* @param {Object} env - The environment/context.
* @param {Object|null} [data=null] - Initial data for the item.
*/
constructor(env, data = null) {
env.create_env_getter(this);
this.config = this.env?.config;
this.merge_defaults();
if (data) deep_merge(this.data, data);
if (!this.data.class_name) this.data.class_name = this.collection.item_class_name;
}
/**
* Loads an item from data and initializes it.
* @param {Object} env
* @param {Object} data
* @returns {CollectionItem}
*/
static load(env, data) {
const item = new this(env, data);
item.init();
return item;
}
/**
* Merge default properties from the entire inheritance chain.
* @private
*/
merge_defaults() {
let current_class = this.constructor;
while (current_class) {
for (let key in current_class.defaults) {
const default_val = current_class.defaults[key];
if (typeof default_val === "object") {
this[key] = { ...default_val, ...this[key] };
} else {
this[key] = this[key] === void 0 ? default_val : this[key];
}
}
current_class = Object.getPrototypeOf(current_class);
}
}
/**
* Generates or retrieves a unique key for the item.
* Key syntax supports:
* - `[i]` for sequences
* - `/` for super-sources (groups, directories, clusters)
* - `#` for sub-sources (blocks)
* @returns {string} The unique key
*/
get_key() {
return create_uid(this.data);
}
/**
* Updates the item data and returns true if changed.
* @param {Object} data
* @returns {boolean} True if data changed.
*/
update_data(data) {
const sanitized_data = this.sanitize_data(data);
const current_data = { ...this.data };
deep_merge(current_data, sanitized_data);
const changed = !deep_equal(this.data, current_data);
if (!changed) return false;
this.data = current_data;
return true;
}
/**
* Sanitizes data for saving. Ensures no circular references.
* @param {*} data
* @returns {*} Sanitized data.
*/
sanitize_data(data) {
if (data instanceof _CollectionItem) return data.ref;
if (Array.isArray(data)) return data.map((val) => this.sanitize_data(val));
if (typeof data === "object" && data !== null) {
return Object.keys(data).reduce((acc, key) => {
acc[key] = this.sanitize_data(data[key]);
return acc;
}, {});
}
return data;
}
/**
* Initializes the item. Override as needed.
* @param {Object} [input_data] - Additional data that might be provided on creation.
*/
init(input_data) {
}
/**
* Queues this item for saving.
*/
queue_save() {
this._queue_save = true;
}
/**
* Saves this item using its data adapter.
* @returns {Promise<void>}
*/
async save() {
try {
await this.data_adapter.save_item(this);
this.init();
} catch (err) {
this._queue_save = true;
console.error(err, err.stack);
}
}
/**
* Queues this item for loading.
*/
queue_load() {
this._queue_load = true;
}
/**
* Loads this item using its data adapter.
* @returns {Promise<void>}
*/
async load() {
try {
await this.data_adapter.load_item(this);
this.init();
} catch (err) {
this._load_error = err;
this.on_load_error(err);
}
}
/**
* Handles load errors by re-queuing for load.
* Override if needed.
* @param {Error} err
*/
on_load_error(err) {
this.queue_load();
}
/**
* Validates the item before saving. Checks for presence and validity of key.
* @deprecated should be better handled 2025-12-17 (wrong scope?)
* @returns {boolean}
*/
validate_save() {
if (!this.key) return false;
if (this.key.trim() === "") return false;
if (this.key === "undefined") return false;
return true;
}
/**
* Marks this item as deleted. This does not immediately remove it from memory,
* but queues a save that will result in the item being removed from persistent storage.
*/
delete() {
this.deleted = true;
this.queue_save();
}
/**
* Filters items in the collection based on provided options.
* functional filter (returns true or false) for filtering items in collection; called by collection class
* @param {Object} filter_opts - Filtering options.
* @param {string} [filter_opts.exclude_key] - A single key to exclude.
* @param {string[]} [filter_opts.exclude_keys] - An array of keys to exclude. If exclude_key is provided, it's added to this array.
* @param {string} [filter_opts.exclude_key_starts_with] - Exclude keys starting with this string.
* @param {string[]} [filter_opts.exclude_key_starts_with_any] - Exclude keys starting with any of these strings.
* @param {string} [filter_opts.exclude_key_includes] - Exclude keys that include this string.
* @param {string[]} [filter_opts.exclude_key_includes_any] - Exclude keys that include any of these strings.
* @param {string} [filter_opts.exclude_key_ends_with] - Exclude keys ending with this string.
* @param {string[]} [filter_opts.exclude_key_ends_with_any] - Exclude keys ending with any of these strings.
* @param {string} [filter_opts.key_ends_with] - Include only keys ending with this string.
* @param {string} [filter_opts.key_starts_with] - Include only keys starting with this string.
* @param {string[]} [filter_opts.key_starts_with_any] - Include only keys starting with any of these strings.
* @param {string} [filter_opts.key_includes] - Include only keys that include this string.
* @returns {boolean} True if the item passes the filter, false otherwise.
*/
filter(filter_opts = {}) {
const {
exclude_key,
exclude_keys = exclude_key ? [exclude_key] : [],
exclude_key_starts_with,
exclude_key_starts_with_any,
exclude_key_includes,
exclude_key_includes_any,
exclude_key_ends_with,
exclude_key_ends_with_any,
key_ends_with,
key_starts_with,
key_starts_with_any,
key_includes,
key_includes_any
} = filter_opts;
if (exclude_keys?.includes(this.key)) return false;
if (exclude_key_starts_with && this.key.startsWith(exclude_key_starts_with)) return false;
if (exclude_key_starts_with_any && exclude_key_starts_with_any.some((prefix) => this.key.startsWith(prefix))) return false;
if (exclude_key_includes && this.key.includes(exclude_key_includes)) return false;
if (exclude_key_includes_any && exclude_key_includes_any.some((include) => this.key.includes(include))) return false;
if (exclude_key_ends_with && this.key.endsWith(exclude_key_ends_with)) return false;
if (exclude_key_ends_with_any && exclude_key_ends_with_any.some((suffix) => this.key.endsWith(suffix))) return false;
if (key_ends_with && !this.key.endsWith(key_ends_with)) return false;
if (key_starts_with && !this.key.startsWith(key_starts_with)) return false;
if (key_starts_with_any && !key_starts_with_any.some((prefix) => this.key.startsWith(prefix))) return false;
if (key_includes && !this.key.includes(key_includes)) return false;
if (key_includes_any && !key_includes_any.some((include) => this.key.includes(include))) return false;
return true;
}
filter_and_score(params = {}) {
if (this.filter(params.filter) === false) return null;
return this.score(params);
}
score(params = {}) {
const score_action = this.actions[params.score_algo_key];
if (typeof score_action !== "function") throw new Error(`Missing score action: ${params.score_algo_key}`);
return {
...score_action(params) || {},
item: this
};
}
/**
* Parses item data for additional processing. Override as needed.
* @deprecated is this used anywhere?
*/
parse() {
}
get actions() {
if (!this._actions) {
this._actions = create_actions_proxy(this, {
...this.env.config.actions || {},
...this.env.opts.items?.[this.item_type_key]?.actions || {}
});
}
return this._actions;
}
/**
* Derives the collection key from the class name.
* @returns {string}
*/
static get collection_key() {
let name = this.name;
if (name.match(/\d$/)) name = name.slice(0, -1);
return collection_instance_name_from(name);
}
/**
* @returns {string} The collection key for this item.
*/
get collection_key() {
let name = this.constructor.name;
if (name.match(/\d$/)) name = name.slice(0, -1);
return collection_instance_name_from(name);
}
/**
* Retrieves the parent collection from the environment.
* @returns {Collection}
*/
get collection() {
return this.env[this.collection_key];
}
/**
* @returns {string} The item's key.
*/
get key() {
return this.data?.key || this.get_key();
}
get item_type_key() {
let name = this.constructor.name;
if (name.match(/\d$/)) name = name.slice(0, -1);
return camel_case_to_snake_case(name);
}
/**
* Emits an event with item metadata.
*
* @param {string} event_key
* @param {Object} [payload={}]
* @returns {void}
*/
emit_event(event_key, payload = {}) {
this.env.events?.emit(event_key, { collection_key: this.collection_key, item_key: this.key, ...payload });
}
on_event(event_key, callback) {
return this.env.events?.on(event_key, (payload) => {
if (payload?.item_key && payload.item_key !== this.key) return;
callback(payload);
});
}
once_event(event_key, callback) {
return this.env.events?.once(event_key, (payload) => {
if (payload?.item_key && payload.item_key !== this.key) return;
callback(payload);
});
}
/**
* @returns {Object} The data adapter for this item's collection.
*/
get data_adapter() {
return this.collection.data_adapter;
}
/**
* @returns {Object} The filesystem adapter.
*/
get data_fs() {
return this.collection.data_fs;
}
/**
* Access to collection-level settings.
* @returns {Object}
*/
get settings() {
if (!this.env.settings[this.collection_key]) this.env.settings[this.collection_key] = {};
return this.env.settings[this.collection_key];
}
set settings(settings) {
this.env.settings[this.collection_key] = settings;
this.env.smart_settings.save();
}
/**
* A simple reference object for this item.
* @deprecated 2025-11-11 lacks adoption
* @returns {{collection_key: string, key: string}}
*/
get ref() {
return { collection_key: this.collection_key, key: this.key };
}
/**
* @deprecated use env.smart_components~~env.smart_view~~ instead
*/
get smart_view() {
if (!this._smart_view) this._smart_view = this.env.init_module("smart_view");
return this._smart_view;
}
/**
* Retrieves the display name of the collection item.
* @readonly
* @deprecated Use `get_item_display_name(key, show_full_path)` instead (keep UI logic out of collections).
* @returns {string} The display name.
*/
get name() {
return get_item_display_name(
this.key,
this.env.settings.smart_view_filter?.show_full_path
);
}
};

var AsyncFunction = Object.getPrototypeOf(async function() {
}).constructor;
var Collection = class {
static {
__name(this, "Collection");
}
static version = 1e-3;
/**
* Constructs a new Collection instance.
*
* @param {Object} env - The environment context containing configurations and adapters.
* @param {Object} [opts={}] - Optional configuration.
* @param {string} [opts.collection_key] - Custom key to override default collection name.
* @param {string} [opts.data_dir] - Custom data directory path.
*/
constructor(env, opts = {}) {
env.create_env_getter(this);
this.opts = opts;
if (opts.collection_key) this.collection_key = opts.collection_key;
this.env[this.collection_key] = this;
this.config = this.env.config;
this.items = {};
this.loaded = null;
this._loading = false;
this.load_time_ms = null;
this.settings_container = null;
}
/**
* Initializes a new collection in the environment. Override in subclass if needed.
*
* @param {Object} env
* @param {Object} [opts={}]
* @returns {Promise<void>}
*/
static async init(env, opts = {}) {
env[this.collection_key] = new this(env, opts);
await env[this.collection_key].init();
env.collections[this.collection_key] = "init";
}
/**
* The unique collection key derived from the class name.
* @returns {string}
*/
static get collection_key() {
let name = this.name;
if (name.match(/\d$/)) name = name.slice(0, -1);
return name.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
}
/**
* Instance-level init. Override in subclasses if necessary.
* @returns {Promise<void>}
*/
async init() {
}
/**
* Creates or updates an item in the collection.
* - If `data` includes a key that matches an existing item, that item is updated.
* - Otherwise, a new item is created.
* After updating or creating, the item is validated. If validation fails, the item is logged and returned without being saved.
* If validation succeeds for a new item, it is added to the collection and marked for saving.
*
* If the item’s `init()` method is async, a promise is returned that resolves once init completes.
*
* NOTE: wrapping in try/catch seems to fail to catch errors thrown in async init functions when awaiting create_or_update
*
* @param {Object} [data={}] - Data for creating/updating an item.
* @returns {Promise<Item>|Item} The created or updated item. May return a promise if `init()` is async.
*/
create_or_update(data = {}) {
const existing_item = this.find_by(data);
const item = existing_item ? existing_item : new this.item_type(this.env);
item._queue_save = !existing_item;
const data_changed = item.update_data(data);
if (!existing_item && !item.validate_save()) {
return item;
}
if (!existing_item) {
this.set(item);
}
if (existing_item && !data_changed) return existing_item;
if (item.init instanceof AsyncFunction) {
return new Promise((resolve) => {
item.init(data).then(() => resolve(item));
});
}
item.init(data);
return item;
}
/**
* Finds an item by partial data match (first checks key). If `data.key` provided,
* returns the item with that key; otherwise attempts a match by merging data.
*
* @param {Object} data - Data to match against.
* @returns {Item|null}
*/
find_by(data) {
if (data.key) return this.get(data.key);
const temp = new this.item_type(this.env);
const temp_data = JSON.parse(JSON.stringify(data, temp.sanitize_data(data)));
deep_merge(temp.data, temp_data);
return temp.key ? this.get(temp.key) : null;
}
/**
* Filters items based on provided filter options or a custom function.
*
* @param {Object|Function} [filter_opts={}] - Filter options or a predicate function.
* @returns {Item[]} Array of filtered items.
*/
filter(filter_opts = {}) {
if (typeof filter_opts === "function") {
return Object.values(this.items).filter(filter_opts);
}
const results = [];
const { first_n } = filter_opts;
for (const item of Object.values(this.items)) {
if (first_n && results.length >= first_n) break;
if (item.filter(filter_opts)) results.push(item);
}
return results;
}
/**
* Alias for `filter()`
* @param {Object|Function} filter_opts
* @returns {Item[]}
*/
list(filter_opts) {
return this.filter(filter_opts);
}
/**
* Retrieves an item by key.
* @param {string} key
* @returns {Item|undefined}
*/
get(key) {
return this.items[key];
}
/**
* Retrieves multiple items by an array of keys.
* @param {string[]} keys
* @returns {Item[]}
*/
get_many(keys = []) {
if (!Array.isArray(keys)) {
console.error("get_many called with non-array keys:", keys);
return [];
}
return keys.map((key) => this.get(key)).filter(Boolean);
}
/**
* Retrieves a random item from the collection, optionally filtered by options.
* @param {Object} [opts]
* @returns {Item|undefined}
*/
get_rand(opts = null) {
if (opts) {
const filtered = this.filter(opts);
return filtered[Math.floor(Math.random() * filtered.length)];
}
const keys = this.keys;
return this.items[keys[Math.floor(Math.random() * keys.length)]];
}
/**
* Adds or updates an item in the collection.
* @param {Item} item
*/
set(item) {
if (!item.key) throw new Error("Item must have a key property");
this.items[item.key] = item;
}
/**
* Updates multiple items by their keys.
* @param {string[]} keys
* @param {Object} data
*/
update_many(keys = [], data = {}) {
this.get_many(keys).forEach((item) => item.update_data(data));
}
/**
* Clears all items from the collection.
*/
clear() {
this.items = {};
}
/**
* @returns {string} The collection key, can be overridden by opts.collection_key
*/
get collection_key() {
return this._collection_key ? this._collection_key : this.constructor.collection_key;
}
set collection_key(key) {
this._collection_key = key;
}
/**
* Lazily initializes and returns the data adapter instance for this collection.
* @returns {Object} The data adapter instance.
*/
get data_adapter() {
if (!this._data_adapter) {
const AdapterClass = this.get_adapter_class("data");
this._data_adapter = new AdapterClass(this);
}
return this._data_adapter;
}
get_adapter_class(type) {
const config = this.env.opts.collections?.[this.collection_key];
const adapter_key = type + "_adapter";
const adapter_module = config?.[adapter_key] ?? this.env.opts.collections?.smart_collections?.[adapter_key];
if (typeof adapter_module === "function") return adapter_module;
if (typeof adapter_module?.collection === "function") return adapter_module.collection;
throw new Error(`No '${type}' adapter class found for ${this.collection_key} or smart_collections`);
}
/**
* Data directory strategy for this collection. Defaults to 'multi'.
* @deprecated should be handled in adapters (2025-12-09)
* @returns {string}
*/
get data_dir() {
return this.collection_key;
}
/**
* File system adapter from the environment.
* @returns {Object}
*/
get data_fs() {
return this.env.data_fs;
}
/**
* Derives the corresponding item class name based on this collection's class name.
* @returns {string}
*/
get item_class_name() {
let name = this.constructor.name;
if (name.match(/\d$/)) name = name.slice(0, -1);
if (name.endsWith("ies")) return name.slice(0, -3) + "y";
else if (name.endsWith("s")) return name.slice(0, -1);
return name + "Item";
}
/**
* Derives a readable item name from the item class name.
* @returns {string}
*/
get item_name() {
return this.item_class_name.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
}
/**
* Retrieves the item type (constructor) from the environment.
* @deprecated replace with item_class with strict adherence to conventions (2025-10-28)
* @returns {Function} Item constructor.
*/
get item_type() {
if (!this._item_type) this._item_type = this.resolve_item_type();
return this._item_type;
}
resolve_item_type() {
const available = [
this.env.config?.items?.[this.item_name],
this.opts.item_type,
this.env.item_types?.[this.item_class_name]
].filter(Boolean).sort((a, b) => {
const a_version = a?.class?.version || a.version || 0;
const b_version = b?.class?.version || b.version || 0;
return b_version - a_version;
});
if (available.length === 0) {
throw new Error(`No item_type found for collection '${this.collection_key}' with item_name '${this.item_name}' or class_name '${this.item_class_name}'`);
}
return available[0].class || available[0];
}
/**
* Returns an array of all keys in the collection.
* @returns {string[]}
*/
get keys() {
return Object.keys(this.items);
}
/**
* @deprecated use data_adapter instead (2024-09-14)
*/
get adapter() {
return this.data_adapter;
}
/**
* @method process_save_queue
* @description
* Saves items flagged for saving (_queue_save) back to AJSON or SQLite. This ensures persistent storage
* of any updates made since last load/import. This method also writes changes to disk (AJSON files or DB).
*/
async process_save_queue(opts = {}) {
if (opts.force) {
Object.values(this.items).forEach((item) => item._queue_save = true);
}
await this.data_adapter.process_save_queue(opts);
}
/**
* @alias process_save_queue
* @returns {Promise<void>}
*/
async save(opts = {}) {
await this.process_save_queue(opts);
}
/**
* @method process_load_queue
* @description
* Loads items that have been flagged for loading (_queue_load). This may involve
* reading from AJSON/SQLite or re-importing from markdown if needed.
* Called once initial environment is ready and collections are known.
*/
async process_load_queue() {
await this.data_adapter.process_load_queue();
}
/**
* Retrieves processed settings configuration.
* @returns {Object}
*/
get settings_config() {
return this.process_settings_config({});
}
/**
* Processes given settings config, adding prefixes and handling conditionals.
* @deprecated removing settings_config from collections (2025-11-24)
*
* @private
* @param {Object} _settings_config
* @param {string} [prefix='']
* @returns {Object}
*/
process_settings_config(_settings_config, prefix = "") {
const add_prefix = /* @__PURE__ */ __name((key) => prefix && !key.includes(`${prefix}.`) ? `${prefix}.${key}` : key, "add_prefix");
return Object.entries(_settings_config).reduce((acc, [key, val]) => {
let new_val = { ...val };
if (new_val.conditional) {
if (!new_val.conditional(this)) return acc;
delete new_val.conditional;
}
if (new_val.callback) new_val.callback = add_prefix(new_val.callback);
if (new_val.btn_callback) new_val.btn_callback = add_prefix(new_val.btn_callback);
if (new_val.options_callback) new_val.options_callback = add_prefix(new_val.options_callback);
const new_key = add_prefix(this.process_setting_key(key));
acc[new_key] = new_val;
return acc;
}, {});
}
/**
* Processes an individual setting key. Override if needed.
* @param {string} key
* @returns {string}
*/
process_setting_key(key) {
return key;
}
/**
* Default settings for this collection. Override in subclasses as needed.
* @returns {Object}
*/
get default_settings() {
return {};
}
/**
* Current settings for the collection.
* Initializes with default settings if none exist.
* @returns {Object}
*/
get settings() {
if (!this.env.settings[this.collection_key]) {
this.env.settings[this.collection_key] = this.default_settings;
}
return this.env.settings[this.collection_key];
}
/**
* Unloads collection data from memory.
*/
unload() {
this.clear();
this.unloaded = true;
this.env.collections[this.collection_key] = null;
}
/**
* Displays a process notice if the operation exceeds one second.
*
* @param {string} process - Identifier for the ongoing process.
* @param {Object} [opts={}] - Additional options passed to the notice.
*/
show_process_notice(process, opts = {}) {
if (!this.debounce_process_notice) this.debounce_process_notice = {};
this.debounce_process_notice[process] = setTimeout(() => {
this.debounce_process_notice[process] = null;
this.env.notices?.show(process, { collection_key: this.collection_key, ...opts });
}, 1e3);
}
/**
* Clears any pending process notice timers and removes active notices.
*
* @param {string} process - Identifier for the process notice to clear.
*/
clear_process_notice(process) {
if (this.debounce_process_notice?.[process]) {
clearTimeout(this.debounce_process_notice[process]);
this.debounce_process_notice[process] = null;
} else {
this.env.notices?.remove(process);
}
}
/**
* Emits an event with collection metadata.
*
* @param {string} event_key
* @param {Object} [payload={}]
* @returns {void}
*/
emit_event(event_key, payload = {}) {
this.env.events?.emit(event_key, { collection_key: this.collection_key, ...payload });
}
on_event(event_key, callback) {
return this.env.events?.on(event_key, (payload) => {
if (payload?.collection_key && payload.collection_key !== this.collection_key) return;
callback(payload);
});
}
/**
* Lazily binds action functions to the collection instance.
*
* @returns {Object} Bound action functions keyed by name.
*/
get actions() {
if (!this.constructor.key) this.constructor.key = this.collection_key;
if (!this._actions) {
const actions_modules = {
...this.env?.config?.actions || {},
...this.env?.config?.collections?.[this.collection_key]?.actions || {},
...this.env?.opts?.collections?.[this.collection_key]?.actions || {},
...this.opts?.actions || {}
};
this._actions = create_actions_proxy(this, actions_modules);
}
return this._actions;
}
/**
* Clears cached actions proxy and rebuilds on next access.
* @returns {Object} Rebuilt proxy with latest source snapshot.
*/
refresh_actions() {
this._actions = null;
return this.actions;
}
queue_save() {
if (this._debounce_queue_save) clearTimeout(this._debounce_queue_save);
this._debounce_queue_save = setTimeout(() => {
this.process_save_queue();
}, 750);
}
/**
* @deprecated use env.smart_components~~env.smart_view~~ instead
* @returns {Object} smart_view instance
*/
get smart_view() {
if (!this._smart_view) this._smart_view = this.env.init_module("smart_view");
return this._smart_view;
}
/**
* Renders the settings for the collection into a given container.
* @deprecated use env.render_component('collection_settings', this) instead (2025-05-25: decouple UI from collections)
* @param {HTMLElement} [container=this.settings_container]
* @param {Object} opts
* @returns {Promise<HTMLElement>}
*/
async render_settings(container = this.settings_container, opts = {}) {
return await this.render_collection_settings(container, opts);
}
/**
* Helper function to render collection settings.
* @deprecated use env.render_component('collection_settings', this) instead (2025-05-25: decouple UI from collections)
* @param {HTMLElement} [container=this.settings_container]
* @param {Object} opts
* @returns {Promise<HTMLElement>}
*/
async render_collection_settings(container = this.settings_container, opts = {}) {
if (container && (!this.settings_container || this.settings_container !== container)) {
this.settings_container = container;
} else if (!container) {
container = this.env.smart_view.create_doc_fragment("<div></div>");
}
this.env.smart_view.safe_inner_html(container, `<div class="sc-loading">Loading ${this.collection_key} settings...</div>`);
const frag = await this.env.render_component("settings", this, opts);
this.env.smart_view.empty(container);
container.appendChild(frag);
return container;
}
};

var EntitiesVectorAdapter = class {
static {
__name(this, "EntitiesVectorAdapter");
}
/**
* @constructor
* @param {import('smart-entities').SmartEntities} collection - The collection (SmartEntities or derived class) instance.
*/
constructor(collection) {
this.collection = collection;
}
/**
* Find the nearest entities to the given vector.
* @async
* @param {number[]} vec - The reference vector.
* @param {Object} [filter={}] - Optional filters (limit, exclude, etc.)
* @returns {Promise<Array<{item: import('smart-entities').SmartEntity, score:number}>>} Array of results sorted by score descending.
* @abstract
* @throws {Error} Not implemented by default.
*/
async nearest(vec, filter = {}) {
throw new Error("EntitiesVectorAdapter.nearest() not implemented");
}
/**
* Find the furthest entities from the given vector.
* @async
* @param {number[]} vec - The reference vector.
* @param {Object} [filter={}] - Optional filters (limit, exclude, etc.)
* @returns {Promise<Array<{item: import('smart-entities').SmartEntity, score:number}>>} Array of results sorted by score ascending (furthest).
* @abstract
* @throws {Error} Not implemented by default.
*/
async furthest(vec, filter = {}) {
throw new Error("EntitiesVectorAdapter.furthest() not implemented");
}
/**
* Embed a batch of entities.
* @async
* @param {Object[]} entities - Array of entity instances to embed.
* @returns {Promise<void>}
* @abstract
* @throws {Error} Not implemented by default.
*/
async embed_batch(entities) {
throw new Error("EntitiesVectorAdapter.embed_batch() not implemented");
}
/**
* Process a queue of entities waiting to be embedded.
* Typically, this will call embed_batch in batches and update entities.
* @async
* @param {Object[]} embed_queue - Array of entities to embed.
* @returns {Promise<void>}
* @abstract
* @throws {Error} Not implemented by default.
*/
async process_embed_queue(embed_queue) {
throw new Error("EntitiesVectorAdapter.process_embed_queue() not implemented");
}
};
var EntityVectorAdapter = class {
static {
__name(this, "EntityVectorAdapter");
}
/**
* @constructor
* @param {import('smart-entities').SmartEntity} item - The SmartEntity instance that this adapter is associated with.
*/
constructor(item) {
this.item = item;
}
/**
* Retrieve the current vector embedding for this entity.
* @async
* @returns {Promise<number[]|undefined>} The entity's vector or undefined if not set.
* @abstract
* @throws {Error} Not implemented by default.
*/
async get_vec() {
throw new Error("EntityVectorAdapter.get_vec() not implemented");
}
/**
* Store/update the vector embedding for this entity.
* @async
* @param {number[]} vec - The vector to set.
* @returns {Promise<void>}
* @abstract
* @throws {Error} Not implemented by default.
*/
async set_vec(vec) {
throw new Error("EntityVectorAdapter.set_vec() not implemented");
}
/**
* Delete/remove the vector embedding for this entity.
* @async
* @returns {Promise<void>}
* @abstract
* @throws {Error} Not implemented by default.
*/
async delete_vec() {
throw new Error("EntityVectorAdapter.delete_vec() not implemented");
}
};

function results_acc(_acc, result, ct = 10) {
if (_acc.results.size < ct) {
_acc.results.add(result);
if (_acc.results.size === ct && _acc.min === Number.POSITIVE_INFINITY) {
let { minScore, minObj } = find_min(_acc.results);
_acc.min = minScore;
_acc.minResult = minObj;
}
} else if (result.score > _acc.min) {
_acc.results.add(result);
_acc.results.delete(_acc.minResult);
let { minScore, minObj } = find_min(_acc.results);
_acc.min = minScore;
_acc.minResult = minObj;
}
}
__name(results_acc, "results_acc");
function furthest_acc(_acc, result, ct = 10) {
if (_acc.results.size < ct) {
_acc.results.add(result);
if (_acc.results.size === ct && _acc.max === Number.NEGATIVE_INFINITY) {
let { maxScore, maxObj } = find_max(_acc.results);
_acc.max = maxScore;
_acc.maxResult = maxObj;
}
} else if (result.score < _acc.max) {
_acc.results.add(result);
_acc.results.delete(_acc.maxResult);
let { maxScore, maxObj } = find_max(_acc.results);
_acc.max = maxScore;
_acc.maxResult = maxObj;
}
}
__name(furthest_acc, "furthest_acc");
function find_min(results) {
let minScore = Number.POSITIVE_INFINITY;
let minObj = null;
for (const obj of results) {
if (obj.score < minScore) {
minScore = obj.score;
minObj = obj;
}
}
return { minScore, minObj };
}
__name(find_min, "find_min");
function find_max(results) {
let maxScore = Number.NEGATIVE_INFINITY;
let maxObj = null;
for (const obj of results) {
if (obj.score > maxScore) {
maxScore = obj.score;
maxObj = obj;
}
}
return { maxScore, maxObj };
}
__name(find_max, "find_max");

function sort_by_score(a, b) {
const epsilon = 1e-9;
const score_diff = a.score - b.score;
if (Math.abs(score_diff) < epsilon) return 0;
return score_diff > 0 ? -1 : 1;
}
__name(sort_by_score, "sort_by_score");
function sort_by_score_descending(a, b) {
return sort_by_score(a, b);
}
__name(sort_by_score_descending, "sort_by_score_descending");
function sort_by_score_ascending(a, b) {
return sort_by_score(a, b) * -1;
}
__name(sort_by_score_ascending, "sort_by_score_ascending");

var DefaultEntitiesVectorAdapter = class extends EntitiesVectorAdapter {
static {
__name(this, "DefaultEntitiesVectorAdapter");
}
constructor(collection) {
super(collection);
this._is_processing_embed_queue = false;
this._reset_embed_queue_stats();
}
/**
* Find the nearest entities to the given vector.
* @async
* @param {number[]} vec - The reference vector.
* @param {Object} [filter={}] - Optional filters (limit, exclude, etc.)
* @returns {Promise<Array<{item:Object, score:number}>>} Array of results sorted by score descending.
*/
async nearest(vec, filter = {}) {
if (!vec || !Array.isArray(vec)) {
throw new Error("Invalid vector input to nearest()");
}
const {
limit = 50
} = filter;
const nearest = this.collection.filter(filter).reduce((acc, item) => {
if (!item.vec) return acc;
const result = { item, score: cos_sim(vec, item.vec) };
results_acc(acc, result, limit);
return acc;
}, { min: 0, results: /* @__PURE__ */ new Set() });
return Array.from(nearest.results).sort(sort_by_score_descending);
}
/**
* Find the furthest entities from the given vector.
* @async
* @param {number[]} vec - The reference vector.
* @param {Object} [filter={}] - Optional filters (limit, exclude, etc.)
* @returns {Promise<Array<{item:Object, score:number}>>} Array of results sorted by score ascending (furthest).
*/
async furthest(vec, filter = {}) {
if (!vec || !Array.isArray(vec)) {
throw new Error("Invalid vector input to furthest()");
}
const {
limit = 50
} = filter;
const furthest = this.collection.filter(filter).reduce((acc, item) => {
if (!item.vec) return acc;
const result = { item, score: cos_sim(vec, item.vec) };
furthest_acc(acc, result, limit);
return acc;
}, { max: 0, results: /* @__PURE__ */ new Set() });
return Array.from(furthest.results).sort(sort_by_score_ascending);
}
/**
* Embed a batch of entities.
* @async
* @param {Object[]} entities - Array of entity instances to embed.
* @returns {Promise<void>}
*/
async embed_batch(entities) {
if (!this.collection.embed_model) {
throw new Error("No embed_model found in collection for embedding");
}
await Promise.all(entities.map((e) => e.get_embed_input()));
const embeddings = await this.collection.embed_model.embed_batch(entities);
embeddings.forEach((emb, i) => {
const entity = entities[i];
entity.vec = emb.vec;
entity.data.last_embed = entity.data.last_read;
if (emb.tokens !== void 0) entity.tokens = emb.tokens;
entity.emit_event("item:embedded");
});
}
/**
* Process a queue of entities waiting to be embedded.
* Prevents multiple concurrent runs by using `_is_processing_embed_queue`.
* @async
* @returns {Promise<void>}
*/
async process_embed_queue() {
if (this._is_processing_embed_queue) {
console.log("process_embed_queue is already running, skipping concurrent call.");
return;
}
this._is_processing_embed_queue = true;
try {
if (!this.collection.embed_model.is_loaded) {
await this.collection.embed_model.load();
}
} catch (e) {
this.collection.emit_event("embed_model:load_failed");
this.notices?.show("Failed to load embed_model");
return;
}
try {
const datetime_start = Date.now();
console.log(`Getting embed queue for ${this.collection.collection_key}...`);
await new Promise((resolve) => setTimeout(resolve, 1));
const embed_queue = this.collection.embed_queue;
this._reset_embed_queue_stats();
if (this.collection.embed_model_key === "None") {
console.log(`Smart Connections: No active embedding model for ${this.collection.collection_key}, skipping embedding`);
return;
}
if (!this.collection.embed_model) {
console.log(`Smart Connections: No active embedding model for ${this.collection.collection_key}, skipping embedding`);
return;
}
if (!embed_queue.length) {
console.log(`Smart Connections: No items in ${this.collection.collection_key} embed queue`);
return;
}
console.log(`Time spent getting embed queue: ${Date.now() - datetime_start}ms`);
console.log(`Processing ${this.collection.collection_key} embed queue: ${embed_queue.length} items`);
for (let i = 0; i < embed_queue.length; i += this.collection.embed_model.batch_size) {
if (this.is_queue_halted) {
this.is_queue_halted = false;
break;
}
this._show_embed_progress_notice(embed_queue.length);
const batch = embed_queue.slice(i, i + this.collection.embed_model.batch_size);
await Promise.all(batch.map((item) => item.get_embed_input()));
try {
const start_time = Date.now();
await this.embed_batch(batch);
this.total_time += Date.now() - start_time;
} catch (e) {
if (e && e.message && e.message.includes("API key not set")) {
this.halt_embed_queue_processing(`API key not set for ${this.collection.embed_model_key}
Please set the API key in the settings.`);
}
console.error(e);
console.error(`Error processing ${this.collection.collection_key} embed queue: ` + JSON.stringify(e || {}, null, 2));
}
batch.forEach((item) => {
item.embed_hash = item.read_hash;
item._queue_save = true;
});
this.embedded_total += batch.length;
this.total_tokens += batch.reduce((acc, item) => acc + (item.tokens || 0), 0);
if (this.embedded_total - this.last_save_total > 1e3) {
this.last_save_total = this.embedded_total;
await this.collection.process_save_queue();
if (this.collection.block_collection) {
console.log(`Saving ${this.collection.block_collection.collection_key} block collection`);
await this.collection.block_collection.process_save_queue();
}
}
}
this._show_embed_completion_notice(embed_queue.length);
await this.collection.process_save_queue();
if (this.collection.block_collection) {
await this.collection.block_collection.process_save_queue();
}
} finally {
this._is_processing_embed_queue = false;
}
}
get should_show_embed_progress_notice() {
if (Date.now() - (this.last_notice_time ?? 0) > 3e4) {
return true;
}
return this.embedded_total - this.last_notice_embedded_total >= 100;
}
/**
* Displays the embedding progress notice.
* @private
* @returns {void}
*/
_show_embed_progress_notice(embed_queue_length) {
if (embed_queue_length < 100) return;
if (!this.should_show_embed_progress_notice) return;
this.last_notice_time = Date.now();
this.last_notice_embedded_total = this.embedded_total;
this.collection.emit_event("embedding:progress_reported", {
progress: this.embedded_total,
total: embed_queue_length,
tokens_per_second: this._calculate_embed_tokens_per_second(),
model_name: this.collection.embed_model_key
});
this.notices?.show("embedding_progress", {
progress: this.embedded_total,
total: embed_queue_length,
tokens_per_second: this._calculate_embed_tokens_per_second(),
model_name: this.collection.embed_model_key
});
}
/**
* Displays the embedding completion notice.
* @private
* @returns {void}
*/
_show_embed_completion_notice() {
this.notices?.remove("embedding_progress");
if (this.embedded_total > 100) {
this.collection.emit_event("embedding:completed", {
total_embeddings: this.embedded_total,
tokens_per_second: this._calculate_embed_tokens_per_second(),
model_name: this.collection.embed_model_key
});
this.notices?.show("embedding_complete", {
total_embeddings: this.embedded_total,
tokens_per_second: this._calculate_embed_tokens_per_second(),
model_name: this.collection.embed_model_key
});
}
}
/**
* Halts the embed queue processing.
* @param {string|null} msg - Optional message.
*/
halt_embed_queue_processing(msg = null) {
this.is_queue_halted = true;
console.log("Embed queue processing halted");
this.notices?.remove("embedding_progress");
this.collection.emit_event("embedding:paused", {
progress: this.embedded_total,
total: this.collection._embed_queue.length,
tokens_per_second: this._calculate_embed_tokens_per_second(),
model_name: this.collection.embed_model_key
});
this.notices?.show("embedding_paused", {
progress: this.embedded_total,
total: this.collection._embed_queue.length,
tokens_per_second: this._calculate_embed_tokens_per_second(),
model_name: this.collection.embed_model_key
});
}
/**
* Resumes the embed queue processing after a delay.
* @param {number} [delay=0] - The delay in milliseconds before resuming.
* @returns {void}
*/
resume_embed_queue_processing(delay = 0) {
console.log("resume_embed_queue_processing");
this.notices?.remove("embedding_paused");
setTimeout(() => {
this.embedded_total = 0;
this.process_embed_queue();
}, delay);
}
/**
* Calculates the number of tokens processed per second.
* @private
* @returns {number} Tokens per second.
*/
_calculate_embed_tokens_per_second() {
const elapsed_time = this.total_time / 1e3;
return Math.round(this.total_tokens / (elapsed_time || 1));
}
/**
* Resets the statistics related to embed queue processing.
* @private
* @returns {void}
*/
_reset_embed_queue_stats() {
this.collection._embed_queue = [];
this.embedded_total = 0;
this.is_queue_halted = false;
this.last_save_total = 0;
this.last_notice_embedded_total = 0;
this.total_tokens = 0;
this.total_time = 0;
}
get notices() {
return this.collection.env.notices;
}
};
var DefaultEntityVectorAdapter = class extends EntityVectorAdapter {
static {
__name(this, "DefaultEntityVectorAdapter");
}
get data() {
return this.item.data;
}
/**
* Retrieve the current vector embedding for this entity.
* @async
* @returns {Promise<number[]|undefined>} The entity's vector or undefined if not set.
*/
async get_vec() {
return this.vec;
}
/**
* Store/update the vector embedding for this entity.
* @async
* @param {number[]} vec - The vector to set.
* @returns {Promise<void>}
*/
async set_vec(vec) {
this.vec = vec;
}
/**
* Delete/remove the vector embedding for this entity.
* @async
* @returns {Promise<void>}
*/
async delete_vec() {
if (this.item.data?.embeddings?.[this.item.embed_model_key]) {
delete this.item.data.embeddings[this.item.embed_model_key].vec;
}
}
get vec() {
return this.item.data?.embeddings?.[this.item.embed_model_key]?.vec;
}
set vec(vec) {
if (!this.item.data.embeddings) {
this.item.data.embeddings = {};
}
if (!this.item.data.embeddings[this.item.embed_model_key]) {
this.item.data.embeddings[this.item.embed_model_key] = {};
}
this.item.data.embeddings[this.item.embed_model_key].vec = vec;
}
};

var FRONTMATTER_SUFFIX = "---frontmatter---";
var to_array = /* @__PURE__ */ __name((value) => {
if (Array.isArray(value)) {
return value.map((entry) => typeof entry === "string" ? entry.trim() : "").filter((entry) => entry.length > 0);
}
if (typeof value === "string") {
const parts = value.includes(",") ? value.split(",") : [value];
return parts.map((part) => part.trim()).filter((part) => part.length > 0);
}
return [];
}, "to_array");
var merge_settings_with_params = /* @__PURE__ */ __name((entity, params = {}) => ({
...entity.env.settings.smart_view_filter || {},
...params,
entity
}), "merge_settings_with_params");
var remove_limit_fields = /* @__PURE__ */ __name((filter_opts) => {
const next = { ...filter_opts };
if (typeof next.limit !== "undefined") delete next.limit;
if (next.filter) {
next.filter = { ...next.filter };
if (typeof next.filter.limit !== "undefined") delete next.filter.limit;
}
return next;
}, "remove_limit_fields");
var apply_frontmatter_exclusion = /* @__PURE__ */ __name((filter_opts) => {
if (!filter_opts.exclude_frontmatter_blocks) return filter_opts;
const next = { ...filter_opts };
const suffixes = Array.isArray(next.exclude_key_ends_with_any) ? [...next.exclude_key_ends_with_any] : [];
suffixes.push(FRONTMATTER_SUFFIX);
next.exclude_key_ends_with_any = suffixes;
return next;
}, "apply_frontmatter_exclusion");
var append_entity_filters = /* @__PURE__ */ __name((filter_opts, entity) => {
if (!entity) return filter_opts;
const next = { ...filter_opts };
let exclude_starts = Array.isArray(next.exclude_key_starts_with_any) ? [...next.exclude_key_starts_with_any] : [];
if (typeof next.exclude_key_starts_with === "string") {
exclude_starts.push(next.exclude_key_starts_with);
delete next.exclude_key_starts_with;
}
const entity_key = entity.source_key || entity.key;
if (entity_key) exclude_starts.push(entity_key);
if (next.exclude_inlinks && Array.isArray(entity.inlinks) && entity.inlinks.length) {
exclude_starts = [...exclude_starts, ...entity.inlinks];
}
if (next.exclude_outlinks && Array.isArray(entity.outlinks) && entity.outlinks.length) {
exclude_starts = [...exclude_starts, ...entity.outlinks.map((o) => o.key)];
}
if (exclude_starts.length) next.exclude_key_starts_with_any = exclude_starts;
if (next.exclude_filter) {
const exclude_values = to_array(next.exclude_filter);
const current = Array.isArray(next.exclude_key_includes_any) ? [...next.exclude_key_includes_any] : [];
next.exclude_key_includes_any = [...current, ...exclude_values];
}
if (next.include_filter) {
const include_values = to_array(next.include_filter);
const current = Array.isArray(next.key_includes_any) ? [...next.key_includes_any] : [];
next.key_includes_any = [...current, ...include_values];
}
return next;
}, "append_entity_filters");
var create_find_connections_filter_opts = /* @__PURE__ */ __name((entity, params = {}) => {
const merged = merge_settings_with_params(entity, params);
const without_limits = remove_limit_fields(merged);
const with_frontmatter = apply_frontmatter_exclusion(without_limits);
return append_entity_filters(with_frontmatter, entity);
}, "create_find_connections_filter_opts");
async function find_connections(params = {}) {
const limit = params.filter?.limit || params.limit || this.env.settings.smart_view_filter?.results_limit || 10;
const filter_opts = create_find_connections_filter_opts(this, params);
if (params.filter?.limit) delete params.filter.limit;
if (params.limit) delete params.limit;
const cache_key = this.key + murmur_hash_32_alphanumeric(JSON.stringify({ ...filter_opts, entity: null }));
if (!this.env.connections_cache) this.env.connections_cache = {};
if (!this.env.connections_cache[cache_key]) {
const connections = (await this.nearest(filter_opts)).sort(sort_by_score).slice(0, limit);
this.connections_to_cache(cache_key, connections);
}
return this.connections_from_cache(cache_key);
}
__name(find_connections, "find_connections");
find_connections.action_type = "connections";

var SmartEntity = class extends CollectionItem {
static {
__name(this, "SmartEntity");
}
/**
* Creates an instance of SmartEntity.
* @constructor
* @param {Object} env - The environment instance.
* @param {Object} [opts={}] - Configuration options.
*/
constructor(env, opts = {}) {
super(env, opts);
this.entity_adapter = new DefaultEntityVectorAdapter(this);
}
/**
* Provides default values for a SmartEntity instance.
* @static
* @readonly
* @returns {Object} The default values.
*/
static get defaults() {
return {
data: {
path: null,
last_embed: {
hash: null
},
embeddings: {}
}
};
}
get vector_adapter() {
if (!this._vector_adapter) {
this._vector_adapter = new this.collection.opts.vector_adapter.item(this);
}
return this._vector_adapter;
}
/**
* Initializes the SmartEntity instance.
* Checks if the entity has a vector and if it matches the model dimensions.
* If not, it queues an embed.
* Removes embeddings for inactive models.
* @returns {void}
*/
init() {
super.init();
if (!this.vec || !this.vec.length) {
this.vec = null;
this.queue_embed();
}
Object.entries(this.data.embeddings || {}).forEach(([model, embedding]) => {
if (model !== this.embed_model_key) {
this.data.embeddings[model] = null;
delete this.data.embeddings[model];
}
});
}
/**
* Queues the entity for embedding.
* @returns {void}
*/
queue_embed() {
this._queue_embed = true;
}
/**
* Finds the nearest entities to this entity.
* @param {Object} [filter={}] - Optional filters to apply.
* @deprecated use actions (getter) instead
* @returns {Array<{item:Object, score:number}>} An array of result objects with score and item.
*/
async nearest(filter = {}) {
return await this.collection.nearest_to(this, filter);
}
/**
* Prepares the input for embedding.
* @async
* @param {string} [content=null] - Optional content to use instead of calling subsequent read()
* @returns {Promise<void>} Should be overridden in child classes.
*/
async get_embed_input(content = null) {
}
/**
* Retrieves the embed input, either from cache or by generating it.
* @readonly
* @returns {string|Promise<string>} The embed input string or a promise resolving to it.
*/
get embed_input() {
return this._embed_input ? this._embed_input : this.get_embed_input();
}
/**
* Finds connections relevant to this entity based on provided parameters.
* @async
* @param {Object} [params={}] - Parameters for finding connections.
* @deprecated should be in actions (getter) but also see ConnectionsLists (smart-lists)
* @returns {Array<{item:Object, score:number}>} An array of result objects with score and item.
*/
async find_connections(params = {}) {
return await this.actions.find_connections(params);
}
/**
* Retrieves connections from the cache based on the cache key.
* @param {string} cache_key - The cache key.
* @deprecated migrating to ConnectionsLists (smart-lists)
* @returns {Array<{item:Object, score:number}>} The cached connections.
*/
connections_from_cache(cache_key) {
return this.env.connections_cache[cache_key];
}
/**
* Stores connections in the cache with the provided cache key.
* @param {string} cache_key - The cache key.
* @deprecated migrating to ConnectionsLists (smart-lists)
* @param {Array<{item:Object, score:number}>} connections - The connections to cache.
* @returns {void}
*/
connections_to_cache(cache_key, connections) {
this.env.connections_cache[cache_key] = connections;
}
get read_hash() {
return this.data.last_read?.hash;
}
set read_hash(hash) {
if (!this.data.last_read) this.data.last_read = {};
this.data.last_read.hash = hash;
}
get embedding_data() {
if (!this.data.embeddings[this.embed_model_key]) {
this.data.embeddings[this.embed_model_key] = {};
}
return this.data.embeddings[this.embed_model_key];
}
get last_embed() {
if (!this.embedding_data.last_embed) {
this.embedding_data.last_embed = {};
if (this.data.last_embed) {
this.embedding_data.last_embed = this.data.last_embed;
delete this.data.last_embed;
this.queue_save();
}
}
return this.embedding_data.last_embed;
}
get embed_hash() {
return this.last_embed?.hash;
}
set embed_hash(hash) {
if (!this.embedding_data.last_embed) this.embedding_data.last_embed = {};
this.embedding_data.last_embed.hash = hash;
}
/**
* Gets the embed link for the entity.
* @readonly
* @returns {string} The embed link.
*/
get embed_link() {
return `![[${this.path}]]`;
}
/**
* Gets the key of the embedding model.
* @readonly
* @returns {string} The embedding model key.
*/
get embed_model_key() {
return this.collection.embed_model_key;
}
/**
* Gets the embedding model instance from the collection.
* @readonly
* @returns {Object} The embedding model instance.
*/
get embed_model() {
return this.collection.embed_model;
}
/**
* Determines if the entity should be embedded if unembedded. NOT the same as is_unembedded.
* @readonly
* @returns {boolean} True if no vector is set, false otherwise.
*/
get should_embed() {
return this.size > (this.settings?.min_chars || 300);
}
/**
* Sets the error for the embedding model.
* @param {string} error - The error message.
*/
set error(error) {
this.data.embeddings[this.embed_model_key].error = error;
}
/**
* Gets the number of tokens associated with the entity's embedding.
* @readonly
* @returns {number|undefined} The number of tokens, or undefined if not set.
*/
get tokens() {
return this.last_embed?.tokens;
}
/**
* Sets the number of tokens for the embedding.
* @param {number} tokens - The number of tokens.
*/
set tokens(tokens) {
this.last_embed.tokens = tokens;
}
/**
* Gets the vector representation from the entity adapter.
* @readonly
* @returns {Array<number>|undefined} The vector or undefined if not set.
*/
get vec() {
return this.entity_adapter.vec;
}
/**
* Sets the vector representation in the entity adapter.
* @param {Array<number>} vec - The vector to set.
*/
set vec(vec) {
this.entity_adapter.vec = vec;
this._queue_embed = false;
this._embed_input = null;
this.queue_save();
}
/**
* Removes all embeddings from the entity.
* @returns {void}
*/
remove_embeddings() {
this.data.embeddings = null;
this.queue_save();
}
/**
* Retrieves the key of the entity.
* @returns {string} The entity key.
*/
get_key() {
return this.data.key || this.data.path;
}
/**
* Retrieves the path of the entity.
* @readonly
* @returns {string|null} The entity path.
*/
get path() {
return this.data.path;
}
get is_unembedded() {
if (!this.vec) return true;
if (!this.embed_hash || this.embed_hash !== this.read_hash) return true;
return false;
}
};

var SmartEntities = class extends Collection {
static {
__name(this, "SmartEntities");
}
/**
* Creates an instance of SmartEntities.
* @constructor
* @param {Object} env - The environment instance.
* @param {Object} opts - Configuration options.
*/
constructor(env, opts) {
super(env, opts);
this.entities_vector_adapter = new DefaultEntitiesVectorAdapter(this);
this.model_instance_id = null;
this._embed_queue = [];
}
/**
* Unloads the smart embedding model.
* @async
* @returns {Promise<void>}
*/
async unload() {
if (typeof this.embed_model?.unload === "function") {
this.embed_model.unload();
}
super.unload();
}
/**
* Gets the key of the embedding model.
* @readonly
* @returns {string} The embedding model key.
*/
get embed_model_key() {
return this.embed_model?.model_key;
}
/**
* Gets the embedding model instance.
* @readonly
* @returns {Object|null} The embedding model instance or null if none.
*/
get embed_model() {
if (this.env.embedding_models.default) {
return this.env.embedding_models.default.instance;
}
throw new Error("DEPRECATED SMART ENVIRONMENT LOADED: UPDATE SMART PLUGINS.");
}
set embed_model(embed_model) {
this.env._embed_model = embed_model;
}
reload_embed_model() {
console.log("reload_embed_model");
this.embed_model.unload();
this.env._embed_model = null;
}
/**
* Finds the nearest entities to a given entity.
* @async
* @param {Object} entity - The reference entity.
* @deprecated moved to action (type=score) and retrieve using filter_and_score()/get_results() patterns
* @param {Object} [filter={}] - Optional filters to apply.
* @returns {Promise<Array<{item:Object, score:number}>>} An array of result objects with score and item.
*/
async nearest_to(entity, filter = {}) {
return await this.nearest(entity.vec, filter);
}
/**
* Finds the nearest entities to a vector using the default adapter.
* @async
* @deprecated moved to action (type=score) and retrieve using filter_and_score()/get_results() patterns
* @param {Array<number>} vec - The vector to compare against.
* @param {Object} [filter={}] - Optional filters to apply.
* @returns {Promise<Array<{item:Object, score:number}>>} An array of result objects with score and item.
*/
async nearest(vec, filter = {}) {
if (!vec) {
console.warn("nearest: no vec");
return [];
}
return await this.entities_vector_adapter.nearest(vec, filter);
}
/**
* Finds the furthest entities from a vector using the default adapter.
* @async
* @deprecated moved to action (type=score) and retrieve using filter_and_score()/get_results() patterns
* @param {Array<number>} vec - The vector to compare against.
* @param {Object} [filter={}] - Optional filters to apply.
* @returns {Promise<Array<{item:Object, score:number}>>} An array of result objects with score and item.
*/
async furthest(vec, filter = {}) {
if (!vec) return console.warn("furthest: no vec");
return await this.entities_vector_adapter.furthest(vec, filter);
}
/**
* Gets the file name based on collection key and embedding model key.
* @readonly
* @deprecated likely unused (2025-09-29)
* @returns {string} The constructed file name.
*/
get file_name() {
return this.collection_key + "-" + this.embed_model_key.split("/").pop();
}
/**
* Looks up entities based on hypothetical content.
* @deprecated moved to action (type=score) and retrieve using get_results() (pre-process generates hypothetical vecs)
* @async
* @param {Object} [params={}] - The parameters for the lookup.
* @param {Array<string>} [params.hypotheticals=[]] - The hypothetical content to lookup.
* @param {Object} [params.filter] - The filter to use for the lookup.
* @param {number} [params.k] - Deprecated: Use `filter.limit` instead.
* @returns {Promise<Array<Result>|Object>} The lookup results or an error object.
*/
async lookup(params = {}) {
const { hypotheticals = [] } = params;
if (!hypotheticals?.length) return { error: "hypotheticals is required" };
if (!this.embed_model) return { error: "Embedding search is not enabled." };
const hyp_vecs = await this.embed_model.embed_batch(hypotheticals.map((h) => ({ embed_input: h })));
const limit = params.filter?.limit || params.k || this.env.settings.lookup_k || 10;
if (params.filter?.limit) delete params.filter.limit;
const filter = {
...this.env.chats?.current?.scope || {},
...params.filter || {}
};
const results = await hyp_vecs.reduce(async (acc_promise, embedding, i) => {
const acc = await acc_promise;
const results2 = await this.nearest(embedding.vec, filter);
results2.forEach((result) => {
if (!acc[result.item.path] || result.score > acc[result.item.path].score) {
acc[result.item.path] = {
key: result.item.key,
score: result.score,
item: result.item,
hypothetical_i: i
};
} else {
result.score = acc[result.item.path].score;
}
});
return acc;
}, Promise.resolve({}));
const top_k = Object.values(results).sort(sort_by_score).slice(0, limit);
console.log(`Found and returned ${top_k.length} ${this.collection_key}.`);
return top_k;
}
/**
* Gets the configuration for settings.
* @readonly
* @returns {Object} The settings configuration.
*/
get settings_config() {
return settings_config;
}
/**
* @deprecated use env.render_component('collection_settings', this) instead (2025-05-25: decouple UI from collections)
*/
async render_settings(container = this.settings_container, opts = {}) {
container = await this.render_collection_settings(container, opts);
const embed_model_settings_frag = await this.env.render_component("settings", this.embed_model, opts);
container.appendChild(embed_model_settings_frag);
return container;
}
/**
* Gets the notices from the environment.
* @readonly
* @returns {Object} The notices object.
*/
get notices() {
return this.env.smart_connections_plugin?.notices || this.env.main?.notices;
}
/**
* Gets the embed queue containing items to be embedded.
* @readonly
* @returns {Array<Object>} The embed queue.
*/
get embed_queue() {
if (!this._embed_queue?.length) {
console.time(`Building embed queue`);
this._embed_queue = Object.values(this.items).filter((item) => item._queue_embed || item.is_unembedded && item.should_embed);
console.timeEnd(`Building embed queue`);
}
return this._embed_queue;
}
/**
* Processes the embed queue by delegating to the default vector adapter.
* @async
* @returns {Promise<void>}
*/
async process_embed_queue() {
await this.entities_vector_adapter.process_embed_queue();
}
/**
* Handles changes to the embedding model by reinitializing and processing the load queue.
* @async
* @returns {Promise<void>}
*/
async embed_model_changed() {
await this.unload();
await this.init();
this.render_settings();
await this.process_load_queue();
}
/**
* @deprecated since v4 2025-11-28
*/
get connections_filter_config() {
return connections_filter_config;
}
};
var settings_config = {
"min_chars": {
name: "Minimum length",
type: "number",
description: "Minimum length of entity to embed (in characters).",
placeholder: "Enter number ex. 300",
default: 300
}
};
var connections_filter_config = {
"smart_view_filter.show_full_path": {
"name": "Show full path",
"type": "toggle",
"description": "Turning on will include the folder path in the connections results."
},
"smart_view_filter.results_limit": {
"name": "Results limit",
"type": "number",
"description": "Adjust the number of connections displayed in the connections view (default 20).",
"default": 20
},
"smart_view_filter.exclude_inlinks": {
"name": "Exclude inlinks (backlinks)",
"type": "toggle",
"description": "Exclude notes that already link to the current note from the connections results."
},
"smart_view_filter.exclude_outlinks": {
"name": "Exclude outlinks",
"type": "toggle",
"description": "Exclude notes that are already linked from within the current note from appearing in the connections results."
},
"smart_view_filter.include_filter": {
"name": "Include filter",
"type": "text",
"description": "Notes must match this value in their file/folder path. Matching notes will be included in the connections results. Separate multiple values with commas."
},
"smart_view_filter.exclude_filter": {
"name": "Exclude filter",
"type": "text",
"description": "Notes must *not* match this value in their file/folder path. Matching notes will be *excluded* from the connections results. Separate multiple values with commas."
},
"smart_view_filter.exclude_blocks_from_source_connections": {
"name": "Hide blocks in results",
"type": "toggle",
"description": "Show only sources in the connections results (no blocks)."
}
};

async function find_connections2(params = {}) {
const filter_settings = this.env.settings.smart_view_filter;
const exclude_blocks_from_source_connections = params.exclude_blocks_from_source_connections ?? filter_settings?.exclude_blocks_from_source_connections ?? false;
const limit = params.filter?.limit || params.limit || this.env.settings.smart_view_filter?.results_limit || 20;
let connections;
if (this.block_collection.settings.embed_blocks && !exclude_blocks_from_source_connections) connections = [];
else connections = await find_connections.call(this, params);
const filter_opts = create_find_connections_filter_opts(this, params);
if (params.filter?.limit) delete params.filter.limit;
if (params.limit) delete params.limit;
if (!exclude_blocks_from_source_connections) {
const cache_key = this.key + murmur_hash_32_alphanumeric(JSON.stringify({ ...filter_opts, entity: null })) + "_blocks";
if (!this.env.connections_cache) this.env.connections_cache = {};
if (!this.env.connections_cache[cache_key]) {
const nearest = (await this.env.smart_blocks.nearest(this.vec, filter_opts)).sort(sort_by_score).slice(0, limit);
this.connections_to_cache(cache_key, nearest);
}
connections = [
...connections,
...this.connections_from_cache(cache_key)
].sort(sort_by_score).slice(0, limit);
}
return connections;
}
__name(find_connections2, "find_connections");
find_connections2.action_type = "connections";

var SmartSource = class extends SmartEntity {
static {
__name(this, "SmartSource");
}
/**
* Provides default values for a SmartSource instance.
* @static
* @readonly
* @returns {Object} The default values.
*/
static get defaults() {
return {
data: {
last_read: {
hash: null,
mtime: 0
},
embeddings: {}
},
_embed_input: null,
_queue_load: true
};
}
/**
* Initializes the SmartSource instance by queuing an import if blocks are missing.
* @returns {void}
*/
init() {
super.init();
if (!this.data.blocks) this.queue_import();
}
/**
* Queues the SmartSource for import.
* @returns {void}
*/
queue_import() {
this._queue_import = true;
}
/**
* Imports the SmartSource by checking for updates and parsing content.
* @async
* @returns {Promise<void>}
*/
async import() {
this._queue_import = false;
try {
await this.source_adapter?.import();
this.emit_event("sources:imported");
} catch (err) {
if (err.code === "ENOENT") {
console.log(`Smart Connections: Deleting ${this.path} data because it no longer exists on disk`);
this.delete();
} else {
console.warn("Smart Connections: Error during import: re-queueing import", err);
this.queue_import();
}
}
}
/**
* @deprecated likely extraneous
*/
async parse_content(content = null) {
const parse_fns = this.env?.opts?.collections?.smart_sources?.content_parsers || [];
for (const fn of parse_fns) {
await fn(this, content);
}
if (this.data.last_import?.hash === this.data.last_read?.hash) {
if (this.data.blocks) return;
}
}
/**
* Finds connections relevant to this SmartSource based on provided parameters.
* @async
* @deprecated use ConnectionsLists
* @param {Object} [params={}] - Parameters for finding connections.
* @param {boolean} [params.exclude_blocks_from_source_connections=false] - Whether to exclude block connections from source connections.
* @param {Object} [params.exclude_frontmatter_blocks=true] - Whether to exclude frontmatter blocks from source connections.
* @returns {Array<SmartSource>} An array of relevant SmartSource entities.
*/
async find_connections(params = {}) {
return await this.actions.find_connections(params);
}
/**
* Prepares the embed input for the SmartSource by reading content and applying exclusions.
* @async
* @returns {Promise<string|false>} The embed input string or `false` if already embedded.
*/
async get_embed_input(content = null) {
if (typeof this._embed_input === "string" && this._embed_input.length) return this._embed_input;
if (!content) content = await this.read();
if (!content) {
console.warn("SmartSource.get_embed_input: No content available for embedding: " + this.path);
return "";
}
if (this.excluded_lines.length) {
const content_lines = content.split("\n");
this.excluded_lines.forEach((lines) => {
const { start, end } = lines;
for (let i = start; i <= end; i++) {
content_lines[i] = "";
}
});
content = content_lines.filter((line) => line.length).join("\n");
}
const breadcrumbs = this.path.split("/").join(" > ").replace(".md", "");
const max_tokens = this.collection.embed_model.model.data.max_tokens || 500;
const max_chars = Math.floor(max_tokens * 3.7);
this._embed_input = `${breadcrumbs}:
${content}`.substring(0, max_chars);
return this._embed_input;
}
/**
* Opens the SmartSource note in the SmartConnections plugin.
* @returns {void}
*/
open() {
this.env.smart_connections_plugin.open_note(this.path);
}
/**
* Retrieves the block associated with a specific line number.
* @param {number} line - The line number to search for.
* @returns {SmartBlock|null} The corresponding SmartBlock or `null` if not found.
*/
get_block_by_line(line) {
return Object.entries(this.data.blocks || {}).reduce((acc, [sub_key, range]) => {
if (acc) return acc;
if (range[0] <= line && range[1] >= line) {
const block = this.block_collection.get(this.key + sub_key);
if (block?.vec) return block;
}
return acc;
}, null);
}
/**
* Checks if the source file exists in the file system.
* @async
* @returns {Promise<boolean>} A promise that resolves to `true` if the file exists, `false` otherwise.
*/
async has_source_file() {
return await this.fs.exists(this.path);
}
/**
* FILTER/SEARCH METHODS
*/
/**
* Searches for keywords within the entity's data and content.
* @async
* @param {Object} search_filter - The search filter object.
* @param {string[]} search_filter.keywords - An array of keywords to search for.
* @param {string} [search_filter.type='any'] - The type of search to perform. 'any' counts all matching keywords, 'all' counts only if all keywords match.
* @returns {Promise<number>} A promise that resolves to the number of matching keywords.
*/
async search(search_filter = {}) {
const { keywords, type = "any", limit } = search_filter;
if (!keywords || !Array.isArray(keywords)) {
console.warn("Entity.search: keywords not set or is not an array");
return 0;
}
if (limit && this.collection.search_results_ct >= limit) return 0;
const lowercased_keywords = keywords.map((keyword) => keyword.toLowerCase());
const content = await this.read();
if (!content || typeof content !== "string" || !content.length) {
if (content.mime_type) {
console.warn(`Entity.search: No content available for searching: ${this.path}, mime_type: ${content.mime_type}`);
} else {
console.warn(`Entity.search: No content available for searching: ${this.path}, content: ${content ? JSON.stringify(content) : "empty"}`);
}
return 0;
}
const lowercased_content = content.toLowerCase();
const lowercased_path = this.path.toLowerCase();
const matching_keywords = lowercased_keywords.filter(
(keyword) => lowercased_path.includes(keyword) || lowercased_content.includes(keyword)
);
if (type === "all") {
return matching_keywords.length === lowercased_keywords.length ? matching_keywords.length : 0;
} else {
return matching_keywords.length;
}
}
/**
* ADAPTER METHODS
*/
use_source_adapter(method, ...args) {
if (!this.source_adapter) {
console.warn(`No source adapter available for ${this.key}. Cannot use method ${method}.`);
return;
}
if (typeof this.source_adapter[method] !== "function") {
console.warn(`Source adapter for ${this.key} does not implement method ${method}.`);
return;
}
return this.source_adapter[method](...args);
}
/**
* Appends content to the end of the source file.
* @async
* @param {string} content - The content to append to the file.
* @returns {Promise<void>} A promise that resolves when the operation is complete.
*/
async append(content) {
await this.use_source_adapter("append", content);
await this.import();
}
/**
* Updates the entire content of the source file.
* @async
* @param {string} full_content - The new content to write to the file.
* @param {Object} [opts={}] - Additional options for the update.
* @returns {Promise<void>} A promise that resolves when the operation is complete.
*/
async update(full_content, opts = {}) {
try {
await this.use_source_adapter("update", full_content, opts);
await this.import();
} catch (error) {
console.error(`Error during update for ${this.key}:`, error);
}
}
/**
* Reads the entire content of the source file.
* @async
* @param {Object} [opts={}] - Additional options for reading.
* @returns {Promise<string>} A promise that resolves with the content of the file.
*/
async read(opts = {}) {
try {
return await this.use_source_adapter("read", opts) || "";
} catch (error) {
console.error(`Error during reading ${this.key} (returning empty string)`, error);
return "";
}
}
/**
* Removes the source file from the file system and deletes the entity.
* This is different from `delete()` because it also removes the source file.
* @async
* @returns {Promise<void>} A promise that resolves when the operation is complete.
*/
async remove() {
try {
await this.use_source_adapter("remove");
} catch (error) {
console.error(`Error during remove for ${this.key}:`, error);
}
}
/**
* Moves the current source to a new location.
* Handles the destination as a string (new path) or entity (block or source).
*
* @async
* @param {string|SmartEntity} entity_ref - The destination path or entity to move to.
* @throws {Error} If the entity reference is invalid.
* @returns {Promise<void>} A promise that resolves when the move operation is complete.
*/
async move_to(entity_ref) {
try {
await this.use_source_adapter("move_to", entity_ref);
} catch (error) {
console.error(`Error during move for ${this.key}:`, error);
}
}
/**
* Merges the given content into the current source.
* Parses the content into blocks and either appends to existing blocks, replaces blocks, or replaces all content.
*
* @async
* @param {string} content - The content to merge into the current source.
* @param {Object} [opts={}] - Options object.
* @param {string} [opts.mode='append'] - The merge mode: 'append', 'replace_blocks', or 'replace_all'.
* @returns {Promise<void>}
*/
async merge(content, opts = {}) {
try {
await this.use_source_adapter("merge", content, opts);
await this.import();
} catch (error) {
console.error(`Error during merge for ${this.key}:`, error);
}
}
/**
* Handles errors during the load process.
* @param {Error} err - The error encountered during load.
* @returns {void}
*/
on_load_error(err) {
super.on_load_error(err);
if (err.code === "ENOENT") {
this._queue_load = false;
this.queue_import();
}
}
/**
* Retrieves the block collection associated with SmartSources.
* @readonly
* @returns {SmartBlocks} The block collection instance.
*/
get block_collection() {
return this.env.smart_blocks;
}
/**
* Retrieves the vector representations of all blocks within the SmartSource.
* @readonly
* @returns {Array<Array<number>>} An array of vectors.
*/
get block_vecs() {
return this.blocks.map((block) => block.vec).filter((vec) => vec);
}
/**
* Retrieves all blocks associated with the SmartSource.
* @readonly
* @returns {Array<SmartBlock>} An array of SmartBlock instances.
* @description
* Uses block refs (Fastest) to get blocks without iterating over all blocks
*/
get blocks() {
if (this.data.blocks) return this.block_collection.get_many(Object.keys(this.data.blocks).map((key) => this.key + key));
return [];
}
/**
* Determines if the SmartSource is excluded from processing.
* @readonly
* @returns {boolean} `true` if excluded, `false` otherwise.
*/
get excluded() {
return this.fs.is_excluded(this.path);
}
/**
* Retrieves the lines excluded from embedding.
* @readonly
* @returns {Array<Object>} An array of objects with `start` and `end` line numbers.
*/
get excluded_lines() {
return this.blocks.filter((block) => block.excluded).map((block) => block.lines);
}
/**
* Retrieves the file system instance from the SmartSource's collection.
* @readonly
* @returns {SmartFS} The file system instance.
*/
get fs() {
return this.collection.fs;
}
/**
* Retrieves the file object associated with the SmartSource.
* @deprecated should be replaced with adapter methods
* @readonly
* @returns {Object} The file object.
*/
get file() {
return this.fs.files[this.path];
}
/**
* Retrieves the file name of the SmartSource.
* @readonly
* @returns {string} The file name.
*/
get file_name() {
return this.path.split("/").pop();
}
/**
* Retrieves the file path of the SmartSource.
* @readonly
* @returns {string} The file path.
*/
get file_path() {
return this.path;
}
/**
* Retrieves the file type based on the file extension.
* @readonly
* @returns {string} The file type in lowercase.
*/
get file_type() {
if (!this._ext) {
this._ext = this.collection.get_extension_for_path(this.path) || "md";
}
return this._ext;
}
/**
* Retrieves the modification time of the SmartSource.
* @deprecated should be replaced with adapter methods (see get size)
* @readonly
* @returns {number} The modification time.
*/
get mtime() {
return this.file?.stat?.mtime || 0;
}
/**
* Retrieves the size of the SmartSource.
* @readonly
* @returns {number} The size.
*/
get size() {
return this.source_adapter?.size || 0;
}
/**
* Retrieves the last import stat of the SmartSource.
* @readonly
* @returns {Object} The last import stat.
*/
get last_import() {
return this.data?.last_import;
}
/**
* Retrieves the last import modification time of the SmartSource.
* @readonly
* @returns {number} The last import modification time.
*/
get last_import_mtime() {
return this.last_import?.mtime || 0;
}
/**
* Retrieves the last import size of the SmartSource.
* @readonly
* @returns {number} The last import size.
*/
get last_import_size() {
return this.last_import?.size || 0;
}
/**
* Retrieves the paths of inlinks to this SmartSource.
* @readonly
* @returns {Array<string>} An array of inlink paths.
*/
get inlinks() {
return Object.keys(this.collection.links?.[this.path] || {});
}
get is_media() {
return this.source_adapter.is_media || false;
}
/**
* Determines if the SmartSource is gone (i.e., the file no longer exists).
* @readonly
* @returns {boolean} `true` if gone, `false` otherwise.
*/
get is_gone() {
return !this.file;
}
/**
* Retrieves the last read hash of the SmartSource.
* @readonly
* @returns {string|undefined} The last read hash or `undefined` if not set.
*/
get last_read() {
return this.data.last_read;
}
get metadata() {
return this.data.metadata;
}
get outdated() {
return this.source_adapter.outdated;
}
/**
* Retrieves the outlink paths from the SmartSource.
* @readonly
* @returns {Array<string>} An array of outlink paths.
*/
get outlinks() {
return (this.data.outlinks || []).map((link) => {
const link_ref = link?.target || link;
if (typeof link_ref !== "string") return null;
if (link_ref.startsWith("http")) return null;
const link_path = this.fs.get_link_target_path(link_ref, this.file_path);
return {
key: link_path,
embedded: link.embedded || false
};
}).filter((link_path) => link_path);
}
/**
* @deprecated path should be derived from key (stable key principle)
*/
get path() {
return this.data.path || this.data.key;
}
get source_adapters() {
return this.collection.source_adapters;
}
get source_adapter() {
if (this._source_adapter) return this._source_adapter;
if (this.source_adapters[this.file_type]) this._source_adapter = new this.source_adapters[this.file_type](this);
else {
for (const Adapter of Object.values(this.source_adapters)) {
if (typeof Adapter.detect_type !== "function") continue;
if (Adapter.detect_type(this)) {
this._source_adapter = new Adapter(this);
break;
}
}
}
return this._source_adapter;
}
/**
* Calculates the mean vector of all blocks within the SmartSource.
* @readonly
* @returns {Array<number>|null} The mean vector or `null` if no vectors are present.
*/
get mean_block_vec() {
if (this._mean_block_vec) {
this._mean_block_vec = compute_centroid(this.block_vecs);
}
return this._mean_block_vec;
}
/**
* Calculates the median vector of all blocks within the SmartSource.
* @readonly
* @returns {Array<number>|null} The median vector or `null` if no vectors are present.
*/
get median_block_vec() {
if (this._median_block_vec) {
this._median_block_vec = compute_medoid(this.block_vecs);
}
return this._median_block_vec;
}
/**
* @async
* @deprecated Use `read` instead.
* @returns {Promise<string>} A promise that resolves with the content of the file.
*/
async _read() {
return await this.source_adapter._read();
}
/**
* @async
* @deprecated Use `remove` instead.
* @returns {Promise<void>} A promise that resolves when the entity is destroyed.
*/
async destroy() {
await this.remove();
}
/**
* @async
* @deprecated Use `update` instead.
* @param {string} content - The content to update.
* @returns {Promise<void>}
*/
async _update(content) {
await this.source_adapter.update(content);
}
/**
* @deprecated Use `source` instead.
* @readonly
* @returns {SmartSource} The associated SmartSource instance.
*/
get t_file() {
return this.fs.files[this.path];
}
};
var smart_source_default = {
class: SmartSource,
actions: {
find_connections: find_connections2
}
};

var SmartSources = class extends SmartEntities {
static {
__name(this, "SmartSources");
}
/**
* Creates an instance of SmartSources.
* @constructor
* @param {Object} env - The environment instance.
* @param {Object} [opts={}] - Configuration options.
*/
constructor(env, opts = {}) {
super(env, opts);
this.search_results_ct = 0;
this._excluded_headings = null;
this.env_event_unsubscribers = [];
this.sources_re_import_queue = {};
this.sources_re_import_timeout = null;
this.sources_re_import_halted = false;
}
/**
* Initializes the SmartSources instance by performing an initial scan of sources.
* @async
* @returns {Promise<void>}
*/
async init() {
await super.init();
await this.init_items();
this.register_env_event_listeners();
this.register_source_watchers();
}
/**
* Registers env.events listeners for source lifecycle events emitted by filesystem adapters.
* @returns {void}
*/
register_env_event_listeners() {
this.unregister_env_event_listeners();
if (!this.env?.events) return;
const listeners = [
["sources:created", (event) => this.handle_source_created(event)],
["sources:modified", (event) => this.handle_source_modified(event)],
["sources:renamed", (event) => this.handle_source_renamed(event)],
["sources:deleted", (event) => this.handle_source_deleted(event)]
];
this.env_event_unsubscribers = listeners.map(([event_key, handler]) => this.env.events.on(event_key, handler)).filter(Boolean);
}
/**
* Unregisters env.events listeners that were previously attached by this collection.
* @returns {void}
*/
unregister_env_event_listeners() {
if (!Array.isArray(this.env_event_unsubscribers)) return;
while (this.env_event_unsubscribers.length) {
const unsub = this.env_event_unsubscribers.pop();
try {
unsub?.();
} catch (error) {
console.warn("SmartSources: Failed to unregister env event listener", error);
}
}
}
/**
* Determines whether the incoming event should be handled by this collection instance.
* @param {Object} event
* @returns {boolean}
*/
should_handle_event(event = {}) {
const { collection_key } = event;
if (collection_key && collection_key !== this.collection_key) return false;
return true;
}
/**
* Normalizes event payload keys into a canonical source path.
* @param {Object} event
* @returns {string|undefined}
*/
get_event_path(event = {}) {
return event.item_key || event.path || event.new_path;
}
/**
* Handles create events emitted by filesystem adapters.
* @param {Object} event
* @returns {void}
*/
handle_source_created(event = {}) {
if (!this.should_handle_event(event)) return;
const key = this.get_event_path(event);
if (!key) return;
const source = this.init_file_path(key) || this.get(key);
if (!source) {
console.warn("SmartSources: Unable to initialize source on create event", event);
return;
}
this.queue_source_re_import(source, { event_source: event.event_source });
}
/**
* Handles modify events emitted by filesystem adapters.
* @param {Object} event
* @returns {void}
*/
handle_source_modified(event = {}) {
if (!this.should_handle_event(event)) return;
const key = this.get_event_path(event);
if (!key) return;
if (this.fs.is_excluded(key)) return;
let source = this.get(key);
if (!source) source = this.init_file_path(key);
if (!source) {
console.warn("SmartSources: Unable to resolve source on modify event", { key, event });
return;
}
this.queue_source_re_import(source, { event_source: event.event_source });
}
/**
* Handles rename events emitted by filesystem adapters.
* @param {Object} event
* @returns {void}
*/
handle_source_renamed(event = {}) {
if (!this.should_handle_event(event)) return;
const new_key = this.get_event_path(event);
const old_key = event.old_path || event.from;
if (!new_key && !old_key) return;
if (old_key && this.items[old_key]) {
const old_source = this.items[old_key];
old_source?.delete?.();
delete this.items[old_key];
if (this.rename_debounce_timeout) clearTimeout(this.rename_debounce_timeout);
this.rename_debounce_timeout = setTimeout(() => {
this.process_save_queue();
this.rename_debounce_timeout = null;
}, 1e3);
}
if (!new_key) return;
let source = this.get(new_key);
if (!source) source = this.init_file_path(new_key);
if (!source) {
console.warn("SmartSources: Unable to initialize source on rename event", event);
return;
}
this.queue_source_re_import(source, { event_source: event.event_source });
}
/**
* Handles delete events emitted by filesystem adapters.
* @param {Object} event
* @returns {void}
*/
handle_source_deleted(event = {}) {
if (!this.should_handle_event(event)) return;
const key = this.get_event_path(event);
if (!key) return;
delete this.items[key];
if (this.sources_re_import_queue[key]) {
delete this.sources_re_import_queue[key];
}
}
/**
* Requests filesystem adapters to register source watchers for this collection.
* @returns {void}
*/
register_source_watchers() {
const adapter = this.fs?.adapter;
if (!adapter || typeof adapter.register_source_watchers !== "function") return;
if (this._source_watchers_registered) return;
this._source_watchers_registered = adapter.register_source_watchers(this);
}
/**
* Queues a SmartSource for re-import and schedules processing.
* @param {import('./smart_source.js').SmartSource} source
* @param {Object} [event_meta]
* @returns {void}
*/
queue_source_re_import(source, event_meta = {}) {
if (!source?.key) return;
if (this.sources_re_import_queue[source.key]) return;
source.data.last_import = { at: 0, hash: null, mtime: 0, size: 0 };
this.sources_re_import_queue[source.key] = { source, event_meta };
this.debounce_re_import_queue();
}
/**
* Debounces re-import processing to respect the configured wait time.
* @returns {void}
*/
debounce_re_import_queue() {
this.sources_re_import_halted = true;
if (this.sources_re_import_timeout) clearTimeout(this.sources_re_import_timeout);
const queue_keys = Object.keys(this.sources_re_import_queue || {});
if (!queue_keys.length) {
this.sources_re_import_timeout = null;
return;
}
const wait_seconds = typeof this.env?.settings?.re_import_wait_time === "number" ? this.env.settings.re_import_wait_time : 13;
this.sources_re_import_timeout = setTimeout(
() => this.run_re_import(),
wait_seconds * 1e3
);
}
/**
* Processes the queued re-import tasks.
* @returns {Promise<void>}
*/
async run_re_import() {
this.sources_re_import_halted = false;
const queue_entries = Object.entries(this.sources_re_import_queue || {});
if (!queue_entries.length) {
if (this.sources_re_import_timeout) clearTimeout(this.sources_re_import_timeout);
this.sources_re_import_timeout = null;
return;
}
for (const [key, { source }] of queue_entries) {
await source.import();
if (!this._embed_queue) this._embed_queue = [];
if (source.should_embed) this._embed_queue.push(source);
if (this.block_collection?.settings?.embed_blocks) {
for (const block of source.blocks || []) {
if (block._queue_embed || block.should_embed && block.is_unembedded) {
this._embed_queue.push(block);
block._queue_embed = true;
}
}
}
delete this.sources_re_import_queue[key];
if (this.sources_re_import_halted) {
this.debounce_re_import_queue();
break;
}
}
if (this._embed_queue?.length) {
const embed_start_at = Date.now();
await this.process_embed_queue();
console.log(`Processed embed queue in ${Date.now() - embed_start_at}ms`);
}
if (this.sources_re_import_timeout) clearTimeout(this.sources_re_import_timeout);
this.sources_re_import_timeout = null;
}
/**
* Initializes items by letting each adapter do any necessary file-based scanning.
* Adapters that do not rely on file scanning can skip or do nothing.
* @async
* @returns {Promise<void>}
*/
async init_items() {
this.emit_event("source:initial_scan_started");
this.show_process_notice("initial_scan");
for (const AdapterClass of Object.values(this.source_adapters)) {
if (typeof AdapterClass.init_items === "function") {
await AdapterClass.init_items(this);
}
}
this.clear_process_notice("initial_scan");
this.emit_event("source:initial_scan_completed");
this.notices?.show("done_initial_scan", { collection_key: this.collection_key });
}
/**
* Creates (or returns existing) a SmartSource for a given file path, if the extension is recognized.
* @param {string} file_path - The path to the file or pseudo-file
* @returns {SmartSource|undefined} The newly created or existing SmartSource, or undefined if no recognized extension
*/
init_file_path(file_path) {
const ext = this.get_extension_for_path(file_path);
if (!ext) {
return;
}
if (this.fs.is_excluded(file_path)) {
console.warn(`File ${file_path} is excluded from processing.`);
return;
}
if (!this.fs.files[file_path]) {
this.fs.include_file(file_path);
}
if (this.items[file_path]) return this.items[file_path];
const item = new this.item_type(this.env, { path: file_path });
this.items[file_path] = item;
item.queue_import();
item.queue_load();
return item;
}
/**
* Looks for an extension in descending order:
* e.g. split "my.file.name.github" -> ["my","file","name","github"]
* Try 'file.name.github', 'name.github', 'github'
* Return the first that is in 'source_adapters'
* @param {string} file_path
* @returns {string|undefined} recognized extension, or undefined if none
*/
get_extension_for_path(file_path) {
if (!file_path) return void 0;
const pcs = file_path.split(".");
if (pcs.length < 2) return void 0;
let last_ext;
pcs.shift();
while (pcs.length) {
const supported_ext = pcs.join(".").toLowerCase();
if (this.source_adapters[supported_ext]) {
return supported_ext;
}
last_ext = pcs.shift();
}
return last_ext;
}
/**
* Builds a map of links between sources.
* @returns {Object} An object mapping link paths to source keys.
*/
build_links_map() {
const start_time = Date.now();
this.links = {};
for (const source of Object.values(this.items)) {
for (const link of source.outlinks) {
if (!this.links[link.key]) this.links[link.key] = {};
this.links[link.key][source.key] = { ...link, key: void 0 };
}
}
const end_time = Date.now();
console.log(`Time spent building links: ${end_time - start_time}ms`);
return this.links;
}
/**
* Creates a new source with the given key and content.
* @async
* @param {string} key - The key (path) of the new source.
* @param {string} content - The content to write to the new source.
* @returns {Promise<SmartSource>} The created SmartSource instance.
*/
async create(key, content) {
await this.fs.write(key, content);
await this.fs.refresh();
const source = await this.create_or_update({ path: key });
await source.import();
return source;
}
/**
* Performs a lexical search for matching SmartSource content.
* @async
* @deprecated uses this.actions 2025-12-02
* @param {Object} search_filter - The filter criteria for the search.
* @param {string[]} search_filter.keywords - An array of keywords to search for.
* @param {number} [search_filter.limit] - The maximum number of results to return.
* @returns {Promise<Array<SmartSource>>} A promise that resolves to an array of matching SmartSource entities.
*/
async search(search_filter = {}) {
const {
keywords,
limit,
...filter_opts
} = search_filter;
if (!keywords) {
console.warn("search_filter.keywords not set");
return [];
}
this.search_results_ct = 0;
const initial_results = this.filter(filter_opts);
const search_results = [];
for (let i = 0; i < initial_results.length; i += 10) {
const batch = initial_results.slice(i, i + 10);
const batch_results = await Promise.all(
batch.map(async (item) => {
try {
const matches = await item.search(search_filter);
if (matches) {
this.search_results_ct++;
return { item, score: matches };
} else return null;
} catch (error) {
console.error(`Error searching item ${item.id || "unknown"}:`, error);
return null;
}
})
);
search_results.push(...batch_results.filter(Boolean));
}
return search_results.sort((a, b) => b.score - a.score).map((result) => result.item);
}
/**
* Looks up entities based on the provided parameters.
* @async
* @deprecated uses this.actions 2025-12-02
* @param {Object} [params={}] - Parameters for the lookup.
* @param {Object} [params.filter] - Filter options.
* @param {number} [params.k] - Deprecated. Use `params.filter.limit` instead.
* @returns {Promise<Array<SmartSource>>} A promise that resolves to an array of matching SmartSource entities.
*/
async lookup(params = {}) {
const limit = params.filter?.limit || params.k || this.env.settings.lookup_k || 10;
if (params.filter?.limit) delete params.filter.limit;
if (params.collection) {
const collection = this.env[params.collection];
if (collection && collection.lookup) {
delete params.collection;
params.skip_blocks = true;
const results2 = await collection.lookup(params);
if (results2.error) {
console.warn(results2.error);
return [];
}
return results2.slice(0, limit);
}
}
let results = await super.lookup(params);
if (results.error) {
console.warn(results.error);
return [];
}
if (this.block_collection?.settings?.embed_blocks && !params.skip_blocks) {
results = [
...results,
...await this.block_collection.lookup(params)
].sort(sort_by_score);
}
return results.slice(0, limit);
}
/**
* Processes the load queue by loading items and optionally importing them.
* Called after a "re-load" from settings, or after environment init.
* @async
* @returns {Promise<void>}
*/
async process_load_queue() {
await super.process_load_queue();
if (this.collection_key === "smart_sources" && this.env.smart_blocks) {
Object.values(this.env.smart_blocks.items).forEach((item) => item.init());
}
if (this.block_collection) {
this.block_collection.loaded = Object.keys(this.block_collection.items).length;
}
if (!this.opts.prevent_import_on_load) {
await this.process_source_import_queue(this.opts);
}
this.build_links_map();
this.block_collection.cleanup_blocks();
}
/**
* @method process_source_import_queue
* @description
* Imports items (SmartSources or SmartBlocks) that have been flagged for import.
*/
async process_source_import_queue(opts = {}) {
const { process_embed_queue = true, force = false } = opts;
if (force) Object.values(this.items).forEach((item) => item._queue_import = true);
const import_queue = Object.values(this.items).filter((item) => item._queue_import);
console.log("import_queue " + import_queue.length);
if (import_queue.length) {
const time_start = Date.now();
for (let i = 0; i < import_queue.length; i += 100) {
this.notices?.show("import_progress", {
progress: i,
total: import_queue.length
});
await Promise.all(import_queue.slice(i, i + 100).map((item) => item.import()));
}
setTimeout(() => {
this.notices?.remove("import_progress");
}, 1e3);
this.notices?.show("done_import", {
count: import_queue.length,
time_in_seconds: (Date.now() - time_start) / 1e3
});
} else {
this.notices?.show("no_import_queue");
}
this.build_links_map();
if (process_embed_queue) await this.process_embed_queue();
else console.log("skipping process_embed_queue");
await this.process_save_queue();
await this.block_collection?.process_save_queue();
this.emit_event("sources:import_completed");
}
/**
* Retrieves the source adapters based on the collection configuration.
* @readonly
* @returns {Object} An object mapping file extensions to adapter constructors.
*/
get source_adapters() {
if (!this._source_adapters) {
const source_adapters = Object.entries(this.env.opts.collections?.[this.collection_key]?.source_adapters || {});
const _source_adapters = source_adapters.reduce((acc, [key, Adapter]) => {
if (Adapter.extensions) Adapter.extensions?.forEach((ext) => acc[ext] = Adapter);
else if (typeof Adapter.detect_type === "function") acc[key] = Adapter;
return acc;
}, {});
if (Object.keys(_source_adapters).length) {
this._source_adapters = _source_adapters;
}
}
return this._source_adapters;
}
/**
* Retrieves the notices system from the environment.
* @readonly
* @returns {Object} The notices object.
*/
get notices() {
return this.env.smart_connections_plugin?.notices || this.env.main?.notices;
}
/**
* Retrieves the currently active note.
* @readonly
* @returns {SmartSource|null} The current SmartSource instance or null if none.
*/
get current_note() {
return this.get(this.env.smart_connections_plugin.app.workspace.getActiveFile().path);
}
/**
* Retrieves the file system instance, initializing it if necessary.
* @readonly
* @returns {SmartFS} The file system instance.
*/
get fs() {
if (!this._fs) {
this._fs = new this.env.opts.modules.smart_fs.class(this.env, {
adapter: this.env.opts.modules.smart_fs.adapter,
fs_path: this.env.opts.env_path || "",
exclude_patterns: this.excluded_patterns || []
});
}
return this._fs;
}
/**
* Retrieves the settings configuration by combining superclass settings and adapter-specific settings.
* @readonly
* @returns {Object} The settings configuration object.
*/
get settings_config() {
const _settings_config = {
...super.settings_config,
...this.process_settings_config(settings_config2),
...Object.entries(this.source_adapters).reduce((acc, [file_extension, adapter_constructor]) => {
if (acc[adapter_constructor]) return acc;
const item = this.items[Object.keys(this.items).find((i) => i.endsWith(file_extension))];
const adapter_instance = new adapter_constructor(item || new this.item_type(this.env, {}));
if (adapter_instance.settings_config) {
acc[adapter_constructor.name] = {
type: "html",
value: `<h4>${adapter_constructor.name} adapter</h4>`
};
acc = { ...acc, ...adapter_instance.settings_config };
}
return acc;
}, {})
};
return _settings_config;
}
/**
* Retrieves the block collection associated with SmartSources.
* @readonly
* @returns {SmartBlocks} The block collection instance.
*/
get block_collection() {
return this.env.smart_blocks;
}
/**
* Retrieves the embed queue containing items and their blocks to be embedded.
* @readonly
* @returns {Array<Object>} The embed queue.
*/
get embed_queue() {
if (!this._embed_queue.length) {
try {
const embed_blocks = this.block_collection.settings.embed_blocks;
this._embed_queue = Object.values(this.items).reduce((acc, item) => {
if (item._queue_embed || item.should_embed && item.is_unembedded) acc.push(item);
if (embed_blocks) item.blocks.forEach((block) => {
if (block._queue_embed || block.should_embed && block.is_unembedded) acc.push(block);
});
return acc;
}, []);
} catch (e) {
console.error(`Error getting embed queue:`, e);
}
}
return this._embed_queue;
}
/**
* Clears all data by removing sources and blocks, reinitializing the file system, and reimporting items.
* @async
* @returns {Promise<void>}
*/
async run_clear_all() {
this.notices?.show("clearing_all");
await this.data_adapter.clear_all();
this.clear();
this.block_collection.clear();
this._fs = null;
await this.init_fs();
await this.init_items();
this._excluded_headings = null;
Object.values(this.items).forEach((item) => {
item.queue_import();
item.queue_embed();
item.loaded_at = Date.now() + 9999999999;
});
this.notices?.remove("clearing_all");
this.notices?.show("done_clearing_all");
await this.process_source_import_queue();
}
async init_fs(opts = {}) {
const { force_refresh = false } = opts;
if (force_refresh) await this.env.fs.refresh();
await this.fs.load_exclusions();
this.fs.file_paths = this.fs.post_process(this.env.fs.file_paths);
this.fs.files = this.fs.file_paths.reduce((acc, file_path) => {
acc[file_path] = this.env.fs.files[file_path];
return acc;
}, {});
this.fs.folder_paths = this.fs.post_process(this.env.fs.folder_paths);
this.fs.folders = this.fs.folder_paths.reduce((acc, folder_path) => {
acc[folder_path] = this.env.fs.folders[folder_path];
return acc;
}, {});
}
/**
* Retrieves patterns for excluding files/folders from processing.
* @readonly
* @returns {Array<string>}
*/
get excluded_patterns() {
return [
...this.file_exclusions?.map((file) => `${file}**`) || [],
...(this.folder_exclusions || []).map((folder) => `${folder}**`),
this.env.env_data_dir + "/**"
];
}
/**
* Retrieves the file exclusion patterns from settings.
* @readonly
* @returns {Array<string>} An array of file exclusion patterns.
*/
get file_exclusions() {
const csv = this.env.settings?.smart_sources?.file_exclusions;
return csv?.length ? csv.split(",").map((file) => file.trim()) : [];
}
/**
* Retrieves the folder exclusion patterns from settings.
* @readonly
* @returns {Array<string>} An array of folder exclusion patterns.
*/
get folder_exclusions() {
const csv = this.env.settings?.smart_sources?.folder_exclusions;
return csv?.length ? csv.split(",").map((folder) => {
folder = folder.trim();
if (folder === "") return false;
if (folder === "/") return false;
if (!folder.endsWith("/")) return folder + "/";
return folder;
}).filter(Boolean) : [];
}
/**
* Retrieves the excluded headings from settings.
* @readonly
* @returns {Array<string>} An array of excluded headings.
*/
get excluded_headings() {
if (!this._excluded_headings) {
const csv = this.env.settings?.smart_sources?.excluded_headings;
this._excluded_headings = csv?.length ? csv.split(",").map((heading) => heading.trim()) : [];
}
return this._excluded_headings;
}
/**
* Retrieves the count of included files that are not excluded.
* @readonly
* @returns {number} The number of included files.
*/
get included_files() {
const extensions = Object.keys(this.source_adapters);
return this.fs.file_paths.filter((file_path) => extensions.some((ext) => file_path.endsWith(ext)) && !this.fs.is_excluded(file_path)).length;
}
get excluded_file_paths() {
return this.env.fs.file_paths.filter((file_path) => this.fs.is_excluded(file_path));
}
/**
* Retrieves the total number of files, regardless of exclusion.
* @readonly
* @returns {number} The total number of files.
*/
get total_files() {
return this.fs.file_paths.filter((file) => file.endsWith(".md") || file.endsWith(".canvas")).length;
}
/**
* Unloads the collection and clears registered listeners and timers.
* @returns {void}
*/
unload() {
this.unregister_env_event_listeners();
if (this.sources_re_import_timeout) clearTimeout(this.sources_re_import_timeout);
this.sources_re_import_timeout = null;
this.sources_re_import_queue = {};
super.unload();
}
get data_dir() {
return "multi";
}
};
var settings_config2 = {
};

var CollectionDataAdapter = class {
static {
__name(this, "CollectionDataAdapter");
}
/**
* @constructor
* @param {Object} collection - The collection instance that this adapter manages.
*/
constructor(collection) {
this.collection = collection;
this.env = collection.env;
}
/**
* The class to use for item adapters.
* @type {typeof ItemDataAdapter}
*/
ItemDataAdapter = ItemDataAdapter;
/**
* Optional factory method to create item adapters.
* If `this.item_adapter_class` is not null, it uses that; otherwise can be overridden by subclasses.
* @param {Object} item - The item to create an adapter for.
* @returns {ItemDataAdapter}
*/
create_item_adapter(item) {
if (!this.ItemDataAdapter) {
throw new Error("No item_adapter_class specified and create_item_adapter not overridden.");
}
return new this.ItemDataAdapter(item);
}
/**
* Load a single item by its key using an `ItemDataAdapter`.
* @async
* @abstract
* @param {string} key - The key of the item to load.
* @returns {Promise<void>} Resolves when the item is loaded.
*/
async load_item(key) {
throw new Error("Not implemented");
}
/**
* Save a single item by its key using its associated `ItemDataAdapter`.
* @async
* @abstract
* @param {string} key - The key of the item to save.
* @returns {Promise<void>} Resolves when the item is saved.
*/
async save_item(key) {
throw new Error("Not implemented");
}
/**
* Delete a single item by its key. This may involve updating or removing its file,
* as handled by the `ItemDataAdapter`.
* @async
* @abstract
* @param {string} key - The key of the item to delete.
* @returns {Promise<void>} Resolves when the item is deleted.
*/
async delete_item(key) {
throw new Error("Not implemented");
}
/**
* Process any queued load operations. Typically orchestrates calling `load_item()`
* on items that have been flagged for loading.
* @async
* @abstract
* @returns {Promise<void>}
*/
async process_load_queue() {
throw new Error("Not implemented");
}
/**
* Process any queued save operations. Typically orchestrates calling `save_item()`
* on items that have been flagged for saving.
* @async
* @abstract
* @returns {Promise<void>}
*/
async process_save_queue() {
throw new Error("Not implemented");
}
/**
* Load the item's data from storage if it has been updated externally.
* @async
* @param {string} key - The key of the item to load.
* @returns {Promise<void>} Resolves when the item is loaded.
*/
async load_item_if_updated(item) {
const adapter = this.create_item_adapter(item);
await adapter.load_if_updated();
}
/**
* Clear all data associated with this collection.
* @async
* @abstract
* @returns {Promise<void>}
*/
async clear_all() {
throw new Error("Not implemented");
}
};
var ItemDataAdapter = class {
static {
__name(this, "ItemDataAdapter");
}
/**
* @constructor
* @param {Object} item - The collection item instance that this adapter manages.
*/
constructor(item) {
this.item = item;
}
/**
* Load the item's data from storage. May involve reading a file and parsing
* its contents, then updating `item.data`.
* @async
* @abstract
* @returns {Promise<void>} Resolves when the item is fully loaded.
*/
async load() {
throw new Error("Not implemented");
}
/**
* Save the item's data to storage. May involve writing to a file or appending
* lines in an append-only format.
* @async
* @abstract
* @param {string|null} [ajson=null] - An optional serialized representation of the item’s data.
*                                     If not provided, the adapter should derive it from the item.
* @returns {Promise<void>} Resolves when the item is saved.
*/
async save(ajson = null) {
throw new Error("Not implemented");
}
/**
* Delete the item's data from storage. May involve removing a file or writing
* a `null` entry in an append-only file to signify deletion.
* @async
* @abstract
* @returns {Promise<void>} Resolves when the item’s data is deleted.
*/
async delete() {
throw new Error("Not implemented");
}
/**
* Returns the file path or unique identifier used by this adapter to locate and store
* the item's data. This may be a file name derived from the item's key.
* @abstract
* @returns {string} The path or identifier for the item's data.
*/
get data_path() {
throw new Error("Not implemented");
}
/**
* @returns {CollectionDataAdapter} The collection data adapter that this item data adapter belongs to.
*/
get collection_adapter() {
return this.item.collection.data_adapter;
}
get env() {
return this.item.env;
}
/**
* Load the item's data from storage if it has been updated externally.
* @async
* @abstract
* @returns {Promise<void>} Resolves when the item is loaded.
*/
async load_if_updated() {
throw new Error("Not implemented");
}
};

var FileCollectionDataAdapter = class extends CollectionDataAdapter {
static {
__name(this, "FileCollectionDataAdapter");
}
/**
* The class to use for item adapters.
* @type {typeof ItemDataAdapter}
*/
ItemDataAdapter = FileItemDataAdapter;
/**
* @returns {Object} Filesystem interface derived from environment or collection settings.
*/
get fs() {
return this.collection.data_fs || this.collection.env.data_fs;
}
async clear_all() {
await this.fs.remove_dir(this.collection.data_dir, true);
}
};
var FileItemDataAdapter = class extends ItemDataAdapter {
static {
__name(this, "FileItemDataAdapter");
}
/**
* @returns {Object} Filesystem interface derived from environment or collection settings.
*/
get fs() {
return this.item.collection.data_fs || this.item.collection.env.data_fs;
}
/**
* Resolve the file path for the item's data.
* @abstract
* @returns {string} Path to the persisted item data.
*/
get data_path() {
throw new Error("Not implemented");
}
async load_if_updated() {
const data_path = this.data_path;
if (await this.fs.exists(data_path)) {
const loaded_at = this.item.loaded_at || 0;
const data_file_stat = await this.fs.stat(data_path);
if (data_file_stat.mtime > loaded_at + 1 * 60 * 1e3) {
console.log(`Smart Collections: Re-loading item ${this.item.key} because it has been updated on disk`);
await this.load();
}
}
}
};

var class_to_collection_key = {
"SmartSource": "smart_sources",
"SmartNote": "smart_sources",
"SmartBlock": "smart_blocks",
"SmartDirectory": "smart_directories"
};
var AjsonMultiFileCollectionDataAdapter = class extends FileCollectionDataAdapter {
static {
__name(this, "AjsonMultiFileCollectionDataAdapter");
}
/**
* The class to use for item adapters.
* @type {typeof ItemDataAdapter}
*/
ItemDataAdapter = AjsonMultiFileItemDataAdapter;
/**
* Load a single item by its key.
* @async
* @param {string} key
* @returns {Promise<void>}
*/
async load_item(key) {
const item = this.collection.get(key);
if (!item) return;
const adapter = this.create_item_adapter(item);
await adapter.load();
}
/**
* Save a single item by its key.
* @async
* @param {string} key
* @returns {Promise<void>}
*/
async save_item(key) {
const item = this.collection.get(key);
if (!item) return;
const adapter = this.create_item_adapter(item);
await adapter.save();
}
/**
* Process any queued load operations.
* @async
* @returns {Promise<void>}
*/
async process_load_queue() {
this.collection.emit_event("collection:load_started");
this.collection.show_process_notice("loading_collection");
if (!await this.fs.exists(this.collection.data_dir)) {
await this.fs.mkdir(this.collection.data_dir);
}
const load_queue = Object.values(this.collection.items).filter((item) => item._queue_load);
if (!load_queue.length) {
this.collection.clear_process_notice("loading_collection");
return;
}
const now = Date.now();
console.log(`Loading ${this.collection.collection_key}: ${load_queue.length} items from disk`);
const batch_size = 100;
for (let i = 0; i < load_queue.length; i += batch_size) {
const batch = load_queue.slice(i, i + batch_size);
await Promise.all(batch.map((item) => {
const adapter = this.create_item_adapter(item);
return adapter.load().catch((err) => {
console.warn(`Error loading item ${item.key}`, err);
item.queue_load();
});
}));
}
console.log(`Loaded ${this.collection.collection_key} from disk in ${Date.now() - now}ms`);
this.collection.loaded = load_queue.length;
this.collection.clear_process_notice("loading_collection");
this.collection.emit_event("collection:load_completed");
}
/**
* Process any queued save operations.
* @async
* @returns {Promise<void>}
*/
async process_save_queue() {
this.collection.emit_event("collection:save_started");
this.collection.show_process_notice("saving_collection");
const save_queue = Object.values(this.collection.items).filter((item) => item._queue_save);
console.log(`Saving ${this.collection.collection_key}: ${save_queue.length} items`);
const time_start = Date.now();
const batch_size = 50;
for (let i = 0; i < save_queue.length; i += batch_size) {
const batch = save_queue.slice(i, i + batch_size);
await Promise.all(batch.map((item) => {
const adapter = this.create_item_adapter(item);
return adapter.save().catch((err) => {
console.warn(`Error saving item ${item.key}`, err);
item.queue_save();
});
}));
}
const deleted_items = Object.values(this.collection.items).filter((item) => item.deleted);
if (deleted_items.length) {
deleted_items.forEach((item) => {
delete this.collection.items[item.key];
});
}
console.log(`Saved ${this.collection.collection_key} in ${Date.now() - time_start}ms`);
this.collection.clear_process_notice("saving_collection");
this.collection.emit_event("collection:save_completed");
}
get_item_data_path(key) {
return [
this.collection.data_dir || "multi",
this.fs?.sep || "/",
this.get_data_file_name(key) + ".ajson"
].join("");
}
/**
* Transforms the item key into a safe filename.
* Replaces spaces, slashes, and dots with underscores.
* @returns {string} safe file name
*/
get_data_file_name(key) {
return key.split("#")[0].replace(/[\s\/\.]/g, "_").replace(".md", "");
}
/**
* Build a single AJSON line for the given item and data.
* @param {Object} item
* @returns {string}
*/
get_item_ajson(item) {
const collection_key = item.collection_key;
const key = item.key;
const data_value = item.deleted ? "null" : JSON.stringify(item.data);
return `${JSON.stringify(`${collection_key}:${key}`)}: ${data_value},`;
}
};
var AjsonMultiFileItemDataAdapter = class extends FileItemDataAdapter {
static {
__name(this, "AjsonMultiFileItemDataAdapter");
}
/**
* Derives the `.ajson` file path from the collection's data_dir and item key.
* @returns {string}
*/
get data_path() {
return this.collection_adapter.get_item_data_path(this.item.key);
}
/**
* Load the item from its `.ajson` file.
* @async
* @returns {Promise<void>}
*/
async load() {
try {
const raw_data = await this.fs.adapter.read(this.data_path, "utf-8", { no_cache: true });
if (!raw_data) {
this.item.queue_import();
return;
}
const { rewrite, file_data } = this._parse(raw_data);
if (rewrite) {
if (file_data.length) await this.fs.write(this.data_path, file_data);
else await this.fs.remove(this.data_path);
}
const last_import_mtime = this.item.data.last_import?.at || 0;
if (last_import_mtime && this.item.init_file_mtime > last_import_mtime) {
this.item.queue_import();
}
} catch (e) {
this.item.queue_import();
}
}
/**
* Parse the entire AJSON content as a JSON object, handle legacy keys, and extract final state.
* @private
* @param {string} ajson
* @returns {boolean}
*/
_parse(ajson) {
try {
let rewrite = false;
if (!ajson.length) return false;
ajson = ajson.trim();
const original_line_count = ajson.split("\n").length;
const json_str = "{" + ajson.slice(0, -1) + "}";
const data = JSON.parse(json_str);
const entries = Object.entries(data);
for (let i = 0; i < entries.length; i++) {
const [ajson_key, value] = entries[i];
if (!value) {
delete data[ajson_key];
rewrite = true;
continue;
}
const { collection_key, item_key, changed } = this._parse_ajson_key(ajson_key);
if (changed) {
rewrite = true;
data[collection_key + ":" + item_key] = value;
delete data[ajson_key];
}
const collection = this.env[collection_key];
if (!collection) continue;
const existing_item = collection.get(item_key);
if (!value.key) value.key = item_key;
if (existing_item) {
existing_item.data = value;
existing_item._queue_load = false;
existing_item.loaded_at = Date.now();
} else {
const ItemClass = collection.item_type;
const new_item = new ItemClass(this.env, value);
new_item._queue_load = false;
new_item.loaded_at = Date.now();
collection.set(new_item);
}
}
if (rewrite || original_line_count > entries.length) {
rewrite = true;
}
return {
rewrite,
file_data: rewrite ? Object.entries(data).map(([key, value]) => `${JSON.stringify(key)}: ${JSON.stringify(value)},`).join("\n") : null
};
} catch (e) {
if (ajson.split("\n").some((line) => !line.endsWith(","))) {
console.warn("fixing trailing comma error");
ajson = ajson.split("\n").map((line) => line.endsWith(",") ? line : line + ",").join("\n");
return this._parse(ajson);
}
console.warn("Error parsing JSON:", e);
return { rewrite: true, file_data: null };
}
}
_parse_ajson_key(ajson_key) {
let changed;
let [collection_key, ...item_key] = ajson_key.split(":");
if (class_to_collection_key[collection_key]) {
collection_key = class_to_collection_key[collection_key];
changed = true;
}
return {
collection_key,
item_key: item_key.join(":"),
changed
};
}
/**
* Save the current state of the item by appending a new line to its `.ajson` file.
* @async
* @returns {Promise<void>}
*/
async save(retries = 0) {
try {
const ajson_line = this.get_item_ajson();
await this.fs.append(this.data_path, "\n" + ajson_line);
this.item._queue_save = false;
} catch (e) {
if (e.code === "ENOENT" && retries < 1) {
const dir = this.collection_adapter.collection.data_dir;
if (!await this.fs.exists(dir)) {
await this.fs.mkdir(dir);
}
return await this.save(retries + 1);
}
console.warn("Error saving item", this.data_path, this.item.key, e);
}
}
/**
* Build a single AJSON line for the given item and data.
* @param {Object} item
* @returns {string}
*/
get_item_ajson() {
return this.collection_adapter.get_item_ajson(this.item);
}
};

var AjsonMultiFileSourcesDataAdapter = class extends AjsonMultiFileCollectionDataAdapter {
static {
__name(this, "AjsonMultiFileSourcesDataAdapter");
}
ItemDataAdapter = AjsonMultiFileSourceDataAdapter;
};
var AjsonMultiFileSourceDataAdapter = class extends AjsonMultiFileItemDataAdapter {
static {
__name(this, "AjsonMultiFileSourceDataAdapter");
}
};

var SourceContentAdapter = class {
static {
__name(this, "SourceContentAdapter");
}
constructor(item) {
this.item = item;
}
async import() {
this.throw_not_implemented("import");
}
async create() {
this.throw_not_implemented("create");
}
async update() {
this.throw_not_implemented("update");
}
async read() {
this.throw_not_implemented("read");
}
async remove() {
this.throw_not_implemented("remove");
}
get data() {
return this.item.data;
}
create_hash(content) {
return murmur_hash_32_alphanumeric(content);
}
get settings() {
return this.item.env.settings.smart_sources[this.adapter_key];
}
get adapter_key() {
return to_snake(this.constructor.name);
}
static get adapter_key() {
return to_snake(this.name);
}
get fs() {
return this.item.collection.fs;
}
get env() {
return this.item.env;
}
};
function to_snake(str) {
return str[0].toLowerCase() + str.slice(1).replace(/([A-Z])/g, "_$1").toLowerCase();
}
__name(to_snake, "to_snake");

function parse_markdown_blocks(markdown, opts = {}) {
const { start_index = 1, line_keys = false } = opts;
const lines = markdown.split("\n");
const LIST_KEY_WORD_LEN = opts.list_key_word_len || 10;
const result = {};
const heading_stack = [];
const heading_lines = {};
const heading_counts = {};
const sub_block_counts = {};
const subheading_counts = {};
const task_lines = [];
const tasks = {};
let current_list_item = null;
let current_content_block = null;
let in_frontmatter = false;
let frontmatter_started = false;
const root_heading_key = "#";
let in_code_block = false;
const codeblock_ranges = [];
let codeblock_start = null;
sub_block_counts[root_heading_key] = 0;
for (let i = 0; i < lines.length; i++) {
const line_number = i + start_index;
const line = lines[i];
const trimmed_line = line.trim();
if (trimmed_line === "---") {
if (!frontmatter_started && line_number === 1) {
frontmatter_started = true;
in_frontmatter = true;
heading_lines["#---frontmatter---"] = [line_number, null];
continue;
} else if (in_frontmatter) {
in_frontmatter = false;
heading_lines["#---frontmatter---"][1] = line_number;
continue;
}
}
if (in_frontmatter) {
continue;
}
if (!in_code_block && /^[-*+]\s+\[(?: |x|X)\]/.test(trimmed_line)) {
task_lines.push(line_number);
if (/^[-*+]\s+\[ \]/.test(trimmed_line)) {
if (!tasks.incomplete) tasks.incomplete = { all: [], top: [] };
tasks.incomplete.all.push(line_number);
}
if (/^[-*+]\s+\[ \]/.test(line)) {
tasks.incomplete.top.push(line_number);
}
}
if (trimmed_line.startsWith("```")) {
in_code_block = !in_code_block;
if (in_code_block && !codeblock_start) codeblock_start = line_number;
else if (!in_code_block && codeblock_start) {
codeblock_ranges.push([codeblock_start, line_number]);
codeblock_start = null;
}
if (!current_content_block) {
const parent_key = heading_stack.length > 0 ? heading_stack[heading_stack.length - 1].key : root_heading_key;
if (parent_key === root_heading_key && !heading_lines[root_heading_key]) {
heading_lines[root_heading_key] = [line_number, null];
}
if (parent_key === root_heading_key) {
current_content_block = { key: root_heading_key, start_line: line_number };
if (heading_lines[root_heading_key][1] === null || heading_lines[root_heading_key][1] < line_number) {
heading_lines[root_heading_key][1] = null;
}
} else {
if (sub_block_counts[parent_key] === void 0) {
sub_block_counts[parent_key] = 0;
}
sub_block_counts[parent_key] += 1;
const n = sub_block_counts[parent_key];
const key = `${parent_key}#{${n}}`;
heading_lines[key] = [line_number, null];
current_content_block = { key, start_line: line_number };
}
}
continue;
}
const heading_match = trimmed_line.match(/^(#{1,6})\s*(.+)$/);
if (heading_match && !in_code_block) {
const level = heading_match[1].length;
let title = heading_match[2].trim();
while (heading_stack.length > 0 && heading_stack[heading_stack.length - 1].level >= level) {
const finished_heading = heading_stack.pop();
if (heading_lines[finished_heading.key][1] === null) {
heading_lines[finished_heading.key][1] = line_number - 1;
}
}
if (heading_stack.length === 0 && heading_lines[root_heading_key] && heading_lines[root_heading_key][1] === null) {
heading_lines[root_heading_key][1] = line_number - 1;
}
if (current_content_block) {
if (heading_lines[current_content_block.key][1] === null) {
heading_lines[current_content_block.key][1] = line_number - 1;
}
current_content_block = null;
}
if (current_list_item) {
if (heading_lines[current_list_item.key][1] === null) {
heading_lines[current_list_item.key][1] = line_number - 1;
}
current_list_item = null;
}
let parent_key = "";
let parent_level = 0;
if (heading_stack.length > 0) {
parent_key = heading_stack[heading_stack.length - 1].key;
parent_level = heading_stack[heading_stack.length - 1].level;
} else {
parent_key = "";
parent_level = 0;
}
if (heading_stack.length === 0) {
heading_counts[title] = (heading_counts[title] || 0) + 1;
if (heading_counts[title] > 1) {
title += `[${heading_counts[title]}]`;
}
} else {
if (!subheading_counts[parent_key]) {
subheading_counts[parent_key] = {};
}
subheading_counts[parent_key][title] = (subheading_counts[parent_key][title] || 0) + 1;
const count = subheading_counts[parent_key][title];
if (count > 1) {
title += `#{${count}}`;
}
}
const level_diff = level - parent_level;
const hashes = "#".repeat(level_diff);
const key = parent_key + hashes + title;
heading_lines[key] = [line_number, null];
sub_block_counts[key] = 0;
heading_stack.push({ level, title, key });
continue;
}
const list_match = line.match(/^(\s*)([-*]|\d+\.) (.+)$/);
if (list_match && !in_code_block) {
const indentation = list_match[1].length;
if (indentation === 0) {
if (current_list_item) {
if (heading_lines[current_list_item.key][1] === null) {
heading_lines[current_list_item.key][1] = line_number - 1;
}
current_list_item = null;
}
if (current_content_block && current_content_block.key !== root_heading_key) {
if (heading_lines[current_content_block.key][1] === null) {
heading_lines[current_content_block.key][1] = line_number - 1;
}
current_content_block = null;
}
let parent_key = heading_stack.length > 0 ? heading_stack[heading_stack.length - 1].key : root_heading_key;
if (parent_key === root_heading_key && !heading_lines[root_heading_key]) {
heading_lines[root_heading_key] = [line_number, null];
}
if (sub_block_counts[parent_key] === void 0) {
sub_block_counts[parent_key] = 0;
}
sub_block_counts[parent_key] += 1;
const n = sub_block_counts[parent_key];
let key;
if (line_keys) {
const content_without_task = list_match[3].replace(/^\[(?: |x|X)\]\s*/, "");
const words = get_longest_words_in_order(content_without_task, LIST_KEY_WORD_LEN);
key = `${parent_key}#${words}`;
} else {
key = `${parent_key}#{${n}}`;
}
heading_lines[key] = [line_number, null];
current_list_item = { key, start_line: line_number };
continue;
}
if (current_list_item) {
continue;
}
}
if (trimmed_line === "") {
continue;
}
if (!current_content_block) {
if (current_list_item) {
if (heading_lines[current_list_item.key][1] === null) {
heading_lines[current_list_item.key][1] = line_number - 1;
}
current_list_item = null;
}
let parent_key = heading_stack.length > 0 ? heading_stack[heading_stack.length - 1].key : root_heading_key;
if (parent_key === root_heading_key) {
if (!heading_lines[root_heading_key]) {
heading_lines[root_heading_key] = [line_number, null];
}
if (heading_lines[root_heading_key][1] === null || heading_lines[root_heading_key][1] < line_number) {
heading_lines[root_heading_key][1] = null;
}
current_content_block = { key: root_heading_key, start_line: line_number };
} else {
if (sub_block_counts[parent_key] === void 0) {
sub_block_counts[parent_key] = 0;
}
sub_block_counts[parent_key] += 1;
const n = sub_block_counts[parent_key];
const key = `${parent_key}#{${n}}`;
heading_lines[key] = [line_number, null];
current_content_block = { key, start_line: line_number };
}
}
}
const total_lines = lines.length;
while (heading_stack.length > 0) {
const finished_heading = heading_stack.pop();
if (heading_lines[finished_heading.key][1] === null) {
heading_lines[finished_heading.key][1] = total_lines + start_index - 1;
}
}
if (current_list_item) {
if (heading_lines[current_list_item.key][1] === null) {
heading_lines[current_list_item.key][1] = total_lines + start_index - 1;
}
current_list_item = null;
}
if (current_content_block) {
if (heading_lines[current_content_block.key][1] === null) {
heading_lines[current_content_block.key][1] = total_lines + start_index - 1;
}
current_content_block = null;
}
if (heading_lines[root_heading_key] && heading_lines[root_heading_key][1] === null) {
heading_lines[root_heading_key][1] = total_lines + start_index - 1;
}
for (const key in heading_lines) {
result[key] = heading_lines[key];
}
return { blocks: result, task_lines, tasks, codeblock_ranges };
}
__name(parse_markdown_blocks, "parse_markdown_blocks");
function get_longest_words_in_order(line, n = 3) {
const words = line.split(/\s+/).sort((a, b) => b.length - a.length).slice(0, n);
return words.sort((a, b) => line.indexOf(a) - line.indexOf(b)).join(" ");
}
__name(get_longest_words_in_order, "get_longest_words_in_order");

var FileSourceContentAdapter = class extends SourceContentAdapter {
static {
__name(this, "FileSourceContentAdapter");
}
static async init_items(collection) {
if (collection.fs_items_initialized) return;
collection._fs = null;
await collection.fs.init();
await collection.init_fs();
for (const file of Object.values(collection.fs.files)) {
const item = collection.init_file_path(file.path);
if (item) item.init_file_mtime = file.stat.mtime;
}
collection.fs_items_initialized = Date.now();
}
/**
* @name fs
* @type {Object}
* @readonly
* @description
* Access the file system interface used by this adapter. Typically derived
* from `this.item.collection.fs`.
*/
get fs() {
return this.item.collection.fs;
}
/**
* @name file_path
* @type {string}
* @readonly
* @description
* The file path on disk corresponding to the source. Used for read/write operations.
*/
get file_path() {
return this.item.file_path;
}
/**
* @async
* @method create
* @param {string|null} [content=null] Initial content for the new file.
* @description
* Create a new file on disk. If content is not provided, attempts to use
* `this.item.data.content` as fallback.
*/
async create(content = null) {
if (!content) content = this.item.data.content || "";
await this.fs.write(this.file_path, content);
}
/**
* @async
* @method update
* @param {string} content The full new content to write to the file.
* @description
* Overwrite the entire file content on disk.
*/
async update(content) {
await this.fs.write(this.file_path, content);
}
/**
* @async
* @method read
* @returns {Promise<string>} The content of the file.
* @description
* Read the file content from disk. Updates `last_read` hash and timestamp on the entity’s data.
* If file is large or special handling is needed, override this method.
*/
async read() {
const content = await this.fs.read(this.file_path);
this.data.last_read = {
hash: this.create_hash(content || ""),
at: Date.now()
};
return content;
}
/**
* @async
* @method remove
* @returns {Promise<void>}
* @description
* Delete the file from disk. After removal, the source item should also be deleted or updated accordingly.
*/
async remove() {
await this.fs.remove(this.file_path);
}
async move_to(move_to_ref) {
if (!move_to_ref) {
throw new Error("Invalid entity reference for move_to operation");
}
const move_content = await this.read();
let has_existing = false;
if (typeof move_to_ref === "string") {
const existing = this.item.collection.get(move_to_ref);
if (existing) {
move_to_ref = existing;
has_existing = true;
}
} else {
has_existing = true;
}
if (has_existing) {
await move_to_ref.append(move_content);
} else {
move_to_ref = await this.item.collection.create(move_to_ref, move_content);
}
if (this.item.key !== move_to_ref.key) {
await this.remove();
this.item.delete();
} else {
console.log(`did not delete ${this.item.key} because it was moved to ${move_to_ref.key}`);
}
return move_to_ref;
}
/**
* Merge content into the source
* @param {string} content - The content to merge into the source
* @param {Object} opts - Options for the merge operation
* @param {string} opts.mode - The mode to use for the merge operation. Defaults to 'append_blocks' (may also be 'replace_blocks')
*/
async merge(content, opts = {}) {
const { mode = "append_blocks" } = opts;
const { blocks: blocks_obj, task_lines } = parse_markdown_blocks(content);
if (typeof blocks_obj !== "object" || Array.isArray(blocks_obj)) {
console.warn("merge error: Expected an object from parse_markdown_blocks, but received:", blocks_obj);
throw new Error("merge error: parse_markdown_blocks did not return an object as expected.");
}
const { new_blocks, new_with_parent_blocks, changed_blocks, same_blocks } = await this.get_changes(blocks_obj, content);
for (const block of new_blocks) {
await this.append(block.content);
}
for (const block of new_with_parent_blocks) {
const parent_block = this.item.block_collection.get(block.parent_key);
await parent_block.append(block.content);
}
for (const block of changed_blocks) {
const changed_block = this.item.block_collection.get(block.key);
if (mode === "replace_blocks") {
await changed_block.update(block.content);
} else {
await changed_block.append(block.content);
}
}
}
async get_changes(blocks_obj, content) {
const new_blocks = [];
const new_with_parent_blocks = [];
const changed_blocks = [];
const same_blocks = [];
const existing_blocks = this.source.data.blocks || {};
for (const [sub_key, line_range] of Object.entries(blocks_obj)) {
const has_existing = !!existing_blocks[sub_key];
const block_key = `${this.source.key}${sub_key}`;
const block_content = get_line_range(content, line_range[0], line_range[1]);
if (!has_existing) {
new_blocks.push({
key: block_key,
state: "new",
content: block_content
});
continue;
}
let has_parent;
let headings = sub_key.split("#");
let parent_key;
while (!has_parent && headings.length > 0) {
headings.pop();
parent_key = headings.join("#");
has_parent = !!existing_blocks[parent_key];
}
if (has_parent) {
new_with_parent_blocks.push({
key: block_key,
parent_key: `${this.source.key}${parent_key}`,
state: "new",
content: block_content
});
continue;
}
const block = this.item.block_collection.get(block_key);
const content_hash = await this.create_hash(block_content);
if (content_hash !== block.last_read?.hash) {
changed_blocks.push({
key: block_key,
state: "changed",
content: block_content
});
continue;
}
same_blocks.push({
key: block_key,
state: "same",
content: block_content
});
}
return {
new_blocks,
new_with_parent_blocks,
changed_blocks,
same_blocks
};
}
/**
* Append new content to the source file, placing it at the end of the file.
* @async
* @param {string} content - The content to append.
* @returns {Promise<void>}
*/
async append(content) {
const current_content = await this.read();
const new_content = [
current_content,
"",
content
].join("\n").trim();
await this.update(new_content);
}
get size() {
return this.item.file?.stat?.size || 0;
}
};

function get_markdown_links(content) {
const result = [];
const markdown_link_re = /\[([^\]]+?)\]\(([^)]+?)\)/g;
const wikilink_re = /\[\[([^\|\]]+?)(?:\|([^\]]+?))?\]\]/g;
const normalise_target = /* @__PURE__ */ __name((raw) => {
const trimmed = raw.trim();
if (/^[a-zA-Z][\w+\-.]*:\/\//.test(trimmed)) return trimmed;
try {
return decodeURIComponent(trimmed);
} catch (_) {
return trimmed.replace(/%20/gi, " ");
}
}, "normalise_target");
const is_embedded = /* @__PURE__ */ __name((index) => {
if (index <= 0) return false;
return content[index - 1] === "!";
}, "is_embedded");
let m;
while ((m = markdown_link_re.exec(content)) !== null) {
const title = m[1];
const target = normalise_target(m[2]);
const line_no = content.slice(0, m.index).split("\n").length;
const embedded = is_embedded(m.index);
const record = { title, target, line: line_no };
if (embedded) record.embedded = true;
result.push(record);
}
while ((m = wikilink_re.exec(content)) !== null) {
const target_raw = m[1];
const title = m[2] || target_raw;
const target = normalise_target(target_raw);
const line_no = content.slice(0, m.index).split("\n").length;
const embedded = is_embedded(m.index);
const record = { title, target, line: line_no };
if (embedded) record.embedded = true;
result.push(record);
}
return result.sort(
(a, b) => a.line - b.line || a.target.localeCompare(b.target)
);
}
__name(get_markdown_links, "get_markdown_links");

function get_bases_cache_links({ source, links = [], cache } = {}) {
if (!source || !Array.isArray(links) || !links.length) return [];
const cache_items = cache || source?.env?.bases_caches?.items;
if (!cache_items) return [];
const source_key = source?.key || source?.path;
if (!source_key) return [];
return links.flatMap((link) => {
if (!link?.embedded) return [];
if (typeof link.target !== "string" || !link.target.includes(".base")) return [];
const cache_key = `${source_key}#${link.target}`;
const markdown_table = cache_items?.[cache_key]?.markdown_table;
if (!markdown_table) return [];
const table_links = get_markdown_links(markdown_table);
if (!table_links.length) return [];
return table_links.map((table_link) => ({
...table_link,
line: link.line,
bases_row: table_link.line - 2
}));
});
}
__name(get_bases_cache_links, "get_bases_cache_links");

function parse_value(raw_value) {
const trimmed = raw_value.trim();
if (trimmed.startsWith('"') && trimmed.endsWith('"') || trimmed.startsWith("'") && trimmed.endsWith("'")) {
return trimmed.slice(1, -1);
}
const lower = trimmed.toLowerCase();
if (lower === "true") return true;
if (lower === "false") return false;
if (!isNaN(trimmed) && trimmed !== "") {
return Number(trimmed);
}
return trimmed;
}
__name(parse_value, "parse_value");
function parse_yaml_block(yaml_block) {
const lines = yaml_block.split(/\r?\n/);
const data = {};
let i = 0;
while (i < lines.length) {
const line = lines[i];
i++;
if (!line.trim() || line.trim().startsWith("#")) {
continue;
}
const match = line.match(/^([^:]+)\s*:\s*(.*)$/);
if (!match) {
continue;
}
const key = match[1].trim();
let value = match[2].trim();
if (value === ">" || value === "|") {
const multiline_lines = [];
while (i < lines.length) {
const next_line = lines[i];
if (!/^\s+/.test(next_line) || next_line.trim().startsWith("#")) {
break;
}
multiline_lines.push(next_line.replace(/^\s+/, ""));
i++;
}
const joined = multiline_lines.join("\n");
data[key] = parse_value(joined);
} else if (value === "") {
const arr = [];
let array_consumed = false;
while (i < lines.length) {
const next_line = lines[i];
if (!next_line.trim().startsWith("- ")) {
break;
}
const item_value = next_line.trim().slice(2);
arr.push(parse_value(item_value));
i++;
array_consumed = true;
}
if (array_consumed) {
data[key] = arr;
} else {
data[key] = "";
}
} else {
data[key] = parse_value(value);
}
}
return data;
}
__name(parse_yaml_block, "parse_yaml_block");
function parse_frontmatter(content) {
if (!content.startsWith("---")) {
return { frontmatter: {}, body: content };
}
const lines = content.split(/\r?\n/);
let end_index = -1;
for (let i = 1; i < lines.length; i++) {
if (lines[i].trim() === "---") {
end_index = i;
break;
}
}
if (end_index === -1) {
return { frontmatter: {}, body: content };
}
const frontmatter_lines = lines.slice(1, end_index);
const frontmatter_block = frontmatter_lines.join("\n");
const frontmatter = parse_yaml_block(frontmatter_block);
const body_lines = lines.slice(end_index + 1);
const body = body_lines.join("\n");
return { frontmatter, body };
}
__name(parse_frontmatter, "parse_frontmatter");

var get_markdown_tags = /* @__PURE__ */ __name((content = "") => {
const tag_re = /(?<!\w)#([\w/-]+)/g;
const tags = /* @__PURE__ */ new Set();
let match;
while ((match = tag_re.exec(content)) !== null) {
tags.add(`#${match[1]}`);
}
return [...tags];
}, "get_markdown_tags");

var MarkdownSourceContentAdapter = class extends FileSourceContentAdapter {
static {
__name(this, "MarkdownSourceContentAdapter");
}
static extensions = ["md", "txt"];
/**
* Import the source file content, parse blocks and links, and update `item.data`.
* @async
* @returns {Promise<void>}
*/
async import() {
if (!this.can_import) return;
if (!this.outdated) {
this.item.blocks.forEach((block) => {
if (!block.vec) block.queue_embed();
});
return;
}
const content = await this.read();
if (!content) {
return;
}
if (!this.item.vec) {
this.item.data.last_import = null;
}
if (this.data.last_import?.hash === this.data.last_read?.hash) {
if (this.data.blocks) return;
}
this.data.blocks = null;
await this.parse_content(content);
await this.item.parse_content(content);
const { mtime, size } = this.item.file.stat;
this.data.last_import = {
mtime,
size,
at: Date.now(),
hash: this.data.last_read.hash
};
this.item.loaded_at = Date.now();
this.item.queue_save();
if (this.item.should_embed) this.item.queue_embed();
}
async parse_content(content) {
const outlinks = await this.get_links(content);
this.data.outlinks = outlinks;
const metadata = await this.get_metadata(content);
this.data.metadata = metadata;
}
async get_links(content = null) {
if (!content) content = await this.read();
if (!content) return;
const markdown_links = get_markdown_links(content);
const bases_links = get_bases_cache_links({
source: this.item,
links: markdown_links
});
return [
...markdown_links,
...bases_links
];
}
async get_metadata(content = null) {
if (!content) content = await this.read();
if (!content) return;
const { frontmatter, body } = parse_frontmatter(content);
const tag_set = /* @__PURE__ */ new Set();
let fm_tags = frontmatter.tags;
if (typeof fm_tags === "string") {
fm_tags = fm_tags.replace(/[\[\]]/g, "").split(",").map((t) => t.trim()).filter(Boolean);
}
if (Array.isArray(fm_tags)) {
fm_tags.forEach((tag) => tag_set.add(tag.startsWith("#") ? tag : `#${tag}`));
}
get_markdown_tags(body).forEach((tag) => tag_set.add(tag));
if (tag_set.size) frontmatter.tags = [...tag_set];
return frontmatter;
}
get can_import() {
if (!this.item.file) {
console.warn(`MarkdownSourceContentAdapter: Skipping missing-file: ${this.file_path}`);
return false;
}
if (this.item.size > (this.settings?.max_import_size || 3e5)) {
console.warn(`MarkdownSourceContentAdapter: Skipping large file: ${this.file_path}`);
return false;
}
return true;
}
/**
* @deprecated use outdated instead
*/
get should_import() {
return this.outdated;
}
get outdated() {
try {
if (!this.data.last_import) {
if (this.data.mtime && this.data.size && this.data.hash) {
this.data.last_import = {
mtime: this.data.mtime,
size: this.data.size,
at: Date.now(),
hash: this.data.hash
};
delete this.data.mtime;
delete this.data.size;
delete this.data.hash;
} else {
return true;
}
}
if (this.data.last_read.at > this.data.last_import.at) {
if (this.data.last_import?.hash !== this.data.last_read?.hash) return true;
}
if (this.data.last_import.mtime < this.item.mtime) {
if (!this.data.last_import.size) return true;
const size_diff = Math.abs(this.data.last_import.size - this.item.size);
const size_diff_ratio = size_diff / (this.data.last_import.size || 1);
if (size_diff_ratio > 0.01) return true;
}
return false;
} catch (e) {
console.warn(`MarkdownSourceContentAdapter: error getting should_import for ${this.file_path}: ${e}`);
return true;
}
}
};

var import_obsidian2 = require("obsidian");
function merge_tags(fm_tags, cache_tags = []) {
const tag_set = /* @__PURE__ */ new Set();
if (typeof fm_tags === "string") {
fm_tags = fm_tags.replace(/[\[\]]/g, "").split(",").map((t) => t.trim()).filter(Boolean);
}
if (Array.isArray(fm_tags)) {
fm_tags.forEach((tag) => tag_set.add(tag.startsWith("#") ? tag : `#${tag}`));
}
cache_tags.forEach(({ tag }) => tag_set.add(tag));
return [...tag_set];
}
__name(merge_tags, "merge_tags");
var ObsidianMarkdownSourceContentAdapter = class extends MarkdownSourceContentAdapter {
static {
__name(this, "ObsidianMarkdownSourceContentAdapter");
}
/**
* Returns metadata using Obsidian's metadataCache, merging frontmatter and tags.
* @async
* @returns {Promise<Object|undefined>}
*/
async get_metadata() {
const app = this.item.env.main.app;
const cache = app.metadataCache.getFileCache(this.item.file) || {};
const tags = merge_tags(cache.frontmatter?.tags, cache.tags);
if (cache.frontmatter) {
if (tags.length) cache.frontmatter.tags = tags;
return cache.frontmatter;
}
return tags.length ? { tags } : void 0;
}
/**
* Reads the file content. If opts.render_output is true, attempts to use
* Obsidian's MarkdownRenderer to render the file to HTML, then convert it
* back to markdown via htmlToMarkdown.
* @async
* @param {Object} [opts={}] - Options for reading.
* @param {boolean} [opts.render_output=false] - If true, render MD -> HTML -> MD.
* @returns {Promise<string>} The file content (possibly rendered).
*/
async read(opts = {}) {
const content = await super.read(opts);
if (!opts.render_output) {
return content;
}
const app = this.item.env.main.app;
if (!app || !import_obsidian2.MarkdownRenderer || !import_obsidian2.htmlToMarkdown) {
console.warn("Obsidian environment not found; cannot render markdown.");
return content;
}
const container = document.createElement("div");
await import_obsidian2.MarkdownRenderer.render(app, content, container, this.item.path, new import_obsidian2.Component());
let last_html = container.innerHTML;
const max_wait = 1e4;
let wait_time = 0;
let conseq_same = 0;
let changed = true;
while (conseq_same < 7) {
await new Promise((resolve) => setTimeout(resolve, 100));
changed = last_html !== container.innerHTML;
last_html = container.innerHTML;
if (!changed) conseq_same++;
else conseq_same = 0;
wait_time += 100;
if (wait_time > max_wait) {
console.warn("ObsidianMarkdownSourceContentAdapter: Timeout waiting for markdown to render.");
break;
}
}
const newMd = (0, import_obsidian2.htmlToMarkdown)(container);
return newMd;
}
};

var BasesSourceContentAdapter = class extends FileSourceContentAdapter {
static {
__name(this, "BasesSourceContentAdapter");
}
static extensions = ["base"];
async import() {
}
};

var RenderedSourceContentAdapter = class extends FileSourceContentAdapter {
static {
__name(this, "RenderedSourceContentAdapter");
}
static extensions = ["rendered"];
async import() {
}
};

function parse_canvas_json({ content } = {}) {
if (!content) return null;
try {
return JSON.parse(content);
} catch (error) {
console.warn("CanvasSourceContentAdapter: invalid JSON content.", error);
return null;
}
}
__name(parse_canvas_json, "parse_canvas_json");
function build_link_record({ target, title } = {}) {
if (!target) return null;
return {
title: title || target,
target,
line: 1
};
}
__name(build_link_record, "build_link_record");
function get_canvas_node_links({ node } = {}) {
if (!node || typeof node !== "object") return [];
if (node.type === "text" && typeof node.text === "string") {
return get_markdown_links(node.text);
}
if (node.type === "file" && typeof node.file === "string") {
const subpath = typeof node.subpath === "string" ? node.subpath : "";
const target = `${node.file}${subpath}`;
const record = build_link_record({ target, title: node.file });
return record ? [record] : [];
}
if (node.type === "link" && typeof node.url === "string") {
const record = build_link_record({ target: node.url, title: node.url });
return record ? [record] : [];
}
return [];
}
__name(get_canvas_node_links, "get_canvas_node_links");
function get_canvas_links_from_nodes({ nodes = [] } = {}) {
if (!Array.isArray(nodes)) return [];
return nodes.reduce((links, node) => {
links.push(...get_canvas_node_links({ node }));
return links;
}, []);
}
__name(get_canvas_links_from_nodes, "get_canvas_links_from_nodes");
function get_canvas_links({ content } = {}) {
const canvas_data = parse_canvas_json({ content });
if (!canvas_data?.nodes) return [];
return get_canvas_links_from_nodes({ nodes: canvas_data.nodes });
}
__name(get_canvas_links, "get_canvas_links");
var CanvasSourceContentAdapter = class extends FileSourceContentAdapter {
static {
__name(this, "CanvasSourceContentAdapter");
}
static extensions = ["canvas"];
async import() {
if (!this.item.file) {
console.warn(`CanvasSourceContentAdapter: Skipping missing-file: ${this.file_path}`);
return;
}
const content = await this.read();
if (!content) return;
if (this.data.last_import?.hash === this.data.last_read?.hash && Array.isArray(this.data.outlinks)) {
return;
}
this.data.outlinks = get_canvas_links({ content });
const file_stat = this.item.file?.stat;
const size = file_stat?.size ?? content.length;
const mtime = file_stat?.mtime ?? 0;
this.data.last_import = {
mtime,
size,
at: Date.now(),
hash: this.data.last_read?.hash
};
this.item.loaded_at = Date.now();
this.item.queue_save();
}
};

var ExcalidrawSourceContentAdapter = class extends ObsidianMarkdownSourceContentAdapter {
static {
__name(this, "ExcalidrawSourceContentAdapter");
}
static extensions = ["excalidraw.md"];
is_media = true;
async read(opts = {}) {
const full_content = await super.read(opts);
const BEGIN_LINE_MATCHER = "# Text Elements";
const END_LINE_MATCHER = "# Drawing";
const text_elements_start = full_content.indexOf(BEGIN_LINE_MATCHER);
const drawing_lines_start = full_content.indexOf(END_LINE_MATCHER);
if (text_elements_start === -1 || drawing_lines_start === -1) {
console.warn("Excalidraw file does not contain expected sections. File: " + this.item.key);
this.item.data.last_read.size = 0;
return "";
}
const text_content = full_content.slice(text_elements_start + BEGIN_LINE_MATCHER.length, drawing_lines_start).trim();
const stripped_refs = text_content.split("\n").map((line) => {
if (line.trim() === "%%") return "";
if (line.trim() === "#") return "";
return line.replace(/\^[a-z0-9]+$/i, "").trim();
}).filter(Boolean).join("\n");
this.item.data.last_read.size = stripped_refs.length;
return stripped_refs;
}
get size() {
if (this.item.data?.last_read?.size) {
return this.item.data.last_read.size;
}
return this.file?.stat?.size || 0;
}
};

function get_block_display_name(key, show_full_path) {
const [source_key, ...path_parts] = key.split("#").filter(Boolean);
const source_name = get_item_display_name(source_key, show_full_path);
if (show_full_path) return [source_name, ...path_parts].join(" > ");
const last_heading = path_parts.findLast((part) => part && part[0] !== "{");
return [source_name, last_heading].join(" > ");
}
__name(get_block_display_name, "get_block_display_name");

var SmartBlock = class extends SmartEntity {
static {
__name(this, "SmartBlock");
}
/**
* Provides default values for a SmartBlock instance.
* @static
* @readonly
* @returns {Object} The default values.
*/
static get defaults() {
return {
data: {
text: null,
length: 0,
last_read: {
hash: null,
at: 0
}
},
_embed_input: ""
};
}
get block_adapter() {
if (!this._block_adapter) {
this._block_adapter = new this.collection.opts.block_adapters.md(this);
}
return this._block_adapter;
}
/**
* Initializes the SmartBlock instance by queuing an embed if embedding is enabled.
* @returns {void}
*/
init() {
if (this.settings.embed_blocks) super.init();
}
/**
* Queues the entity for embedding.
* @returns {void}
*/
queue_embed() {
this._queue_embed = this.should_embed;
this.source?.queue_embed();
}
/**
* Queues the block for import via the source.
* @returns {void}
*/
queue_import() {
this.source?.queue_import();
}
/**
* Prepares the embed input for the SmartBlock by reading content and generating a hash.
* @async
* @returns {Promise<string|false>} The embed input string or `false` if already embedded.
*/
async get_embed_input(content = null) {
if (typeof this._embed_input !== "string" || !this._embed_input.length) {
if (!content) content = await this.read();
this._embed_input = this.breadcrumbs + "\n" + content;
}
return this._embed_input;
}
/**
* @method read
* @description Reads the block content by delegating to the block adapter.
* @async
* @returns {Promise<string>} The block content.
*/
async read() {
try {
return await this.block_adapter.read();
} catch (e) {
if (e.message.includes("BLOCK NOT FOUND")) {
return 'BLOCK NOT FOUND (run "Prune" to remove)';
} else {
throw e;
}
}
}
/**
* @method append
* @description Appends content to this block by delegating to the block adapter.
* @async
* @param {string} content
* @returns {Promise<void>}
*/
async append(content) {
await this.block_adapter.append(content);
this.queue_save();
}
/**
* @method update
* @description Updates the block content by delegating to the block adapter.
* @async
* @param {string} new_block_content
* @param {Object} [opts={}]
* @returns {Promise<void>}
*/
async update(new_block_content, opts = {}) {
await this.block_adapter.update(new_block_content, opts);
this.queue_save();
}
/**
* @method remove
* @description Removes the block by delegating to the block adapter.
* @async
* @returns {Promise<void>}
*/
async remove() {
await this.block_adapter.remove();
this.queue_save();
}
/**
* @method move_to
* @description Moves the block to another location by delegating to the block adapter.
* @async
* @param {string} to_key
* @returns {Promise<void>}
*/
async move_to(to_key) {
await this.block_adapter.move_to(to_key);
this.queue_save();
}
get_display_name(params = {}) {
return this.block_adapter?.get_display_name(params);
}
/**
* Retrieves the breadcrumbs representing the block's path within the source.
* @readonly
* @returns {string} The breadcrumbs string.
*/
get breadcrumbs() {
return this.key.split("/").join(" > ").split("#").slice(0, -1).join(" > ").replace(".md", "");
}
/**
* Determines if the block is excluded from embedding based on headings.
* @readonly
* @returns {boolean} `true` if excluded, `false` otherwise.
*/
get excluded() {
const block_headings = this.path.split("#").slice(1);
if (this.source_collection.excluded_headings.some((heading) => block_headings.includes(heading))) return true;
return this.source?.excluded;
}
/**
* Retrieves the file path of the SmartSource associated with the block.
* @readonly
* @returns {string} The file path.
*/
get file_path() {
return this.source?.file_path;
}
/**
* Retrieves the file type of the SmartSource associated with the block.
* @readonly
* @returns {string} The file type.
*/
get file_type() {
return this.source.file_type;
}
/**
* Retrieves the folder path of the block.
* @readonly
* @returns {string} The folder path.
*/
get folder() {
return this.path.split("/").slice(0, -1).join("/");
}
/**
* Retrieves the embed link for the block.
* @readonly
* @returns {string} The embed link.
*/
get embed_link() {
return `![[${this.link}]]`;
}
/**
* Determines if the block has valid line range information.
* @readonly
* @returns {boolean} `true` if the block has both start and end lines, `false` otherwise.
*/
get has_lines() {
return this.lines && this.lines.length === 2;
}
/**
* Determines if the entity is a block based on its key.
* @readonly
* @returns {boolean} `true` if it's a block, `false` otherwise.
*/
get is_block() {
return this.key.includes("#");
}
/**
* Determines if the block is gone (i.e., the source file or block data no longer exists).
* @readonly
* @returns {boolean} `true` if gone, `false` otherwise.
*/
get is_gone() {
if (!this.source?.file) return true;
if (!this.source?.data?.blocks?.[this.sub_key]) return true;
return false;
}
get last_read() {
return this.data.last_read;
}
/**
* Retrieves the sub-key of the block.
* @readonly
* @returns {string} The sub-key.
*/
get sub_key() {
return "#" + this.key.split("#").slice(1).join("#");
}
/**
* Retrieves the lines range of the block.
* @readonly
* @returns {Array<number>|undefined} An array containing the start and end lines or `undefined` if not set.
*/
get lines() {
return this.data.lines;
}
/**
* Retrieves the starting line number of the block.
* @readonly
* @returns {number|undefined} The starting line number or `undefined` if not set.
*/
get line_start() {
return this.lines?.[0];
}
/**
* Retrieves the ending line number of the block.
* @readonly
* @returns {number|undefined} The ending line number or `undefined` if not set.
*/
get line_end() {
return this.lines?.[1];
}
/**
* Retrieves the link associated with the block, handling page numbers if present.
* @readonly
* @deprecated was specific to PDFs and removed this sort of PDF handling
* @returns {string} The block link.
*/
get link() {
if (/^.*page\s*(\d+).*$/i.test(this.sub_key)) {
const number = this.sub_key.match(/^.*page\s*(\d+).*$/i)[1];
return `${this.source.path}#page=${number}`;
} else {
return this.source?.path || "MISSING SOURCE";
}
}
get next_block() {
if (!this.data.lines) return null;
const next_line = this.data.lines[1] + 1;
return this.source.blocks?.find((block) => next_line === block.data?.lines?.[0]);
}
/**
* Retrieves the paths of outlinks from the block.
* @readonly
* @returns {Array<string>} An array of outlink paths.
*/
get outlinks() {
return this.source.outlinks;
}
/**
* Retrieves the path of the SmartBlock.
* @readonly
* @returns {string} The path of the SmartBlock.
*/
get path() {
return this.key;
}
/**
* Determines if the block should be embedded based on its coverage and size.
* @readonly
* @returns {boolean} `true` if it should be embedded, `false` otherwise.
*/
get should_embed() {
try {
if (this.settings?.min_chars && this.size < this.settings.min_chars) return false;
const match_line_start = this.line_start + 1;
const match_line_end = this.line_end;
const { has_line_start, has_line_end } = Object.entries(this.source?.data?.blocks || {}).reduce((acc, [key, range]) => {
if (!key.startsWith(this.sub_key + "#")) return acc;
if (range[0] === match_line_start) acc.has_line_start = key;
if (range[1] === match_line_end) acc.has_line_end = key;
return acc;
}, { has_line_start: null, has_line_end: null });
if (has_line_start && has_line_end) {
const start_block = this.collection.get(this.source_key + has_line_start);
if (start_block?.should_embed) {
const end_block = this.collection.get(this.source_key + has_line_end);
if (end_block?.should_embed) return false;
}
}
return true;
} catch (e) {
console.error(e, e.stack);
console.error(`Error getting should_embed for ${this.key}: ` + JSON.stringify(e || {}, null, 2));
}
}
/**
* Retrieves the size of the SmartBlock.
* @readonly
* @returns {number} The size of the SmartBlock.
*/
get size() {
return this.data.size;
}
/**
* Retrieves the SmartSource associated with the block.
* @readonly
* @returns {import("smart-sources").SmartSource} The associated SmartSource instance.
*/
get source() {
return this.source_collection.get(this.source_key);
}
/**
* Retrieves the SmartSources collection instance.
* @readonly
* @returns {import("smart-sources").SmartSources} The SmartSources collection.
*/
get source_collection() {
return this.env.smart_sources;
}
get source_key() {
return this.key.split("#")[0];
}
get sub_blocks() {
return this.source?.blocks?.filter((block) => block.key.startsWith(this.key + "#") && block.line_start > this.line_start && block.line_end <= this.line_end) || [];
}
get excluded_lines() {
return this.source.excluded_lines;
}
get file() {
return this.source.file;
}
get is_media() {
return this.source.is_media;
}
get mtime() {
return this.source.mtime;
}
/**
* Retrieves the display name of the block.
* @readonly
* @returns {string} The display name.
*/
get name() {
return get_block_display_name(
this.key,
this.env.settings.smart_view_filter?.show_full_path
);
}
/**
* @deprecated Use `source` instead. Removing after 2025-09-01.
* @readonly
* @returns {SmartSource} The associated SmartSource instance.
*/
get note() {
return this.source;
}
/**
* @deprecated Use `source.key` instead. Removing after 2025-09-01.
* @readonly
* @returns {string} The source key.
*/
get note_key() {
return this.key.split("#")[0];
}
};
var smart_block_default = {
class: SmartBlock,
actions: {
find_connections
}
};

var SmartBlocks = class extends SmartEntities {
static {
__name(this, "SmartBlocks");
}
/**
* Initializes the SmartBlocks instance. Currently muted as processing is handled by SmartSources.
* @returns {void}
*/
init() {
}
get fs() {
return this.env.smart_sources.fs;
}
/**
* Retrieves the embedding model associated with the SmartSources collection.
* @readonly
* @returns {Object|undefined} The embedding model instance or `undefined` if not set.
*/
get embed_model() {
return this.source_collection?.embed_model;
}
/**
* Retrieves the embedding model key from the SmartSources collection.
* @readonly
* @returns {string|undefined} The embedding model key or `undefined` if not set.
*/
get embed_model_key() {
return this.source_collection?.embed_model_key;
}
/**
* Calculates the expected number of blocks based on the SmartSources collection.
* @readonly
* @returns {number} The expected count of blocks.
*/
get expected_blocks_ct() {
return Object.values(this.source_collection.items).reduce((acc, item) => acc += Object.keys(item.data.blocks || {}).length, 0);
}
/**
* Retrieves the notices system from the environment.
* @readonly
* @returns {Object} The notices object.
*/
get notices() {
return this.env.smart_connections_plugin?.notices || this.env.main?.notices;
}
/**
* Retrieves the settings configuration for SmartBlocks.
* @readonly
* @returns {Object} The settings configuration object.
*/
get settings_config() {
return this.process_settings_config({
"embed_blocks": {
name: "Embed blocks",
type: "toggle",
description: "Blocks represent parts/sections of notes. Get more granular results.",
default: true
},
...super.settings_config
});
}
render_settings(container, opts = {}) {
return this.render_collection_settings(container, opts);
}
get data_dir() {
return "multi";
}
/**
* Retrieves the SmartSources collection instance.
* @readonly
* @returns {SmartSources} The SmartSources collection.
*/
get source_collection() {
return this.env.smart_sources;
}
/**
* Processes the embed queue. Currently handled by SmartSources, so this method is muted.
* @async
* @returns {Promise<void>}
*/
async process_embed_queue() {
}
/**
* Processes the load queue. Currently muted as processing is handled by SmartSources.
* @async
* @returns {Promise<void>}
*/
async process_load_queue() {
}
/**
* @async
* @abstract
* @throws {Error} Throws an error indicating the method is not implemented.
* @returns {Promise<void>}
*/
async prune() {
throw "Not implemented: prune";
}
/**
* @throws {Error} Throws an error indicating the method is not implemented.
* @abstract
* @returns {void}
*/
build_links_map() {
throw "Not implemented: build_links_map";
}
/**
* @async
* @abstract
* @throws {Error} Throws an error indicating the method is not implemented.
* @returns {Promise<void>}
*/
async refresh() {
throw "Not implemented: refresh";
}
/**
* @async
* @abstract
* @throws {Error} Throws an error indicating the method is not implemented.
* @returns {Promise<void>}
*/
async search() {
throw "Not implemented: search";
}
/**
* @async
* @abstract
* @throws {Error} Throws an error indicating the method is not implemented.
* @returns {Promise<void>}
*/
async run_refresh() {
throw "Not implemented: run_refresh";
}
/**
* @async
* @abstract
* @throws {Error} Throws an error indicating the method is not implemented.
* @returns {Promise<void>}
*/
async run_force_refresh() {
throw "Not implemented: run_force_refresh";
}
async cleanup_blocks() {
const expired_blocks = Object.values(this.items).filter((i) => i.is_gone);
console.log(`Removing ${expired_blocks.length} expired blocks`);
expired_blocks.forEach((i) => i.delete());
await this.process_save_queue();
expired_blocks.forEach((i) => {
delete this.items[i.key];
});
this.emit_event("blocks:cleaned", { expired_blocks_ct: expired_blocks.length });
}
};

var AjsonMultiFileBlocksDataAdapter = class extends AjsonMultiFileCollectionDataAdapter {
static {
__name(this, "AjsonMultiFileBlocksDataAdapter");
}
ItemDataAdapter = AjsonMultiFileBlockDataAdapter;
/**
* Transforms the item key into a safe filename.
* Replaces spaces, slashes, and dots with underscores.
* @returns {string} safe file name
*/
get_data_file_name(key) {
return key.split("#")[0].replace(/[\s\/\.]/g, "_").replace(".md", "");
}
/**
* Process any queued save operations.
* @async
* @returns {Promise<void>}
*/
async process_save_queue() {
this.collection.emit_event("collection:save_started");
this.collection.show_process_notice("saving_collection");
const save_queue = Object.values(this.collection.items).filter((item) => item._queue_save);
console.log(`Saving ${this.collection.collection_key}: ${save_queue.length} items`);
const time_start = Date.now();
const save_files = Object.entries(save_queue.reduce((acc, item) => {
const file_name = this.get_item_data_path(item.key);
acc[file_name] = acc[file_name] || [];
acc[file_name].push(item);
return acc;
}, {}));
for (let i = 0; i < save_files.length; i++) {
const [file_name, items] = save_files[i];
await this.fs.append(
file_name,
items.map((item) => this.get_item_ajson(item)).join("\n") + "\n"
);
items.forEach((item) => item._queue_save = false);
}
console.log(`Saved ${this.collection.collection_key} in ${Date.now() - time_start}ms`);
this.collection.clear_process_notice("saving_collection");
this.collection.emit_event("collection:save_completed");
}
process_load_queue() {
console.log(`Skipping loading ${this.collection.collection_key}...`);
}
};
var AjsonMultiFileBlockDataAdapter = class extends AjsonMultiFileItemDataAdapter {
static {
__name(this, "AjsonMultiFileBlockDataAdapter");
}
};

var BlockContentAdapter = class {
static {
__name(this, "BlockContentAdapter");
}
/**
* @constructor
* @param {import('smart-blocks').SmartBlock} item - The SmartBlock instance this adapter operates on.
* The `item` should at least provide `data` and references to its parent source.
*/
constructor(item) {
this.item = item;
}
/**
* @async
* @method read
* @abstract
* @returns {Promise<string>} The content of the block.
* @throws {Error} If not implemented by subclass.
*/
async read() {
throw new Error("Not implemented");
}
/**
* @async
* @method append
* @abstract
* @param {string} content Content to append to the block.
* @returns {Promise<void>}
* @throws {Error} If not implemented by subclass.
*/
async append(content) {
throw new Error("Not implemented");
}
/**
* @async
* @method update
* @abstract
* @param {string} new_content The new content for the block.
* @param {Object} [opts={}] Additional update options.
* @returns {Promise<void>}
* @throws {Error} If not implemented by subclass.
*/
async update(new_content, opts = {}) {
throw new Error("Not implemented");
}
/**
* @async
* @method remove
* @abstract
* @returns {Promise<void>}
* @throws {Error} If not implemented by subclass.
*/
async remove() {
throw new Error("Not implemented");
}
/**
* @async
* @method move_to
* @abstract
* @param {string} to_key The destination key (source or block reference).
* @returns {Promise<void>}
* @throws {Error} If not implemented by subclass.
*/
async move_to(to_key) {
throw new Error("Not implemented");
}
/**
* @method get_display_name
* @abstract
* @param {Object} params Parameters for display name generation.
* @returns {string} The display name of the block.
* @throws {Error} If not implemented by subclass.
*/
get_display_name(params) {
throw new Error("Not implemented");
}
/**
* @name data
* @type {Object}
* @readonly
* @description Access the block’s data object. Useful for updating metadata like line references or hashes.
*/
get data() {
return this.item.data;
}
/**
* @async
* @method update_last_read
* @param {string} content The current content of the block.
* @returns {Promise<void>}
* @description Update the block’s `last_read` hash and timestamp based on the given content.
*/
async update_last_read(content) {
this.data.last_read = {
hash: this.create_hash(content),
at: Date.now()
};
}
/**
* @method create_hash
* @param {string} content The content to hash.
* @returns {Promise<string>} The computed hash of the content.
* @description Hash the block content to detect changes and prevent unnecessary re-embeddings.
*/
create_hash(content) {
return murmur_hash_32_alphanumeric(content);
}
};

function get_line_range2(content, start_line, end_line) {
const lines = content.split("\n");
return lines.slice(start_line - 1, end_line).join("\n");
}
__name(get_line_range2, "get_line_range");

var MarkdownBlockContentAdapter = class extends BlockContentAdapter {
static {
__name(this, "MarkdownBlockContentAdapter");
}
/**
* Read the content of the block.
* @async
* @returns {Promise<string>} The block content as a string.
* @throws {Error} If the block cannot be found.
*/
async read() {
const source_content = await this.item.source?.read();
if (!source_content) {
console.warn(`BLOCK NOT FOUND: ${this.item.key} has no source content.`);
return "";
}
const content = this._extract_block(source_content);
this.update_last_read(content);
return content;
}
/**
* Append content to the existing block.
* This method inserts additional lines after the block's end, then re-parses the file to update line references.
* @async
* @param {string} content Content to append to the block.
* @returns {Promise<void>}
* @throws {Error} If the block cannot be found.
*/
async append(content) {
let full_content = await this.item.source.read();
const { line_start, line_end } = this.item;
if (!line_start || !line_end) {
throw new Error(`Cannot append to block ${this.item.key}: invalid line references.`);
}
const lines = full_content.split("\n");
lines.splice(line_end, 0, "", content);
const updated_content = lines.join("\n");
await this.item.source._update(updated_content);
await this._reparse_source();
}
/**
* Update the block with new content, replacing its current lines.
* @async
* @param {string} new_content New content for the block.
* @param {Object} [opts={}] Additional options.
* @returns {Promise<void>}
* @throws {Error} If the block cannot be found.
*/
async update(new_content, opts = {}) {
let full_content = await this.item.source.read();
const { line_start, line_end } = this.item;
if (!line_start || !line_end) {
throw new Error(`Cannot update block ${this.item.key}: invalid line references.`);
}
const lines = full_content.split("\n");
const updated_lines = [
...lines.slice(0, line_start - 1),
...new_content.split("\n"),
...lines.slice(line_end)
];
const updated_content = updated_lines.join("\n");
await this.item.source._update(updated_content);
await this._reparse_source();
}
/**
* Remove the block entirely from the source.
* @async
* @returns {Promise<void>}
* @throws {Error} If the block cannot be found.
*/
async remove() {
let full_content = await this.item.source.read();
const { line_start, line_end } = this.item;
if (!line_start || !line_end) {
throw new Error(`Cannot remove block ${this.item.key}: invalid line references.`);
}
const lines = full_content.split("\n");
const updated_lines = [
...lines.slice(0, line_start - 1),
...lines.slice(line_end)
];
const updated_content = updated_lines.join("\n");
await this.item.source._update(updated_content);
await this._reparse_source();
}
/**
* Move the block to a new location (another source or heading).
* This involves reading the block content, removing it from the current source, and appending it to the target.
* @async
* @param {string} to_key The destination path or entity reference.
* @returns {Promise<void>}
* @throws {Error} If the block or target is invalid.
*/
async move_to(to_key) {
const content = await this.read();
await this.remove();
const is_block_ref = to_key.includes("#");
let target_source_key = is_block_ref ? to_key.split("#")[0] : to_key;
const target_source = this.item.env.smart_sources.get(target_source_key);
if (!target_source) {
await this.item.env.smart_sources.create(target_source_key, content);
return;
}
if (is_block_ref) {
const target_block = this.item.env.smart_blocks.get(to_key);
if (target_block) {
await target_block.append(content);
} else {
await target_source.append(content);
}
} else {
await target_source.append(content);
}
}
/**
* Extract the block content using current line references from a full source content.
* @private
* @param {string} source_content Full source file content.
* @returns {string} Extracted block content.
* @throws {Error} If the block cannot be found.
*/
_extract_block(source_content) {
if (!source_content) {
console.warn(`BLOCK NOT FOUND: ${this.item.key} has no source content.`);
return "";
}
const { line_start, line_end } = this.item;
if (!line_start || !line_end) {
throw new Error(`BLOCK NOT FOUND: ${this.item.key} has invalid line references.`);
}
return get_line_range2(source_content, line_start, line_end);
}
/**
* Re-parse the source file after a CRUD operation to update line references for all blocks.
* @private
* @async
* @returns {Promise<void>}
*/
async _reparse_source() {
await this.item.source.import();
}
get_display_name(params = {}) {
if (!this.item?.key) return "";
const show_full_path = params.show_full_path ?? true;
if (show_full_path) {
return this.item.key.replace(/#/g, " > ").replace(/\//g, " > ");
}
const pcs = [];
const [source_key, ...block_parts] = this.item.key.split("#");
const filename = source_key.split("/").pop();
pcs.push(filename);
if (block_parts.length) {
const last = block_parts[block_parts.length - 1];
if (last.startsWith("{") && last.endsWith("}")) {
block_parts.pop();
pcs.push(block_parts.pop());
if (this.item.lines) pcs.push(`Lines: ${this.item.lines.join("-")}`);
} else {
pcs.push(block_parts.pop());
}
}
return pcs.filter(Boolean).join(" > ");
}
};

var SmartModel = class {
static {
__name(this, "SmartModel");
}
scope_name = "smart_model";
static defaults = {
};
/**
* Create a SmartModel instance.
* @param {Object} opts - Configuration options
* @param {Object} opts.adapters - Map of adapter names to adapter classes
* @param {Object} opts.settings - Model settings configuration
* @param {string} [opts.model_key] - Optional model identifier to override settings
* @throws {Error} If required options are missing
*/
constructor(opts = {}) {
this.opts = opts;
this.validate_opts(opts);
this.state = "unloaded";
this._adapter = null;
this.data = opts;
}
/**
* Initialize the model by loading the configured adapter.
* @async
* @returns {Promise<void>}
*/
async initialize() {
this.load_adapter(this.adapter_name);
await this.load();
}
/**
* Validate required options.
* @param {Object} opts - Configuration options
*/
validate_opts(opts) {
if (!opts.adapters) throw new Error("opts.adapters is required");
if (!opts.settings) throw new Error("opts.settings is required");
}
/**
* Get the current settings
* @returns {Object} Current settings
*/
get settings() {
if (!this.opts.settings) this.opts.settings = {
...this.constructor.defaults
};
return this.opts.settings;
}
/**
* Get the current adapter name
* @returns {string} Current adapter name
*/
get adapter_name() {
let adapter_key = this.opts.adapter || this.settings.adapter || Object.keys(this.adapters)[0];
if (!adapter_key || !this.adapters[adapter_key]) {
console.warn(`Platform "${adapter_key}" not supported`);
adapter_key = Object.keys(this.adapters)[0];
}
return adapter_key;
}
/**
* Get available models.
* @returns {Object} Map of model objects
*/
get models() {
return this.adapter.models;
}
/**
* Get default model key.
* @returns {string} Default model key
*/
get default_model_key() {
return this.adapter.constructor.defaults.default_model;
}
/**
* Get the current model key
* @returns {string} Current model key
*/
get model_key() {
return this.opts.model_key || this.settings.model_key || this.default_model_key;
}
/**
* Load the current adapter and transition to loaded state.
* @async
* @returns {Promise<void>}
*/
async load() {
this.set_state("loading");
try {
if (!this.adapter?.is_loaded) {
await this.invoke_adapter_method("load");
}
} catch (err) {
this.set_state("unloaded");
if (!this.reload_model_timeout) {
this.reload_model_timeout = setTimeout(async () => {
this.reload_model_timeout = null;
await this.load();
this.set_state("loaded");
this.env?.events?.emit("model:loaded", { model_key: this.model_key });
this.notices?.show("Loaded model: " + this.model_key);
}, 6e4);
}
throw new Error(`Failed to load model: ${err.message}`);
}
this.set_state("loaded");
}
/**
* Unload the current adapter and transition to unloaded state.
* @async
* @returns {Promise<void>}
*/
async unload() {
if (this.adapter?.is_loaded) {
this.set_state("unloading");
await this.invoke_adapter_method("unload");
this.set_state("unloaded");
}
}
/**
* Set the model's state.
* @param {('unloaded'|'loading'|'loaded'|'unloading')} new_state - The new state
* @throws {Error} If the state is invalid
*/
set_state(new_state) {
const valid_states = ["unloaded", "loading", "loaded", "unloading"];
if (!valid_states.includes(new_state)) {
throw new Error(`Invalid state: ${new_state}`);
}
this.state = new_state;
}
get is_loading() {
return this.state === "loading";
}
get is_loaded() {
return this.state === "loaded";
}
get is_unloading() {
return this.state === "unloading";
}
get is_unloaded() {
return this.state === "unloaded";
}
/**
* Get the map of available adapters
* @returns {Object} Map of adapter names to adapter classes
*/
get adapters() {
return this.opts.adapters || {};
}
/**
* Load a specific adapter by name.
* @async
* @param {string} adapter_name - Name of the adapter to load
* @throws {Error} If adapter not found or loading fails
* @returns {Promise<void>}
*/
async load_adapter(adapter_name) {
this.set_adapter(adapter_name);
if (!this._adapter.loaded) {
this.set_state("loading");
try {
await this.invoke_adapter_method("load");
this.set_state("loaded");
} catch (err) {
this.set_state("unloaded");
throw new Error(`Failed to load adapter: ${err.message}`);
}
}
}
/**
* Set an adapter instance by name without loading it.
* @param {string} adapter_name - Name of the adapter to set
* @throws {Error} If adapter not found
*/
set_adapter(adapter_name) {
const AdapterClass = this.adapters[adapter_name];
if (!AdapterClass) {
throw new Error(`Adapter "${adapter_name}" not found.`);
}
if (this._adapter?.constructor.name.toLowerCase() === adapter_name.toLowerCase()) {
return;
}
this._adapter = new AdapterClass(this);
}
/**
* Get the current active adapter instance
* @returns {Object} The active adapter instance
* @throws {Error} If adapter not found
*/
get adapter() {
const adapter_name = this.adapter_name;
if (!adapter_name) {
throw new Error(`Adapter not set for model.`);
}
if (!this._adapter) {
this.load_adapter(adapter_name);
}
return this._adapter;
}
/**
* Ensure the adapter is ready to execute a method.
* @param {string} method - Name of the method to check
* @throws {Error} If adapter not loaded or method not implemented
*/
ensure_adapter_ready(method) {
if (!this.adapter) {
throw new Error("No adapter loaded.");
}
if (typeof this.adapter[method] !== "function") {
throw new Error(`Adapter does not implement method: ${method}`);
}
}
/**
* Invoke a method on the current adapter.
* @async
* @param {string} method - Name of the method to call
* @param {...any} args - Arguments to pass to the method
* @returns {Promise<any>} Result from the adapter method
* @throws {Error} If adapter not ready or method fails
*/
async invoke_adapter_method(method, ...args) {
this.ensure_adapter_ready(method);
return await this.adapter[method](...args);
}
/**
* Get platforms as dropdown options.
* @returns {Array<Object>} Array of {value, name} option objects
*/
get_platforms_as_options() {
return Object.entries(this.adapters).map(([key, AdapterClass]) => ({ value: key, name: AdapterClass.defaults.description || key }));
}
/**
* Get the settings configuration schema
* @returns {Object} Settings configuration object
*/
get settings_config() {
return this.process_settings_config({
adapter: {
name: "Model Platform",
type: "dropdown",
description: "Select a model platform to use with Smart Model.",
options_callback: "get_platforms_as_options",
is_scope: true,
callback: "adapter_changed",
default: "default"
}
});
}
/**
* Process settings configuration with conditionals and prefixes.
* @param {Object} _settings_config - Raw settings configuration
* @param {string} [prefix] - Optional prefix for setting keys
* @returns {Object} Processed settings configuration
*/
process_settings_config(_settings_config, prefix = null) {
return Object.entries(_settings_config).reduce((acc, [key, val]) => {
const new_key = (prefix ? prefix + "." : "") + this.process_setting_key(key);
acc[new_key] = val;
return acc;
}, {});
}
/**
* Process an individual setting key.
* Example: replace placeholders with actual adapter names.
* @param {string} key - The setting key with placeholders.
* @returns {string} Processed setting key.
*/
process_setting_key(key) {
return key.replace(/\[ADAPTER\]/g, this.adapter_name);
}
re_render_settings() {
if (typeof this.opts.re_render_settings === "function") this.opts.re_render_settings();
else console.warn("re_render_settings is not a function (must be passed in model opts)");
}
/**
* Reload model.
*/
reload_model() {
if (typeof this.opts.reload_model === "function") this.opts.reload_model();
else console.warn("reload_model is not a function (must be passed in model opts)");
}
adapter_changed() {
this.reload_model();
this.re_render_settings();
}
model_changed() {
this.reload_model();
this.re_render_settings();
}
};

var SmartEmbedModel = class extends SmartModel {
static {
__name(this, "SmartEmbedModel");
}
scope_name = "smart_embed_model";
static defaults = {
adapter: "transformers"
};
/**
* Create a SmartEmbedModel instance
* @param {Object} opts - Configuration options
* @param {Object} [opts.adapters] - Map of available adapter implementations
* @param {number} [opts.batch_size] - Default batch size for processing
* @param {Object} [opts.settings] - User settings
* @param {string} [opts.settings.api_key] - API key for remote models
* @param {number} [opts.settings.min_chars] - Minimum text length to embed
*/
constructor(opts = {}) {
super(opts);
}
/**
* Count tokens in an input string
* @param {string} input - Text to tokenize
* @returns {Promise<Object>} Token count result
* @property {number} tokens - Number of tokens in input
*
* @example
* ```javascript
* const result = await model.count_tokens("Hello world");
* console.log(result.tokens); // 2
* ```
*/
async count_tokens(input) {
return await this.invoke_adapter_method("count_tokens", input);
}
/**
* Generate embeddings for a single input
* @param {string|Object} input - Text or object with embed_input property
* @returns {Promise<Object>} Embedding result
* @property {number[]} vec - Embedding vector
* @property {number} tokens - Token count
*
* @example
* ```javascript
* const result = await model.embed("Hello world");
* console.log(result.vec); // [0.1, 0.2, ...]
* ```
*/
async embed(input) {
if (typeof input === "string") input = { embed_input: input };
return (await this.embed_batch([input]))[0];
}
/**
* Generate embeddings for multiple inputs in batch
* @param {Array<string|Object>} inputs - Array of texts or objects with embed_input
* @returns {Promise<Array<Object>>} Array of embedding results
* @property {number[]} vec - Embedding vector for each input
* @property {number} tokens - Token count for each input
*
* @example
* ```javascript
* const results = await model.embed_batch([
*   { embed_input: "First text" },
*   { embed_input: "Second text" }
* ]);
* ```
*/
async embed_batch(inputs) {
return await this.invoke_adapter_method("embed_batch", inputs);
}
/**
* Get the current batch size based on GPU settings
* @returns {number} Current batch size for processing
*/
get batch_size() {
return this.adapter.batch_size || 1;
}
/**
* Get settings configuration schema
* @returns {Object} Settings configuration object
*/
get settings_config() {
const _settings_config = {
adapter: {
name: "Embedding model platform",
type: "dropdown",
description: "Select an embedding model platform. The default 'transformers' utilizes built-in local models.",
options_callback: "get_platforms_as_options",
callback: "adapter_changed",
default: this.constructor.defaults.adapter
},
...this.adapter.settings_config || {}
};
return this.process_settings_config(_settings_config);
}
process_setting_key(key) {
return key.replace(/\[ADAPTER\]/g, this.adapter_name);
}
/**
* Get available embedding model options
* @returns {Array<Object>} Array of model options with value and name
*/
get_embedding_model_options() {
return Object.entries(this.models).map(([key, model]) => ({ value: key, name: key }));
}
};

var SmartModelAdapter = class {
static {
__name(this, "SmartModelAdapter");
}
/**
* Create a SmartModelAdapter instance.
* @param {SmartModel} model - The parent SmartModel instance
*/
constructor(model) {
this.model = model;
this.state = "unloaded";
}
/**
* Load the adapter.
* @async
* @returns {Promise<void>}
*/
async load() {
this.set_state("loaded");
}
/**
* Unload the adapter.
* @returns {void}
*/
unload() {
this.set_state("unloaded");
}
/**
* Get all settings.
* @returns {Object} All settings
*/
get settings() {
return this.model.settings;
}
/**
* Get the current model key.
* @returns {string} Current model identifier
*/
get model_key() {
return this.model.model_key;
}
/**
* Get the models.
* @returns {Object} Map of model objects
*/
get models() {
const models = this.model.data.provider_models;
if (typeof models === "object" && Object.keys(models || {}).length > 0) return models;
else {
return {};
}
}
/**
* Get available models from the API.
* @abstract
* @param {boolean} [refresh=false] - Whether to refresh cached models
* @returns {Promise<Object>} Map of model objects
*/
async get_models(refresh = false) {
throw new Error("get_models not implemented");
}
/**
* Get available models as dropdown options synchronously.
* @returns {Array<Object>} Array of model options.
*/
get_models_as_options() {
const models = this.models;
if (!Object.keys(models || {}).length) {
this.get_models(true);
return [{ value: "", name: "No models currently available" }];
}
return Object.entries(models).map(([id, model]) => ({ value: id, name: model.name || id })).sort((a, b) => a.name.localeCompare(b.name));
}
/**
* Set the adapter's state.
* @deprecated should be handled in SmartModel (only handle once)
* @param {('unloaded'|'loading'|'loaded'|'unloading')} new_state - The new state
* @throws {Error} If the state is invalid
*/
set_state(new_state) {
const valid_states = ["unloaded", "loading", "loaded", "unloading"];
if (!valid_states.includes(new_state)) {
throw new Error(`Invalid state: ${new_state}`);
}
this.state = new_state;
}
get is_loading() {
return this.state === "loading";
}
get is_loaded() {
return this.state === "loaded";
}
get is_unloading() {
return this.state === "unloading";
}
get is_unloaded() {
return this.state === "unloaded";
}
};

var SmartEmbedAdapter = class extends SmartModelAdapter {
static {
__name(this, "SmartEmbedAdapter");
}
/**
* @override in sub-class with adapter-specific default configurations
* @property {string} id - The adapter identifier
* @property {string} description - Human-readable description
* @property {string} type - Adapter type ("API")
* @property {string} endpoint - API endpoint
* @property {string} adapter - Adapter identifier
* @property {string} default_model - Default model to use
*/
static defaults = {};
/**
* Count tokens in input text
* @abstract
* @param {string} input - Text to tokenize
* @returns {Promise<Object>} Token count result
* @property {number} tokens - Number of tokens in input
* @throws {Error} If not implemented by subclass
*/
async count_tokens(input) {
throw new Error("count_tokens method not implemented");
}
/**
* Generate embeddings for single input
* @abstract
* @param {string|Object} input - Text to embed
* @returns {Promise<Object>} Embedding result
* @property {number[]} vec - Embedding vector
* @property {number} tokens - Number of tokens in input
* @throws {Error} If not implemented by subclass
*/
async embed(input) {
if (typeof input === "string") input = { embed_input: input };
return (await this.embed_batch([input]))[0];
}
/**
* Generate embeddings for multiple inputs
* @abstract
* @param {Array<string|Object>} inputs - Texts to embed
* @returns {Promise<Array<Object>>} Array of embedding results
* @property {number[]} vec - Embedding vector for each input
* @property {number} tokens - Number of tokens in each input
* @throws {Error} If not implemented by subclass
*/
async embed_batch(inputs) {
throw new Error("embed_batch method not implemented");
}
get settings_config() {
return {
"[ADAPTER].model_key": {
name: "Embedding model",
type: "dropdown",
description: "Select an embedding model.",
options_callback: "adapter.get_models_as_options",
callback: "model_changed",
default: this.constructor.defaults.default_model
}
};
}
get dims() {
return this.model.data.dims;
}
get max_tokens() {
return this.model.data.max_tokens;
}
get batch_size() {
return this.model.data.batch_size || 1;
}
};

var SmartHttpRequest = class {
static {
__name(this, "SmartHttpRequest");
}
/**
* @param {object} opts - Options for the SmartHttpRequest class
* @param {SmartHttpRequestAdapter} opts.adapter - The adapter constructor to use for making HTTP requests
* @param {Obsidian.requestUrl} opts.obsidian_request_adapter - For use with Obsidian adapter
*/
constructor(opts = {}) {
this.opts = opts;
if (!opts.adapter) throw new Error("HttpRequestAdapter is required");
this.adapter = new opts.adapter(this);
}
/**
* Returns a well-formed response object
* @param {object} request_params - Parameters for the HTTP request
* @param {string} request_params.url - The URL to make the request to
* @param {string} [request_params.method='GET'] - The HTTP method to use
* @param {object} [request_params.headers] - Headers to include in the request
* @param {*} [request_params.body] - The body of the request (for POST, PUT, etc.)
* @returns {SmartHttpResponseAdapter} instance of the SmartHttpResponseAdapter class
* @example
* const response = await smart_http_request.request({
*   url: 'https://api.example.com/data',
*   method: 'GET',
*   headers: { 'Content-Type': 'application/json' }
* });
* console.log(await response.json());
*/
async request(request_params, throw_on_error = false) {
return await this.adapter.request(request_params, throw_on_error);
}
};

var SmartHttpRequestAdapter = class {
static {
__name(this, "SmartHttpRequestAdapter");
}
constructor(main) {
this.main = main;
}
/**
* Execute an HTTP request using adapter-specific transport.
* @abstract
* @param {Object} request_params - Parameters for the outbound request.
* @returns {Promise<SmartHttpResponseAdapter>} Adapter-specific response wrapper.
*/
async request(request_params) {
throw new Error("request not implemented");
}
};
var SmartHttpResponseAdapter = class {
static {
__name(this, "SmartHttpResponseAdapter");
}
constructor(response) {
this.response = response;
}
/**
* Retrieve response headers.
* @abstract
* @returns {Promise<Object>} Headers object for the response.
*/
async headers() {
throw new Error("headers not implemented");
}
/**
* Parse the response body as JSON.
* @abstract
* @returns {Promise<*>} Parsed JSON payload.
*/
async json() {
throw new Error("json not implemented");
}
/**
* Get the HTTP status code.
* @abstract
* @returns {Promise<number>} Response status code.
*/
async status() {
throw new Error("status not implemented");
}
/**
* Read the raw text body.
* @abstract
* @returns {Promise<string>} Response body as text.
*/
async text() {
throw new Error("text not implemented");
}
};

var SmartHttpObsidianRequestAdapter = class extends SmartHttpRequestAdapter {
static {
__name(this, "SmartHttpObsidianRequestAdapter");
}
async request(request_params, throw_on_error = false) {
let response;
try {
if (!this.main.opts.obsidian_request_url) {
throw new Error("obsidian_request_url is required in SmartHttp constructor opts");
}
response = await this.main.opts.obsidian_request_url({ ...request_params, throw: throw_on_error });
if (throw_on_error && response.status === 400) throw new Error("Obsidian request failed");
return new SmartHttpObsidianResponseAdapter(response);
} catch (error) {
console.error("Error in SmartHttpObsidianRequestAdapter.request():");
console.error(JSON.stringify(request_params, null, 2));
console.error(response);
console.error(error);
return null;
}
}
};
var SmartHttpObsidianResponseAdapter = class extends SmartHttpResponseAdapter {
static {
__name(this, "SmartHttpObsidianResponseAdapter");
}
async status() {
return this.response.status;
}
async json() {
return await this.response.json;
}
async text() {
return await this.response.text;
}
async headers() {
return this.response.headers;
}
};

var SmartHttpRequestFetchAdapter = class extends SmartHttpRequestAdapter {
static {
__name(this, "SmartHttpRequestFetchAdapter");
}
async request(request_params) {
const { url, ...opts } = request_params;
const resp = await fetch(url, opts);
return new SmartHttpResponseFetchAdapter(resp);
}
};
var SmartHttpResponseFetchAdapter = class extends SmartHttpResponseAdapter {
static {
__name(this, "SmartHttpResponseFetchAdapter");
}
async headers() {
return this.response.headers;
}
async json() {
if (!this._json) {
this._json = await this.response.json();
}
return this._json;
}
async status() {
return this.response.status;
}
async text() {
if (!this._text) {
this._text = await this.response.text();
}
return this._text;
}
};

var import_base64_js = __toESM(require_base64_js(), 1);
var __defProp2 = Object.defineProperty;
var __defNormalProp = /* @__PURE__ */ __name((obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value, "__defNormalProp");
var __publicField = /* @__PURE__ */ __name((obj, key, value) => {
__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
return value;
}, "__publicField");
function bytePairMerge(piece, ranks) {
let parts = Array.from(
{ length: piece.length },
(_, i) => ({ start: i, end: i + 1 })
);
while (parts.length > 1) {
let minRank = null;
for (let i = 0; i < parts.length - 1; i++) {
const slice = piece.slice(parts[i].start, parts[i + 1].end);
const rank = ranks.get(slice.join(","));
if (rank == null)
continue;
if (minRank == null || rank < minRank[0]) {
minRank = [rank, i];
}
}
if (minRank != null) {
const i = minRank[1];
parts[i] = { start: parts[i].start, end: parts[i + 1].end };
parts.splice(i + 1, 1);
} else {
break;
}
}
return parts;
}
__name(bytePairMerge, "bytePairMerge");
function bytePairEncode(piece, ranks) {
if (piece.length === 1)
return [ranks.get(piece.join(","))];
return bytePairMerge(piece, ranks).map((p) => ranks.get(piece.slice(p.start, p.end).join(","))).filter((x) => x != null);
}
__name(bytePairEncode, "bytePairEncode");
function escapeRegex(str) {
return str.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
}
__name(escapeRegex, "escapeRegex");
var _Tiktoken = class {
static {
__name(this, "_Tiktoken");
}
/** @internal */
specialTokens;
/** @internal */
inverseSpecialTokens;
/** @internal */
patStr;
/** @internal */
textEncoder = new TextEncoder();
/** @internal */
textDecoder = new TextDecoder("utf-8");
/** @internal */
rankMap = /* @__PURE__ */ new Map();
/** @internal */
textMap = /* @__PURE__ */ new Map();
constructor(ranks, extendedSpecialTokens) {
this.patStr = ranks.pat_str;
const uncompressed = ranks.bpe_ranks.split("\n").filter(Boolean).reduce((memo, x) => {
const [_, offsetStr, ...tokens] = x.split(" ");
const offset = Number.parseInt(offsetStr, 10);
tokens.forEach((token, i) => memo[token] = offset + i);
return memo;
}, {});
for (const [token, rank] of Object.entries(uncompressed)) {
const bytes = import_base64_js.default.toByteArray(token);
this.rankMap.set(bytes.join(","), rank);
this.textMap.set(rank, bytes);
}
this.specialTokens = { ...ranks.special_tokens, ...extendedSpecialTokens };
this.inverseSpecialTokens = Object.entries(this.specialTokens).reduce((memo, [text, rank]) => {
memo[rank] = this.textEncoder.encode(text);
return memo;
}, {});
}
encode(text, allowedSpecial = [], disallowedSpecial = "all") {
const regexes = new RegExp(this.patStr, "ug");
const specialRegex = _Tiktoken.specialTokenRegex(
Object.keys(this.specialTokens)
);
const ret = [];
const allowedSpecialSet = new Set(
allowedSpecial === "all" ? Object.keys(this.specialTokens) : allowedSpecial
);
const disallowedSpecialSet = new Set(
disallowedSpecial === "all" ? Object.keys(this.specialTokens).filter(
(x) => !allowedSpecialSet.has(x)
) : disallowedSpecial
);
if (disallowedSpecialSet.size > 0) {
const disallowedSpecialRegex = _Tiktoken.specialTokenRegex([
...disallowedSpecialSet
]);
const specialMatch = text.match(disallowedSpecialRegex);
if (specialMatch != null) {
throw new Error(
`The text contains a special token that is not allowed: ${specialMatch[0]}`
);
}
}
let start = 0;
while (true) {
let nextSpecial = null;
let startFind = start;
while (true) {
specialRegex.lastIndex = startFind;
nextSpecial = specialRegex.exec(text);
if (nextSpecial == null || allowedSpecialSet.has(nextSpecial[0]))
break;
startFind = nextSpecial.index + 1;
}
const end = nextSpecial?.index ?? text.length;
for (const match of text.substring(start, end).matchAll(regexes)) {
const piece = this.textEncoder.encode(match[0]);
const token2 = this.rankMap.get(piece.join(","));
if (token2 != null) {
ret.push(token2);
continue;
}
ret.push(...bytePairEncode(piece, this.rankMap));
}
if (nextSpecial == null)
break;
let token = this.specialTokens[nextSpecial[0]];
ret.push(token);
start = nextSpecial.index + nextSpecial[0].length;
}
return ret;
}
decode(tokens) {
const res = [];
let length = 0;
for (let i2 = 0; i2 < tokens.length; ++i2) {
const token = tokens[i2];
const bytes = this.textMap.get(token) ?? this.inverseSpecialTokens[token];
if (bytes != null) {
res.push(bytes);
length += bytes.length;
}
}
const mergedArray = new Uint8Array(length);
let i = 0;
for (const bytes of res) {
mergedArray.set(bytes, i);
i += bytes.length;
}
return this.textDecoder.decode(mergedArray);
}
};
var Tiktoken = _Tiktoken;
__publicField(Tiktoken, "specialTokenRegex", (tokens) => {
return new RegExp(tokens.map((i) => escapeRegex(i)).join("|"), "g");
});

async function fetch_json_cached(url, cache_key = url) {
const is_browser = typeof window !== "undefined" && typeof window.document !== "undefined";
if (is_browser) {
const cached_text = window.localStorage.getItem(cache_key);
if (cached_text) return JSON.parse(cached_text);
const remote2 = await do_fetch(url);
window.localStorage.setItem(cache_key, JSON.stringify(remote2));
return remote2;
}
const fs = await import("node:fs/promises");
const path = await import("node:path");
const os = await import("node:os");
const cache_dir = path.join(os.homedir(), ".cache", "smart-embed-model");
const cache_file = path.join(cache_dir, cache_key);
try {
const txt = await fs.readFile(cache_file, "utf8");
return JSON.parse(txt);
} catch {
}
const remote = await do_fetch(url);
await fs.mkdir(cache_dir, { recursive: true });
await fs.writeFile(cache_file, JSON.stringify(remote), "utf8");
return remote;
}
__name(fetch_json_cached, "fetch_json_cached");
async function do_fetch(url) {
const resp = await fetch(url);
if (!resp.ok) throw new Error(`failed to download ${url} \u2013 ${resp.status}`);
return await resp.json();
}
__name(do_fetch, "do_fetch");

function is_json_compatible(value) {
if (value === null) {
return true;
}
const type = typeof value;
if (type === "string" || type === "number" || type === "boolean") {
return true;
}
if (Array.isArray(value)) {
return value.every(is_json_compatible);
}
if (type === "object") {
const obj = (
/** @type {Record<string, unknown>} */
value
);
return Object.values(obj).every(is_json_compatible);
}
return false;
}
__name(is_json_compatible, "is_json_compatible");
function extract_json_details(source, exclude_keys) {
const details = {};
for (const [key, value] of Object.entries(source)) {
if (exclude_keys.includes(key)) {
continue;
}
if (!is_json_compatible(value)) {
continue;
}
details[key] = value;
}
return details;
}
__name(extract_json_details, "extract_json_details");
function is_empty_object(obj) {
return Object.keys(obj).length === 0;
}
__name(is_empty_object, "is_empty_object");
function merge_details(first, second) {
if (is_empty_object(first)) {
return second;
}
if (is_empty_object(second)) {
return first;
}
return { ...first, ...second };
}
__name(merge_details, "merge_details");
function get_message_from_object(value) {
const raw = value.message;
if (typeof raw === "string") {
const trimmed = raw.trim();
if (trimmed.length > 0) {
return trimmed;
}
}
return null;
}
__name(get_message_from_object, "get_message_from_object");
function normalize_error(error, http_status = null) {
if (Array.isArray(error) && error.length > 0) {
return normalize_error(error[0], http_status);
}
if (error == null) {
return { message: "Unknown error", details: null, http_status };
}
if (typeof error === "string") {
return { message: error, details: null, http_status };
}
if (error instanceof Error) {
const message = (error.message || "").trim() || "Unknown error";
const extra_details = extract_json_details(
/** @type {Record<string, unknown>} */
error,
["message"]
);
return {
message,
details: is_empty_object(extra_details) ? null : extra_details,
http_status
};
}
if (typeof error === "object") {
const obj = (
/** @type {Record<string, unknown>} */
error
);
if ("error" in obj && obj.error != null) {
const nested_error = obj.error;
if (typeof nested_error === "object") {
const nested_obj = (
/** @type {Record<string, unknown>} */
nested_error
);
const nested_message = get_message_from_object(nested_obj);
const nested_details = extract_json_details(nested_obj, ["message"]);
const outer_details = extract_json_details(obj, ["message", "error"]);
const combined_details = merge_details(outer_details, nested_details);
const message = nested_message || get_message_from_object(obj) || "Unknown error";
return {
message,
details: is_empty_object(combined_details) ? null : combined_details,
http_status
};
}
return normalize_error(nested_error);
}
const object_message = get_message_from_object(obj);
if (object_message) {
const details = extract_json_details(obj, ["message"]);
return {
message: object_message,
details: is_empty_object(details) ? null : details,
http_status
};
}
}
return { message: "Unknown error", details: null, http_status };
}
__name(normalize_error, "normalize_error");

var CL100K_URL = "https://raw.githubusercontent.com/brianpetro/jsbrains/refs/heads/main/smart-embed-model/cl100k_base.json";
var SmartEmbedModelApiAdapter = class extends SmartEmbedAdapter {
static {
__name(this, "SmartEmbedModelApiAdapter");
}
/**
* Get the request adapter class.
* @returns {SmartEmbedModelRequestAdapter} The request adapter class
*/
get req_adapter() {
return SmartEmbedModelRequestAdapter;
}
/**
* Get the response adapter class.
* @returns {SmartEmbedModelResponseAdapter} The response adapter class
*/
get res_adapter() {
return SmartEmbedModelResponseAdapter;
}
/** @returns {string} API endpoint URL */
get endpoint() {
return this.model.data.endpoint;
}
/**
* Get HTTP request adapter instance
* @returns {SmartHttpRequest} HTTP request handler
*/
get http_adapter() {
if (!this._http_adapter) {
if (this.model.opts.http_adapter)
this._http_adapter = this.model.opts.http_adapter;
else
this._http_adapter = new SmartHttpRequest({
adapter: SmartHttpRequestFetchAdapter
});
}
return this._http_adapter;
}
/**
* Get API key for authentication
* @returns {string} API key
*/
get api_key() {
return this.model.data.api_key;
}
/**
* Count tokens in input text
* @abstract
* @param {string} input - Text to tokenize
* @returns {Promise<Object>} Token count result
* @throws {Error} If not implemented by subclass
*/
async count_tokens(input) {
throw new Error("count_tokens not implemented");
}
/**
* Estimate token count for input text
* Uses character-based estimation (3.7 chars per token)
* @param {string|Object} input - Input to estimate tokens for
* @returns {number} Estimated token count
*/
estimate_tokens(input) {
if (typeof input === "object") input = JSON.stringify(input);
return Math.ceil(input.length / 3.7);
}
/**
* Process a batch of inputs for embedding
* @param {Array<Object>} inputs - Array of input objects
* @returns {Promise<Array<Object>>} Processed inputs with embeddings
* @throws {Error} If API key is not set
*/
async embed_batch(inputs) {
if (!this.api_key) throw new Error("API key not set");
inputs = inputs.filter((item) => item.embed_input?.length > 0);
if (inputs.length === 0) {
console.log("Empty batch (or all items have empty embed_input)");
return [];
}
const embed_inputs = await Promise.all(
inputs.map((item) => this.prepare_embed_input(item.embed_input))
);
const _req = new this.req_adapter(this, embed_inputs);
const request_params = _req.to_platform();
const resp = await this.request(request_params);
if (!resp) {
console.error("No response received for embedding request.");
return [];
}
if (resp.error) return [resp];
const _res = new this.res_adapter(this, resp);
const embeddings = _res.to_openai();
if (!embeddings) {
console.error("Failed to parse embeddings.");
return [];
}
return inputs.map((item, i) => {
item.vec = embeddings[i].vec;
item.tokens = embeddings[i].tokens;
return item;
});
}
/**
* Prepare input text for embedding
* @abstract
* @param {string} embed_input - Raw input text
* @returns {Promise<string>} Processed input text
* @throws {Error} If not implemented by subclass
*/
async prepare_embed_input(embed_input) {
throw new Error("prepare_embed_input not implemented");
}
/**
* Prepare request headers
* @returns {Object} Headers object with authorization
*/
prepare_request_headers() {
let headers = {
"Content-Type": "application/json"
};
if (this.api_key) {
headers["Authorization"] = `Bearer ${this.api_key}`;
}
return headers;
}
/**
* Make API request with retry logic
* @param {Object} req - Request configuration
* @param {number} [retries=0] - Number of retries attempted
* @returns {Promise<Object>} API response
*/
async request(req, retries = 0) {
try {
req.throw = false;
const resp = await this.http_adapter.request({
url: this.endpoint,
...req
});
const resp_json = await this.get_resp_json(resp);
if (resp_json.error) {
return { error: normalize_error(resp_json, resp.status()) };
}
return resp_json;
} catch (error) {
console.warn("Request error:", error);
return await this.handle_request_err(error, req, retries);
}
}
/**
* Handle API request errors with retry logic
* @param {Error|Object} error - Error object
* @param {Object} req - Original request
* @param {number} retries - Number of retries attempted
* @returns {Promise<Object|null>} Retry response or null
*/
async handle_request_err(error, req, retries) {
if (error.status === 429 && retries < 3) {
const backoff = Math.pow(retries + 1, 2);
console.log(`Retrying request (429) in ${backoff} seconds...`);
await new Promise((r) => setTimeout(r, 1e3 * backoff));
return await this.request(req, retries + 1);
}
console.error(error);
return null;
}
/**
* Parse response body as JSON
* @param {Response} resp - Response object
* @returns {Promise<Object>} Parsed JSON
*/
async get_resp_json(resp) {
return typeof resp.json === "function" ? await resp.json() : await resp.json;
}
/**
* Validate API key by making test request
* @returns {Promise<boolean>} True if API key is valid
*/
async validate_api_key() {
const resp = await this.embed_batch([{ embed_input: "test" }]);
return Array.isArray(resp) && resp.length > 0 && resp[0].vec !== null;
}
/**
* Trim input text to satisfy `max_tokens`.
* @param {string} embed_input - Input text
* @param {number} tokens_ct - Existing token count
* @returns {Promise<string|null>} Trimmed text
*/
async trim_input_to_max_tokens(embed_input, tokens_ct) {
const reduce_ratio = (tokens_ct - this.max_tokens) / tokens_ct;
const new_length = Math.floor(embed_input.length * (1 - reduce_ratio));
let trimmed_input = embed_input.slice(0, new_length);
const last_space_index = trimmed_input.lastIndexOf(" ");
if (last_space_index > 0) trimmed_input = trimmed_input.slice(0, last_space_index);
const prepared = await this.prepare_embed_input(trimmed_input);
if (prepared === null) return null;
return prepared;
}
async load_tiktoken() {
const cl100k_base = await fetch_json_cached(CL100K_URL, "cl100k_base.json");
this.tiktoken = new Tiktoken(cl100k_base);
}
};
var SmartEmbedModelRequestAdapter = class {
static {
__name(this, "SmartEmbedModelRequestAdapter");
}
/**
* @constructor
* @param {SmartEmbedModelApiAdapter} adapter - The SmartEmbedModelApiAdapter instance
* @param {Array<string>} embed_inputs - The array of input texts
*/
constructor(adapter, embed_inputs) {
this.adapter = adapter;
this.embed_inputs = embed_inputs;
}
get model_id() {
return this.adapter.model.data.model_key;
}
get model_dims() {
return this.adapter.model.data.dims;
}
/**
* Get request headers
* @returns {Object} Headers object
*/
get_headers() {
return this.adapter.prepare_request_headers();
}
/**
* Convert request to platform-specific format
* @returns {Object} Platform-specific request parameters
*/
to_platform() {
return {
method: "POST",
headers: this.get_headers(),
body: JSON.stringify(this.prepare_request_body())
};
}
/**
* Prepare request body for API call
* @abstract
* @returns {Object} Request body object
* @throws {Error} If not implemented by subclass
*/
prepare_request_body() {
throw new Error("prepare_request_body not implemented");
}
};
var SmartEmbedModelResponseAdapter = class {
static {
__name(this, "SmartEmbedModelResponseAdapter");
}
/**
* @constructor
* @param {SmartEmbedModelApiAdapter} adapter - The SmartEmbedModelApiAdapter instance
* @param {Object} response - The response object
*/
constructor(adapter, response) {
this.adapter = adapter;
this.response = response;
}
/**
* Convert response to standard format
* @returns {Array<Object>} Array of embedding results
*/
to_openai() {
return this.parse_response();
}
/**
* Parse API response
* @abstract
* @returns {Array<Object>} Parsed embedding results
* @throws {Error} If not implemented by subclass
*/
parse_response() {
throw new Error("parse_response not implemented");
}
};

var SmartEmbedOpenAIAdapter = class extends SmartEmbedModelApiAdapter {
static {
__name(this, "SmartEmbedOpenAIAdapter");
}
static defaults = {
adapter: "openai",
description: "OpenAI (API)",
default_model: "text-embedding-3-small",
endpoint: "https://api.openai.com/v1/embeddings"
};
/**
* Count tokens in input text using OpenAI's tokenizer
* @param {string} input - Text to tokenize
* @returns {Promise<Object>} Token count result
*/
async count_tokens(input) {
if (!this.tiktoken) await this.load_tiktoken();
return { tokens: this.tiktoken.encode(input).length };
}
/**
* Prepare input text for embedding
* Handles token limit truncation
* @param {string} embed_input - Raw input text
* @returns {Promise<string|null>} Processed input text
*/
async prepare_embed_input(embed_input) {
if (typeof embed_input !== "string") {
throw new TypeError("embed_input must be a string");
}
if (embed_input.length === 0) {
console.log("Warning: prepare_embed_input received an empty string");
return null;
}
const { tokens } = await this.count_tokens(embed_input);
if (tokens <= this.max_tokens) {
return embed_input;
}
return await this.trim_input_to_max_tokens(embed_input, tokens);
}
/**
* Trim input text to fit token limit
* @private
* @param {string} embed_input - Input text to trim
* @param {number} tokens_ct - Current token count
* @returns {Promise<string|null>} Trimmed input text
*/
async trim_input_to_max_tokens(embed_input, tokens_ct) {
const reduce_ratio = (tokens_ct - this.max_tokens) / tokens_ct;
const new_length = Math.floor(embed_input.length * (1 - reduce_ratio));
let trimmed_input = embed_input.slice(0, new_length);
const last_space_index = trimmed_input.lastIndexOf(" ");
if (last_space_index > 0) {
trimmed_input = trimmed_input.slice(0, last_space_index);
}
const prepared_input = await this.prepare_embed_input(trimmed_input);
if (prepared_input === null) {
console.log(
"Warning: prepare_embed_input resulted in an empty string after trimming"
);
return null;
}
return prepared_input;
}
/**
* Get the request adapter class.
* @returns {SmartEmbedOpenAIRequestAdapter} The request adapter class
*/
get req_adapter() {
return SmartEmbedOpenAIRequestAdapter;
}
/**
* Get the response adapter class.
* @returns {SmartEmbedOpenAIResponseAdapter} The response adapter class
*/
get res_adapter() {
return SmartEmbedOpenAIResponseAdapter;
}
/** @returns {number} Maximum tokens per input */
get max_tokens() {
return this.model.data.max_tokens || 8191;
}
/** @returns {Object} Settings configuration for OpenAI adapter */
get settings_config() {
return {
...super.settings_config,
"[ADAPTER].api_key": {
name: "OpenAI API key for embeddings",
type: "password",
description: "Required for OpenAI embedding models.",
placeholder: "Enter OpenAI API key"
}
};
}
/**
* Get available models (hardcoded list)
* @returns {Promise<Object>} Map of model objects
*/
get_models() {
return Promise.resolve(this.models);
}
get models() {
return {
"text-embedding-3-small": {
"id": "text-embedding-3-small",
"batch_size": 50,
"dims": 1536,
"max_tokens": 8191,
"name": "OpenAI Text-3 Small",
"description": "API, 8,191 tokens, 1,536 dim",
"endpoint": "https://api.openai.com/v1/embeddings",
"adapter": "openai"
},
"text-embedding-3-large": {
"id": "text-embedding-3-large",
"batch_size": 50,
"dims": 3072,
"max_tokens": 8191,
"name": "OpenAI Text-3 Large",
"description": "API, 8,191 tokens, 3,072 dim",
"endpoint": "https://api.openai.com/v1/embeddings",
"adapter": "openai"
},
"text-embedding-ada-002": {
"id": "text-embedding-ada-002",
"batch_size": 50,
"dims": 1536,
"max_tokens": 8191,
"name": "OpenAI Ada",
"description": "API, 8,191 tokens, 1,536 dim",
"endpoint": "https://api.openai.com/v1/embeddings",
"adapter": "openai"
}
};
}
};
var SmartEmbedOpenAIRequestAdapter = class extends SmartEmbedModelRequestAdapter {
static {
__name(this, "SmartEmbedOpenAIRequestAdapter");
}
/**
* Prepare request body for OpenAI API
* @returns {Object} Request body for API
*/
prepare_request_body() {
const body = {
model: this.model_id,
input: this.embed_inputs
};
if (this.model_id.startsWith("text-embedding-3")) {
body.dimensions = this.model_dims;
}
return body;
}
};
var SmartEmbedOpenAIResponseAdapter = class extends SmartEmbedModelResponseAdapter {
static {
__name(this, "SmartEmbedOpenAIResponseAdapter");
}
/**
* Parse OpenAI API response
* @returns {Array<Object>} Parsed embedding results
*/
parse_response() {
const resp = this.response;
if (!resp || !resp.data || !resp.usage) {
console.error("Invalid response format", resp);
return [];
}
const avg_tokens = resp.usage.total_tokens / resp.data.length;
return resp.data.map((item) => ({
vec: item.embedding,
tokens: avg_tokens
}));
}
};

var SmartEmbedMessageAdapter = class extends SmartEmbedAdapter {
static {
__name(this, "SmartEmbedMessageAdapter");
}
/**
* Create message adapter instance
*/
constructor(model) {
super(model);
this.message_queue = {};
this.message_id = 0;
this.connector = null;
this.message_prefix = `msg_${Math.random().toString(36).substr(2, 9)}_`;
}
/**
* Send message and wait for response
* @protected
* @param {string} method - Method name to call
* @param {Object} params - Method parameters
* @returns {Promise<any>} Response data
*/
async _send_message(method, params) {
return new Promise((resolve, reject) => {
const id = `${this.message_prefix}${this.message_id++}`;
this.message_queue[id] = { resolve, reject };
this._post_message({ method, params, id });
});
}
/**
* Handle response message from worker/iframe
* @protected
* @param {string} id - Message ID
* @param {*} result - Response result
* @param {Error} [error] - Response error
*/
_handle_message_result(id, result, error) {
if (!id.startsWith(this.message_prefix)) return;
if (result?.model_loaded) {
console.log("model loaded");
this.state = "loaded";
this.model.model_loaded = true;
this.model.load_result = result;
}
if (this.message_queue[id]) {
if (error) {
this.message_queue[id].reject(new Error(error));
} else {
this.message_queue[id].resolve(result);
}
delete this.message_queue[id];
}
}
/**
* Count tokens in input text
* @param {string} input - Text to tokenize
* @returns {Promise<Object>} Token count result
*/
async count_tokens(input) {
return this._send_message("count_tokens", { input });
}
/**
* Generate embeddings for multiple inputs
* @param {Array<Object>} inputs - Array of input objects
* @returns {Promise<Array<Object>>} Processed inputs with embeddings
*/
async embed_batch(inputs) {
inputs = inputs.filter((item) => item.embed_input?.length > 0);
if (!inputs.length) return [];
const embed_inputs = inputs.map((item) => ({ embed_input: item.embed_input }));
const result = await this._send_message("embed_batch", { inputs: embed_inputs });
return inputs.map((item, i) => {
item.vec = result[i].vec;
item.tokens = result[i].tokens;
return item;
});
}
/**
* Post message to worker/iframe
* @abstract
* @protected
* @param {Object} message_data - Message to send
* @throws {Error} If not implemented by subclass
*/
_post_message(message_data) {
throw new Error("_post_message must be implemented by subclass");
}
};

var SmartEmbedIframeAdapter = class extends SmartEmbedMessageAdapter {
static {
__name(this, "SmartEmbedIframeAdapter");
}
/**
* Create iframe adapter instance
*/
constructor(model) {
super(model);
this.iframe = null;
this.origin = window.location.origin;
this.iframe_id = `smart_embed_iframe`;
}
/**
* Initialize iframe and load model
* @returns {Promise<void>}
*/
async load() {
const existing_iframe = document.getElementById(this.iframe_id);
if (existing_iframe) {
existing_iframe.remove();
}
this.iframe = document.createElement("iframe");
this.iframe.style.display = "none";
this.iframe.id = this.iframe_id;
document.body.appendChild(this.iframe);
window.addEventListener("message", this._handle_message.bind(this));
this.iframe.srcdoc = `
<html>
<body>
<script type="module">
${this.connector}
window.addEventListener('message', async (event) => {
if (event.origin !== '${this.origin}' || event.data.iframe_id !== '${this.iframe_id}') return console.log('message ignored (listener)', event);
const response = await process_message(event.data);
window.parent.postMessage({ ...response, iframe_id: '${this.iframe_id}' }, '${this.origin}');
});
</script>
</body>
</html>
`;
await new Promise((resolve) => this.iframe.onload = resolve);
const load_opts = {
model_key: this.model.model_key,
adapters: null,
settings: null,
batch_size: this.batch_size,
use_gpu: this.use_gpu
};
await this._send_message("load", load_opts);
return new Promise((resolve) => {
const check_model_loaded = /* @__PURE__ */ __name(() => {
if (this.model.model_loaded) {
resolve();
} else {
setTimeout(check_model_loaded, 100);
}
}, "check_model_loaded");
check_model_loaded();
});
}
/**
* Post message to iframe
* @protected
* @param {Object} message_data - Message to send
*/
_post_message(message_data) {
this.iframe.contentWindow.postMessage({ ...message_data, iframe_id: this.iframe_id }, this.origin);
}
/**
* Handle message from iframe
* @private
* @param {MessageEvent} event - Message event
*/
_handle_message(event) {
if (event.origin !== this.origin || event.data.iframe_id !== this.iframe_id) return;
const { id, result, error } = event.data;
this._handle_message_result(id, result, error);
}
};

var transformers_connector = 'var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);\n\n// ../smart-model/adapters/_adapter.js\nvar SmartModelAdapter = class {\n  /**\n   * Create a SmartModelAdapter instance.\n   * @param {SmartModel} model - The parent SmartModel instance\n   */\n  constructor(model2) {\n    this.model = model2;\n    this.state = "unloaded";\n  }\n  /**\n   * Load the adapter.\n   * @async\n   * @returns {Promise<void>}\n   */\n  async load() {\n    this.set_state("loaded");\n  }\n  /**\n   * Unload the adapter.\n   * @returns {void}\n   */\n  unload() {\n    this.set_state("unloaded");\n  }\n  /**\n   * Get all settings.\n   * @returns {Object} All settings\n   */\n  get settings() {\n    return this.model.settings;\n  }\n  /**\n   * Get the current model key.\n   * @returns {string} Current model identifier\n   */\n  get model_key() {\n    return this.model.model_key;\n  }\n  /**\n   * Get the models.\n   * @returns {Object} Map of model objects\n   */\n  get models() {\n    const models = this.model.data.provider_models;\n    if (typeof models === "object" && Object.keys(models || {}).length > 0) return models;\n    else {\n      return {};\n    }\n  }\n  /**\n   * Get available models from the API.\n   * @abstract\n   * @param {boolean} [refresh=false] - Whether to refresh cached models\n   * @returns {Promise<Object>} Map of model objects\n   */\n  async get_models(refresh = false) {\n    throw new Error("get_models not implemented");\n  }\n  /**\n   * Get available models as dropdown options synchronously.\n   * @returns {Array<Object>} Array of model options.\n   */\n  get_models_as_options() {\n    const models = this.models;\n    if (!Object.keys(models || {}).length) {\n      this.get_models(true);\n      return [{ value: "", name: "No models currently available" }];\n    }\n    return Object.entries(models).map(([id, model2]) => ({ value: id, name: model2.name || id })).sort((a, b) => a.name.localeCompare(b.name));\n  }\n  /**\n   * Set the adapter\'s state.\n   * @deprecated should be handled in SmartModel (only handle once)\n   * @param {(\'unloaded\'|\'loading\'|\'loaded\'|\'unloading\')} new_state - The new state\n   * @throws {Error} If the state is invalid\n   */\n  set_state(new_state) {\n    const valid_states = ["unloaded", "loading", "loaded", "unloading"];\n    if (!valid_states.includes(new_state)) {\n      throw new Error(`Invalid state: ${new_state}`);\n    }\n    this.state = new_state;\n  }\n  // Replace individual state getters/setters with a unified state management\n  get is_loading() {\n    return this.state === "loading";\n  }\n  get is_loaded() {\n    return this.state === "loaded";\n  }\n  get is_unloading() {\n    return this.state === "unloading";\n  }\n  get is_unloaded() {\n    return this.state === "unloaded";\n  }\n};\n\n// adapters/_adapter.js\nvar SmartEmbedAdapter = class extends SmartModelAdapter {\n  /**\n   * Count tokens in input text\n   * @abstract\n   * @param {string} input - Text to tokenize\n   * @returns {Promise<Object>} Token count result\n   * @property {number} tokens - Number of tokens in input\n   * @throws {Error} If not implemented by subclass\n   */\n  async count_tokens(input) {\n    throw new Error("count_tokens method not implemented");\n  }\n  /**\n   * Generate embeddings for single input\n   * @abstract\n   * @param {string|Object} input - Text to embed\n   * @returns {Promise<Object>} Embedding result\n   * @property {number[]} vec - Embedding vector\n   * @property {number} tokens - Number of tokens in input\n   * @throws {Error} If not implemented by subclass\n   */\n  async embed(input) {\n    if (typeof input === "string") input = { embed_input: input };\n    return (await this.embed_batch([input]))[0];\n  }\n  /**\n   * Generate embeddings for multiple inputs\n   * @abstract\n   * @param {Array<string|Object>} inputs - Texts to embed\n   * @returns {Promise<Array<Object>>} Array of embedding results\n   * @property {number[]} vec - Embedding vector for each input\n   * @property {number} tokens - Number of tokens in each input\n   * @throws {Error} If not implemented by subclass\n   */\n  async embed_batch(inputs) {\n    throw new Error("embed_batch method not implemented");\n  }\n  get settings_config() {\n    return {\n      "[ADAPTER].model_key": {\n        name: "Embedding model",\n        type: "dropdown",\n        description: "Select an embedding model.",\n        options_callback: "adapter.get_models_as_options",\n        callback: "model_changed",\n        default: this.constructor.defaults.default_model\n      }\n    };\n  }\n  get dims() {\n    return this.model.data.dims;\n  }\n  get max_tokens() {\n    return this.model.data.max_tokens;\n  }\n  get batch_size() {\n    return this.model.data.batch_size || 1;\n  }\n};\n/**\n * @override in sub-class with adapter-specific default configurations\n * @property {string} id - The adapter identifier\n * @property {string} description - Human-readable description\n * @property {string} type - Adapter type ("API")\n * @property {string} endpoint - API endpoint\n * @property {string} adapter - Adapter identifier\n * @property {string} default_model - Default model to use\n */\n__publicField(SmartEmbedAdapter, "defaults", {});\n\n// adapters/transformers.js\nvar transformers_defaults = {\n  adapter: "transformers",\n  description: "Transformers (Local, built-in)",\n  default_model: "TaylorAI/bge-micro-v2",\n  models: transformers_models\n};\nvar DEVICE_CONFIGS = {\n  // // WebGPU: high quality first\n  webgpu_fp16: {\n    device: "webgpu",\n    dtype: "fp16",\n    quantized: false\n  },\n  webgpu_fp32: {\n    device: "webgpu",\n    dtype: "fp32",\n    quantized: false\n  },\n  // WebGPU: quantized tiers\n  webgpu_q8: {\n    device: "webgpu",\n    dtype: "q8",\n    quantized: true\n  },\n  webgpu_q4: {\n    device: "webgpu",\n    dtype: "q4",\n    quantized: true\n  },\n  // Optional, if you use it\n  webgpu_q4f16: {\n    device: "webgpu",\n    dtype: "q4f16",\n    quantized: true\n  },\n  webgpu_bnb4: {\n    device: "webgpu",\n    dtype: "bnb4",\n    quantized: true\n  },\n  // WASM: quantized CPU\n  wasm_q8: {\n    dtype: "q8",\n    quantized: true\n  },\n  wasm_q4: {\n    dtype: "q4",\n    quantized: true\n  },\n  // Final universal fallback: WASM CPU, dtype = auto\n  wasm_auto: {\n    // NOTE: leaving out device to avoid Linux issues with \'wasm\'\n    // transformers.js will pick CPU/WASM backend itself\n    quantized: false\n  }\n};\nvar is_webgpu_available = async () => {\n  if (!("gpu" in navigator)) return false;\n  const adapter = await navigator.gpu.requestAdapter();\n  if (!adapter) return false;\n  return true;\n};\nvar SmartEmbedTransformersAdapter = class extends SmartEmbedAdapter {\n  /**\n   * @param {import("../smart_embed_model.js").SmartEmbedModel} model\n   */\n  constructor(model2) {\n    super(model2);\n    this.pipeline = null;\n    this.tokenizer = null;\n    this.active_config_key = null;\n    this.has_gpu = false;\n  }\n  /**\n   * Load the underlying transformers pipeline with WebGPU \u2192 WASM fallback.\n   * @returns {Promise<void>}\n   */\n  async load() {\n    this.has_gpu = await is_webgpu_available();\n    try {\n      if (this.loading) {\n        console.warn("[Transformers v2] load already in progress, waiting...");\n        while (this.loading) {\n          await new Promise((resolve) => setTimeout(resolve, 100));\n        }\n      } else {\n        this.loading = true;\n        if (this.pipeline) {\n          this.loaded = true;\n          this.loading = false;\n          return;\n        }\n        await this.load_transformers_with_fallback();\n        this.loading = false;\n        this.loaded = true;\n        console.log(`[Transformers v2] model loaded using ${this.active_config_key}`, this);\n      }\n    } catch (e) {\n      this.loading = false;\n      this.loaded = false;\n      console.error("[Transformers v2] load failed", e);\n      throw e;\n    }\n  }\n  /**\n   * Unload the pipeline and free resources.\n   * @returns {Promise<void>}\n   */\n  async unload() {\n    try {\n      if (this.pipeline) {\n        if (typeof this.pipeline.destroy === "function") {\n          this.pipeline.destroy();\n        } else if (typeof this.pipeline.dispose === "function") {\n          this.pipeline.dispose();\n        }\n      }\n    } catch (err) {\n      console.warn("[Transformers v2] error while disposing pipeline", err);\n    }\n    this.pipeline = null;\n    this.tokenizer = null;\n    this.active_config_key = null;\n    this.loaded = false;\n  }\n  /**\n   * Available models \u2013 reuses the v1 transformers model catalog.\n   * @returns {Object}\n   */\n  get models() {\n    return transformers_models;\n  }\n  /**\n   * Maximum tokens per input.\n   * @returns {number}\n   */\n  get max_tokens() {\n    return this.model.data.max_tokens || 512;\n  }\n  /**\n   * Effective batch size.\n   * Prefers small deterministic batches when not explicitly configured.\n   * @returns {number}\n   */\n  get batch_size() {\n    const configured = this.model.data.batch_size;\n    if (configured && configured > 0) return configured;\n    return this.gpu_enabled ? 16 : 8;\n  }\n  get gpu_enabled() {\n    if (this.has_gpu) {\n      const explicit = typeof this.model.data.use_gpu === "boolean" ? this.model.data.use_gpu : null;\n      if (explicit === false) return false;\n      return true;\n    } else {\n      return false;\n    }\n  }\n  /**\n   * Initialize transformers pipeline with WebGPU \u2192 WASM fallback.\n   * @private\n   * @returns {Promise<void>}\n   */\n  async load_transformers_with_fallback() {\n    const { pipeline, env, AutoTokenizer } = await import("@huggingface/transformers");\n    env.allowLocalModels = false;\n    if (typeof env.useBrowserCache !== "undefined") {\n      env.useBrowserCache = true;\n    }\n    let last_error = null;\n    const CONFIG_LIST_ORDER = Object.keys(DEVICE_CONFIGS);\n    const try_create = async (config_key) => {\n      const pipe = await pipeline("feature-extraction", this.model_key, DEVICE_CONFIGS[config_key]);\n      return pipe;\n    };\n    for (const config of CONFIG_LIST_ORDER) {\n      if (this.pipeline) break;\n      if (config.includes("gpu") && !this.gpu_enabled) {\n        console.warn(`[Transformers v2: ${config}] skipping ${config} as GPU is disabled`);\n        continue;\n      }\n      try {\n        console.log(`[Transformers v2] trying to load pipeline on ${config}`);\n        this.pipeline = await try_create(config);\n        this.active_config_key = config;\n        break;\n      } catch (err) {\n        console.warn(`[Transformers v2: ${config}] failed to load pipeline on ${config}`, err);\n        last_error = err;\n      }\n    }\n    if (this.pipeline) {\n      console.log(`[Transformers v2: ${this.active_config_key}] pipeline initialized using ${this.active_config_key}`);\n    } else {\n      throw last_error || new Error("Failed to initialize transformers pipeline");\n    }\n    this.tokenizer = await AutoTokenizer.from_pretrained(this.model_key);\n  }\n  /**\n   * Count tokens in input text.\n   * @param {string} input\n   * @returns {Promise<{tokens:number}>}\n   */\n  async count_tokens(input) {\n    if (!this.tokenizer) {\n      await this.load();\n    }\n    const { input_ids } = await this.tokenizer(input);\n    return { tokens: input_ids.data.length };\n  }\n  /**\n   * Generate embeddings for multiple inputs.\n   * @param {Array<Object>} inputs\n   * @returns {Promise<Array<Object>>}\n   */\n  async embed_batch(inputs) {\n    if (!this.pipeline) {\n      await this.load();\n    }\n    const filtered_inputs = inputs.filter((item) => item.embed_input && item.embed_input.length > 0);\n    if (!filtered_inputs.length) return [];\n    const results = [];\n    for (let i = 0; i < filtered_inputs.length; i += this.batch_size) {\n      const batch = filtered_inputs.slice(i, i + this.batch_size);\n      const batch_results = await this._process_batch(batch);\n      results.push(...batch_results);\n    }\n    return results;\n  }\n  /**\n   * Process a single batch \u2013 with per-item retry on failure.\n   * @private\n   * @param {Array<Object>} batch_inputs\n   * @returns {Promise<Array<Object>>}\n   */\n  async _process_batch(batch_inputs) {\n    const prepared = await Promise.all(\n      batch_inputs.map((item) => this._prepare_input(item.embed_input))\n    );\n    const embed_inputs = prepared.map((p) => p.text);\n    const tokens = prepared.map((p) => p.tokens);\n    try {\n      const resp = await this.pipeline(embed_inputs, { pooling: "mean", normalize: true });\n      return batch_inputs.map((item, i) => {\n        const vec = Array.from(resp[i].data).map((val) => Math.round(val * 1e8) / 1e8);\n        item.vec = vec;\n        item.tokens = tokens[i];\n        return item;\n      });\n    } catch (err) {\n      console.error("[Transformers v2] batch embed failed \\u2013 retrying items individually", err);\n      return await this._retry_items_individually(batch_inputs);\n    }\n  }\n  /**\n   * Prepare a single input by truncating to max_tokens if necessary.\n   * @private\n   * @param {string} embed_input\n   * @returns {Promise<{text:string,tokens:number}>}\n   */\n  async _prepare_input(embed_input) {\n    let { tokens } = await this.count_tokens(embed_input);\n    if (tokens <= this.max_tokens) {\n      return { text: embed_input, tokens };\n    }\n    let truncated = embed_input;\n    while (tokens > this.max_tokens && truncated.length > 0) {\n      const pct = this.max_tokens / tokens;\n      const max_chars = Math.floor(truncated.length * pct * 0.9);\n      truncated = truncated.slice(0, max_chars);\n      const last_space = truncated.lastIndexOf(" ");\n      if (last_space > 0) {\n        truncated = truncated.slice(0, last_space);\n      }\n      tokens = (await this.count_tokens(truncated)).tokens;\n    }\n    return { text: truncated, tokens };\n  }\n  /**\n   * Retry each item individually after a batch failure.\n   * @private\n   * @param {Array<Object>} batch_inputs\n   * @returns {Promise<Array<Object>>}\n   */\n  async _retry_items_individually(batch_inputs) {\n    await this._reset_pipeline_after_error();\n    const results = [];\n    for (const item of batch_inputs) {\n      try {\n        const prepared = await this._prepare_input(item.embed_input);\n        const resp = await this.pipeline(prepared.text, { pooling: "mean", normalize: true });\n        const vec = Array.from(resp[0].data).map((val) => Math.round(val * 1e8) / 1e8);\n        results.push({\n          ...item,\n          vec,\n          tokens: prepared.tokens\n        });\n      } catch (single_err) {\n        console.error("[Transformers v2] single item embed failed \\u2013 skipping", single_err);\n        results.push({\n          ...item,\n          vec: [],\n          tokens: 0,\n          error: single_err.message\n        });\n      }\n    }\n    return results;\n  }\n  /**\n   * Reset pipeline after a failure \u2013 falling back to WASM if needed.\n   * @private\n   * @returns {Promise<void>}\n   */\n  async _reset_pipeline_after_error() {\n    try {\n      if (this.pipeline) {\n        if (typeof this.pipeline.destroy === "function") {\n          this.pipeline.destroy();\n        } else if (typeof this.pipeline.dispose === "function") {\n          this.pipeline.dispose();\n        }\n      }\n    } catch (err) {\n      console.warn("[Transformers v2] error while resetting pipeline", err);\n    }\n    this.pipeline = null;\n    await this.load_transformers_with_fallback();\n  }\n  /**\n   * V2 intentionally exposes only model selection in the settings UI.\n   * @returns {Object}\n   */\n  get settings_config() {\n    return super.settings_config;\n  }\n};\n__publicField(SmartEmbedTransformersAdapter, "defaults", transformers_defaults);\nvar transformers_models = {\n  "TaylorAI/bge-micro-v2": {\n    "id": "TaylorAI/bge-micro-v2",\n    "batch_size": 1,\n    "dims": 384,\n    "max_tokens": 512,\n    "name": "BGE-micro-v2",\n    "description": "Local, 512 tokens, 384 dim (recommended)",\n    "adapter": "transformers"\n  },\n  "Snowflake/snowflake-arctic-embed-xs": {\n    "id": "Snowflake/snowflake-arctic-embed-xs",\n    "batch_size": 1,\n    "dims": 384,\n    "max_tokens": 512,\n    "name": "Snowflake Arctic Embed XS",\n    "description": "Local, 512 tokens, 384 dim",\n    "adapter": "transformers"\n  },\n  "Snowflake/snowflake-arctic-embed-s": {\n    "id": "Snowflake/snowflake-arctic-embed-s",\n    "batch_size": 1,\n    "dims": 384,\n    "max_tokens": 512,\n    "name": "Snowflake Arctic Embed Small",\n    "description": "Local, 512 tokens, 384 dim",\n    "adapter": "transformers"\n  },\n  "Snowflake/snowflake-arctic-embed-m": {\n    "id": "Snowflake/snowflake-arctic-embed-m",\n    "batch_size": 1,\n    "dims": 768,\n    "max_tokens": 512,\n    "name": "Snowflake Arctic Embed Medium",\n    "description": "Local, 512 tokens, 768 dim",\n    "adapter": "transformers"\n  },\n  "TaylorAI/gte-tiny": {\n    "id": "TaylorAI/gte-tiny",\n    "batch_size": 1,\n    "dims": 384,\n    "max_tokens": 512,\n    "name": "GTE-tiny",\n    "description": "Local, 512 tokens, 384 dim",\n    "adapter": "transformers"\n  },\n  "onnx-community/embeddinggemma-300m-ONNX": {\n    "id": "onnx-community/embeddinggemma-300m-ONNX",\n    "batch_size": 1,\n    "dims": 768,\n    "max_tokens": 2048,\n    "name": "EmbeddingGemma-300M",\n    "description": "Local, 2,048 tokens, 768 dim",\n    "adapter": "transformers"\n  },\n  "Mihaiii/Ivysaur": {\n    "id": "Mihaiii/Ivysaur",\n    "batch_size": 1,\n    "dims": 384,\n    "max_tokens": 512,\n    "name": "Ivysaur",\n    "description": "Local, 512 tokens, 384 dim",\n    "adapter": "transformers"\n  },\n  "andersonbcdefg/bge-small-4096": {\n    "id": "andersonbcdefg/bge-small-4096",\n    "batch_size": 1,\n    "dims": 384,\n    "max_tokens": 4096,\n    "name": "BGE-small-4K",\n    "description": "Local, 4,096 tokens, 384 dim",\n    "adapter": "transformers"\n  },\n  // Too slow and persistent crashes\n  // "jinaai/jina-embeddings-v2-base-de": {\n  //   "id": "jinaai/jina-embeddings-v2-base-de",\n  //   "batch_size": 1,\n  //   "dims": 768,\n  //   "max_tokens": 4096,\n  //   "name": "jina-embeddings-v2-base-de",\n  //   "description": "Local, 4,096 tokens, 768 dim, German",\n  //   "adapter": "transformers"\n  // },\n  "Xenova/jina-embeddings-v2-base-zh": {\n    "id": "Xenova/jina-embeddings-v2-base-zh",\n    "batch_size": 1,\n    "dims": 768,\n    "max_tokens": 8192,\n    "name": "Jina-v2-base-zh-8K",\n    "description": "Local, 8,192 tokens, 768 dim, Chinese/English bilingual",\n    "adapter": "transformers"\n  },\n  "Xenova/jina-embeddings-v2-small-en": {\n    "id": "Xenova/jina-embeddings-v2-small-en",\n    "batch_size": 1,\n    "dims": 512,\n    "max_tokens": 8192,\n    "name": "Jina-v2-small-en",\n    "description": "Local, 8,192 tokens, 512 dim",\n    "adapter": "transformers"\n  },\n  "nomic-ai/nomic-embed-text-v1.5": {\n    "id": "nomic-ai/nomic-embed-text-v1.5",\n    "batch_size": 1,\n    "dims": 768,\n    "max_tokens": 2048,\n    "name": "Nomic-embed-text-v1.5",\n    "description": "Local, 8,192 tokens, 768 dim",\n    "adapter": "transformers"\n  },\n  "Xenova/bge-small-en-v1.5": {\n    "id": "Xenova/bge-small-en-v1.5",\n    "batch_size": 1,\n    "dims": 384,\n    "max_tokens": 512,\n    "name": "BGE-small",\n    "description": "Local, 512 tokens, 384 dim",\n    "adapter": "transformers"\n  },\n  "nomic-ai/nomic-embed-text-v1": {\n    "id": "nomic-ai/nomic-embed-text-v1",\n    "batch_size": 1,\n    "dims": 768,\n    "max_tokens": 2048,\n    "name": "Nomic-embed-text",\n    "description": "Local, 2,048 tokens, 768 dim",\n    "adapter": "transformers"\n  }\n};\n\n// build/transformers_iframe_script.js\nvar model = null;\nasync function process_message(data) {\n  const { method, params, id, iframe_id } = data;\n  try {\n    let result;\n    switch (method) {\n      case "init":\n        console.log("init");\n        break;\n      case "load":\n        const model_params = { data: params, ...params };\n        console.log("load", { model_params });\n        model = new SmartEmbedTransformersAdapter(model_params);\n        await model.load();\n        result = { model_loaded: true, model_config_key: model.active_config_key };\n        break;\n      case "embed_batch":\n        if (!model) throw new Error("Model not loaded");\n        result = await model.embed_batch(params.inputs);\n        break;\n      case "count_tokens":\n        if (!model) throw new Error("Model not loaded");\n        result = await model.count_tokens(params);\n        break;\n      default:\n        throw new Error(`Unknown method: ${method}`);\n    }\n    return { id, result, iframe_id };\n  } catch (error) {\n    console.error("Error processing message:", error);\n    return { id, error: error.message, iframe_id };\n  }\n}\nprocess_message({ method: "init" });\n';

var transformers_defaults = {
adapter: "transformers",
description: "Transformers (Local, built-in)",
default_model: "TaylorAI/bge-micro-v2",
models: transformers_models
};
var transformers_models = {
"TaylorAI/bge-micro-v2": {
"id": "TaylorAI/bge-micro-v2",
"batch_size": 1,
"dims": 384,
"max_tokens": 512,
"name": "BGE-micro-v2",
"description": "Local, 512 tokens, 384 dim (recommended)",
"adapter": "transformers"
},
"Snowflake/snowflake-arctic-embed-xs": {
"id": "Snowflake/snowflake-arctic-embed-xs",
"batch_size": 1,
"dims": 384,
"max_tokens": 512,
"name": "Snowflake Arctic Embed XS",
"description": "Local, 512 tokens, 384 dim",
"adapter": "transformers"
},
"Snowflake/snowflake-arctic-embed-s": {
"id": "Snowflake/snowflake-arctic-embed-s",
"batch_size": 1,
"dims": 384,
"max_tokens": 512,
"name": "Snowflake Arctic Embed Small",
"description": "Local, 512 tokens, 384 dim",
"adapter": "transformers"
},
"Snowflake/snowflake-arctic-embed-m": {
"id": "Snowflake/snowflake-arctic-embed-m",
"batch_size": 1,
"dims": 768,
"max_tokens": 512,
"name": "Snowflake Arctic Embed Medium",
"description": "Local, 512 tokens, 768 dim",
"adapter": "transformers"
},
"TaylorAI/gte-tiny": {
"id": "TaylorAI/gte-tiny",
"batch_size": 1,
"dims": 384,
"max_tokens": 512,
"name": "GTE-tiny",
"description": "Local, 512 tokens, 384 dim",
"adapter": "transformers"
},
"onnx-community/embeddinggemma-300m-ONNX": {
"id": "onnx-community/embeddinggemma-300m-ONNX",
"batch_size": 1,
"dims": 768,
"max_tokens": 2048,
"name": "EmbeddingGemma-300M",
"description": "Local, 2,048 tokens, 768 dim",
"adapter": "transformers"
},
"Mihaiii/Ivysaur": {
"id": "Mihaiii/Ivysaur",
"batch_size": 1,
"dims": 384,
"max_tokens": 512,
"name": "Ivysaur",
"description": "Local, 512 tokens, 384 dim",
"adapter": "transformers"
},
"andersonbcdefg/bge-small-4096": {
"id": "andersonbcdefg/bge-small-4096",
"batch_size": 1,
"dims": 384,
"max_tokens": 4096,
"name": "BGE-small-4K",
"description": "Local, 4,096 tokens, 384 dim",
"adapter": "transformers"
},
"Xenova/jina-embeddings-v2-base-zh": {
"id": "Xenova/jina-embeddings-v2-base-zh",
"batch_size": 1,
"dims": 768,
"max_tokens": 8192,
"name": "Jina-v2-base-zh-8K",
"description": "Local, 8,192 tokens, 768 dim, Chinese/English bilingual",
"adapter": "transformers"
},
"Xenova/jina-embeddings-v2-small-en": {
"id": "Xenova/jina-embeddings-v2-small-en",
"batch_size": 1,
"dims": 512,
"max_tokens": 8192,
"name": "Jina-v2-small-en",
"description": "Local, 8,192 tokens, 512 dim",
"adapter": "transformers"
},
"nomic-ai/nomic-embed-text-v1.5": {
"id": "nomic-ai/nomic-embed-text-v1.5",
"batch_size": 1,
"dims": 768,
"max_tokens": 2048,
"name": "Nomic-embed-text-v1.5",
"description": "Local, 8,192 tokens, 768 dim",
"adapter": "transformers"
},
"Xenova/bge-small-en-v1.5": {
"id": "Xenova/bge-small-en-v1.5",
"batch_size": 1,
"dims": 384,
"max_tokens": 512,
"name": "BGE-small",
"description": "Local, 512 tokens, 384 dim",
"adapter": "transformers"
},
"nomic-ai/nomic-embed-text-v1": {
"id": "nomic-ai/nomic-embed-text-v1",
"batch_size": 1,
"dims": 768,
"max_tokens": 2048,
"name": "Nomic-embed-text",
"description": "Local, 2,048 tokens, 768 dim",
"adapter": "transformers"
}
};
var transformers_settings_config = {
};
var settings_config4 = {
};

var SmartEmbedTransformersIframeAdapter = class extends SmartEmbedIframeAdapter {
static {
__name(this, "SmartEmbedTransformersIframeAdapter");
}
static defaults = transformers_defaults;
/**
* Create transformers iframe adapter instance
*/
constructor(model) {
super(model);
this.connector = transformers_connector.replace("@huggingface/transformers", "https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.8.0");
console.log("transformers iframe connector", this.model);
}
/** @returns {Object} Settings configuration for transformers adapter */
get settings_config() {
return {
...super.settings_config,
...transformers_settings_config
};
}
/**
* Get available models (hardcoded list)
* @returns {Promise<Object>} Map of model objects
*/
get_models() {
return Promise.resolve(this.models);
}
get models() {
return transformers_models;
}
};

var SmartEmbedOllamaAdapter = class extends SmartEmbedModelApiAdapter {
static {
__name(this, "SmartEmbedOllamaAdapter");
}
static defaults = {
description: "Ollama (Local)",
type: "API",
host: "http://localhost:11434",
endpoint: "/api/embed",
models_endpoint: "/api/tags",
api_key: "na",
streaming: false,
max_tokens: 512,
signup_url: null,
batch_size: 30,
models: {}
};
get host() {
return this.model.data.host || this.constructor.defaults.host;
}
get endpoint() {
return `${this.host}${this.constructor.defaults.endpoint}`;
}
get models_endpoint() {
return `${this.host}${this.constructor.defaults.models_endpoint}`;
}
get model_show_endpoint() {
return `${this.host}/api/show`;
}
async load() {
await this.get_models();
await super.load();
}
/**
* Estimate token count for input text.
* Ollama does not expose a tokenizer so we use a character based heuristic.
* @param {string} input - Text to tokenize
* @returns {Promise<Object>} Token count result
*/
async count_tokens(input) {
return { tokens: this.estimate_tokens(input) };
}
/**
* Prepare input text and ensure it fits within `max_tokens`.
* @param {string} embed_input - Raw input text
* @returns {Promise<string|null>} Processed input text
*/
async prepare_embed_input(embed_input) {
if (typeof embed_input !== "string") throw new TypeError("embed_input must be a string");
if (embed_input.length === 0) return null;
const { tokens } = await this.count_tokens(embed_input);
if (tokens <= this.max_tokens) return embed_input;
return await this.trim_input_to_max_tokens(embed_input, tokens);
}
/**
* Trim input text to satisfy `max_tokens`.
* @private
* @param {string} embed_input - Input text
* @param {number} tokens_ct - Existing token count
* @returns {Promise<string|null>} Trimmed text
*/
async trim_input_to_max_tokens(embed_input, tokens_ct) {
const reduce_ratio = (tokens_ct - this.max_tokens) / tokens_ct;
const new_length = Math.floor(embed_input.length * (1 - reduce_ratio));
let trimmed_input = embed_input.slice(0, new_length);
const last_space_index = trimmed_input.lastIndexOf(" ");
if (last_space_index > 0) trimmed_input = trimmed_input.slice(0, last_space_index);
const prepared = await this.prepare_embed_input(trimmed_input);
if (prepared === null) return null;
return prepared;
}
/** @returns {number} Maximum tokens for an input */
get max_tokens() {
return this.model.data.max_tokens || this.constructor.defaults.max_tokens;
}
/**
* Get the request adapter class.
* @returns {SmartEmbedModelOllamaRequestAdapter} The request adapter class
*/
get req_adapter() {
return SmartEmbedModelOllamaRequestAdapter;
}
/**
* Get the response adapter class.
* @returns {SmartEmbedModelOllamaResponseAdapter} The response adapter class
*/
get res_adapter() {
return SmartEmbedModelOllamaResponseAdapter;
}
/**
* Get available models from local Ollama instance.
* @param {boolean} [refresh=false] - Whether to refresh cached models
* @returns {Promise<Object>} Map of model objects
*/
async get_models(refresh = false) {
if (!this.model_data || refresh) {
const list_resp = await this.http_adapter.request({
url: this.models_endpoint,
method: "GET"
});
if (list_resp.ok === false) {
throw new Error(`Failed to fetch models list: ${list_resp.statusText}`);
}
const list_data = await list_resp.json();
const models_raw = [];
for (const m of filter_embedding_models(list_data.models || [])) {
const detail_resp = await this.http_adapter.request({
url: this.model_show_endpoint,
method: "POST",
body: JSON.stringify({ model: m.name })
});
models_raw.push({ ...await detail_resp.json(), name: m.name });
}
const model_data = this.parse_model_data(models_raw);
this.model_data = model_data;
if (typeof this.model.re_render_settings === "function") {
this.model.re_render_settings();
}
return model_data;
}
return this.model_data;
}
/**
* Get available models as dropdown options synchronously.
* @returns {Array<Object>} Array of model options.
*/
get_models_as_options() {
const models = this.model_data;
if (!Object.keys(models || {}).length) {
this.get_models(true);
return [{ value: "", name: "No models currently available" }];
}
return Object.values(models).map((model) => ({ value: model.id, name: model.name || model.id })).sort((a, b) => a.name.localeCompare(b.name));
}
/**
* Parse model data from Ollama API response.
* @param {Object} model_data - Raw model data from Ollama
* @returns {Object} Map of model objects with capabilities and limits
*/
parse_model_data(model_data) {
if (!Array.isArray(model_data)) {
this.model_data = {};
console.error("Invalid model data format from Ollama:", model_data);
return {};
}
if (model_data.length === 0) {
this.model_data = { "no_models_available": {
id: "no_models_available",
name: "No models currently available"
} };
return this.model_data;
}
this.model_data = model_data.reduce((acc, model) => {
const info = model.model_info || {};
const ctx = Object.entries(info).find(([k]) => k.includes("context_length"))?.[1];
const dims = Object.entries(info).find(([k]) => k.includes("embedding_length"))?.[1];
acc[model.name] = {
model_name: model.name,
id: model.name,
multimodal: false,
max_tokens: ctx || this.max_tokens,
dims,
description: model.description || `Model: ${model.name}`
};
return acc;
}, {});
this._models = this.model_data;
return this.model_data;
}
/**
* Get the models.
* @returns {Object} Map of model objects
*/
get models() {
if (typeof this._models === "object" && Object.keys(this._models || {}).length > 0) return this._models;
else {
return {};
}
}
/**
* Override settings config to remove API key setting since not needed for local instance.
* @returns {Object} Settings configuration object
*/
get settings_config() {
const config = super.settings_config;
delete config["[ADAPTER].api_key"];
config["[ADAPTER].host"] = {
name: "Ollama host",
type: "text",
description: "Enter the host for your Ollama instance",
default: this.constructor.defaults.host
};
return config;
}
};
var SmartEmbedModelOllamaRequestAdapter = class extends SmartEmbedModelRequestAdapter {
static {
__name(this, "SmartEmbedModelOllamaRequestAdapter");
}
/**
* Convert request to Ollama's embed API format.
* @returns {Object} Request parameters in Ollama's format
*/
to_platform() {
const ollama_body = {
model: this.model_id,
input: this.embed_inputs
};
return {
url: this.adapter.endpoint,
method: "POST",
headers: this.get_headers(),
body: JSON.stringify(ollama_body)
};
}
/**
* Prepare request headers for Ollama API.
* @returns {Object} Headers object
*/
get_headers() {
return {
"Content-Type": "application/json"
};
}
};
var SmartEmbedModelOllamaResponseAdapter = class extends SmartEmbedModelResponseAdapter {
static {
__name(this, "SmartEmbedModelOllamaResponseAdapter");
}
/**
* Convert Ollama's response to a standardized OpenAI-like format.
* @returns {Array<Object>} Array of embedding results
*/
to_openai() {
const resp = this.response;
if (!resp || !resp.embeddings) {
console.error("Invalid response format from Ollama:", resp);
return [];
}
const tokens = Math.ceil(resp.prompt_eval_count / this.adapter.batch_size);
const embeddings = resp.embeddings.map((vec) => ({
vec,
tokens
}));
return embeddings;
}
/**
* Parse the response object.
* @returns {Array<Object>} Parsed embedding results
*/
parse_response() {
return this.to_openai();
}
};
var is_embedding_model = /* @__PURE__ */ __name((mod) => {
return ["embed", "embedding", "bge"].some((keyword) => mod.name.toLowerCase().includes(keyword));
}, "is_embedding_model");
var filter_embedding_models = /* @__PURE__ */ __name((models) => {
if (!Array.isArray(models)) {
throw new TypeError("models must be an array");
}
return models.filter(is_embedding_model);
}, "filter_embedding_models");

var GeminiEmbedModelAdapter = class extends SmartEmbedModelApiAdapter {
static {
__name(this, "GeminiEmbedModelAdapter");
}
static defaults = {
adapter: "gemini",
description: "Google Gemini (API)",
default_model: "gemini-embedding-001",
endpoint: "https://generativelanguage.googleapis.com/v1beta/models/gemini-embedding-001:batchEmbedContents",
dims: 768,
max_tokens: 2048,
batch_size: 50
};
/**
* Count tokens in input text using tokenizer
* @param {string} input - Text to tokenize
* @returns {Promise<Object>} Token count result
*/
async count_tokens(input) {
if (!this.tiktoken) await this.load_tiktoken();
return { tokens: this.tiktoken.encode(input).length };
}
/**
* Prepare input text for embedding
* Handles token limit truncation
* @param {string} embed_input - Raw input text
* @returns {Promise<string|null>} Processed input text
*/
async prepare_embed_input(embed_input) {
if (typeof embed_input !== "string") {
throw new TypeError("embed_input must be a string");
}
if (embed_input.length === 0) {
console.log("Warning: prepare_embed_input received an empty string");
return null;
}
const { tokens } = await this.count_tokens(embed_input);
if (tokens <= this.max_tokens) {
return embed_input;
}
return await this.trim_input_to_max_tokens(embed_input, tokens);
}
/**
* Trim input text to fit token limit
* @private
* @param {string} embed_input - Input text to trim
* @param {number} tokens_ct - Current token count
* @returns {Promise<string|null>} Trimmed input text
*/
async trim_input_to_max_tokens(embed_input, tokens_ct) {
const reduce_ratio = (tokens_ct - this.max_tokens) / tokens_ct;
const new_length = Math.floor(embed_input.length * (1 - reduce_ratio));
let trimmed_input = embed_input.slice(0, new_length);
const last_space_index = trimmed_input.lastIndexOf(" ");
if (last_space_index > 0) {
trimmed_input = trimmed_input.slice(0, last_space_index);
}
const prepared_input = await this.prepare_embed_input(trimmed_input);
if (prepared_input === null) {
console.log(
"Warning: prepare_embed_input resulted in an empty string after trimming"
);
return null;
}
return prepared_input;
}
/**
* Get the request adapter class.
* @returns {SmartEmbedGeminiRequestAdapter} The request adapter class
*/
get req_adapter() {
return SmartEmbedGeminiRequestAdapter;
}
/**
* Get the response adapter class.
* @returns {SmartEmbedGeminiResponseAdapter} The response adapter class
*/
get res_adapter() {
return SmartEmbedGeminiResponseAdapter;
}
/** @returns {Object} Settings configuration for Gemini adapter */
get settings_config() {
return {
...super.settings_config,
"[ADAPTER].api_key": {
name: "Google API Key for Gemini embeddings",
type: "password",
description: "Required for Gemini embedding models",
placeholder: "Enter Google API Key"
}
};
}
/**
* Get available models (hardcoded list)
* @returns {Promise<Object>} Map of model objects
*/
get_models() {
return Promise.resolve(this.models);
}
get models() {
return {
"gemini-embedding-001": {
"id": "gemini-embedding-001",
"batch_size": 50,
"dims": 768,
"max_tokens": 2048,
"name": "Gemini Embedding",
"description": "API, 2,048 tokens, 768 dim",
"endpoint": "https://generativelanguage.googleapis.com/v1beta/models/gemini-embedding-001:batchEmbedContents",
"adapter": "gemini"
}
};
}
prepare_request_headers() {
return {
"Content-Type": "application/json",
"x-goog-api-key": this.api_key
};
}
backoff_wait_time = 5e3;
backoff_factor = 1;
async embed_batch(inputs, retries = 0) {
if (smart_env.smart_sources.entities_vector_adapter.is_queue_halted) {
throw new Error("Embedding queue halted during backoff wait due to rate limit errors.");
}
const token_cts = inputs.map((item) => this.estimate_tokens(item.embed_input));
const resp = await super.embed_batch(inputs);
if (resp[0].error && resp[0].error.details && resp[0].error.details.code === 429) {
console.warn("Rate limit error detected in Gemini embed_batch response.", resp);
if (retries > 3) {
console.error("Max retries reached for rate limit errors.");
throw new Error("Max retries reached for rate limit errors.");
}
console.warn(resp[0].error.message);
const retry_detail = resp[0].error.details?.details?.find((d) => d.retryDelay);
if (retry_detail.retryDelay) {
const wait_time_ms = parseInt(retry_detail.retryDelay) * 1e3 * 2;
console.warn(`Using server-specified retry delay of ${wait_time_ms} ms`);
await new Promise((resolve) => setTimeout(resolve, wait_time_ms));
return await this.embed_batch(inputs, retries + 1);
} else {
this.backoff_factor += 1;
console.warn(`Rate limit exceeded, backing off for ${this.backoff_wait_time * this.backoff_factor} ms`);
await new Promise((resolve) => setTimeout(resolve, this.backoff_wait_time * this.backoff_factor));
return await this.embed_batch(inputs, retries + 1);
}
} else if (resp[0].error) {
console.error("Error in Gemini embed_batch response:", resp[0].error);
throw new Error(`Gemini embed_batch error: ${resp[0].error.message}`);
}
resp.forEach((item, idx) => {
item.tokens = token_cts[idx];
});
console.log("Gemini embed_batch response:", resp);
return resp;
}
};
var SmartEmbedGeminiRequestAdapter = class extends SmartEmbedModelRequestAdapter {
static {
__name(this, "SmartEmbedGeminiRequestAdapter");
}
get model_id() {
let model_id = this.adapter.model.data.model_key;
return `models/${model_id}`;
}
/**
* Prepare request body for Gemini API
* @returns {Object} Request body for API
*/
prepare_request_body() {
const requests = this.embed_inputs.map((input) => {
const [title, ...content] = input.split("\n");
const doc_content = content.join("\n").trim() || "";
if (doc_content.length) {
return {
model: this.model_id,
content: {
parts: [{ text: doc_content }]
},
outputDimensionality: this.model_dims,
taskType: "RETRIEVAL_DOCUMENT",
title
};
} else {
return {
model: this.model_id,
content: {
parts: [{ text: title }]
},
outputDimensionality: this.model_dims,
taskType: "RETRIEVAL_DOCUMENT"
};
}
});
return {
requests
};
}
};
var SmartEmbedGeminiResponseAdapter = class extends SmartEmbedModelResponseAdapter {
static {
__name(this, "SmartEmbedGeminiResponseAdapter");
}
/**
* Parse Gemini API response
* @returns {Array<Object>} Parsed embedding results
*/
parse_response() {
const resp = this.response;
console.log("Gemini response:", resp);
if (!resp || !resp.embeddings || !resp.embeddings[0].values) {
console.error("Invalid Gemini embedding response format", resp);
return [];
}
return resp.embeddings.map((embedding, i) => {
if (!embedding.values || embedding.values.length === 0) {
console.warn(`No values for embedding at index ${i}`);
return { vec: [], tokens: 0 };
}
return {
vec: embedding.values,
tokens: null
};
});
}
};

function parse_lm_studio_models(list, adapter_key = "lm_studio") {
if (list.object !== "list" || !Array.isArray(list.data)) {
return { _: { id: "No models found." } };
}
console.log("LM Studio models", list);
return list.data.filter((m) => m.id && m.type === "embeddings").reduce((acc, m) => {
acc[m.id] = {
id: m.id,
model_name: m.id,
max_tokens: m.loaded_context_length || 512,
description: `LM Studio model: ${m.id}`,
adapter: adapter_key
};
return acc;
}, {});
}
__name(parse_lm_studio_models, "parse_lm_studio_models");
var LmStudioEmbedModelAdapter = class extends SmartEmbedModelApiAdapter {
static {
__name(this, "LmStudioEmbedModelAdapter");
}
static key = "lm_studio";
static defaults = {
description: "LM Studio",
type: "API",
host: "http://localhost:1234",
endpoint: "/api/v0/embeddings",
models_endpoint: "/api/v0/models",
default_model: "",
streaming: false,
api_key: "na",
batch_size: 10,
max_tokens: 512
};
get req_adapter() {
return LmStudioEmbedModelRequestAdapter;
}
get res_adapter() {
return LmStudioEmbedModelResponseAdapter;
}
get host() {
return this.model.data.host || this.constructor.defaults.host;
}
get endpoint() {
return `${this.host}${this.constructor.defaults.endpoint}`;
}
get models_endpoint() {
return `${this.host}${this.constructor.defaults.models_endpoint}`;
}
get settings_config() {
const cfg = { ...super.settings_config };
delete cfg["[ADAPTER].api_key"];
cfg["[ADAPTER].refresh_models"] = {
name: "Refresh Models",
type: "button",
description: "Refresh the list of available models.",
callback: "adapter.refresh_models"
};
cfg["[ADAPTER].current_model"] = {
type: "html",
value: `<p>Embedding Model Max Tokens: ${this.max_tokens} (may be configured in LM Studio)</p>`
};
cfg["[ADAPTER].batch_size"] = {
name: "Embedding Batch Size",
type: "number",
description: "Number of embeddings to process in parallel. Adjusting this may improve performance.",
value: this.batch_size,
default: this.constructor.defaults.batch_size
};
cfg["[ADAPTER].cors_note"] = {
name: "CORS required",
type: "html",
value: `<p>Before you can use LM Studio you must <strong>Enable CORS</strong> inside LM Studio \u2192 Developer \u2192 Settings</p>`
};
return cfg;
}
async get_models(refresh = false) {
if (!refresh && this.model.data.provider_models) return this.model.data.provider_models;
const resp = await this.http_adapter.request({
url: this.models_endpoint,
method: "GET"
});
const raw = await resp.json();
const parsed = this.parse_model_data(raw);
this.model.data.provider_models = parsed;
this.model.re_render_settings();
return parsed;
}
parse_model_data(list) {
return parse_lm_studio_models(list, this.constructor.key);
}
async count_tokens(input) {
return { tokens: this.estimate_tokens(input) };
}
/**
* Prepare input text and ensure it fits within `max_tokens`.
* @param {string} embed_input - Raw input text
* @returns {Promise<string|null>} Processed input text
*/
async prepare_embed_input(embed_input) {
if (typeof embed_input !== "string") throw new TypeError("embed_input must be a string");
if (embed_input.length === 0) return null;
const { tokens } = await this.count_tokens(embed_input);
if (tokens <= this.max_tokens) return embed_input;
return await this.trim_input_to_max_tokens(embed_input, tokens);
}
/**
* Refresh available models.
*/
refresh_models() {
console.log("refresh_models");
this.get_models(true);
}
async embed_batch(inputs) {
const token_cts = inputs.map((item) => this.estimate_tokens(item.embed_input));
const resp = await super.embed_batch(inputs);
resp.forEach((item, idx) => {
item.tokens = token_cts[idx];
});
return resp;
}
};
var LmStudioEmbedModelRequestAdapter = class extends SmartEmbedModelRequestAdapter {
static {
__name(this, "LmStudioEmbedModelRequestAdapter");
}
/**
* Prepare request body for LM Studio API
* @returns {Object} Request body for API
*/
prepare_request_body() {
const body = {
model: this.model_id,
input: this.embed_inputs
};
return body;
}
};
var LmStudioEmbedModelResponseAdapter = class extends SmartEmbedModelResponseAdapter {
static {
__name(this, "LmStudioEmbedModelResponseAdapter");
}
/**
* Parse LM Studio API response
* @returns {Array<Object>} Parsed embedding results
*/
parse_response() {
const resp = this.response;
if (!resp || !resp.data) {
console.error("Invalid response format", resp);
return [];
}
return resp.data.map((item) => ({
vec: item.embedding,
tokens: null
}));
}
};

var SmartChatModel = class extends SmartModel {
static {
__name(this, "SmartChatModel");
}
scope_name = "smart_chat_model";
static defaults = {
adapter: "openai"
};
/**
* Create a SmartChatModel instance.
* @param {Object} opts - Configuration options
* @param {string} opts.adapter - Adapter to use
* @param {Object} opts.adapters - Map of adapter names to adapter classes
* @param {Object} opts.settings - Model settings configuration
*/
constructor(opts = {}) {
super(opts);
}
/**
* Get available models.
* @returns {Object} Map of model objects
*/
get models() {
return this.adapter.models;
}
get can_stream() {
return this.adapter.constructor.defaults.streaming;
}
/**
* Complete a chat request.
* @param {Object} req - Request parameters
* @returns {Promise<Object>} Completion result
*/
async complete(req) {
const resp = await this.invoke_adapter_method("complete", req);
if (resp.error) {
throw normalize_error(resp.error);
}
return resp;
}
/**
* Stream chat responses.
* @param {Object} req - Request parameters
* @param {Object} handlers - Event handlers for streaming
* @param {Function} handlers.chunk - Handler for chunks: receives response object
* @param {Function} handlers.error - Handler for errors: receives error object
* @param {Function} handlers.done - Handler for completion: receives final response object
* @returns {Promise<string>} Complete response text
*/
async stream(req, handlers = {}) {
return await this.invoke_adapter_method("stream", req, handlers);
}
/**
* Stop active stream.
*/
stop_stream() {
this.invoke_adapter_method("stop_stream");
}
/**
* Count tokens in input text.
* @param {string|Object} input - Text to count tokens for
* @returns {Promise<number>} Token count
*/
async count_tokens(input) {
return await this.invoke_adapter_method("count_tokens", input);
}
/**
* Test if API key is valid.
* @returns {Promise<boolean>} True if API key is valid
*/
async test_api_key() {
await this.invoke_adapter_method("test_api_key");
this.re_render_settings();
}
/**
* Get default model key.
* @returns {string} Default model key
*/
get default_model_key() {
return this.adapter.constructor.defaults.default_model;
}
/**
* Get current settings.
* @returns {Object} Settings object
*/
get settings() {
return this.opts.settings;
}
/**
* Get settings configuration.
* @returns {Object} Settings configuration object
*/
get settings_config() {
const _settings_config = {
adapter: {
name: "Chat Model Platform",
type: "dropdown",
description: "Select a platform/provider for chat models.",
options_callback: "get_platforms_as_options",
is_scope: true,
callback: "adapter_changed"
},
...this.adapter.settings_config || {}
};
return this.process_settings_config(_settings_config);
}
/**
* Process setting key.
* @param {string} key - Setting key
* @returns {string} Processed key
*/
process_setting_key(key) {
return key.replace(/\[CHAT_ADAPTER\]/g, this.adapter_name);
}
};

var SmartStreamer = class {
static {
__name(this, "SmartStreamer");
}
constructor(url, options = {}) {
const {
method = "GET",
headers = {},
body = null,
withCredentials = false
} = options;
this.url = url;
this.method = method;
this.headers = headers;
this.body = body;
this.withCredentials = withCredentials;
this.listeners = {};
this.readyState = this.CONNECTING;
this.progress = 0;
this.chunk = "";
this.last_event_id = "";
this.xhr = null;
this.FIELD_SEPARATOR = ":";
this.INITIALIZING = -1;
this.CONNECTING = 0;
this.OPEN = 1;
this.CLOSED = 2;
this.chunk_accumulator = "";
this.chunk_splitting_regex = options.chunk_splitting_regex || /(\r\n|\n|\r)/g;
}
/**
* Adds an event listener for the specified event type.
*
* @param {string} type - The type of the event.
* @param {Function} listener - The listener function to be called when the event is triggered.
*/
addEventListener(type, listener) {
if (!this.listeners[type]) this.listeners[type] = [];
if (!this.listeners[type].includes(listener)) this.listeners[type].push(listener);
}
/**
* Removes an event listener from the SmartStreamer instance.
*
* @param {string} type - The type of event to remove the listener from.
* @param {Function} listener - The listener function to remove.
*/
removeEventListener(type, listener) {
if (!this.listeners[type]) return;
this.listeners[type] = this.listeners[type].filter((callback) => callback !== listener);
if (this.listeners[type].length === 0) delete this.listeners[type];
}
/**
* Dispatches an event to the appropriate event handlers.
*
* @param {Event} event - The event to be dispatched.
* @returns {boolean} - Returns true if the event was successfully dispatched, false otherwise.
*/
dispatchEvent(event) {
if (!event) return true;
event.source = this;
const onHandler = "on" + event.type;
if (Object.prototype.hasOwnProperty.call(this, onHandler)) {
this[onHandler].call(this, event);
if (event.defaultPrevented) return false;
}
if (this.listeners[event.type]) {
this.listeners[event.type].forEach((callback) => {
callback(event);
return !event.defaultPrevented;
});
}
return true;
}
/**
* Initiates the streaming process.
*/
stream() {
this.#setReadyState(this.CONNECTING);
this.xhr = new XMLHttpRequest();
this.xhr.addEventListener("progress", this.#onStreamProgress.bind(this));
this.xhr.addEventListener("load", this.#onStreamLoaded.bind(this));
this.xhr.addEventListener("readystatechange", this.#checkStreamClosed.bind(this));
this.xhr.addEventListener("error", this.#onStreamFailure.bind(this));
this.xhr.addEventListener("abort", this.#onStreamAbort.bind(this));
this.xhr.open(this.method, this.url);
for (const header in this.headers) {
this.xhr.setRequestHeader(header, this.headers[header]);
}
if (this.last_event_id) this.xhr.setRequestHeader("Last-Event-ID", this.last_event_id);
this.xhr.withCredentials = this.withCredentials;
this.xhr.send(this.body);
}
/**
* Ends the streamer connection.
* Aborts the current XHR request and sets the ready state to CLOSED.
*/
end() {
if (this.readyState === this.CLOSED) return;
this.xhr.abort();
this.xhr = null;
this.#setReadyState(this.CLOSED);
}
#setReadyState(state) {
const event = new CustomEvent("readyStateChange");
event.readyState = state;
this.readyState = state;
this.dispatchEvent(event);
}
#onStreamFailure(e) {
const event = new CustomEvent("error");
try {
const parsed = JSON.parse(e.currentTarget.response);
if (typeof parsed === "object") {
event.data = parsed;
} else {
event.data = e.currentTarget.response;
}
} catch {
event.data = e.currentTarget.response;
}
this.dispatchEvent(event);
this.end();
}
#onStreamAbort(e) {
const event = new CustomEvent("abort");
this.end();
}
#onStreamProgress(e) {
if (!this.xhr) return;
if (this.xhr.status !== 200) {
this.#onStreamFailure(e);
return;
}
if (this.readyState === this.CONNECTING) {
this.dispatchEvent(new CustomEvent("open"));
this.#setReadyState(this.OPEN);
}
const data = this.xhr.responseText.substring(this.progress);
this.progress += data.length;
const parts = data.split(this.chunk_splitting_regex);
parts.forEach((part, index) => {
if (part.trim().length === 0) {
if (this.chunk) {
this.dispatchEvent(this.#parseEventChunk(this.chunk.trim()));
this.chunk = "";
}
} else {
this.chunk += part;
if (index === parts.length - 1 && this.xhr.readyState === XMLHttpRequest.DONE) {
this.dispatchEvent(this.#parseEventChunk(this.chunk.trim()));
this.chunk = "";
}
}
});
}
#onStreamLoaded(e) {
this.#onStreamProgress(e);
this.dispatchEvent(this.#parseEventChunk(this.chunk));
this.chunk = "";
}
#parseEventChunk(chunk) {
if (!chunk) return console.log("no chunk");
const event = new CustomEvent("message");
event.data = chunk;
event.last_event_id = this.last_event_id;
return event;
}
#checkStreamClosed() {
if (!this.xhr) return;
if (this.xhr.readyState === XMLHttpRequest.DONE) this.#setReadyState(this.CLOSED);
}
};

var SmartChatModelAdapter = class extends SmartModelAdapter {
static {
__name(this, "SmartChatModelAdapter");
}
/**
* @override in sub-class with adapter-specific default configurations
* @property {string} id - The adapter identifier
* @property {string} description - Human-readable description
* @property {string} type - Adapter type ("API")
* @property {string} endpoint - API endpoint
* @property {boolean} streaming - Whether streaming is supported
* @property {string} adapter - Adapter identifier
* @property {string} models_endpoint - Endpoint for retrieving models
* @property {string} default_model - Default model to use
* @property {string} signup_url - URL for API key signup
*/
static defaults = {};
/**
* Create a SmartChatModelAdapter instance.
* @param {SmartChatModel} model - The parent SmartChatModel instance
*/
constructor(model) {
super(model);
this.smart_chat = model;
this.main = model;
}
/**
* Complete a chat request.
* @abstract
* @param {Object} req - Request parameters
* @returns {Promise<Object>} Completion result
*/
async complete(req) {
throw new Error("complete not implemented");
}
/**
* Count tokens in input text.
* @abstract
* @param {string|Object} input - Text to count tokens for
* @returns {Promise<number>} Token count
*/
async count_tokens(input) {
throw new Error("count_tokens not implemented");
}
/**
* Stream chat responses.
* @abstract
* @param {Object} req - Request parameters
* @param {Object} handlers - Event handlers for streaming
* @returns {Promise<string>} Complete response text
*/
async stream(req, handlers = {}) {
throw new Error("stream not implemented");
}
/**
* Test if API key is valid.
* @abstract
* @returns {Promise<boolean>} True if API key is valid
*/
async test_api_key() {
throw new Error("test_api_key not implemented");
}
/**
* Refresh available models.
*/
refresh_models() {
console.log("refresh_models");
this.get_models(true);
}
/**
* Get settings configuration.
* @returns {Object} Settings configuration object
*/
get settings_config() {
return {
"[CHAT_ADAPTER].model_key": {
name: "Chat Model",
type: "dropdown",
description: "Select a chat model.",
options_callback: "adapter.get_models_as_options",
callback: "reload_model",
default: this.constructor.defaults.default_model
},
"[CHAT_ADAPTER].refresh_models": {
name: "Refresh Models",
type: "button",
description: "Refresh the list of available models.",
callback: "adapter.refresh_models"
}
};
}
};

var MODEL_ADAPTER_CACHE = {};
var MODELS_DEV_CACHE = { data: null, fetched_at: 0 };
var SmartChatModelApiAdapter = class extends SmartChatModelAdapter {
static {
__name(this, "SmartChatModelApiAdapter");
}
constructor(model) {
super(model);
this.model_data_loaded_at = 0;
}
/**
* Get the request adapter class.
* @returns {SmartChatModelRequestAdapter} The request adapter class
*/
get req_adapter() {
return SmartChatModelRequestAdapter;
}
/**
* Get the response adapter class.
* @returns {SmartChatModelResponseAdapter} The response adapter class
*/
get res_adapter() {
return SmartChatModelResponseAdapter;
}
/**
* Get or initialize the HTTP adapter.
* @returns {SmartHttpRequest} The HTTP adapter instance
*/
get http_adapter() {
if (!this._http_adapter) {
if (this.model.http_adapter) this._http_adapter = this.model.http_adapter;
else if (this.model.opts.http_adapter) this._http_adapter = this.model.opts.http_adapter;
else this._http_adapter = new SmartHttpRequest({ adapter: SmartHttpRequestFetchAdapter });
}
return this._http_adapter;
}
/**
* Get the settings configuration for the API adapter.
* @deprecated migrating to module export
* @returns {Object} Settings configuration object with API key and other settings
*/
get settings_config() {
return {
...super.settings_config,
"[CHAT_ADAPTER].api_key": {
name: "API Key",
type: "password",
description: "Enter your API key for the chat model platform.",
callback: "test_api_key",
is_scope: true
}
};
}
/**
* Count tokens in the input text.
* @abstract
* @param {string|Object} input - Text or message object to count tokens for
* @returns {Promise<number>} Number of tokens in the input
*/
async count_tokens(input) {
throw new Error("count_tokens not implemented");
}
/**
* Get the parameters for requesting available models.
* @returns {Object} Request parameters for models endpoint
*/
get models_request_params() {
return {
url: this.models_endpoint,
method: this.models_endpoint_method,
headers: {
"Authorization": `Bearer ${this.api_key}`
}
};
}
async get_enriched_model_data() {
const provider_key = this.constructor.models_dev_key || this.constructor.key;
await this.get_models_dev_index();
const provider_data = MODELS_DEV_CACHE.data[provider_key] || {};
const get_limit_i = /* @__PURE__ */ __name((model) => model.limit?.context || 1e4, "get_limit_i");
const get_limit_o = /* @__PURE__ */ __name((model) => model.limit?.output || 1e4, "get_limit_o");
const get_multimodal = /* @__PURE__ */ __name((model) => model.modalities?.input?.includes("image") || false, "get_multimodal");
if (Object.keys(this.model_data || {}).length > 0) {
for (const [key, model] of Object.entries(this.model_data)) {
const enriched = provider_data?.models?.[model.id];
if (!enriched) continue;
this.model_data[key].models_dev = enriched;
this.model_data[key].name = enriched.name || model.name;
this.model_data[key].max_input_tokens = get_limit_i(enriched);
this.model_data[key].max_output_tokens = get_limit_o(enriched);
this.model_data[key].multimodal = get_multimodal(enriched);
this.model_data[key].cost = enriched.cost;
}
} else {
for (const [key, model] of Object.entries(provider_data?.models || {})) {
this.model_data[key] = {
...model,
model_name: model.name,
description: model.name,
max_input_tokens: get_limit_i(model),
max_output_tokens: get_limit_o(model),
multimodal: get_multimodal(model)
};
}
}
return this.model_data;
}
valid_model_data() {
return typeof this.model_data === "object" && Object.keys(this.model_data || {}).length > 0 && this.model_data_loaded_at && Date.now() - this.model_data_loaded_at < 1 * 60 * 60 * 1e3;
}
/**
* Get available models from the API.
* @param {boolean} [refresh=false] - Whether to refresh cached models
* @returns {Promise<Object>} Map of model objects
*/
async get_models(refresh = false) {
if (!refresh && this.valid_model_data()) return this.model_data;
if (this.api_key) {
let response;
try {
response = await this.http_adapter.request(this.models_request_params);
this.model_data = this.parse_model_data(await response.json());
} catch (error) {
console.error("Failed to fetch model data:", { error, response });
}
}
this.model_data = await this.get_enriched_model_data();
this.model_data_loaded_at = Date.now();
if (this.model.data) {
this.model.data.provider_models = this.model_data;
}
if (this.valid_model_data() && typeof this.model.re_render_settings === "function") setTimeout(() => {
this.model.re_render_settings();
}, 100);
else console.warn("Invalid model data, not re-rendering settings");
return this.model_data;
}
/**
* Parses the raw model data from OpenAI API and transforms it into a more usable format.
* @param {Object} model_data - The raw model data received from OpenAI API.
* @abstract
* @returns {Array<Object>} An array of parsed model objects with the following properties:
*   @property {string} model_name - The name/ID of the model as returned by the API.
*   @property {string} id - The id used to identify the model (usually same as model_name).
*   @property {boolean} multimodal - Indicates if the model supports multimodal inputs.
*   @property {number} [max_input_tokens] - The maximum number of input tokens the model can process.
*   @property {string} [description] - A description of the model's context and output capabilities.
*/
parse_model_data(model_data) {
throw new Error("parse_model_data not implemented");
}
/**
* Complete a chat request.
* @param {Object} req - Request parameters
* @returns {Promise<Object>} Completion response in OpenAI format
*/
async complete(req) {
const _req = new this.req_adapter(this, {
...req,
stream: false
});
const request_params = _req.to_platform();
const http_resp = await this.http_adapter.request(request_params);
if (!http_resp) return null;
const _res = new this.res_adapter(this, await http_resp.json());
try {
const resp = _res.to_openai();
return resp;
} catch (error) {
const normalized_error = normalize_error(error?.data || error);
console.error("Error in SmartChatModelApiAdapter.complete():", { normalized_error, error });
console.error(http_resp);
return normalized_error;
}
}
/**
* Stream chat responses.
* @param {Object} req - Request parameters
* @param {Object} handlers - Event handlers for streaming
* @param {Function} handlers.chunk - Handler for response objects
* @param {Function} handlers.error - Handler for errors
* @param {Function} handlers.done - Handler for completion
* @returns {Promise<Object>} Complete response object
*/
async stream(req, handlers = {}) {
const _req = new this.req_adapter(this, req);
const request_params = _req.to_platform(true);
if (this.streaming_chunk_splitting_regex) request_params.chunk_splitting_regex = this.streaming_chunk_splitting_regex;
return await new Promise((resolve, reject) => {
try {
this.active_stream = new SmartStreamer(this.endpoint_streaming, request_params);
const resp_adapter = new this.res_adapter(this);
this.active_stream.addEventListener("message", async (e) => {
if (this.is_end_of_stream(e)) {
await resp_adapter.handle_chunk(e.data);
this.stop_stream();
const final_resp = resp_adapter.to_openai();
handlers.done && await handlers.done(final_resp);
resolve(final_resp);
return;
}
try {
const raw = resp_adapter.handle_chunk(e.data);
handlers.chunk && await handlers.chunk({ ...resp_adapter.to_openai(), raw });
} catch (error) {
const normalized_error = normalize_error({ ...e.data, ...error });
console.error("Error processing stream chunk:", { e, error, normalized_error });
handlers.error && handlers.error(normalized_error);
this.stop_stream();
reject(normalized_error);
}
});
this.active_stream.addEventListener("error", (e) => {
console.error("Stream error:", e);
const normalized_error = normalize_error(e?.data || e);
handlers.error && handlers.error(normalized_error);
this.stop_stream();
reject(normalized_error);
});
this.active_stream.stream();
} catch (err) {
console.error("Failed to start stream:", err);
const normalized_error = normalize_error(err?.data || err);
handlers.error && handlers.error(normalized_error);
this.stop_stream();
reject(normalized_error);
}
});
}
/**
* Check if a stream event indicates end of stream.
* @param {Event} event - Stream event
* @returns {boolean} True if end of stream
*/
is_end_of_stream(event) {
return event.data === "data: [DONE]";
}
/**
* Stop active stream.
*/
stop_stream() {
if (this.active_stream) {
this.active_stream.end();
this.active_stream = null;
}
}
/**
* Get the API key.
* @returns {string} The API key.
*/
get api_key() {
return this.model.api_key || this.main.opts.api_key;
}
get models_endpoint() {
return this.constructor.defaults.models_endpoint;
}
get models_endpoint_method() {
return "POST";
}
/**
* Get the endpoint URL.
* @returns {string} The endpoint URL.
*/
get endpoint() {
return this.constructor.defaults.endpoint;
}
/**
* Get the streaming endpoint URL.
* @returns {string} The streaming endpoint URL.
*/
get endpoint_streaming() {
return this.constructor.defaults.endpoint_streaming || this.endpoint;
}
/**
* Get the maximum output tokens.
* @returns {number} The maximum output tokens.
*/
get max_output_tokens() {
return this.model.data.max_output_tokens || 3e3;
}
async get_models_dev_index(ttl_ms = 60 * 60 * 1e3) {
const now = Date.now();
if (MODELS_DEV_CACHE?.data && now - MODELS_DEV_CACHE?.fetched_at < ttl_ms) {
return MODELS_DEV_CACHE.data;
}
try {
const req = {
url: "https://models.dev/api.json",
method: "GET",
headers: { "Content-Type": "application/json" }
};
const resp = await this.http_adapter.request(req);
const data = await resp.json();
MODELS_DEV_CACHE.data = data;
MODELS_DEV_CACHE.fetched_at = now;
console.log({ MODELS_DEV_CACHE });
return data;
} catch (err) {
console.warn("models.dev fetch failed; continuing without enrichment", err);
return MODELS_DEV_CACHE.data || [];
}
}
/**
* Get available models as dropdown options synchronously.
* @returns {Array<Object>} Array of model options.
*/
get_models_as_options() {
if (Object.keys(this.model_data || {}).length) {
return Object.entries(this.model_data).map(([id, model]) => ({ value: id, name: model.name || id })).sort((a, b) => a.name.localeCompare(b.name));
}
this.get_models(true);
return [{ value: "", name: "No models currently available" }];
}
get model_data() {
if (!MODEL_ADAPTER_CACHE[this.constructor.key]) MODEL_ADAPTER_CACHE[this.constructor.key] = {};
return MODEL_ADAPTER_CACHE[this.constructor.key];
}
set model_data(data) {
if (!MODEL_ADAPTER_CACHE[this.constructor.key]) MODEL_ADAPTER_CACHE[this.constructor.key] = {};
MODEL_ADAPTER_CACHE[this.constructor.key] = data;
}
};
var SmartChatModelRequestAdapter = class {
static {
__name(this, "SmartChatModelRequestAdapter");
}
/**
* @constructor
* @param {SmartChatModelAdapter} adapter - The SmartChatModelAdapter instance
* @param {Object} req - The incoming request object
*/
constructor(adapter, req = {}) {
this.adapter = adapter;
this._req = req;
}
/**
* Get the messages array from the request
* @returns {Array<Object>} Array of message objects
*/
get messages() {
return this._req.messages || [];
}
/**
* Get the model identifier
* @returns {string} Model ID
*/
get model_id() {
return this._req.model || this.adapter.model.model_key || this.adapter.model.data.id;
}
/**
* Get the temperature setting
* @returns {number} Temperature value
*/
get temperature() {
return this._req.temperature;
}
/**
* Get the maximum tokens setting
* @returns {number} Max tokens value
*/
get max_tokens() {
return this._req.max_tokens || this.adapter.max_output_tokens;
}
/**
* Get the streaming flag
* @returns {boolean} Whether to stream responses
*/
get stream() {
return this._req.stream;
}
/**
* Get the tools array
* @returns {Array<Object>|null} Array of tool objects or null
*/
get tools() {
return this._req.tools || null;
}
/**
* Get the tool choice setting
* @returns {string|Object|null} Tool choice configuration
*/
get tool_choice() {
return this._req.tool_choice || null;
}
get frequency_penalty() {
return this._req.frequency_penalty;
}
get presence_penalty() {
return this._req.presence_penalty;
}
get top_p() {
return this._req.top_p;
}
/**
* Get request headers
* @returns {Object} Headers object
*/
get_headers() {
const headers = {
"Content-Type": "application/json",
...this.adapter.constructor.defaults.headers || {}
};
const api_key_header = this.adapter.constructor.defaults.api_key_header;
if (api_key_header !== "none") {
if (api_key_header) {
headers[api_key_header] = this.adapter.api_key;
} else if (this.adapter.api_key) {
headers["Authorization"] = `Bearer ${this.adapter.api_key}`;
}
}
return headers;
}
/**
* Convert request to platform-specific format
* @returns {Object} Platform-specific request parameters
*/
to_platform(streaming = false) {
return this.to_openai(streaming);
}
/**
* Convert request to OpenAI format
* @returns {Object} Request parameters in OpenAI format
*/
to_openai(streaming = false) {
const body = {
messages: this._transform_messages_to_openai(),
model: this.model_id,
temperature: this.temperature,
stream: streaming,
...this.tools && { tools: this._transform_tools_to_openai() }
};
if (body.tools?.length > 0 && this.tool_choice && this.tool_choice !== "none") {
body.tool_choice = this.tool_choice;
}
if (this.model_id?.startsWith("o1-")) {
body.messages = body.messages.filter((m) => m.role !== "system");
delete body.temperature;
}
if (typeof this._req.top_p === "number") body.top_p = this._req.top_p;
if (typeof this._req.presence_penalty === "number") body.presence_penalty = this._req.presence_penalty;
if (typeof this._req.frequency_penalty === "number") body.frequency_penalty = this._req.frequency_penalty;
return {
url: this.adapter.endpoint,
method: "POST",
headers: this.get_headers(),
body: JSON.stringify(body)
};
}
/**
* Transform messages to OpenAI format
* @returns {Array<Object>} Transformed messages array
* @private
*/
_transform_messages_to_openai() {
return this.messages.map((message) => this._transform_single_message_to_openai(message));
}
/**
* Transform a single message to OpenAI format
* @param {Object} message - Message object to transform
* @returns {Object} Transformed message object
* @private
*/
_transform_single_message_to_openai(message) {
const transformed = {
role: this._get_openai_role(message.role),
content: this._get_openai_content(message)
};
if (message.name) transformed.name = message.name;
if (message.tool_calls) transformed.tool_calls = this._transform_tool_calls_to_openai(message.tool_calls);
if (message.image_url) transformed.image_url = message.image_url;
if (message.tool_call_id) transformed.tool_call_id = message.tool_call_id;
return transformed;
}
/**
* Get the OpenAI role for a given role.
* @param {string} role - The role to transform.
* @returns {string} The transformed role.
* @private
*/
_get_openai_role(role) {
return role;
}
/**
* Get the OpenAI content for a given content.
* @param {string} content - The content to transform.
* @returns {string} The transformed content.
* @private
*/
_get_openai_content(message) {
return message.content;
}
/**
* Transform tool calls to OpenAI format.
* @param {Array} tool_calls - Array of tool call objects.
* @returns {Array} Transformed tool calls array.
* @private
*/
_transform_tool_calls_to_openai(tool_calls) {
return tool_calls.map((tool_call) => ({
id: tool_call.id,
type: tool_call.type,
function: {
name: tool_call.function.name,
arguments: tool_call.function.arguments
}
}));
}
/**
* Transform tools to OpenAI format.
* @returns {Array} Transformed tools array.
* @private
*/
_transform_tools_to_openai() {
return this.tools.map((tool2) => ({
type: tool2.type,
function: {
name: tool2.function.name,
description: tool2.function.description,
parameters: tool2.function.parameters
}
}));
}
};
var SmartChatModelResponseAdapter = class {
static {
__name(this, "SmartChatModelResponseAdapter");
}
static get platform_res() {
return {
id: "",
object: "chat.completion",
created: 0,
model: "",
choices: [],
usage: {}
};
}
/**
* @constructor
* @param {SmartChatModelAdapter} adapter - The SmartChatModelAdapter instance
* @param {Object} res - The response object
*/
constructor(adapter, res, status = null) {
this.adapter = adapter;
this._res = res || this.constructor.platform_res;
this.status = status;
}
/**
* Get response ID
* @returns {string|null} Response ID
*/
get id() {
return this._res.id || null;
}
/**
* Get response object type
* @returns {string|null} Object type
*/
get object() {
return this._res.object || null;
}
/**
* Get creation timestamp
* @returns {number|null} Creation timestamp
*/
get created() {
return this._res.created || null;
}
/**
* Get response choices
* @returns {Array<Object>} Array of choice objects
*/
get choices() {
return this._res.choices || [];
}
/**
* Get first tool call if present
* @returns {Object|null} Tool call object
*/
get tool_call() {
return this.message.tool_calls?.[0] || null;
}
/**
* Get tool name from first tool call
* @returns {string|null} Tool name
*/
get tool_name() {
return this.tool_call?.tool_name || null;
}
/**
* Get tool call parameters
* @returns {Object|null} Tool parameters
*/
get tool_call_content() {
return this.tool_call?.parameters || null;
}
/**
* Get token usage statistics
* @returns {Object|null} Usage statistics
*/
get usage() {
return this._res.usage || null;
}
get error() {
return this._res.error || null;
}
/**
* Convert response to OpenAI format
* @returns {Object} Response in OpenAI format
*/
to_openai() {
if (this.error) return { error: normalize_error(this.error, this.status) };
const res = {
id: this.id,
object: this.object,
created: this.created,
choices: this._transform_choices_to_openai(),
usage: this._transform_usage_to_openai(),
raw: this._res
};
return res;
}
/**
* Parse chunk adds delta to content as expected output format
*/
handle_chunk(chunk) {
if (chunk === "data: [DONE]") return;
chunk = JSON.parse(chunk.split("data: ")[1] || "{}");
if (Object.keys(chunk).length === 0) return;
if (!this._res.choices[0]) {
this._res.choices.push({
message: {
index: 0,
role: "assistant",
content: ""
}
});
}
if (!this._res.id) {
this._res.id = chunk.id;
}
let raw;
if (chunk.choices?.[0]?.delta?.content) {
const content = chunk.choices[0].delta.content;
raw = content;
this._res.choices[0].message.content += content;
}
if (chunk.choices?.[0]?.delta?.tool_calls) {
if (!this._res.choices[0].message.tool_calls) {
this._res.choices[0].message.tool_calls = [{
id: "",
type: "function",
function: {
name: "",
arguments: ""
}
}];
}
if (chunk.choices[0].delta.tool_calls[0].id) {
this._res.choices[0].message.tool_calls[0].id += chunk.choices[0].delta.tool_calls[0].id;
}
if (chunk.choices[0].delta.tool_calls[0].function.name) {
this._res.choices[0].message.tool_calls[0].function.name += chunk.choices[0].delta.tool_calls[0].function.name;
}
if (chunk.choices[0].delta.tool_calls[0].function.arguments) {
this._res.choices[0].message.tool_calls[0].function.arguments += chunk.choices[0].delta.tool_calls[0].function.arguments;
}
}
return raw;
}
/**
* Transform choices to OpenAI format.
* @returns {Array} Transformed choices array.
* @private
*/
_transform_choices_to_openai() {
return this.choices.map((choice) => ({
index: choice.index,
message: this._transform_message_to_openai(choice.message),
finish_reason: this._get_openai_finish_reason(choice.finish_reason)
}));
}
/**
* Transform a single message to OpenAI format.
* @param {Object} message - The message object to transform.
* @returns {Object} Transformed message object.
* @private
*/
_transform_message_to_openai(message = {}) {
const transformed = {
role: this._get_openai_role(message.role),
content: this._get_openai_content(message)
};
if (message.name) transformed.name = message.name;
if (message.tool_calls) transformed.tool_calls = this._transform_tool_calls_to_openai(message.tool_calls);
if (message.image_url) transformed.image_url = message.image_url;
return transformed;
}
/**
* Get the OpenAI role for a given role.
* @param {string} role - The role to transform.
* @returns {string} The transformed role.
* @private
*/
_get_openai_role(role) {
return role;
}
/**
* Get the OpenAI content for a given content.
* @param {string} content - The content to transform.
* @returns {string} The transformed content.
* @private
*/
_get_openai_content(message) {
return message.content;
}
/**
* Get the OpenAI finish reason for a given finish reason.
* @param {string} finish_reason - The finish reason to transform.
* @returns {string} The transformed finish reason.
* @private
*/
_get_openai_finish_reason(finish_reason) {
return finish_reason;
}
/**
* Transform usage to OpenAI format.
* @returns {Object} Transformed usage object.
* @private
*/
_transform_usage_to_openai() {
return this.usage;
}
/**
* Transform tool calls to OpenAI format.
* @param {Array} tool_calls - Array of tool call objects.
* @returns {Array} Transformed tool calls array.
* @private
*/
_transform_tool_calls_to_openai(tool_calls) {
return tool_calls.map((tool_call) => ({
id: tool_call.id,
type: tool_call.type,
function: {
name: tool_call.function.name,
arguments: tool_call.function.arguments
}
}));
}
};

var SmartChatModelAnthropicAdapter = class extends SmartChatModelApiAdapter {
static {
__name(this, "SmartChatModelAnthropicAdapter");
}
static key = "anthropic";
static defaults = {
description: "Anthropic Claude",
type: "API",
endpoint: "https://api.anthropic.com/v1/messages",
streaming: true,
api_key_header: "x-api-key",
headers: {
"anthropic-version": "2023-06-01",
"anthropic-beta": "tools-2024-04-04",
"anthropic-dangerous-direct-browser-access": true
},
adapter: "Anthropic",
models_endpoint: false,
default_model: "claude-opus-4-1-20250805",
signup_url: "https://console.anthropic.com/login?returnTo=%2Fsettings%2Fkeys"
};
/**
* Get request adapter class
* @returns {typeof SmartChatModelAnthropicRequestAdapter} Request adapter class
*/
get req_adapter() {
return SmartChatModelAnthropicRequestAdapter;
}
/**
* Get response adapter class
* @returns {typeof SmartChatModelAnthropicResponseAdapter} Response adapter class
*/
res_adapter = SmartChatModelAnthropicResponseAdapter;
/**
* Get available models (hardcoded list) and enrich via models.dev
* @returns {Promise<Object>} Map of model objects
*/
async get_models() {
try {
this.model_data = await this.get_enriched_model_data();
this.model_data_loaded_at = Date.now();
this.model.data.provider_models = this.model_data;
setTimeout(() => {
this.model.re_render_settings();
}, 100);
return this.model_data;
} catch {
return this.anthropic_models;
}
}
is_end_of_stream(event) {
return event.data.includes("message_stop");
}
/**
* Get hardcoded list of available models
* @deprecated use get_enriched_model_data() instead (remove after no-incidents)
* @returns {Object} Map of model objects with capabilities and limits
*/
get anthropic_models() {
return {
"claude-opus-4-1-20250805": {
name: "Claude Opus 4.1 (2025-08-05)",
id: "claude-opus-4-1-20250805",
model_name: "claude-opus-4-1-20250805",
description: "Anthropic Claude Opus 4.1 snapshot (2025-08-05)",
max_input_tokens: 2e5,
max_output_tokens: 32e3,
multimodal: true
},
"claude-opus-4-20250514": {
name: "Claude Opus 4 (2025-05-14)",
id: "claude-opus-4-20250514",
model_name: "claude-opus-4-20250514",
description: "Anthropic Claude Opus 4 snapshot (2025-05-14)",
max_input_tokens: 2e5,
max_output_tokens: 32e3,
multimodal: true
},
"claude-sonnet-4-20250514": {
name: "Claude Sonnet 4 (2025-05-14)",
id: "claude-sonnet-4-20250514",
model_name: "claude-sonnet-4-20250514",
description: "Anthropic Claude Sonnet 4 snapshot (2025-05-14)",
max_input_tokens: 2e5,
max_output_tokens: 64e3,
multimodal: true
},
"claude-3-7-sonnet-latest": {
name: "Claude 3.7 Sonnet (latest)",
id: "claude-3-7-sonnet-latest",
model_name: "claude-3-7-sonnet-latest",
description: "Anthropic Claude 3.7 Sonnet (rolling-latest)",
max_input_tokens: 2e5,
max_output_tokens: 64e3,
multimodal: true
},
"claude-3-7-sonnet-20250219": {
name: "Claude 3.7 Sonnet (2025-02-19)",
id: "claude-3-7-sonnet-20250219",
model_name: "claude-3-7-sonnet-20250219",
description: "Anthropic Claude 3.7 Sonnet snapshot (2025-02-19)",
max_input_tokens: 2e5,
max_output_tokens: 64e3,
multimodal: true
},
"claude-3-5-sonnet-latest": {
name: "Claude 3.5 Sonnet (latest)",
id: "claude-3-5-sonnet-latest",
model_name: "claude-3-5-sonnet-latest",
description: "Anthropic Claude 3.5 Sonnet (rolling-latest)",
max_input_tokens: 2e5,
max_output_tokens: 8192,
multimodal: true
},
"claude-3-5-sonnet-20241022": {
name: "Claude 3.5 Sonnet (2024-10-22)",
id: "claude-3-5-sonnet-20241022",
model_name: "claude-3-5-sonnet-20241022",
description: "Anthropic Claude 3.5 Sonnet snapshot (2024-10-22)",
max_input_tokens: 2e5,
max_output_tokens: 8192,
multimodal: true
},
"claude-3-5-haiku-latest": {
name: "Claude 3.5 Haiku (latest)",
id: "claude-3-5-haiku-latest",
model_name: "claude-3-5-haiku-latest",
description: "Anthropic Claude 3.5 Haiku (rolling-latest)",
max_input_tokens: 2e5,
max_output_tokens: 8192
},
"claude-3-5-haiku-20241022": {
name: "Claude 3.5 Haiku (2024-10-22)",
id: "claude-3-5-haiku-20241022",
model_name: "claude-3-5-haiku-20241022",
description: "Anthropic Claude 3.5 Haiku snapshot (2024-10-22)",
max_input_tokens: 2e5,
max_output_tokens: 8192
},
"claude-3-opus-latest": {
name: "Claude 3 Opus (latest)",
id: "claude-3-opus-latest",
model_name: "claude-3-opus-latest",
description: "Anthropic Claude 3 Opus (rolling-latest)",
max_input_tokens: 2e5,
max_output_tokens: 4096,
multimodal: true
},
"claude-3-opus-20240229": {
name: "Claude 3 Opus (2024-02-29)",
id: "claude-3-opus-20240229",
model_name: "claude-3-opus-20240229",
description: "Anthropic Claude 3 Opus snapshot (2024-02-29)",
max_input_tokens: 2e5,
max_output_tokens: 4096,
multimodal: true
},
"claude-3-sonnet-20240229": {
name: "Claude 3 Sonnet (2024-02-29)",
id: "claude-3-sonnet-20240229",
model_name: "claude-3-sonnet-20240229",
description: "Anthropic Claude 3 Sonnet snapshot (2024-02-29)",
max_input_tokens: 2e5,
max_output_tokens: 4096,
multimodal: true
},
"claude-3-haiku-20240307": {
name: "Claude 3 Haiku (2024-03-07)",
id: "claude-3-haiku-20240307",
model_name: "claude-3-haiku-20240307",
description: "Anthropic Claude 3 Haiku snapshot (2024-03-07)",
max_input_tokens: 2e5,
max_output_tokens: 4096,
multimodal: true
}
};
}
};
var SmartChatModelAnthropicRequestAdapter = class extends SmartChatModelRequestAdapter {
static {
__name(this, "SmartChatModelAnthropicRequestAdapter");
}
/**
* Convert request to Anthropic format
* @returns {Object} Request parameters in Anthropic format
*/
to_platform(streaming = false) {
return this.to_anthropic(streaming);
}
/**
* Convert request to Anthropic format
* @returns {Object} Request parameters in Anthropic format
*/
to_anthropic(streaming = false) {
this.anthropic_body = {
model: this.model_id,
max_tokens: this.max_tokens,
temperature: this.temperature,
stream: streaming
};
this.anthropic_body.messages = this._transform_messages_to_anthropic();
if (this.tools) {
this.anthropic_body.tools = this._transform_tools_to_anthropic();
}
if (this.tool_choice) {
this.anthropic_body.tool_choice = this.tool_choice === "auto" ? { type: "auto" } : { type: "tool", name: this.tool_choice.function.name };
}
return {
url: this.adapter.endpoint,
method: "POST",
headers: this.get_headers(),
body: JSON.stringify(this.anthropic_body)
};
}
/**
* Transform messages to Anthropic format
* @returns {Array<Object>} Messages in Anthropic format
* @private
*/
_transform_messages_to_anthropic() {
let anthropic_messages = [];
for (const message of this.messages) {
if (message.role === "system") {
if (!this.anthropic_body.system) this.anthropic_body.system = "";
else this.anthropic_body.system += "\n\n";
this.anthropic_body.system += Array.isArray(message.content) ? message.content.map((part) => part.text).join("\n") : message.content;
} else if (message.role === "tool") {
const msg = {
role: "user",
content: [
{
type: "tool_result",
tool_use_id: message.tool_call_id,
content: message.content
}
]
};
anthropic_messages.push(msg);
} else {
const msg = {
role: this._get_anthropic_role(message.role),
content: this._get_anthropic_content(message.content)
};
if (message.tool_calls?.length > 0) msg.content = this._transform_tool_calls_to_content(message.tool_calls);
anthropic_messages.push(msg);
}
}
return anthropic_messages;
}
/**
* Transform tool calls to Anthropic format
* @param {Array<Object>} tool_calls - Tool calls
* @returns {Array<Object>} Tool calls in Anthropic format
* @private
*/
_transform_tool_calls_to_content(tool_calls) {
return tool_calls.map((tool_call) => ({
type: "tool_use",
id: tool_call.id,
name: tool_call.function.name,
input: JSON.parse(tool_call.function.arguments)
}));
}
/**
* Transform role to Anthropic format
* @param {string} role - Original role
* @returns {string} Role in Anthropic format
* @private
*/
_get_anthropic_role(role) {
const role_map = {
function: "assistant",
tool: "user"
};
return role_map[role] || role;
}
/**
* Transform content to Anthropic format
* @param {string|Array} content - Original content
* @returns {string|Array} Content in Anthropic format
* @private
*/
_get_anthropic_content(content) {
if (Array.isArray(content)) {
return content.map((item) => {
if (item.type === "text") return { type: "text", text: item.text };
if (item.type === "image_url") {
return {
type: "image",
source: {
type: "base64",
media_type: item.image_url.url.split(";")[0].split(":")[1],
data: item.image_url.url.split(",")[1]
}
};
}
if (item.type === "file" && item.file?.filename?.toLowerCase().endsWith(".pdf")) {
if (item.file?.file_data) {
return {
type: "document",
source: {
type: "base64",
media_type: "application/pdf",
data: item.file.file_data.split(",")[1]
}
};
}
}
return item;
});
}
return content;
}
/**
* Transform tools to Anthropic format
* @returns {Array<Object>} Tools in Anthropic format
* @private
*/
_transform_tools_to_anthropic() {
if (!this.tools) return void 0;
return this.tools.map((tool2) => ({
name: tool2.function.name,
description: tool2.function.description,
input_schema: tool2.function.parameters
}));
}
};
var SmartChatModelAnthropicResponseAdapter = class extends SmartChatModelResponseAdapter {
static {
__name(this, "SmartChatModelAnthropicResponseAdapter");
}
static get platform_res() {
return {
content: [],
id: "",
model: "",
role: "assistant",
stop_reason: null,
stop_sequence: null,
type: "message",
usage: {
input_tokens: 0,
output_tokens: 0
}
};
}
/**
* Convert response to OpenAI format
* @returns {Object} Response in OpenAI format
*/
to_openai() {
if (this.error) return { error: normalize_error(this.error, this.status) };
return {
id: this._res.id,
object: "chat.completion",
created: Date.now(),
choices: [
{
index: 0,
message: this._transform_message_to_openai(),
finish_reason: this._get_openai_finish_reason(this._res.stop_reason)
}
],
usage: this._transform_usage_to_openai()
};
}
/**
* Transform message to OpenAI format
* @returns {Object} Message in OpenAI format
* @private
*/
_transform_message_to_openai() {
const message = {
role: "assistant",
content: "",
tool_calls: []
};
if (Array.isArray(this._res.content)) {
for (const content of this._res.content) {
if (content.type === "text") {
message.content += (message.content ? "\n\n" : "") + content.text;
} else if (content.type === "tool_use") {
message.tool_calls.push({
id: content.id,
type: "function",
function: {
name: content.name,
arguments: JSON.stringify(content.input)
}
});
}
}
} else {
message.content = this._res.content;
}
if (message.tool_calls.length === 0) {
delete message.tool_calls;
}
return message;
}
/**
* Transform finish reason to OpenAI format
* @param {string} stop_reason - Original finish reason
* @returns {string} Finish reason in OpenAI format
* @private
*/
_get_openai_finish_reason(stop_reason) {
const reason_map = {
"end_turn": "stop",
"max_tokens": "length",
"tool_use": "function_call"
};
return reason_map[stop_reason] || stop_reason;
}
/**
* Transform usage statistics to OpenAI format
* @returns {Object} Usage statistics in OpenAI format
* @private
*/
_transform_usage_to_openai() {
if (!this._res.usage) {
return {
prompt_tokens: 0,
completion_tokens: 0,
total_tokens: 0
};
}
return {
prompt_tokens: this._res.usage.input_tokens || 0,
completion_tokens: this._res.usage.output_tokens || 0,
total_tokens: (this._res.usage.input_tokens || 0) + (this._res.usage.output_tokens || 0)
};
}
handle_chunk(chunk) {
if (!chunk.startsWith("data: ")) return;
chunk = JSON.parse(chunk.slice(6));
if (!this._res.content.length) {
this._res.content = [
{
type: "text",
text: ""
}
];
}
if (chunk.message?.id) {
this._res.id = chunk.message.id;
}
if (chunk.message?.model) {
this._res.model = chunk.message.model;
}
if (chunk.message?.role) {
this._res.role = chunk.message.role;
}
let raw;
if (chunk.delta?.type === "text_delta") {
const content = chunk.delta?.text;
raw = content;
this._res.content[0].text += content;
}
if (chunk.delta?.stop_reason) {
this._res.stop_reason = chunk.delta.stop_reason;
}
if (chunk.usage) {
this._res.usage = {
...this._res.usage,
...chunk.usage
};
}
return raw;
}
};

var EXCLUDED_PREFIXES = [
"text-",
"davinci",
"babbage",
"ada",
"curie",
"dall-e",
"whisper",
"omni",
"tts",
"gpt-4o-mini-tts",
"computer-use",
"codex",
"gpt-4o-transcribe",
"gpt-4o-mini-transcribe",
"gpt-4o-mini-realtime",
"gpt-4o-realtime",
"o4-mini-deep-research",
"o3-deep-research",
"gpt-image"
];
var SmartChatModelOpenaiAdapter = class extends SmartChatModelApiAdapter {
static {
__name(this, "SmartChatModelOpenaiAdapter");
}
static key = "openai";
static defaults = {
description: "OpenAI",
type: "API",
endpoint: "https://api.openai.com/v1/chat/completions",
streaming: true,
models_endpoint: "https://api.openai.com/v1/models",
default_model: "gpt-5-nano",
signup_url: "https://platform.openai.com/api-keys"
};
res_adapter = SmartChatModelOpenaiResponseAdapter;
/**
* Parse model data from OpenAI API response.
* Filters for GPT models and adds context window information.
* @param {Object} model_data - Raw model data from OpenAI
* @returns {Object} Map of model objects with capabilities and limits
*/
parse_model_data(model_data) {
return model_data.data.filter((model) => !EXCLUDED_PREFIXES.some((m) => model.id.startsWith(m)) && !model.id.includes("-instruct")).reduce((acc, model) => {
const out = {
model_name: model.id,
id: model.id,
multimodal: true,
max_input_tokens: get_max_input_tokens(model.id)
};
acc[model.id] = out;
return acc;
}, {});
}
/**
* Override the HTTP method for fetching models.
*/
models_endpoint_method = "GET";
/**
* Test the API key by attempting to fetch models.
* @returns {Promise<boolean>} True if API key is valid
*/
async test_api_key() {
const models = await this.get_models();
return models.length > 0;
}
/**
* Get settings configuration for OpenAI adapter.
* Adds image resolution setting for multimodal models.
* @returns {Object} Settings configuration object
*/
get settings_config() {
const config = super.settings_config;
config["[CHAT_ADAPTER].open_ai_note"] = {
name: "Note about using OpenAI",
type: "html",
value: "<b>OpenAI models:</b> Some models require extra verification steps in your OpenAI account for them to appear in the model list."
};
return config;
}
};
function get_max_input_tokens(model_id) {
if (model_id.startsWith("gpt-4.1")) {
return 1e6;
}
if (model_id.startsWith("o")) {
return 2e5;
}
if (model_id.startsWith("gpt-5")) {
return 4e5;
}
if (model_id.startsWith("gpt-4o") || model_id.startsWith("gpt-4.5") || model_id.startsWith("gpt-4-turbo")) {
return 128e3;
}
if (model_id.startsWith("gpt-4")) {
return 8192;
}
if (model_id.startsWith("gpt-3")) {
return 16385;
}
return 8e3;
}
__name(get_max_input_tokens, "get_max_input_tokens");
var SmartChatModelOpenaiResponseAdapter = class extends SmartChatModelResponseAdapter {
static {
__name(this, "SmartChatModelOpenaiResponseAdapter");
}
};

var SmartChatModelAzureAdapter = class extends SmartChatModelOpenaiAdapter {
static {
__name(this, "SmartChatModelAzureAdapter");
}
static key = "azure";
static defaults = {
description: "Azure OpenAI",
type: "API",
adapter: "AzureOpenAI",
streaming: true,
api_key_header: "api-key",
azure_resource_name: "",
azure_deployment_name: "",
azure_api_version: "2024-10-01-preview",
default_model: "gpt-35-turbo",
signup_url: "https://learn.microsoft.com/azure/cognitive-services/openai/quickstart?tabs=command-line",
models_endpoint: "https://{azure_resource_name}.openai.azure.com/openai/deployments?api-version={azure_api_version}"
};
/**
* Override the settings configuration to include Azure-specific fields.
*/
get settings_config() {
return {
...super.settings_config,
"[CHAT_ADAPTER].azure_resource_name": {
name: "Azure Resource Name",
type: "text",
description: "The name of your Azure OpenAI resource (e.g. 'my-azure-openai').",
default: ""
},
"[CHAT_ADAPTER].azure_deployment_name": {
name: "Azure Deployment Name",
type: "text",
description: "The name of your specific model deployment (e.g. 'gpt35-deployment').",
default: ""
},
"[CHAT_ADAPTER].azure_api_version": {
name: "Azure API Version",
type: "text",
description: "The API version for Azure OpenAI (e.g. '2024-10-01-preview').",
default: "2024-10-01-preview"
}
};
}
/**
* Build the endpoint dynamically based on Azure settings.
* Example:
*  https://<RESOURCE>.openai.azure.com/openai/deployments/<DEPLOYMENT>/chat/completions?api-version=2023-05-15
*/
get endpoint() {
const { azure_resource_name, azure_deployment_name, azure_api_version } = this.model.data;
return `https://${azure_resource_name}.openai.azure.com/openai/deployments/${azure_deployment_name}/chat/completions?api-version=${azure_api_version}`;
}
/**
* For streaming, we can reuse the same endpoint.
* The request body includes `stream: true` which the base class uses.
*/
get endpoint_streaming() {
return this.endpoint;
}
/**
* The models endpoint for retrieving a list of your deployments.
* E.g.:
*   https://<RESOURCE>.openai.azure.com/openai/deployments?api-version=2023-05-15
*/
get models_endpoint() {
const { azure_resource_name, azure_api_version } = this.model.data;
return `https://${azure_resource_name}.openai.azure.com/openai/deployments?api-version=${azure_api_version}`;
}
/**
* Azure returns a list of deployments in the shape:
* {
*   "object": "list",
*   "data": [
*     {
*       "id": "mydeployment",
*       "model": "gpt-35-turbo",
*       "status": "succeeded",
*       "createdAt": ...
*       "updatedAt": ...
*       ...
*     },
*     ...
*   ]
* }
* We'll parse them into a dictionary keyed by deployment ID.
*/
parse_model_data(model_data) {
if (model_data.object !== "list" || !Array.isArray(model_data.data)) {
return { "_": { id: "No deployments found." } };
}
const parsed = {};
for (const d of model_data.data) {
parsed[d.id] = {
model_name: d.id,
id: d.id,
raw: d,
description: `Model: ${d.model}, Status: ${d.status}`,
max_input_tokens: 4e3
};
}
return parsed;
}
};

var SmartChatModelGoogleAdapter = class extends SmartChatModelApiAdapter {
static {
__name(this, "SmartChatModelGoogleAdapter");
}
static key = "google";
static defaults = {
description: "Google (Gemini)",
type: "API",
api_key_header: "none",
endpoint: "https://generativelanguage.googleapis.com/v1beta/models/MODEL_NAME:generateContent",
endpoint_streaming: "https://generativelanguage.googleapis.com/v1beta/models/MODEL_NAME:streamGenerateContent",
streaming: true,
adapter: "Gemini",
models_endpoint: "https://generativelanguage.googleapis.com/v1beta/models",
default_model: "gemini-1.5-pro",
signup_url: "https://ai.google.dev/"
};
streaming_chunk_splitting_regex = /(\r\n|\n|\r){2}/g;
/**
* Get request adapter class
*/
req_adapter = SmartChatModelGeminiRequestAdapter;
/**
* Get response adapter class
*/
res_adapter = SmartChatModelGeminiResponseAdapter;
/**
* Uses Gemini's dedicated token counting endpoint
*/
async count_tokens(input) {
const req = {
url: `https://generativelanguage.googleapis.com/v1beta/models/${this.model_key}:countTokens?key=${this.api_key}`,
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify(this.prepare_token_count_body(input))
};
const resp = await this.http_adapter.request(req);
return resp.json.totalTokens;
}
/**
* Formats input for token counting based on type
* @private
*/
prepare_token_count_body(input) {
if (typeof input === "string") {
return { contents: [{ parts: [{ text: input }] }] };
} else if (Array.isArray(input)) {
return { contents: input.map((msg) => this.transform_message_for_token_count(msg)) };
} else if (typeof input === "object") {
return { contents: [this.transform_message_for_token_count(input)] };
}
throw new Error("Invalid input for count_tokens");
}
/**
* Transforms message for token counting, handling text and images
* @private
*/
transform_message_for_token_count(message) {
return {
role: message.role === "assistant" ? "model" : message.role,
parts: Array.isArray(message.content) ? message.content.map((part) => {
if (part.type === "text") return { text: part.text };
if (part.type === "image_url") return {
inline_data: {
mime_type: part.image_url.url.split(";")[0].split(":")[1],
data: part.image_url.url.split(",")[1]
}
};
return part;
}) : [{ text: message.content }]
};
}
/**
* Builds endpoint URLs with model and API key
*/
get endpoint() {
return `https://generativelanguage.googleapis.com/v1beta/models/${this.model_key}:generateContent?key=${this.api_key}`;
}
get endpoint_streaming() {
return `https://generativelanguage.googleapis.com/v1beta/models/${this.model_key}:streamGenerateContent?key=${this.api_key}`;
}
/**
* Get models endpoint URL with API key
* @returns {string} Complete models endpoint URL
*/
get models_endpoint() {
return `${this.constructor.defaults.models_endpoint}?key=${this.api_key}`;
}
/**
* Get HTTP method for models endpoint
* @returns {string} HTTP method ("GET")
*/
get models_endpoint_method() {
return "GET";
}
get models_request_params() {
return {
url: this.models_endpoint,
method: this.models_endpoint_method
};
}
/**
* Parse model data from Gemini API response
* @param {Object} model_data - Raw model data from API
* @returns {Object} Map of model objects with capabilities and limits
*/
parse_model_data(model_data) {
return model_data.models.filter((model) => model.name.startsWith("models/gemini")).reduce((acc, model) => {
const out = {
model_name: model.name.split("/").pop(),
id: model.name.split("/").pop(),
max_input_tokens: model.inputTokenLimit,
max_output_tokens: model.maxOutputTokens,
description: model.description,
multimodal: model.name.includes("vision") || model.description.includes("multimodal"),
raw: model
};
acc[model.name.split("/").pop()] = out;
return acc;
}, {});
}
is_end_of_stream(event) {
return event.data.includes('"finishReason"');
return false;
}
};
var SmartChatModelGeminiRequestAdapter = class extends SmartChatModelRequestAdapter {
static {
__name(this, "SmartChatModelGeminiRequestAdapter");
}
to_platform(streaming = false) {
return this.to_gemini(streaming);
}
to_gemini(streaming = false) {
const gemini_body = {
contents: this._transform_messages_to_gemini(),
generationConfig: {
temperature: this.temperature,
maxOutputTokens: this.max_tokens,
topK: this._req.topK || 1,
topP: this._req.topP || 1,
stopSequences: this._req.stop || []
},
safetySettings: [
{
category: "HARM_CATEGORY_HARASSMENT",
threshold: "BLOCK_NONE"
},
{
category: "HARM_CATEGORY_HATE_SPEECH",
threshold: "BLOCK_NONE"
},
{
category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
threshold: "BLOCK_NONE"
},
{
category: "HARM_CATEGORY_DANGEROUS_CONTENT",
threshold: "BLOCK_NONE"
}
]
};
if (this.tools) gemini_body.tools = this._transform_tools_to_gemini();
if (gemini_body.tools && this.tool_choice !== "none") gemini_body.tool_config = this._transform_tool_choice_to_gemini();
return {
url: streaming ? this.adapter.endpoint_streaming : this.adapter.endpoint,
method: "POST",
headers: this.get_headers(),
body: JSON.stringify(gemini_body)
};
}
_transform_messages_to_gemini() {
let gemini_messages = [];
let system_message = "";
for (const message of this.messages) {
if (message.role === "system") {
system_message += message.content + "\n";
} else {
gemini_messages.push({
role: this._get_gemini_role(message.role),
parts: this._transform_content_to_gemini(message.content)
});
}
}
if (system_message) {
gemini_messages.unshift({
role: "user",
parts: [{ text: system_message.trim() }]
});
}
return gemini_messages;
}
_get_gemini_role(role) {
const role_map = {
user: "user",
assistant: "model",
function: "model"
};
return role_map[role] || role;
}
_transform_content_to_gemini(content) {
if (Array.isArray(content)) {
return content.map((part) => {
if (part.type === "text") return { text: part.text };
if (part.type === "image_url") {
let mime_type = part.image_url.url.split(";")[0].split(":")[1];
if (mime_type === "image/jpg") mime_type = "image/jpeg";
return {
inline_data: {
mime_type,
data: part.image_url.url.split(",")[1]
}
};
}
if (part.type === "file" && part.file?.filename?.toLowerCase().endsWith(".pdf")) {
if (part.file?.file_data) {
return {
inline_data: {
mime_type: "application/pdf",
data: part.file.file_data.split(",")[1]
}
};
}
}
return part;
});
}
return [{ text: content }];
}
_transform_tools_to_gemini() {
return [{
function_declarations: this.tools.map((tool2) => ({
name: tool2.function.name,
description: tool2.function.description,
parameters: tool2.function.parameters
}))
}];
}
_transform_tool_choice_to_gemini() {
return {
function_calling_config: {
mode: "ANY",
allowed_function_names: this.tools.map((tool2) => tool2.function.name)
}
};
}
};
var SmartChatModelGeminiResponseAdapter = class extends SmartChatModelResponseAdapter {
static {
__name(this, "SmartChatModelGeminiResponseAdapter");
}
static get platform_res() {
return {
candidates: [{
content: {
parts: [
{
text: ""
}
],
role: ""
},
finishReason: ""
}],
promptFeedback: {},
usageMetadata: {}
};
}
to_openai() {
if (this.error) return { error: normalize_error(this.error, this.status) };
const first_candidate = this._res.candidates[0];
if (!this._res.id) this._res.id = "gemini-" + Date.now().toString();
return {
id: this._res.id,
object: "chat.completion",
created: Date.now(),
model: this.adapter.model_key,
choices: [{
index: 0,
message: first_candidate?.content ? this._transform_message_to_openai(first_candidate.content) : "",
finish_reason: this._get_openai_finish_reason(first_candidate.finishReason)
}],
usage: this._transform_usage_to_openai()
};
}
_transform_message_to_openai(content) {
const message = {
role: "assistant",
content: content.parts.filter((part) => part.text).map((part) => part.text).join("")
};
const function_call = content.parts.find((part) => part.functionCall);
if (function_call) {
message.tool_calls = [{
type: "function",
function: {
name: function_call.functionCall.name,
arguments: JSON.stringify(function_call.functionCall.args)
}
}];
}
return message;
}
_get_openai_finish_reason(finish_reason) {
const reason_map = {
"STOP": "stop",
"MAX_TOKENS": "length",
"SAFETY": "content_filter",
"RECITATION": "content_filter",
"OTHER": "null"
};
return reason_map[finish_reason] || finish_reason.toLowerCase();
}
_transform_usage_to_openai() {
if (!this._res.usageMetadata) {
return {
prompt_tokens: null,
completion_tokens: null,
total_tokens: null
};
}
return {
prompt_tokens: this._res.usageMetadata.promptTokenCount || null,
completion_tokens: this._res.usageMetadata.candidatesTokenCount || null,
total_tokens: this._res.usageMetadata.totalTokenCount || null
};
}
handle_chunk(chunk) {
let chunk_trimmed = chunk.trim();
if (["[", ","].includes(chunk_trimmed[0])) chunk_trimmed = chunk_trimmed.slice(1);
if (["]", ","].includes(chunk_trimmed[chunk_trimmed.length - 1])) chunk_trimmed = chunk_trimmed.slice(0, -1);
const data = JSON.parse(chunk_trimmed);
let raw;
if (data.candidates?.[0]?.content?.parts?.[0]?.text?.length) {
const content = data.candidates[0].content.parts[0].text;
raw = content;
this._res.candidates[0].content.parts[0].text += content;
}
if (data.candidates?.[0]?.content?.role?.length) {
this._res.candidates[0].content.role = data.candidates[0].content.role;
}
if (data.candidates?.[0]?.finishReason?.length) {
this._res.candidates[0].finishReason += data.candidates[0].finishReason;
}
if (data.promptFeedback) {
this._res.promptFeedback = {
...this._res.promptFeedback || {},
...data.promptFeedback
};
}
if (data.usageMetadata) {
this._res.usageMetadata = {
...this._res.usageMetadata || {},
...data.usageMetadata
};
}
if (data.candidates?.[0]?.content?.parts?.[0]?.functionCall) {
if (!this._res.candidates[0].content.parts[0].functionCall) {
this._res.candidates[0].content.parts[0].functionCall = {
name: "",
args: {}
};
}
this._res.candidates[0].content.parts[0].functionCall.name += data.candidates[0].content.parts[0].functionCall.name;
if (data.candidates[0].content.parts[0].functionCall.args) {
Object.entries(data.candidates[0].content.parts[0].functionCall.args).forEach(([key, value]) => {
if (!this._res.candidates[0].content.parts[0].functionCall.args[key]) {
this._res.candidates[0].content.parts[0].functionCall.args[key] = "";
}
this._res.candidates[0].content.parts[0].functionCall.args[key] += value;
});
}
}
return raw;
}
};
var SmartChatModelGeminiAdapter = class extends SmartChatModelGoogleAdapter {
static {
__name(this, "SmartChatModelGeminiAdapter");
}
static key = "gemini";
static defaults = {
description: "Gemini (SWITCH TO **GOOGLE** ADAPTER)",
type: "API",
api_key_header: "none",
endpoint: "https://generativelanguage.googleapis.com/v1beta/models/MODEL_NAME:generateContent",
endpoint_streaming: "https://generativelanguage.googleapis.com/v1beta/models/MODEL_NAME:streamGenerateContent",
streaming: true,
adapter: "Gemini",
models_endpoint: "https://generativelanguage.googleapis.com/v1beta/models",
default_model: "gemini-1.5-pro",
signup_url: "https://ai.google.dev/"
};
};

var SmartChatModelOpenRouterAdapter = class extends SmartChatModelApiAdapter {
static {
__name(this, "SmartChatModelOpenRouterAdapter");
}
static key = "open_router";
static models_dev_key = "openrouter";
static defaults = {
description: "Open Router",
type: "API",
endpoint: "https://openrouter.ai/api/v1/chat/completions",
streaming: true,
adapter: "OpenRouter",
models_endpoint: "https://openrouter.ai/api/v1/models",
default_model: "mistralai/mistral-7b-instruct:free",
signup_url: "https://accounts.openrouter.ai/sign-up?redirect_url=https%3A%2F%2Fopenrouter.ai%2Fkeys"
};
/**
* Get request adapter class
* @returns {typeof SmartChatModelOpenRouterRequestAdapter} Request adapter class
*/
get req_adapter() {
return SmartChatModelOpenRouterRequestAdapter;
}
/**
* Get response adapter class
* @returns {typeof SmartChatModelOpenRouterResponseAdapter} Response adapter class
*/
get res_adapter() {
return SmartChatModelOpenRouterResponseAdapter;
}
/**
* Count tokens in input text (rough estimate)
* @param {string|Object} input - Text to count tokens for
* @returns {Promise<number>} Estimated token count
*/
async count_tokens(input) {
const text = typeof input === "string" ? input : JSON.stringify(input);
return Math.ceil(text.length / 4);
}
get models_request_params() {
return {
url: this.models_endpoint,
method: "GET"
};
}
/**
* Parse model data from OpenRouter API response
* @param {Object} model_data - Raw model data
* @returns {Object} Map of model objects with capabilities and limits
*/
parse_model_data(model_data) {
if (model_data.data) {
model_data = model_data.data;
}
if (model_data.error) throw new Error(model_data.error);
return model_data.reduce((acc, model) => {
acc[model.id] = {
model_name: model.id,
id: model.id,
max_input_tokens: model.context_length,
name: model.name,
description: model.name,
long_desc: model.description,
multimodal: model.architecture.modality === "multimodal",
raw: model
};
return acc;
}, {});
}
};
var SmartChatModelOpenRouterRequestAdapter = class extends SmartChatModelRequestAdapter {
static {
__name(this, "SmartChatModelOpenRouterRequestAdapter");
}
to_platform(stream = false) {
const req = this.to_openai(stream);
return req;
}
_get_openai_content(message) {
if (message.role === "user") {
if (Array.isArray(message.content) && message.content.every((part) => part.type === "text")) {
return message.content.map((part) => part.text).join("\n");
}
}
return message.content;
}
};
var SmartChatModelOpenRouterResponseAdapter = class extends SmartChatModelResponseAdapter {
static {
__name(this, "SmartChatModelOpenRouterResponseAdapter");
}
static get platform_res() {
return {
id: "",
object: "chat.completion",
created: 0,
model: "",
choices: [],
usage: {}
};
}
to_platform() {
return this.to_openai();
}
get object() {
return "chat.completion";
}
get error() {
if (!this._res.error) return null;
const error = this._res.error;
if (!error.message) error.message = "";
if (this._res.error.metadata?.raw) {
if (typeof this._res.error.metadata.raw === "string") {
error.message += `

${this._res.error.metadata.raw}`;
} else {
error.message += `

${JSON.stringify(this._res.error.metadata.raw, null, 2)}`;
}
}
if (error.message.startsWith("No cookie auth")) {
error.suggested_action = "Ensure your Open Router API key is set correctly.";
}
return error;
}
};

var SmartChatModelLmStudioAdapter = class extends SmartChatModelApiAdapter {
static {
__name(this, "SmartChatModelLmStudioAdapter");
}
static key = "lm_studio";
/** @type {import('./_adapter.js').SmartChatModelAdapter['constructor']['defaults']} */
static defaults = {
description: "LM Studio (OpenAI\u2011compatible)",
type: "API",
endpoint: "http://localhost:1234/v1/chat/completions",
streaming: true,
adapter: "LM_Studio_OpenAI_Compat",
models_endpoint: "http://localhost:1234/v1/models",
default_model: "",
signup_url: "https://lmstudio.ai/docs/api/openai-api",
api_key: "no api key required"
};
/* ------------------------------------------------------------------ *
*  Request / Response classes
* ------------------------------------------------------------------ */
get req_adapter() {
return SmartChatModelLmStudioRequestAdapter;
}
get res_adapter() {
return SmartChatModelLmStudioResponseAdapter;
}
/* ------------------------------------------------------------------ *
*  Settings
* ------------------------------------------------------------------ */
/**
* Extend the base settings with a read‑only HTML block that reminds the
* user to enable CORS inside LM Studio. The Smart View renderer treats
* `type: "html"` as a static fragment, so no extra runtime logic is needed.
*/
get settings_config() {
const config = super.settings_config;
delete config["[CHAT_ADAPTER].api_key"];
return {
...config,
"[CHAT_ADAPTER].cors_instructions": {
/* visible only when this adapter is selected */
name: "CORS required",
type: "html",
value: `<p>Before you can use LM Studio you must <strong>Enable CORS</strong> inside LM Studio \u2192 Developer \u2192 Settings</p>`
}
};
}
/* ------------------------------------------------------------------ *
*  Model list helpers
* ------------------------------------------------------------------ */
/**
* LM Studio returns an OpenAI‑style list; normalise to the project shape.
*/
parse_model_data(model_data) {
if (model_data.object !== "list" || !Array.isArray(model_data.data)) {
return { _: { id: "No models found." } };
}
const out = {};
for (const m of model_data.data) {
out[m.id] = {
id: m.id,
model_name: m.id,
description: `LM Studio model: ${m.id}`,
multimodal: false
};
}
return out;
}
get models_endpoint_method() {
return "get";
}
/**
* Count tokens in input text (no dedicated endpoint)
* Rough estimate: 1 token ~ 4 chars
* @param {string|Object} input
* @returns {Promise<number>}
*/
async count_tokens(input) {
const text = typeof input === "string" ? input : JSON.stringify(input);
return Math.ceil(text.length / 4);
}
/**
* Test API key - LM Studio doesn't require API key. Always true.
* @returns {Promise<boolean>}
*/
async test_api_key() {
return true;
}
get api_key() {
return "no api key required";
}
};
var SmartChatModelLmStudioRequestAdapter = class extends SmartChatModelRequestAdapter {
static {
__name(this, "SmartChatModelLmStudioRequestAdapter");
}
to_platform(streaming = false) {
const req = this.to_openai(streaming);
const body = JSON.parse(req.body);
if (this.tool_choice?.function?.name) {
const last_msg = body.messages[body.messages.length - 1];
if (typeof last_msg.content === "string") {
last_msg.content = [
{ type: "text", text: last_msg.content }
];
}
last_msg.content.push({
type: "text",
text: `Use the "${this.tool_choice.function.name}" tool.`
});
body.tool_choice = "required";
} else if (body.tool_choice && typeof body.tool_choice === "object") {
body.tool_choice = "auto";
}
req.body = JSON.stringify(body);
return req;
}
};
var SmartChatModelLmStudioResponseAdapter = class extends SmartChatModelResponseAdapter {
static {
__name(this, "SmartChatModelLmStudioResponseAdapter");
}
};

var SmartChatModelOllamaAdapter = class extends SmartChatModelApiAdapter {
static {
__name(this, "SmartChatModelOllamaAdapter");
}
static key = "ollama";
static defaults = {
description: "Ollama (Local)",
type: "API",
api_key: "na",
host: "http://localhost:11434",
endpoint: "/api/chat",
models_endpoint: "/api/tags",
streaming: true
};
req_adapter = SmartChatModelOllamaRequestAdapter;
res_adapter = SmartChatModelOllamaResponseAdapter;
get host() {
return this.model.data.host || this.constructor.defaults.host;
}
get endpoint() {
return `${this.host}${this.constructor.defaults.endpoint}`;
}
get models_endpoint() {
return `${this.host}${this.constructor.defaults.models_endpoint}`;
}
get model_show_endpoint() {
return `${this.host}/api/show`;
}
get models_endpoint_method() {
return "GET";
}
/**
* Get available models from local Ollama instance
* @param {boolean} [refresh=false] - Whether to refresh cached models
* @returns {Promise<Object>} Map of model objects
*/
async get_models(refresh = false) {
if (!refresh && typeof this.model_data === "object" && Object.keys(this.model_data || {}).length > 0 && this.model_data_loaded_at && time_now - this.model_data_loaded_at < 1 * 60 * 60 * 1e3) return this.model_data;
try {
const list_resp = await this.http_adapter.request(this.models_request_params);
const list_data = await list_resp.json();
const models_raw_data = [];
for (const model of list_data.models) {
const model_details_resp = await this.http_adapter.request({
url: this.model_show_endpoint,
method: "POST",
body: JSON.stringify({ model: model.name })
});
const model_details_data = await model_details_resp.json();
models_raw_data.push({ ...model_details_data, name: model.name });
}
this.model_data = this.parse_model_data(models_raw_data);
await this.get_enriched_model_data();
this.model.data.provider_models = this.model_data;
if (typeof this.model.re_render_settings === "function") {
this.model.re_render_settings();
}
this.model_data_loaded_at = Date.now();
return this.model_data;
} catch (error) {
console.error("Failed to fetch model data:", error);
return { "_": { id: `Failed to fetch models from ${this.model.adapter_name}` } };
}
}
/**
* Parse model data from Ollama API response
* @param {Object[]} model_data - Raw model data from Ollama
* @returns {Object} Map of model objects with capabilities and limits
*/
parse_model_data(model_data) {
if (!Array.isArray(model_data)) {
this.model_data = {};
console.error("Invalid model data format from Ollama:", model_data);
return {};
}
if (model_data.length === 0) {
this.model_data = { "no_models_available": {
id: "no_models_available",
name: "No models currently available"
} };
return this.model_data;
}
return model_data.reduce((acc, model) => {
if (model.name.includes("embed")) return acc;
const out = {
model_name: model.name,
id: model.name,
multimodal: false,
max_input_tokens: Object.entries(model.model_info).find((m) => m[0].includes(".context_length"))[1]
};
acc[model.name] = out;
return acc;
}, {});
}
/**
* Override settings config to remove API key setting since not needed for local instance
* @returns {Object} Settings configuration object
*/
get settings_config() {
const config = super.settings_config;
delete config["[CHAT_ADAPTER].api_key"];
config["[CHAT_ADAPTER].host"] = {
name: "Ollama host",
type: "text",
description: "Enter the host for your Ollama instance",
default: this.constructor.defaults.host
};
return config;
}
is_end_of_stream(event) {
return event.data.includes('"done_reason"');
}
};
var SmartChatModelOllamaRequestAdapter = class extends SmartChatModelRequestAdapter {
static {
__name(this, "SmartChatModelOllamaRequestAdapter");
}
/**
* Convert request to Ollama format
* @returns {Object} Request parameters in Ollama format
*/
to_platform(streaming = false) {
const ollama_body = {
model: this.model_id,
messages: this._transform_messages_to_ollama(),
options: this._transform_parameters_to_ollama(),
stream: streaming || this.stream
};
if (this.tools) {
ollama_body.tools = this._transform_functions_to_tools();
if (this.tool_choice?.function?.name) {
ollama_body.messages[ollama_body.messages.length - 1].content += `

Use the "${this.tool_choice.function.name}" tool.`;
ollama_body.format = "json";
}
}
return {
url: this.adapter.endpoint,
method: "POST",
body: JSON.stringify(ollama_body)
};
}
/**
* Transform messages to Ollama format
* @returns {Array} Messages in Ollama format
* @private
*/
_transform_messages_to_ollama() {
return this.messages.map((message) => {
const ollama_message = {
role: message.role,
content: this._transform_content_to_ollama(message.content)
};
const images = this._extract_images_from_content(message.content);
if (images.length > 0) {
ollama_message.images = images.map((img) => img.replace(/^data:image\/[^;]+;base64,/, ""));
}
return ollama_message;
});
}
/**
* Transform content to Ollama format
* @param {string|Array} content - Message content
* @returns {string} Content in Ollama format
* @private
*/
_transform_content_to_ollama(content) {
if (Array.isArray(content)) {
return content.filter((item) => item.type === "text").map((item) => item.text).join("\n");
}
return content;
}
/**
* Extract images from content
* @param {string|Array} content - Message content
* @returns {Array} Array of image URLs
* @private
*/
_extract_images_from_content(content) {
if (!Array.isArray(content)) return [];
return content.filter((item) => item.type === "image_url").map((item) => item.image_url.url);
}
/**
* Transform functions to tools format
* @returns {Array} Tools array in Ollama format
* @private
*/
_transform_functions_to_tools() {
return this.tools;
}
/**
* Transform parameters to Ollama options format
* @returns {Object} Options in Ollama format
* @private
*/
_transform_parameters_to_ollama() {
const options = {};
if (this.max_tokens) options.num_predict = this.max_tokens;
if (this.temperature) options.temperature = this.temperature;
if (this.top_p) options.top_p = this.top_p;
if (this.frequency_penalty) options.frequency_penalty = this.frequency_penalty;
if (this.presence_penalty) options.presence_penalty = this.presence_penalty;
return options;
}
};
var SmartChatModelOllamaResponseAdapter = class extends SmartChatModelResponseAdapter {
static {
__name(this, "SmartChatModelOllamaResponseAdapter");
}
static get platform_res() {
return {
model: "",
created_at: null,
message: {
role: "",
content: ""
},
total_duration: 0,
load_duration: 0,
prompt_eval_count: 0,
prompt_eval_duration: 0,
eval_count: 0,
eval_duration: 0
};
}
/**
* Convert response to OpenAI format
* @returns {Object} Response in OpenAI format
*/
to_openai() {
if (this.error) return { error: normalize_error(this.error, this.status) };
return {
id: this._res.created_at,
object: "chat.completion",
created: Date.now(),
model: this._res.model,
choices: [
{
index: 0,
message: this._transform_message_to_openai(),
finish_reason: this._res.done_reason
}
],
usage: this._transform_usage_to_openai()
};
}
/**
* Transform message to OpenAI format
* @returns {Object} Message in OpenAI format
* @private
*/
_transform_message_to_openai() {
return {
role: this._res.message.role,
content: this._res.message.content,
tool_calls: this._res.message.tool_calls
};
}
/**
* Transform usage statistics to OpenAI format
* @returns {Object} Usage statistics in OpenAI format
* @private
*/
_transform_usage_to_openai() {
return {
prompt_tokens: this._res.prompt_eval_count || 0,
completion_tokens: this._res.eval_count || 0,
total_tokens: (this._res.prompt_eval_count || 0) + (this._res.eval_count || 0)
};
}
/**
* Parse chunk adds delta to content as expected output format
*/
handle_chunk(chunk) {
chunk = JSON.parse(chunk || "{}");
if (chunk.created_at && !this._res.created_at) {
this._res.created_at = chunk.created_at;
}
let raw;
if (chunk.message?.content) {
const content = chunk.message.content;
raw = content;
this._res.message.content += content;
}
if (chunk.message?.role) {
this._res.message.role = chunk.message.role;
}
if (chunk.model) {
this._res.model = chunk.model;
}
if (chunk.message?.tool_calls) {
if (!this._res.message.tool_calls) {
this._res.message.tool_calls = [{
id: "",
type: "function",
function: {
name: "",
arguments: ""
}
}];
}
if (chunk.message.tool_calls[0].id) {
this._res.message.tool_calls[0].id += chunk.message.tool_calls[0].id;
}
if (chunk.message.tool_calls[0].function.name) {
this._res.message.tool_calls[0].function.name += chunk.message.tool_calls[0].function.name;
}
if (chunk.message.tool_calls[0].function.arguments) {
if (typeof chunk.message.tool_calls[0].function.arguments === "string") {
this._res.message.tool_calls[0].function.arguments += chunk.message.tool_calls[0].function.arguments;
} else {
this._res.message.tool_calls[0].function.arguments = chunk.message.tool_calls[0].function.arguments;
}
}
}
return raw;
}
};

var adapters_map = {
"openai": {
req: SmartChatModelRequestAdapter,
res: SmartChatModelResponseAdapter
},
"anthropic": {
req: SmartChatModelAnthropicRequestAdapter,
res: SmartChatModelAnthropicResponseAdapter
},
"gemini": {
req: SmartChatModelGeminiRequestAdapter,
res: SmartChatModelGeminiResponseAdapter
},
"lm_studio": {
req: SmartChatModelLmStudioRequestAdapter,
res: SmartChatModelLmStudioResponseAdapter
},
"ollama": {
req: SmartChatModelOllamaRequestAdapter,
res: SmartChatModelOllamaResponseAdapter
}
};
var SmartChatModelCustomAdapter = class extends SmartChatModelApiAdapter {
static {
__name(this, "SmartChatModelCustomAdapter");
}
static key = "custom";
static defaults = {
description: "Custom API (Local or Remote, OpenAI format)",
type: "API",
/**
* new default property: 'api_adapter' indicates which
* request/response adapter set to use internally
*/
api_adapter: "openai"
};
/**
* Provide dynamic request/response classes
*/
/**
* @override
* @returns {typeof SmartChatModelRequestAdapter}
*/
get req_adapter() {
const adapter_name = this.model.data.api_adapter || "openai";
const map_entry = adapters_map[adapter_name];
return map_entry && map_entry.req ? map_entry.req : SmartChatModelRequestAdapter;
}
/**
* @override
* @returns {typeof SmartChatModelResponseAdapter}
*/
get res_adapter() {
const adapter_name = this.model.data.api_adapter || "openai";
const map_entry = adapters_map[adapter_name];
return map_entry && map_entry.res ? map_entry.res : SmartChatModelResponseAdapter;
}
/**
* Synthesize a custom endpoint from the config fields.
* All fields are optional; fallback to a minimal default.
* @returns {string}
*/
get endpoint() {
const protocol = this.model.data.protocol || "http";
const hostname = this.model.data.hostname || "localhost";
const port = this.model.data.port ? `:${this.model.data.port}` : "";
let path = this.model.data.path || "";
if (path && !path.startsWith("/")) path = `/${path}`;
return `${protocol}://${hostname}${port}${path}`;
}
get_adapters_as_options() {
return Object.keys(adapters_map).map((adapter_name) => ({ value: adapter_name, name: adapter_name }));
}
/**
* Provide custom settings for configuring
* the user-defined fields plus the new 'api_adapter'.
* @override
* @returns {Object} settings configuration
*/
get settings_config() {
return {
/**
* Select which specialized request/response adapter
* you'd like to use for your custom endpoint.
*/
"[CHAT_ADAPTER].api_adapter": {
name: "API Adapter",
type: "dropdown",
description: "Pick a built-in or external adapter to parse request/response data.",
options_callback: /* @__PURE__ */ __name(() => {
this.get_adapters_as_options();
}, "options_callback"),
default: "openai"
},
"[CHAT_ADAPTER].id": {
name: "Model Name",
type: "text",
description: "Enter the model name for your endpoint if needed."
},
"[CHAT_ADAPTER].protocol": {
name: "Protocol",
type: "text",
description: "e.g. http or https"
},
"[CHAT_ADAPTER].hostname": {
name: "Hostname",
type: "text",
description: "e.g. localhost or some.remote.host"
},
"[CHAT_ADAPTER].port": {
name: "Port",
type: "number",
description: "Port number or leave blank"
},
"[CHAT_ADAPTER].path": {
name: "Path",
type: "text",
description: "Path portion of the URL (leading slash optional)"
},
"[CHAT_ADAPTER].streaming": {
name: "Streaming",
type: "toggle",
description: "Enable streaming if your API supports it."
},
"[CHAT_ADAPTER].max_input_tokens": {
name: "Max Input Tokens",
type: "number",
description: "Max number of tokens your model can handle in the prompt."
},
"[CHAT_ADAPTER].api_key": {
name: "API Key",
type: "password",
description: "If your service requires an API key, add it here."
}
};
}
};

var SmartChatModelGroqAdapter = class extends SmartChatModelApiAdapter {
static {
__name(this, "SmartChatModelGroqAdapter");
}
static key = "groq";
static defaults = {
description: "Groq",
type: "API",
endpoint: "https://api.groq.com/openai/v1/chat/completions",
streaming: true,
adapter: "Groq",
models_endpoint: "https://api.groq.com/openai/v1/models",
default_model: "llama3-8b-8192",
signup_url: "https://groq.com"
};
/**
* Request adapter class
* @returns {typeof SmartChatModelGroqRequestAdapter}
*/
get req_adapter() {
return SmartChatModelGroqRequestAdapter;
}
/**
* Response adapter class
* @returns {typeof SmartChatModelGroqResponseAdapter}
*/
get res_adapter() {
return SmartChatModelGroqResponseAdapter;
}
get models_endpoint_method() {
return "GET";
}
/**
* Parse model data from Groq API format to a dictionary keyed by model ID.
* The API returns a list of model objects like:
* {
*   "object": "list",
*   "data": [ { "id": "...", "object": "model", ... }, ... ]
* }
*
* We'll convert each model to:
* {
*   model_name: model.id,
*   id: model.id,
*   max_input_tokens: model.context_window,
*   description: `Owned by: ${model.owned_by}, context: ${model.context_window}`,
*   multimodal: Check if model name or description suggests multimodality
* }
*/
parse_model_data(model_data) {
if (model_data.object !== "list" || !Array.isArray(model_data.data)) {
return { "_": { id: "No models found." } };
}
const parsed = {};
for (const m of model_data.data) {
parsed[m.id] = {
model_name: m.id,
id: m.id,
max_input_tokens: m.context_window || 8192,
description: `Owned by: ${m.owned_by}, context: ${m.context_window}`,
multimodal: m.id.includes("vision")
};
}
return parsed;
}
};
var SmartChatModelGroqRequestAdapter = class extends SmartChatModelRequestAdapter {
static {
__name(this, "SmartChatModelGroqRequestAdapter");
}
_get_openai_content(message) {
if (["assistant", "tool"].includes(message.role)) {
if (Array.isArray(message.content)) {
return message.content.map((part) => {
if (typeof part === "string") return part;
if (part?.text) return part.text;
return "";
}).join("\n");
}
}
return message.content;
}
};
var SmartChatModelGroqResponseAdapter = class extends SmartChatModelResponseAdapter {
static {
__name(this, "SmartChatModelGroqResponseAdapter");
}
};

var SmartChatModelXaiAdapter = class extends SmartChatModelApiAdapter {
static {
__name(this, "SmartChatModelXaiAdapter");
}
/** Human-readable platform key used by SmartChatModel */
static key = "xai";
/** @type {import('./_adapter.js').SmartChatModelAdapter['constructor']['defaults']} */
static defaults = {
description: "xAI Grok",
type: "API",
adapter: "xAI_Grok",
endpoint: "https://api.x.ai/v1/chat/completions",
streaming: true,
models_endpoint: "https://api.x.ai/v1/models",
default_model: "grok-3-mini-beta",
signup_url: "https://ide.x.ai"
};
/** Grok is OpenAI-compatible → reuse the stock adapters */
get req_adapter() {
return SmartChatModelRequestAdapter;
}
get res_adapter() {
return SmartChatModelResponseAdapter;
}
/* ------------------------------------------------------------------ *
*  Model-list helpers
* ------------------------------------------------------------------ */
/**
* The Grok `/v1/models` route is **GET**, not POST.
* Override the HTTP verb so `get_models()` works.
* @returns {string} 'GET'
*/
get models_endpoint_method() {
return "GET";
}
/**
* Parse `/v1/models` payload to the canonical shape used by SmartChat.
*
* Grok returns:
* ```json
* { "object":"list",
*   "data":[{ "id":"grok-3-beta", "context_length":128000, …}] }
* ```
*/
parse_model_data(model_data = {}) {
const list = model_data.data || model_data.models || [];
return list.reduce((acc, m) => {
const id = m.id || m.name;
acc[id] = {
id,
model_name: id,
description: m.description || `context: ${m.context_length || "n/a"}`,
max_input_tokens: m.context_length || 128e3,
multimodal: !!m.modality && m.modality.includes("vision"),
raw: m
};
return acc;
}, {});
}
};

var SmartChatModelDeepseekAdapter = class extends SmartChatModelApiAdapter {
static {
__name(this, "SmartChatModelDeepseekAdapter");
}
static key = "deepseek";
static defaults = {
description: "DeepSeek",
type: "API",
endpoint: "https://api.deepseek.com/chat/completions",
streaming: true,
adapter: "DeepSeek",
models_endpoint: "https://api.deepseek.com/models",
default_model: "deepseek-base",
signup_url: "https://deepseek.com/signup"
};
/**
* Get the request adapter class
* @returns {typeof SmartChatModelDeepseekRequestAdapter} Request adapter class
*/
get req_adapter() {
return SmartChatModelDeepseekRequestAdapter;
}
/**
* Get the response adapter class
* @returns {typeof SmartChatModelDeepseekResponseAdapter} Response adapter class
*/
get res_adapter() {
return SmartChatModelDeepseekResponseAdapter;
}
get models_endpoint_method() {
return "GET";
}
/**
* Parse the raw model data from DeepSeek's /v1/models endpoint
* into a structured map of model objects keyed by model ID.
* @param {Object} model_data - Raw JSON from DeepSeek
* @returns {Object} Map of model objects
*/
parse_model_data(model_data) {
if (!model_data?.data || !Array.isArray(model_data.data)) {
return { "_": { id: "No models found." } };
}
const parsed = {};
for (const m of model_data.data) {
parsed[m.id] = {
model_name: m.id,
id: m.id,
max_input_tokens: m.context_size || 8192,
description: m.description || m.name || m.id,
raw: m
};
}
return parsed;
}
/**
* Estimate tokens in user input.
* @param {string|Object} input - Input text or structured message
* @returns {Promise<number>} Token count estimate
*/
async count_tokens(input) {
const text = typeof input === "string" ? input : JSON.stringify(input);
return Math.ceil(text.length / 4);
}
/**
* Check if an incoming streaming chunk signals end of stream.
* @param {CustomEvent} event - SSE event with data
* @returns {boolean} True if end of stream
*/
is_end_of_stream(event) {
if (!event?.data) return false;
return event.data.includes('"done":true') || event.data.includes("[DONE]");
}
};
var SmartChatModelDeepseekRequestAdapter = class extends SmartChatModelRequestAdapter {
static {
__name(this, "SmartChatModelDeepseekRequestAdapter");
}
/**
* Convert incoming request to DeepSeek's expected format
* Often just reuse the base "to_openai()" if that matches DeepSeek's design
* @param {boolean} streaming - True if streaming
* @returns {Object} Request parameters
*/
to_platform(streaming = false) {
return this.to_openai(streaming);
}
};
var SmartChatModelDeepseekResponseAdapter = class extends SmartChatModelResponseAdapter {
static {
__name(this, "SmartChatModelDeepseekResponseAdapter");
}
};

var import_obsidian37 = require("obsidian");

function parse_blocks(source, content) {
let { blocks: blocks_obj, task_lines, tasks, codeblock_ranges } = parse_markdown_blocks(content);
const last_read_at = source.data.last_read?.at || Date.now();
for (const [sub_key, line_range] of Object.entries(blocks_obj)) {
const block_key = source.key + sub_key;
const existing_block = source.block_collection.get(block_key);
const block_content = get_line_range2(content, line_range[0], line_range[1]);
if (existing_block && existing_block.lines[0] === line_range[0] && existing_block.lines[1] === line_range[1] && existing_block.size === block_content.length && existing_block.vec) {
continue;
}
const block_outlinks = get_markdown_links(block_content);
const bases_links = get_bases_cache_links({
source,
links: block_outlinks
});
const block_data = {
key: block_key,
lines: line_range,
size: block_content.length,
outlinks: [
...block_outlinks,
...bases_links
],
last_read: {
at: last_read_at,
hash: murmur_hash_32_alphanumeric(block_content)
}
};
if (!existing_block || existing_block?.data.last_read?.hash !== block_data.last_read.hash) {
const new_item = new source.block_collection.item_type(source.env, block_data);
source.block_collection.set(new_item);
} else {
existing_block.data = {
...existing_block.data,
...block_data
};
}
}
clean_and_update_source_blocks(source, blocks_obj, task_lines, tasks, codeblock_ranges);
for (const block of source.blocks) {
if (!block.vec) {
block.queue_embed();
}
}
}
__name(parse_blocks, "parse_blocks");
function clean_and_update_source_blocks(source, blocks_obj, task_lines = [], tasks = {}, codeblock_ranges = {}) {
const current_block_keys = new Set(Object.keys(blocks_obj).map((sk) => source.key + sk));
const blocks = source.blocks;
for (let i = 0; i < blocks.length; i++) {
if (!current_block_keys.has(blocks[i].key)) {
blocks[i].deleted = true;
blocks[i].queue_save();
}
}
source.data.blocks = blocks_obj;
source.data.task_lines = task_lines;
source.data.tasks = tasks;
source.data.codeblock_ranges = codeblock_ranges;
source.queue_save();
}
__name(clean_and_update_source_blocks, "clean_and_update_source_blocks");

function ajson_merge(existing, new_obj) {
if (new_obj === null) return null;
if (new_obj === void 0) return existing;
if (typeof new_obj !== "object") return new_obj;
if (typeof existing !== "object" || existing === null) existing = {};
const keys = Object.keys(new_obj);
const length = keys.length;
for (let i = 0; i < length; i++) {
const key = keys[i];
const new_val = new_obj[key];
const existing_val = existing[key];
if (Array.isArray(new_val)) {
existing[key] = new_val.slice();
} else if (is_object(new_val)) {
existing[key] = ajson_merge(is_object(existing_val) ? existing_val : {}, new_val);
} else if (new_val !== void 0) {
existing[key] = new_val;
}
}
return existing;
}
__name(ajson_merge, "ajson_merge");
function is_object(obj) {
return obj !== null && typeof obj === "object" && !Array.isArray(obj);
}
__name(is_object, "is_object");

var class_to_collection_key2 = {
"SmartSource": "smart_sources",
"SmartNote": "smart_sources",
"SmartBlock": "smart_blocks",
"SmartDirectory": "smart_directories"
};
function _parse_ajson_key(ajson_key) {
let changed = false;
let [collection_key, ...item_key] = ajson_key.split(":");
if (class_to_collection_key2[collection_key]) {
collection_key = class_to_collection_key2[collection_key];
changed = true;
}
return {
collection_key,
item_key: item_key.join(":"),
changed
};
}
__name(_parse_ajson_key, "_parse_ajson_key");
var AjsonSingleFileCollectionDataAdapter = class extends AjsonMultiFileCollectionDataAdapter {
static {
__name(this, "AjsonSingleFileCollectionDataAdapter");
}
/**
* Returns the single shared `.ajson` file path for this collection.
* @param {string} [key] - (unused) Item key, ignored in single-file mode.
* @returns {string} The single .ajson file path for the entire collection.
*/
get_item_data_path(key) {
const file_name = (this.collection?.collection_key || "collection") + ".ajson";
const sep = this.fs?.sep || "/";
const dir = this.collection.data_dir || "data";
return [dir, file_name].join(sep);
}
/**
* Override process_load_queue to parse the entire single-file .ajson once,
* distributing final states to items.
*
* @async
* @returns {Promise<void>}
*/
async process_load_queue() {
this.collection.emit_event("collection:load_started");
this.collection.show_process_notice("loading_collection");
if (!await this.fs.exists(this.collection.data_dir)) {
await this.fs.mkdir(this.collection.data_dir);
}
const path = this.get_item_data_path();
if (!await this.fs.exists(path)) {
for (const item of Object.values(this.collection.items)) {
if (item._queue_load) {
item.queue_import?.();
}
}
this.collection.clear_process_notice("loading_collection");
this.collection.emit_event("collection:load_halted");
return;
}
const raw_data = await this.fs.read(path, "utf-8", { no_cache: true });
if (!raw_data) {
for (const item of Object.values(this.collection.items)) {
if (item._queue_load) {
item.queue_import?.();
}
}
this.collection.clear_process_notice("loading_collection");
this.collection.emit_event("collection:load_halted");
return;
}
const { rewrite, file_data } = this.parse_single_file_ajson(raw_data);
if (rewrite) {
if (file_data.length) {
await this.fs.write(path, file_data);
} else {
await this.fs.remove(path);
}
}
for (const item of Object.values(this.collection.items)) {
item._queue_load = false;
item.loaded_at = Date.now();
}
this.collection.clear_process_notice("loading_collection");
this.collection.emit_event("collection:load_completed");
}
/**
* Helper to parse single-file .ajson content, distributing states to items.
*
* @param {string} raw
* @returns {{ rewrite: boolean, file_data: string }}
*/
parse_single_file_ajson(raw) {
let rewrite = false;
const lines = raw.trim().split("\n").filter(Boolean);
let data_map = {};
let line_count = 0;
for (let i = 0; i < lines.length; i++) {
const line = lines[i].trim();
if (!line.endsWith(",")) {
rewrite = true;
}
const trimmed = line.replace(/,$/, "");
const combined = "{" + trimmed + "}";
try {
const obj = JSON.parse(combined);
const [fullKey, value] = Object.entries(obj)[0];
let { collection_key, item_key, changed } = _parse_ajson_key(fullKey);
const newKey = `${collection_key}:${item_key}`;
if (!value) {
delete data_map[newKey];
if (changed || newKey !== fullKey) {
delete data_map[fullKey];
}
rewrite = true;
} else {
data_map[newKey] = value;
if (changed || newKey !== fullKey) {
delete data_map[fullKey];
rewrite = true;
}
}
} catch (err) {
console.warn("parse error for line: ", line, err);
rewrite = true;
}
line_count++;
}
for (const [ajson_key, val] of Object.entries(data_map)) {
const [collection_key, ...rest] = ajson_key.split(":");
const item_key = rest.join(":");
const collection = this.collection.env[collection_key];
if (!collection) continue;
let item = collection.get(item_key);
if (!item) {
const ItemClass = collection.item_type;
item = new ItemClass(this.env, val);
collection.set(item);
} else {
item.data = ajson_merge(item.data, val);
}
item.loaded_at = Date.now();
item._queue_load = false;
if (!val.key) val.key = item_key;
}
if (line_count > Object.keys(data_map).length) {
rewrite = true;
}
let minimal_lines = [];
for (const [ajson_key, val] of Object.entries(data_map)) {
minimal_lines.push(`${JSON.stringify(ajson_key)}: ${JSON.stringify(val)},`);
}
return {
rewrite,
file_data: minimal_lines.join("\n")
};
}
/**
* Override process_save_queue for single-file approach.
* We'll simply call save_item for each queued item, which appends a line to the same `.ajson`.
*
* @async
* @returns {Promise<void>}
*/
async process_save_queue() {
this.collection.emit_event("collection:save_started");
this.collection.show_process_notice("saving_collection");
const save_queue = Object.values(this.collection.items).filter((item) => item._queue_save);
const time_start = Date.now();
const batch_size = 50;
for (let i = 0; i < save_queue.length; i += batch_size) {
const batch = save_queue.slice(i, i + batch_size);
await Promise.all(batch.map((item) => {
const adapter = this.create_item_adapter(item);
return adapter.save().catch((err) => {
console.warn(`Error saving item ${item.key}`, err);
item.queue_save();
});
}));
}
const deleted_items = Object.values(this.collection.items).filter((item) => item.deleted);
if (deleted_items.length) {
deleted_items.forEach((item) => {
delete this.collection.items[item.key];
});
}
console.log(`Saved (single-file) ${this.collection.collection_key} in ${Date.now() - time_start}ms`);
this.collection.clear_process_notice("saving_collection");
this.collection.emit_event("collection:save_completed");
}
};
var AjsonSingleFileItemDataAdapter = class extends AjsonMultiFileItemDataAdapter {
static {
__name(this, "AjsonSingleFileItemDataAdapter");
}
/**
* Overridden to always return the single file path from the parent collection adapter.
* @returns {string}
*/
get data_path() {
return this.collection_adapter.get_item_data_path(this.item.key);
}
/**
* Load logic:
* In single-file mode, we typically rely on the collection's `process_load_queue()`
* to parse the entire file. This direct `load()` will do a naive re-parse as well
* if used individually.
*/
async load() {
const path = this.data_path;
if (!await this.fs.exists(path)) {
this.item.queue_import?.();
return;
}
try {
const raw_data = await this.fs.read(path, "utf-8", { no_cache: true });
if (!raw_data) {
this.item.queue_import?.();
return;
}
const { rewrite } = this.collection_adapter.parse_single_file_ajson(raw_data);
} catch (err) {
console.warn(`Error loading single-file item ${this.item.key}`, err);
this.item.queue_import?.();
}
}
};
var ajson_single_file_default = {
collection: AjsonSingleFileCollectionDataAdapter,
item: AjsonSingleFileItemDataAdapter
};

var SmartComponent = class extends CollectionItem {
static {
__name(this, "SmartComponent");
}
static key = "smart_component";
static collection_key = "smart_components";
collection_key = "smart_components";
get_key() {
if (this.data?.key) return this.data.key;
const scope_key = this.scope_key;
const component_key = this.component_key;
const version2 = Number.isFinite(this.data?.version) ? this.data.version : 0;
const hash = this.data?.hash || "nohash";
const key_pcs = [];
if (!component_key.includes(scope_key) && scope_key !== "global") key_pcs.push(scope_key);
key_pcs.push(component_key);
return `${key_pcs.join("_").replace(/\./g, "_")}#${[version2, hash].join("#")}`;
}
get scope_key() {
return this.data?.scope_key;
}
get component_key() {
return this.data?.component_key;
}
get component_adapter() {
return this._component_adapter;
}
/**
* Delegates render logic to the adapter.
* @param {object} component_scope
* @param {object} [opts={}]
* @returns {Promise<*>}
*/
async render(component_scope, opts = {}) {
if (!this.component_adapter) {
throw new Error(`SmartComponent: adapter missing for ${this.component_key}`);
}
return await this.component_adapter.render(component_scope, opts);
}
};

function parse_component_properties(component_properties = []) {
const parts = component_properties.filter(Boolean).map((part) => part.toString());
const component_key = parts.pop();
const scope_key = parts.length ? parts.join(".") : "global";
return { scope_key, component_key };
}
__name(parse_component_properties, "parse_component_properties");
async function build_component_data(component_properties, component_module) {
const { scope_key, component_key } = parse_component_properties(component_properties);
if (!component_key) return null;
const render_fn = typeof component_module === "function" ? component_module : component_module?.render;
const version2 = typeof render_fn?.version === "number" ? render_fn.version : 0;
const hash = await murmur_hash_32_alphanumeric(render_fn.toString());
return { scope_key, component_key, version: version2, hash };
}
__name(build_component_data, "build_component_data");
var SmartComponentAdapter = class {
static {
__name(this, "SmartComponentAdapter");
}
constructor(item, component_module) {
this.item = item;
this.module = component_module;
this.item.env.create_env_getter(this);
}
static should_use_adapter(component_module) {
return true;
}
static async register_component(collection, component_properties, component_module) {
if (!this.should_use_adapter(component_module)) return null;
const data = await build_component_data(component_properties, component_module);
if (!data) return null;
const item = await collection.create_or_update({ ...data });
if (!item) return null;
item._component_module = component_module;
item._component_adapter = new this(item, component_module);
return item;
}
/**
* Render the component for the provided scope.
* @abstract
* @param {Object} scope - Render scope from the hosting environment.
* @param {Object} [opts] - Optional render options.
* @returns {Promise<*>} Rendered output for the component.
*/
async render(scope, opts) {
throw new Error("render() not implemented");
}
};

var SmartViewComponentAdapter = class extends SmartComponentAdapter {
static {
__name(this, "SmartViewComponentAdapter");
}
static should_use_adapter(component_module) {
return typeof component_module === "function" || typeof component_module?.render === "function";
}
get smart_view() {
if (!this._smart_view) {
this._smart_view = this.env.init_module("smart_view");
}
return this._smart_view;
}
async render(scope, opts = {}) {
const render_fn = typeof this.module === "function" ? this.module : this.module?.render;
if (typeof render_fn !== "function") {
throw new Error("SmartViewComponentAdapter: render() missing on module");
}
return await render_fn.call(this.smart_view, scope, opts);
}
};

function flatten_components_config(config, path = [], acc = []) {
if (!config || typeof config !== "object") return acc;
Object.entries(config).forEach(([key, value]) => {
const next_path = [...path, key];
if (!value) return;
if (typeof value === "function" || typeof value?.render === "function") {
acc.push({ properties: next_path, module: value });
return;
}
if (typeof value === "object") {
flatten_components_config(value, next_path, acc);
}
});
return acc;
}
__name(flatten_components_config, "flatten_components_config");
var SmartComponents = class extends Collection {
static {
__name(this, "SmartComponents");
}
static key = "smart_components";
static collection_key = "smart_components";
collection_key = "smart_components";
async init() {
await this.load_components_from_config();
}
get component_adapters() {
if (Array.isArray(this.opts?.component_adapters)) {
return this.opts.component_adapters;
}
if (this.opts?.component_adapters && typeof this.opts.component_adapters === "object") {
return Object.values(this.opts.component_adapters);
}
return this.constructor.default_component_adapters || [];
}
async load_components_from_config() {
const records = flatten_components_config(this.env.config?.components || {});
for (const record of records) {
await this.register_component(record.properties, record.module);
}
}
async register_component(component_properties, component_module) {
for (const AdapterClass of this.component_adapters) {
const item = await AdapterClass.register_component(this, component_properties, component_module);
if (item) return item;
}
return null;
}
async render_component(component_key, scope, opts = {}) {
const components = this.filter((item) => {
if (item.key.startsWith(component_key + "#")) return true;
return item.component_key === component_key;
}).sort((a, b) => {
const a_scope_match = a.scope_key === scope.key ? 1 : 0;
const b_scope_match = b.scope_key === scope.key ? 1 : 0;
return b_scope_match - a_scope_match;
});
if (components.length === 0) {
throw new Error(`SmartComponents: no component found for key ${component_key}`);
}
const selected_component = components[0];
return await selected_component.render(scope, opts);
}
};
var smart_components_default = {
class: SmartComponents,
item_type: SmartComponent,
data_adapter: ajson_single_file_default,
component_adapters: {
SmartViewComponentAdapter
}
};

var smart_components_default2 = smart_components_default;

function filter_redundant_context_items(items = []) {
const parents = /* @__PURE__ */ new Set();
for (const { key } of items) {
if (!key.includes("#")) parents.add(key);
}
return items.filter(({ key }) => {
if (!key.includes("#")) return true;
const base = key.split("#")[0];
return !parents.has(base);
});
}
__name(filter_redundant_context_items, "filter_redundant_context_items");

var remove_context_item_data = /* @__PURE__ */ __name((context_items, key) => {
if (!key || !context_items?.[key]) return false;
if (context_items[key].folder) {
if (context_items[key].exclude) return false;
context_items[key].exclude = true;
return true;
}
delete context_items[key];
return true;
}, "remove_context_item_data");
var SmartContext = class extends CollectionItem {
static {
__name(this, "SmartContext");
}
static version = 1;
static get defaults() {
return {
data: {
key: "",
context_items: {},
context_opts: {}
}
};
}
queue_save() {
super.queue_save();
this.collection.queue_save();
}
/**
* add_item
* @param {string|object} item
*/
add_item(item, params = {}) {
const {
emit_updated = true
} = params;
let key;
if (typeof item === "object") {
key = item.key || item.path;
} else {
key = item;
}
const existing = this.data.context_items[key];
const context_item = {
d: 0,
at: Date.now(),
...existing || {},
...typeof item === "object" ? item : {}
};
if (!key) return console.error("SmartContext: add_item called with invalid item", item);
this.data.context_items[key] = context_item;
this.queue_save();
if (emit_updated) this.emit_event("context:updated", { add_item: key });
}
/**
* add_items
* @param {string[]|object[]} items
*/
add_items(items) {
if (!Array.isArray(items)) items = [items];
items.forEach((item) => this.add_item(item, { emit_updated: false }));
this.emit_event("context:updated", { added_items: items.map((item) => typeof item === "object" ? item.key || item.path : item) });
}
/**
* remove_item
* Removes a path/ref from context and emits context:updated
* @param {string} key
* @param {object} params
* @param {boolean} params.emit_updated
*/
remove_item(key, params = {}) {
const { emit_updated = true } = params;
const removed = remove_context_item_data(this.data.context_items, key);
if (!removed) return;
this.queue_save();
if (emit_updated) this.emit_event("context:updated", { removed_key: key, removed_keys: [key] });
}
/**
* remove_items
* Removes paths/refs from context and emits context:updated once
* @param {string[]|string} keys
* @param {object} params
* @param {boolean} params.emit_updated
* @returns {string[]}
*/
remove_items(keys, params = {}) {
const { emit_updated = true } = params;
const items = Array.isArray(keys) ? keys : [keys];
const removed_keys = [];
items.forEach((item_key) => {
if (remove_context_item_data(this.data.context_items, item_key)) {
removed_keys.push(item_key);
}
});
if (!removed_keys.length) return [];
this.queue_save();
if (emit_updated) this.emit_event("context:updated", { removed_keys });
return removed_keys;
}
clear_all() {
this.data.context_items = {};
this.queue_save();
this.emit_event("context:updated", { cleared: true });
}
get context_item_keys() {
return Object.entries(this.data?.context_items || {}).filter(([key, item_data]) => !item_data.exclude).map(([key, item_data]) => key);
}
get key() {
if (!this.data.key) {
this.data.key = Date.now().toString();
}
return this.data.key;
}
get has_context_items() {
return Object.keys(this.data.context_items || {}).length > 0;
}
get name() {
return this.data.name;
}
set name(name) {
if (typeof name !== "string") throw new TypeError("Name must be a string");
const was_nameless = !this.data.name || String(this.data.name).trim().length === 0;
this.data.name = name;
if (was_nameless) this.emit_event("context:named");
else this.emit_event("context:renamed", { name });
this.queue_save();
}
get size() {
let size = 0;
const context_items = this.get_context_items();
context_items.forEach((item) => {
if (item.size) size += item.size;
});
return size;
}
get item_count() {
return Object.entries(this.data?.context_items || {}).filter(([key, item_data]) => !item_data.exclude).length;
}
async get_text(params = {}) {
const segments = [];
const context_items = this.context_items.filter(params.filter).sort((a, b) => a.data.d - b.data.d);
console.log("get_text context_items", context_items);
for (const item of context_items) {
if (item.is_media) continue;
const item_text = await item.get_text();
if (typeof item_text === "string") segments.push(item_text);
else this.emit_get_text_error(item, item_text);
}
const context_items_text = segments.join("\n");
if (typeof this.actions.context_merge_template === "function") {
return await this.actions.context_merge_template(context_items_text, { context_items });
}
return context_items_text;
}
async get_media(params = {}) {
const context_items = this.context_items.filter(params.filter);
const out = [];
for (const item of context_items) {
if (!item.is_media) continue;
const item_base64 = await item.get_base64();
if (item_base64.error) this.emit_get_media_error(item, item_base64);
else out.push(item_base64);
}
return out;
}
get context_items() {
if (!this._context_items) {
const config = this.env.config.collections.context_items;
const Class = config.class;
this._context_items = new Class(this.env, { ...config, class: null });
this._context_items.load_from_data(this.data.context_items || {});
if (!this._context_items_listener_registered) {
this.on_event("context:updated", () => {
this._context_items = null;
});
this._context_items_listener_registered = true;
}
}
return this._context_items;
}
emit_get_text_error(item, item_text) {
this.emit_event("notification:error", {
message: `Context item did not return text: ${item.key}`,
...item_text && typeof item_text === "object" ? item_text : {}
});
}
emit_get_media_error(item, item_base64) {
this.emit_event("notification:error", {
message: `Context item did not return media: ${item.key}`,
...item_base64 && typeof item_base64 === "object" ? item_base64 : {}
});
}
/**
* DEPRECATED
*/
/**
* Return *ContextItem* instances (any depth) for a given key array.
* @deprecated use context_items property instead
* @param {string[]} keys
*/
get_context_items(keys = this.context_item_keys) {
return filter_redundant_context_items(
keys.map((k) => this.get_context_item(k)).filter(Boolean)
);
}
/**
* @deprecated use context_items property instead
*/
get_context_item(key) {
const existing = this.env.context_items.get(key);
if (existing) return existing;
return this.env.context_items.new_item({ key, ...this.data.context_items[key] || {} });
}
/**
* @method get_ref
* @deprecated moving to using ContextItem instances
*/
get_ref(key) {
return this.collection.get_ref(key);
}
/**
* @deprecated
*/
get_item_keys_by_depth(depth) {
return Object.keys(this.data.context_items).filter((k) => {
const item_depth = this.data.context_items[k].d;
if (item_depth === depth) return true;
if (typeof item_depth === "undefined" && depth === 0) return true;
return false;
});
}
};

var SmartContexts = class extends Collection {
static {
__name(this, "SmartContexts");
}
static version = 0.1;
/**
* new_context
* @param {object} data
* @param {object} opts
* @param {string[]} opts.add_items
* @returns {SmartContext}
*/
new_context(data = {}, opts = {}) {
const item = new this.item_type(this.env, data);
if (Array.isArray(opts.add_items)) item.add_items(opts.add_items);
this.set(item);
item.queue_save();
item.emit_event("context:created");
return item;
}
/**
* Default settings for all SmartContext items in this collection.
* @readonly
*/
static get default_settings() {
return {
template_preset: "xml_structured",
template_before: "<context>\n{{FILE_TREE}}",
template_after: "</context>"
};
}
get settings_config() {
return {
...this.env.config.actions.context_merge_template?.settings_config || {}
};
}
get_ref(key) {
const collection = key.includes("#") ? this.env.smart_blocks : this.env.smart_sources;
return collection.get(key);
}
};

var smart_contexts_default_config = {
class: SmartContexts,
data_adapter: AjsonSingleFileCollectionDataAdapter,
item_type: SmartContext
};
var smart_contexts_default = smart_contexts_default_config;

var ContextItem = class extends CollectionItem {
static {
__name(this, "ContextItem");
}
get collection_key() {
return "context_items";
}
get context_type_adapter() {
if (!this._context_type_adapter) {
const Class = this.collection.context_item_adapters.find((adapter_class) => adapter_class.detect(this.key, this.data));
if (!Class) throw new Error(`No context item adapter found for key: ${this.key}`);
this._context_type_adapter = new Class(this);
}
return this._context_type_adapter;
}
get exists() {
return this.context_type_adapter.exists;
}
async get_text() {
const item_text = await this.context_type_adapter.get_text();
if (typeof item_text !== "string") return item_text;
if (typeof this.actions.context_item_merge_template === "function") {
return await this.actions.context_item_merge_template(item_text);
}
return item_text;
}
async get_base64() {
if (this.is_media) {
return await this.context_type_adapter.get_base64();
}
return { error: `Context item is not media type: ${this.key}` };
}
async open(event = null) {
return await this.context_type_adapter.open(event);
}
get is_media() {
return this.context_type_adapter.is_media || false;
}
get item_ref() {
return this.context_type_adapter.ref || null;
}
get size() {
return this.data.size || this.context_type_adapter.size || 0;
}
get mtime() {
return this.data.mtime || this.context_type_adapter.mtime || null;
}
};

var ContextItemAdapter = class {
static {
__name(this, "ContextItemAdapter");
}
constructor(item) {
this.item = item;
}
static detect(key, data = {}) {
return false;
}
get env() {
return this.item.env;
}
get exists() {
return true;
}
/**
* for calculating context size
*/
get size() {
return 0;
}
async get_text() {
}
async open() {
}
};

var BlockContextItemAdapter = class extends ContextItemAdapter {
static {
__name(this, "BlockContextItemAdapter");
}
static order = 6;
static detect(key) {
return key.includes("#");
}
get ref() {
return this.env.smart_blocks.get(this.item.key);
}
get inlinks() {
return this.ref.inlinks || [];
}
get outlinks() {
return this.ref.outlinks || [];
}
get exists() {
return !!(this.ref && !this.ref.is_gone);
}
get mtime() {
return this.ref?.mtime || null;
}
get size() {
return this.ref?.size || 0;
}
async get_text() {
const block = this.ref;
if (!block) return { error: "Block not found" };
return await block.read();
}
async open(event = null) {
this.ref.actions.source_open(event);
}
};

var SourceContextItemAdapter = class extends ContextItemAdapter {
static {
__name(this, "SourceContextItemAdapter");
}
static order = 7;
static detect(key) {
return true;
}
get ref() {
return this.env.smart_sources.get(this.item.key);
}
get inlinks() {
return this.ref.inlinks || [];
}
get outlinks() {
return this.ref.outlinks || [];
}
get exists() {
return !!(this.ref && !this.ref.is_gone);
}
get size() {
return this.ref?.size || 0;
}
get mtime() {
return this.ref?.mtime || null;
}
async get_text() {
return await this.ref?.read() || "MISSING SOURCE";
}
async open(event = null) {
this.ref.actions.source_open(event);
}
};

var image_extension_regex = /\.(png|jpe?g|gif|bmp|webp|svg|ico|mp4)$/i;

var ImageContextItemAdapter = class extends ContextItemAdapter {
static {
__name(this, "ImageContextItemAdapter");
}
static detect(key) {
if (image_extension_regex.test(key)) return "image";
return false;
}
get exists() {
return this.item.env.smart_sources.fs.exists_sync(this.item.key);
}
get is_media() {
return true;
}
async get_base64() {
const ext = this.item.key.split(".").pop().toLowerCase();
try {
const base64_data = await this.item.env.fs.read(this.item.key, "base64");
const base64_url = `data:image/${ext};base64,${base64_data}`;
return {
type: "image_url",
key: this.item.key,
name: this.item.key.split(/[\\/]/).pop(),
url: base64_url
};
} catch (err) {
console.warn(`Failed to convert image ${this.item.key} to base64`, err);
return { error: `Failed to convert image to base64: ${err.message}` };
}
}
};

var PdfContextItemAdapter = class extends ContextItemAdapter {
static {
__name(this, "PdfContextItemAdapter");
}
static detect(key) {
if (key.endsWith(".pdf")) return "pdf";
return false;
}
async add_to_snapshot(snapshot) {
if (!snapshot.pdfs) snapshot.pdfs = [];
snapshot.pdfs.push(this.item.key);
}
get is_media() {
return true;
}
async get_base64() {
try {
const base64_data = await this.item.env.fs.read(this.item.key, "base64");
const base64_url = `data:application/pdf;base64,${base64_data}`;
return {
type: "pdf_url",
key: this.item.key,
name: this.item.key.split(/[\\/]/).pop(),
url: base64_url
};
} catch (err) {
console.warn(`Failed to convert PDF ${this.item.key} to base64`, err);
return { error: `Failed to convert PDF to base64: ${err.message}` };
}
}
get exists() {
return this.item.env.smart_sources.fs.exists_sync(this.item.key);
}
};

var ContextItems = class extends Collection {
static {
__name(this, "ContextItems");
}
async load() {
console.log("ContextItems: load called");
}
static version = 1;
get context_item_adapters() {
if (!this._context_item_adapters) {
this._context_item_adapters = Object.values(this.opts.context_item_adapters).sort((a, b) => {
const order_a = a.order || 0;
const order_b = b.order || 0;
return order_a - order_b;
});
}
return this._context_item_adapters;
}
new_item(data) {
const item = new this.item_type(this.env, data);
this.set(item);
return item;
}
process_load_queue() {
}
get settings_config() {
return {
...this.env.config.actions.context_item_merge_template?.settings_config || {}
};
}
get_adapter_class(key, item_data) {
return this.context_item_adapters.find((adapter_class) => adapter_class.detect(key, item_data));
}
static get default_settings() {
return {
template_preset: "xml_structured",
template_before: '<item loc="{{KEY}}" at="{{TIME_AGO}}">',
template_after: "</item>"
};
}
load_from_data(context_items_data) {
delete this.items;
this.items = {};
const entries = Object.entries(context_items_data || {});
for (let i = 0; i < entries.length; i++) {
const [key, item_data] = entries[i];
if (item_data.exclude) continue;
this.new_item({
key,
...item_data
});
}
}
};
var context_items_default = {
version: 1,
class: ContextItems,
collection_key: "context_items",
item_type: ContextItem,
context_item_adapters: {
BlockContextItemAdapter,
SourceContextItemAdapter,
ImageContextItemAdapter,
PdfContextItemAdapter
}
};

function next_log_stats(prev = {}, at_ms) {
const ct = (prev.ct || 0) + 1;
const first_at = prev.first_at ?? at_ms;
const last_at = at_ms;
return { ct, first_at, last_at };
}
__name(next_log_stats, "next_log_stats");
var EventLog = class extends CollectionItem {
static {
__name(this, "EventLog");
}
static version = 2e-3;
/** @returns {{data: EventLogData}} */
static get defaults() {
return {
data: {
key: null,
ct: 0,
first_at: null,
last_at: null
}
};
}
/**
* Counters are updated via EventLogs listener.
* @param {Partial<EventLogData>} [_input_data]
*/
init(_input_data) {
}
};

var EXCLUDED_EVENT_KEYS = {
"collection:save_started": true,
"collection:save_completed": true
};
var EventLogs = class extends Collection {
static {
__name(this, "EventLogs");
}
static version = 3e-3;
constructor(env, opts = {}) {
super(env, opts);
this.session_events = [];
this.notification_status = null;
}
/**
* Factory that attaches the collection to env and registers the wildcard listener.
* @param {Object} env
* @param {Object} [opts={}]
* @returns {EventLogs}
*/
static create(env, opts = {}) {
const instance = new this(env, opts);
instance.init();
return instance;
}
/** Prefer an explicit item class to keep wiring thin. */
get item_type() {
return EventLog;
}
/**
* Instance init
* - Ensure env.events exists
* - Register wildcard listener
* - Idempotent across repeated calls
*/
init() {
if (!this.env?.events) SmartEvents.create(this.env);
if (this._unsub_wildcard) this._unsub_wildcard();
this._unsub_wildcard = this.env.events.on(WILDCARD_KEY, (event, event_key) => {
this.on_any_event(event_key, event);
});
}
/**
* Handle any emitted event.
* Persists counters and timestamps in epoch ms.
* @param {string} event_key
* @param {Record<string, unknown>} event
*/
on_any_event(event_key, event) {
if (EXCLUDED_EVENT_KEYS[event_key]) return;
this.session_events.push({ event_key, event });
if (event_key === "notification:error") this.notification_status = "error";
else if (event_key === "notification:warning" && this.notification_status !== "error") this.notification_status = "warning";
else if (event_key === "notification:attention" && !this.notification_status) this.notification_status = "attention";
try {
if (typeof event_key !== "string") return;
const at_ms = Date.now();
let event_log = this.get(event_key);
if (!event_log) {
event_log = new EventLog(this.env, { key: event_key });
this.set(event_log);
this.emit_event("event_log:first", { first_of_event_key: event_key });
}
const next = next_log_stats(
{ ct: event_log.data.ct, first_at: event_log.data.first_at, last_at: event_log.data.last_at },
at_ms
);
event_log.data = { ...event_log.data, ...next };
if (event.event_source) {
if (!event_log.data.event_sources) event_log.data.event_sources = {};
if (!event_log.data.event_sources[event.event_source]) {
event_log.data.event_sources[event.event_source] = 0;
}
event_log.data.event_sources[event.event_source]++;
}
event_log.queue_save();
this.queue_save();
} catch (err) {
console.error("[EventLogs] record failure", event_key, err);
}
}
/**
* Cleanly detach listeners and cancel pending save.
*/
unload() {
if (this._save_timer) {
clearTimeout(this._save_timer);
this._save_timer = null;
}
if (typeof this._unsub_wildcard === "function") {
this._unsub_wildcard();
this._unsub_wildcard = null;
}
return super.unload();
}
};
var event_logs_default = {
class: EventLogs,
collection_key: "event_logs",
data_adapter: AjsonSingleFileCollectionDataAdapter,
item_type: EventLog
};

var import_obsidian4 = require("obsidian");

function build_suggest_scope_items(modal, params = {}) {
if (!modal) return [];
const action_keys = Array.isArray(params.action_keys) ? params.action_keys : [];
const action_configs = modal?.env?.config?.actions || {};
const action_handlers = modal?.item_or_collection?.actions || {};
const unique_action_keys = [...new Set(action_keys)];
return unique_action_keys.reduce((acc, action_key) => {
const action_handler = action_handlers[action_key];
if (typeof action_handler !== "function") return acc;
const action_config = action_configs[action_key] || {};
const display_name9 = action_config.display_name || action_key;
acc.push({
select_action: /* @__PURE__ */ __name(() => {
modal.update_suggestions(action_key);
}, "select_action"),
key: action_key,
display: display_name9
});
return acc;
}, []);
}
__name(build_suggest_scope_items, "build_suggest_scope_items");
var should_handle_arrow_left = /* @__PURE__ */ __name((modal, params = {}) => {
const input_el = modal?.inputEl;
const event_target = params.event_target;
const input_value = typeof params.input_value === "string" ? params.input_value : input_el?.value || "";
if (event_target === input_el && input_value) {
return false;
}
return true;
}, "should_handle_arrow_left");

var SmartFuzzySuggestModal = class extends import_obsidian4.FuzzySuggestModal {
static {
__name(this, "SmartFuzzySuggestModal");
}
constructor(item_or_collection) {
const env = item_or_collection.env;
const plugin = env.plugin;
const app = plugin.app;
super(app);
this.app = app;
env.create_env_getter(this);
this.plugin = plugin;
this.item_or_collection = item_or_collection;
this.emptyStateText = "No suggestions available";
this._set_custom_instructions = false;
}
/** Unique type key for this modal class. Subclasses override. */
static get modal_type() {
return "smart-fuzzy-suggest";
}
/** Human label used in commands. Subclasses override as needed. */
static get display_text() {
return "Smart Fuzzy Suggest";
}
/** Event name listened to on env.events to open this modal. */
static get event_domain() {
return `${this.modal_type}`;
}
/** Command id used with addCommand. */
static get command_id() {
return this.modal_type;
}
static open(item_or_collection, params) {
const Modal17 = (
/** @type {typeof SmartFuzzySuggestModal} */
this
);
const modal = new Modal17(item_or_collection, params);
modal.open(params);
return modal;
}
static register_modal(plugin) {
const Modal17 = (
/** @type {typeof SmartFuzzySuggestModal} */
this
);
const env = plugin?.env;
const modal_config = {
...env.config.modals?.[this.modal_key] || {},
class: null
};
console.log(`Registering modal: ${this.display_text}`, { modal_config, Modal: Modal17 });
const open_handler = /* @__PURE__ */ __name((payload = {}) => {
const item = Modal17.resolve_item_from_payload(env, payload);
const modal = Modal17.open(item, {
...modal_config,
...payload
});
return modal;
}, "open_handler");
const disposers = [
env?.events?.on?.(`${Modal17.event_domain}:open`, open_handler)
];
const dispose_all = /* @__PURE__ */ __name(() => {
disposers.forEach((dispose) => typeof dispose === "function" && dispose());
}, "dispose_all");
if (typeof plugin.register === "function") {
plugin.register(() => dispose_all());
}
return {
event_domain: Modal17.event_domain
};
}
static resolve_item_from_payload(env, payload) {
const item = env?.[payload.collection_key]?.items?.[payload.item_key];
return item;
}
setInstructions(instructions, is_custom = true) {
this._set_custom_instructions = is_custom;
super.setInstructions(instructions);
}
set_default_instructions() {
this.setInstructions([
{ command: "Enter", purpose: "Select" }
], false);
}
open(params = {}) {
super.open();
this.modalEl.addEventListener("keydown", (e) => {
if (e.key === "Enter") {
if (e.shiftKey) this.use_shift_select = true;
this.selectActiveSuggestion(e);
}
const is_cursor_end_of_input = this.inputEl.selectionStart === this.inputEl.value.length;
const should_handle_arrow_right = is_cursor_end_of_input || e.target !== this.inputEl || !this.inputEl.value;
const should_handle_arrow_left_action = should_handle_arrow_left(this, {
event_target: e.target,
input_value: this.inputEl.value
});
if (e.key === "ArrowLeft" && should_handle_arrow_left_action) {
this.use_arrow_left = true;
this.selectActiveSuggestion(e);
return;
}
if (e.key === "ArrowRight" && should_handle_arrow_right) {
e.preventDefault();
this.use_mod_select = true;
this.use_arrow_right = true;
this.selectActiveSuggestion(e);
return;
}
});
}
getItems() {
return this.get_suggestions();
}
getItemText(suggestion_item) {
return suggestion_item.display;
}
filter_suggestions(suggestions) {
return suggestions;
}
get_suggestions() {
if (this.suggestions?.length) {
this.suggestions = this.filter_suggestions(this.suggestions);
if (this.suggestions.length > 0) {
return this.suggestions;
}
}
if (this.default_suggest_action_keys?.length) {
if (this.default_suggest_action_keys.length === 1) {
this.update_suggestions(this.default_suggest_action_keys[0]);
return [];
}
return this.get_suggest_scopes();
}
return [];
}
get_suggest_scopes() {
return build_suggest_scope_items(this, {
action_keys: this.default_suggest_action_keys
});
}
async update_suggestions(suggest_ref) {
if (typeof suggest_ref === "string") {
suggest_ref = this.item_or_collection.actions[suggest_ref];
}
if (typeof suggest_ref === "function") {
this._set_custom_instructions = false;
const result = await suggest_ref({ modal: this });
console.log("Suggestion action result", result);
if (Array.isArray(result) && result.length) {
this.suggestions = result;
}
} else if (Array.isArray(suggest_ref)) {
this.suggestions = suggest_ref;
}
if (Array.isArray(this.suggestions) && this.suggestions.length) {
this.updateSuggestions();
} else {
this.env.events.emit("notification:error", { message: "Invalid suggestion action" });
console.warn("Invalid suggestion action", suggest_ref);
}
if (!this._set_custom_instructions) {
this.set_default_instructions();
}
}
get default_suggest_action_keys() {
if (Array.isArray(this.params?.default_suggest_action_keys)) {
return this.params.default_suggest_action_keys;
}
return this.env.config.modals[this.modal_key]?.default_suggest_action_keys || [];
}
renderSuggestion(sug, el) {
super.renderSuggestion(sug, el);
if (sug.item.icon) {
el.addClass("sc-modal-suggestion-has-icon");
const icon_el = el.createEl("span");
(0, import_obsidian4.setIcon)(icon_el, sug.item.icon);
}
return el;
}
onChooseSuggestion(selected, evt, ...other) {
this.prevent_close = true;
const suggestion = selected.item;
const is_arrow_left = this.use_arrow_left;
const is_arrow_right = this.use_arrow_right;
const is_shift_select = evt?.shiftKey || this.use_shift_select;
const is_mod_select = import_obsidian4.Keymap.isModifier(evt, "Mod") || this.use_mod_select;
this.use_arrow_right = false;
this.use_mod_select = false;
this.use_arrow_left = false;
this.use_shift_select = false;
if (is_arrow_left) {
if (typeof suggestion.arrow_left_action === "function") {
this.handle_choose_action(suggestion, "arrow_left_action");
} else {
if (this.last_input_value) {
this.inputEl.value = this.last_input_value;
setTimeout(() => {
const len = this.inputEl.value.length;
this.inputEl.setSelectionRange(len, len);
}, 0);
this.last_input_value = null;
}
this.suggestions = null;
this.params.default_suggest_action_keys = null;
this.updateSuggestions();
return;
}
} else if (is_arrow_right && typeof suggestion.arrow_right_action === "function") {
this.handle_choose_action(suggestion, "arrow_right_action");
} else if (is_mod_select && typeof suggestion.mod_select_action === "function") {
this.handle_choose_action(suggestion, "mod_select_action");
} else if (is_shift_select && typeof suggestion.shift_select_action === "function") {
this.handle_choose_action(suggestion, "shift_select_action");
} else if (typeof suggestion.select_action === "function") {
this.handle_choose_action(suggestion, "select_action");
} else {
this.env.events.emit("notification:warning", { selection_display: suggestion.display, message: "No action defined for this suggestion" });
}
}
async handle_choose_action(suggestion, action_key) {
let chosen_action = suggestion[action_key];
const result = await chosen_action({ modal: this });
if (Array.isArray(result) && result.length) {
this.suggestions = result;
} else if (Array.isArray(result)) {
this.env.events.emit("notification:info", { message: "No suggestions returned from action" });
}
const idx = this.chooser.values.findIndex((i) => i.item?.display === suggestion.display);
setTimeout(() => {
this.updateSuggestions();
if (idx !== -1) {
this.chooser.setSelectedItem(idx);
}
}, 100);
}
close() {
setTimeout(() => {
if (!this.prevent_close) super.close();
this.prevent_close = false;
}, 10);
}
onClose() {
this.item_or_collection.emit_event(`${this.constructor.event_domain}:closed`);
}
};

var import_obsidian5 = require("obsidian");
var ContextModal = class extends SmartFuzzySuggestModal {
static {
__name(this, "ContextModal");
}
/** Modal identity */
static get modal_type() {
return "context_selector";
}
static get display_text() {
return "Context Selector";
}
static get event_domain() {
return "context_selector";
}
static get command_id() {
return this.modal_type;
}
static get modal_key() {
return "context_selector";
}
get modal_key() {
return "context_selector";
}
constructor(smart_context, params = {}) {
super(smart_context);
this.params = { ...params };
this.smart_context = smart_context;
this.set_default_instructions();
}
set_default_instructions() {
this.setInstructions([
{ command: "Enter", purpose: "Add to context" },
{ command: `\u2192 / \u2190`, purpose: "Toggle block view" },
{ command: "Esc", purpose: "Close" }
]);
}
open(params = {}) {
this.params = { ...this.params, ...params };
super.open();
this.render(this.params);
}
async render(params = this.params) {
this.modalEl.style.display = "flex";
this.modalEl.style.flexDirection = "column";
this.modalEl.style.height = "100%";
this.modalEl.prepend(
await this.env.smart_components.render_component(
"smart_context_item",
this.smart_context,
params
)
);
}
filter_suggestions(suggestions) {
return suggestions.filter((s) => {
if (s.key && this.smart_context?.data?.context_items[s.key]) return false;
return true;
});
}
};

var import_obsidian6 = require("obsidian");
var NotificationsFeedModal = class extends import_obsidian6.Modal {
static {
__name(this, "NotificationsFeedModal");
}
constructor(app, env) {
super(app);
this.env = env;
}
async onOpen() {
this.titleEl.setText("Smart Env notifications");
this.contentEl.empty();
const event_log = await this.env.smart_components.render_component("notifications_feed", this.env);
this.contentEl.appendChild(event_log);
}
onClose() {
this.contentEl.empty();
}
};

var import_obsidian7 = require("obsidian");
var MILESTONES_HELP_URL = "https://smartconnections.app/smart-environment/milestones/?utm_source=milestones_modal_help";
var MilestonesModal = class extends import_obsidian7.Modal {
static {
__name(this, "MilestonesModal");
}
constructor(app, env) {
super(app);
this.env = env;
}
async onOpen() {
render_milestones_modal_title(this.titleEl, this.env);
this.contentEl.empty();
const milestones = await this.env.smart_components.render_component("milestones", this.env, {});
this.contentEl.appendChild(milestones);
}
onClose() {
this.contentEl.empty();
}
};
function render_milestones_modal_title(title_el, env) {
if (!title_el) return;
title_el.empty();
title_el.classList.add("sc-milestones-modal__title");
const row_el = document.createElement("div");
row_el.className = "sc-milestones-modal__title-row";
const text_el = document.createElement("div");
text_el.className = "sc-milestones-modal__title-text";
text_el.textContent = "Smart Milestones";
const help_btn_el = document.createElement("button");
help_btn_el.type = "button";
help_btn_el.className = "sc-milestones-modal__help-btn";
help_btn_el.setAttribute("aria-label", "Open Smart Milestones help");
help_btn_el.setAttribute("title", "Help");
render_help_icon(help_btn_el);
help_btn_el.addEventListener("click", (evt) => {
evt.preventDefault();
evt.stopPropagation();
try {
env?.events?.emit?.("milestones:help", {});
} catch (err) {
}
window.open(MILESTONES_HELP_URL, "_external");
});
row_el.appendChild(text_el);
row_el.appendChild(help_btn_el);
title_el.appendChild(row_el);
}
__name(render_milestones_modal_title, "render_milestones_modal_title");
function render_help_icon(icon_el) {
const ok = set_icon_with_fallback(icon_el, ["circle-help", "help-circle", "help", "info"]);
if (!ok) icon_el.textContent = "?";
}
__name(render_help_icon, "render_help_icon");
function set_icon_with_fallback(icon_el, icon_ids) {
if (!icon_el) return false;
const ids = Array.isArray(icon_ids) ? icon_ids : [];
for (const icon_id of ids) {
if (typeof icon_id !== "string" || icon_id.length === 0) continue;
icon_el.textContent = "";
try {
(0, import_obsidian7.setIcon)(icon_el, icon_id);
} catch (err) {
continue;
}
if (icon_el.querySelector("svg")) return true;
}
return false;
}
__name(set_icon_with_fallback, "set_icon_with_fallback");

var default_settings = {
is_obsidian_vault: true,
smart_blocks: {
embed_blocks: true,
min_chars: 200
},
smart_sources: {
min_chars: 200,
embed_model: {
adapter: "transformers",
transformers: {
model_key: "TaylorAI/bge-micro-v2"
}
},
excluded_headings: "",
file_exclusions: "Untitled",
folder_exclusions: ""
},
language: "en",
re_import_wait_time: 13,
smart_chat_threads: {
chat_model: {
adapter: "ollama",
ollama: {}
}
},
smart_notices: {},
smart_view_filter: {
expanded_view: false,
render_markdown: true,
show_full_path: false
},
version: "",
new_user: true,
models: {
embedding_platform: "transformers",
chat_completion_platform: "open_router"
}
};

var Model = class extends CollectionItem {
static {
__name(this, "Model");
}
/**
* Default properties for an instance of CollectionItem.
* @returns {Object}
*/
static get defaults() {
return {
data: {
api_key: "",
provider_key: "",
model_key: ""
}
};
}
get_key() {
if (!this.data.key) {
this.data.created_at = Date.now();
this.data.key = `${this.data.provider_key}#${this.data.created_at}`;
}
return this.data.key;
}
get provider_key() {
return this.data.provider_key;
}
get env_config() {
return this.collection.env_config;
}
get provider_config() {
return this.env_config.providers?.[this.provider_key] || {};
}
get ProviderAdapterClass() {
return this.provider_config.class;
}
get instance() {
if (!this._instance) {
if (!this.ProviderAdapterClass) {
const new_default_model = this.collection.new_model({ provider_key: this.collection.default_provider_key });
return new_default_model.instance;
}
const Class = this.ProviderAdapterClass;
this._instance = new Class(this);
this._instance.load();
this.once_event("model:changed", () => {
this._instance.unload?.();
this._instance = null;
});
}
return this._instance;
}
async count_tokens(text) {
return this.instance.count_tokens(text);
}
get api_key() {
return this.data.api_key;
}
/**
* Create (or reuse) a proxy around a target settings object so that
* any mutations trigger queue_save on the model.
* Proxies are cached per-target via WeakMap to support deep nested objects.
*
* @param {Object} target - The settings object or nested object to wrap.
* @returns {Object} Proxied object or original value if not an object.
* @private
*/
create_settings_proxy(target) {
if (!target || typeof target !== "object") return target;
if (!this._settings_proxy_map) {
this._settings_proxy_map = /* @__PURE__ */ new WeakMap();
}
const existing = this._settings_proxy_map.get(target);
if (existing) return existing;
const self = this;
const handler = {
get(target_obj, prop, receiver) {
const value = Reflect.get(target_obj, prop, receiver);
if (value && typeof value === "object") {
return self.create_settings_proxy(value);
}
return value;
},
set(target_obj, prop, value, receiver) {
const previous = target_obj[prop];
const result = Reflect.set(target_obj, prop, value, receiver);
if (previous !== value) {
self.debounce_save();
}
return result;
},
deleteProperty(target_obj, prop) {
const had = Object.prototype.hasOwnProperty.call(target_obj, prop);
const result = Reflect.deleteProperty(target_obj, prop);
if (had) {
self.debounce_save();
}
return result;
}
};
const proxy = new Proxy(target, handler);
this._settings_proxy_map.set(target, proxy);
return proxy;
}
debounce_save(ms = 100) {
this.emit_event("model:changed");
if (this._debounce_save_timeout) {
clearTimeout(this._debounce_save_timeout);
}
this._debounce_save_timeout = setTimeout(() => {
this.queue_save();
this.collection.process_save_queue();
this._debounce_save_timeout = null;
}, ms);
}
async get_model_key_options() {
const model_configs = await this.instance.get_models();
return Object.entries(model_configs).map(([key, model_config]) => ({
label: model_config.name || key,
value: model_config.key || key
})).sort((a, b) => {
if (a.label.toLowerCase().includes("free") && !b.label.toLowerCase().includes("free")) {
return -1;
}
if (!a.label.toLowerCase().includes("free") && b.label.toLowerCase().includes("free")) {
return 1;
}
return a.label.localeCompare(b.label);
});
}
model_changed(key, value, elm) {
if (key === "model_key") {
this.data.model_key = value;
const model_defaults = this.data.provider_models?.[this.data.model_key] || {};
const adapter_defaults = this.ProviderAdapterClass.defaults || {};
delete this.data.test_passed;
this.data = {
...this.data,
...adapter_defaults,
...model_defaults
};
}
if (!["api_key", "meta.name"].includes(key)) {
this.emit_event("model:changed");
}
}
/**
* @abstract should be implemented by subclasses
*/
async test_model() {
}
get display_name() {
return this.data.meta?.name || `${this.data.provider_key} - ${this.data.model_key}`;
}
get settings_config() {
return {
provider_key: {
type: "html",
value: `<p><strong>Provider:</strong> ${this.data.provider_key}</p>`
},
"meta.name": {
type: "text",
name: "Name",
description: "A friendly name for this model configuration."
},
model_key: {
type: "dropdown",
name: "Model",
description: "The model to use from the selected provider.",
options_callback: "get_model_key_options",
callback: "model_changed"
},
...Object.fromEntries(
Object.entries(this.provider_config.settings_config || {}).map(
([setting_key, setting_config]) => [setting_key, { ...setting_config, callback: setting_config.callback || "model_changed" }]
)
)
};
}
delete_model() {
this.delete();
this.debounce_save();
}
/**
* Reactive settings view for this model.
* Mutating any property (including nested objects/arrays) via this proxy
* will call queue_save().
*
* @returns {Object} Proxied view of this.data.
*/
get settings() {
return this.create_settings_proxy(this.data);
}
get model_key() {
return this.data.model_key;
}
/**
* @deprecated included for backward compatibility
*/
get opts() {
return this.settings;
}
};

var Models = class extends Collection {
static {
__name(this, "Models");
}
model_type = "Model type";
new_model(data = {}) {
if (!data.provider_key) throw new Error("provider_key is required to create a new model");
const existing_from_provider = this.filter((m) => m.provider_key === data.provider_key).sort((a, b) => b.data.created_at - a.data.created_at)[0];
if (existing_from_provider) {
if (!data.api_key && existing_from_provider.data.api_key) {
data.api_key = existing_from_provider.data.api_key;
}
}
const item = new this.item_type(this.env, {
...data
});
this.set(item);
this.settings.default_model_key = item.key;
this.emit_event("model:changed");
item.queue_save();
return item;
}
/**
* Retrieve the provider key used when creating a default model.
* @abstract
* @returns {string} provider key for the default model.
*/
get default_provider_key() {
throw new Error("default_provider_key not implemented");
}
get default_model_key() {
const should_update_default = !this.settings.default_model_key || !this.get(this.settings.default_model_key) || this.get(this.settings.default_model_key).deleted;
if (should_update_default) {
const existing = this.filter((m) => !m.deleted).sort((a, b) => b.data.created_at - a.data.created_at)[0];
if (existing) {
this.settings.default_model_key = existing.key;
} else {
const new_default = this.new_model({ provider_key: this.default_provider_key });
new_default.queue_save();
this.process_save_queue();
this.settings.default_model_key = new_default.key;
}
}
return this.settings.default_model_key;
}
get default() {
return this.get(this.default_model_key);
}
get env_config() {
return this.env.config.collections[this.collection_key];
}
get_model_key_options() {
return this.filter((i) => !i.deleted && i.ProviderAdapterClass).map((model) => ({
label: model.data.meta?.name || `${model.provider_key} - ${model.data.model_key}`,
value: model.key
}));
}
};
function settings_config5(scope) {
return {
default_model_key: {
type: "dropdown",
name: `Default ${scope.model_type.toLowerCase()} model`,
description: `Used as the default ${scope.model_type.toLowerCase()} model when no other is specified.`,
options_callback: /* @__PURE__ */ __name(() => {
return scope.get_model_key_options();
}, "options_callback"),
callback: /* @__PURE__ */ __name(async (value, setting) => {
scope.emit_event("model:changed");
}, "callback")
}
};
}
__name(settings_config5, "settings_config");

var EmbeddingModel = class extends Model {
static {
__name(this, "EmbeddingModel");
}
/**
* Default properties for an instance of CollectionItem.
* @returns {Object}
*/
static get defaults() {
return {
data: {
api_key: "",
provider_key: "transformers",
model_key: "TaylorAI/bge-micro-v2",
dims: 384,
max_tokens: 512
}
};
}
async embed(input) {
if (typeof input === "string") {
input = [{ embed_input: input }];
}
return (await this.embed_batch(input))[0];
}
async embed_batch(inputs) {
return this.instance.embed_batch(inputs);
}
async test_model() {
try {
const resp = await this.embed("test input");
const success = resp && !resp?.error;
this.data.test_passed = success;
this.debounce_save();
return { success, response: resp };
} catch (e) {
this.data.test_passed = false;
return { error: e.message || String(e) };
}
}
};

var EmbeddingModels = class extends Models {
static {
__name(this, "EmbeddingModels");
}
model_type = "Embedding";
get default_provider_key() {
return "transformers";
}
};
var embedding_models_collection = {
class: EmbeddingModels,
data_dir: "embedding_models",
collection_key: "embedding_models",
data_adapter: ajson_single_file_default,
item_type: EmbeddingModel,
providers: {
},
settings_config: settings_config5
};
var embedding_models_default = embedding_models_collection;

var TransformersIframeEmbeddingModelAdapter = class extends SmartEmbedTransformersIframeAdapter {
static {
__name(this, "TransformersIframeEmbeddingModelAdapter");
}
constructor(model_item) {
super(model_item);
}
get models() {
return {
"TaylorAI/bge-micro-v2": {
"id": "TaylorAI/bge-micro-v2",
"batch_size": 1,
"dims": 384,
"max_tokens": 512,
"name": "BGE-micro-v2 (fastest)",
"description": "Local, 512 tokens, 384 dim (recommended)",
"adapter": "transformers"
},
"Snowflake/snowflake-arctic-embed-xs": {
"id": "Snowflake/snowflake-arctic-embed-xs",
"batch_size": 1,
"dims": 384,
"max_tokens": 512,
"name": "Snowflake Arctic Embed XS (fast)",
"description": "Local, 512 tokens, 384 dim",
"adapter": "transformers"
},
"Xenova/multilingual-e5-small": {
"id": "Xenova/multilingual-e5-small",
"batch_size": 1,
"dims": 384,
"max_tokens": 512,
"name": "Multilingual E5 Small",
"description": "Local, 512 tokens, 384 dim",
"adapter": "transformers"
}
};
}
};
var transformers_iframe_default = {
class: TransformersIframeEmbeddingModelAdapter,
settings_config: settings_config4
};

embedding_models_default.providers = {
transformers: transformers_iframe_default
};
var embedding_models_default2 = embedding_models_default;

var LookupList = class extends CollectionItem {
static {
__name(this, "LookupList");
}
static key = "lookup_list";
static get defaults() {
return { data: {} };
}
async pre_process(params) {
if (typeof this.actions.lookup_list_pre_process === "function") {
await this.actions.lookup_list_pre_process(params);
}
}
async get_results(params = {}) {
await this.pre_process(params);
let results = this.filter_and_score(params);
if (this.should_post_process) results = await this.post_process(results, params);
this.emit_event("lookup:get_results");
return results;
}
filter_and_score(params = {}) {
const collection = this.env[params.results_collection_key] || this.env[this.collection.results_collection_key];
const score_errors = [];
const { results: raw_results } = Object.values(collection.items).reduce((acc, target) => {
const scored = target.filter_and_score(params);
if (!scored?.score) {
if (scored?.error) score_errors.push(scored.error);
return acc;
}
results_acc(acc, scored, params.limit || 20);
return acc;
}, { min: 0, results: /* @__PURE__ */ new Set() });
const results = Array.from(raw_results).sort(sort_by_score_descending);
if (!results.length) return results;
while (!results.some((r) => r.score > 0.5)) {
results.forEach((r) => r.score *= 2);
}
return results;
}
async post_process(results, params = {}) {
return results;
}
get should_post_process() {
return this.settings.lookup_post_process && this.settings.lookup_post_process !== "none";
}
get item() {
return this;
}
};

var settings_config6 = {
results_collection_key: {
name: "Lookup results type",
type: "dropdown",
description: "Choose whether results should be sources or blocks.",
option_1: "smart_sources|Sources",
option_2: "smart_blocks|Blocks",
options_callback: /* @__PURE__ */ __name((scope) => {
const options = [
{ value: "smart_sources", name: "Sources" }
];
if (scope.env.smart_blocks) {
options.push({ value: "smart_blocks", name: "Blocks" });
}
return options;
}, "options_callback")
}
};
var LookupLists = class extends Collection {
static {
__name(this, "LookupLists");
}
static get default_settings() {
return {
results_collection_key: "smart_blocks",
score_algo_key: "similarity",
results_limit: 20
};
}
static version = 0.01;
new_item({ query, filter }) {
if (!query || typeof query !== "string" || !query.trim()) {
throw new Error("LookupLists.new_item requires a non-empty query string.");
}
const date = format_ymd(/* @__PURE__ */ new Date());
const hash = murmur_hash_32_alphanumeric(query);
const key = `${date}+${hash}`;
if (this.items[key]) return this.items[key];
const list = new LookupList(this.env, {
key,
query,
filter
});
this.set(list);
return list;
}
get settings_config() {
return { ...settings_config6 };
}
process_load_queue() {
}
get results_collection_key() {
const stored_key = this.settings?.results_collection_key;
if (this.env.collections?.[stored_key]) return stored_key;
return "smart_sources";
}
};
function format_ymd(d) {
const y = d.getFullYear();
const m = String(d.getMonth() + 1).padStart(2, "0");
const day = String(d.getDate()).padStart(2, "0");
return `${y}-${m}-${day}`;
}
__name(format_ymd, "format_ymd");
var lookup_lists_default = {
class: LookupLists,
collection_key: "lookup_lists",
item_type: LookupList,
settings_config: settings_config6
};

function format_collection_name(key) {
return key.replace(/_/g, " ").replace(/\b\w/g, (c) => c.toUpperCase());
}
__name(format_collection_name, "format_collection_name");

async function build_html2(collection, opts = {}) {
const settings_html = Object.entries(collection.settings_config).map(([setting_key, setting_config]) => {
if (!setting_config.setting) setting_config.setting = setting_key;
return this.render_setting_html(setting_config);
}).join("\n");
const html = `<div><div class="collection-settings-container"><div class="source-settings collection-settings">
<h2>${format_collection_name(collection.collection_key)}</h2>
${settings_html}
</div></div></div>`;
return html;
}
__name(build_html2, "build_html");
async function render2(collection, opts = {}) {
const html = await build_html2.call(this, collection, opts);
const frag = this.create_doc_fragment(html);
await this.render_setting_components(frag, { scope: collection });
if (opts.settings_container) {
this.empty(opts.settings_container);
opts.settings_container.appendChild(frag.querySelector(".collection-settings"));
} else {
collection.settings_container = frag.querySelector(".collection-settings-container");
}
return collection.settings_container;
}
__name(render2, "render");

var import_obsidian8 = require("obsidian");
function register_block_hover_popover(parent, target, env, block_key, params = {}) {
const app = env?.plugin?.app || window.app;
target.addEventListener("mouseover", async (ev) => {
if (import_obsidian8.Keymap.isModEvent(ev)) {
const block = env.smart_blocks.get(block_key);
const markdown = await block?.read();
if (markdown) {
const popover = new import_obsidian8.HoverPopover(parent, target);
const frag = env.smart_view.create_doc_fragment(`<div class="markdown-embed is-loaded">
<div class="markdown-embed-content node-insert-event">
<div class="markdown-preview-view markdown-rendered node-insert-event show-indentation-guide allow-fold-headings allow-fold-lists">
<div class="markdown-preview-sizer markdown-preview-section">
</div>
</div>
</div>
</div>`);
popover.hoverEl.classList.add("smart-block-popover");
popover.hoverEl.appendChild(frag);
const sizer = popover.hoverEl.querySelector(".markdown-preview-sizer");
import_obsidian8.MarkdownRenderer.render(app, markdown, sizer, "/", popover);
const event_domain = params.event_key_domain || "block";
block.emit_event(`${event_domain}:hover_preview`);
}
}
});
}
__name(register_block_hover_popover, "register_block_hover_popover");

var import_obsidian9 = require("obsidian");
function register_item_hover_popover(container, item, params = {}) {
const app = item.env?.plugin?.app || window.app;
if (item.key.indexOf("{") === -1) {
container.addEventListener("mouseover", (event) => {
const linktext_path = item.key.replace(/#$/, "");
app.workspace.trigger("hover-link", {
event,
source: "smart-connections-view",
hoverParent: container.parentElement,
targetEl: container,
linktext: linktext_path
});
if (import_obsidian9.Keymap.isModEvent(event)) {
const event_domain = params.event_key_domain || item.collection_key || "item";
item.emit_event(`${event_domain}:hover_preview`);
}
});
} else {
register_block_hover_popover(container.parentElement, container, item.env, item.key);
}
}
__name(register_item_hover_popover, "register_item_hover_popover");

var import_obsidian10 = require("obsidian");
function format_score(score) {
const numeric_score = typeof score === "number" ? score : Number.parseFloat(score);
if (!Number.isFinite(numeric_score)) return null;
return Number.parseFloat(numeric_score.toFixed(2)).toString();
}
__name(format_score, "format_score");
function format_size(size) {
const numeric_size = typeof size === "number" ? size : Number.parseFloat(size);
if (!Number.isFinite(numeric_size) || numeric_size < 0) return null;
const units = ["B", "KB", "MB", "GB"];
let size_value = numeric_size;
let unit_index = 0;
while (size_value >= 1024 && unit_index < units.length - 1) {
size_value /= 1024;
unit_index += 1;
}
const precision = size_value >= 10 || Number.isInteger(size_value) ? 0 : 1;
const rounded_value = Number.parseFloat(size_value.toFixed(precision));
return `${rounded_value.toString()} ${units[unit_index]}`;
}
__name(format_size, "format_size");
function build_badge_html(label, class_name) {
if (!label) return "";
return `<span class="${class_name}">${label}</span>`;
}
__name(build_badge_html, "build_badge_html");
function build_html3(context_item, params = {}) {
let name;
if (context_item.item_ref) {
if (context_item.item_ref.key.includes("#")) {
const name_pcs = context_item.item_ref.key.split("/").pop().split("#").filter(Boolean);
const last_pc = name_pcs.pop();
const segments = [];
if (last_pc && last_pc.startsWith("{")) {
segments.push(name_pcs.pop());
segments.push(context_item.item_ref.lines.join("-"));
name = segments.join(" > Lines: ");
}
} else {
name = context_item.item_ref.key.split("/").pop();
}
} else {
name = context_item.key.split("/").pop();
}
const score = format_score(context_item?.data?.score);
const size = format_size(context_item?.size || context_item?.data?.size);
const score_html = build_badge_html(score, "sc-context-item-score");
const size_html = build_badge_html(size, "sc-context-item-size");
return `<span class="sc-context-item-leaf">
<span class="sc-context-item-remove" data-path="${context_item.key}">\xD7</span>
${score_html}
<span class="sc-context-item-name">${name || context_item.key}</span>
${size_html}
</span>`;
}
__name(build_html3, "build_html");
async function render3(context_item, params = {}) {
const html = build_html3(context_item, params);
const frag = this.create_doc_fragment(html);
const container = frag.firstElementChild;
post_process2.call(this, context_item, container, params);
return container;
}
__name(render3, "render");
async function post_process2(context_item, container, params = {}) {
const env = context_item.env;
const remove_btn = container.querySelector(".sc-context-item-remove");
if (remove_btn) {
remove_btn.addEventListener("click", (event) => {
const target = event.currentTarget;
const tree_container = target.closest("[data-context-key]");
const ctx_key = tree_container?.getAttribute("data-context-key");
const ctx = env.smart_contexts.get(ctx_key);
ctx.remove_item(context_item.key);
});
}
if (context_item.item_ref) {
const name2 = container.querySelector(".sc-context-item-name");
name2.setAttribute("title", `Hold ${import_obsidian10.Platform.isMacOS ? "\u2318" : "Ctrl"} to preview`);
register_item_hover_popover(name2, context_item.item_ref);
}
const name = container.querySelector(".sc-context-item-name");
name.addEventListener("click", (event) => {
context_item.open(event);
});
return container;
}
__name(post_process2, "post_process");

async function build_html4(env, opts = {}) {
const lines = [];
lines.push(`<h2>Collections</h2>`);
const collection_keys = Object.keys(env.collections).filter((key) => ["smart_sources", "smart_blocks"].includes(key)).sort((a, b) => {
if (a === "smart_sources" || a === "smart_blocks") return -1;
if (b === "smart_sources" || b === "smart_blocks") return 1;
return a.localeCompare(b);
});
for (const collection_key of collection_keys) {
const collection = env[collection_key];
if (!collection || !collection.items) {
lines.push(`
<div class="sc-collection-stats">
<h3>${format_collection_name(collection_key)}</h3>
<p>No valid items.</p>
</div>
`);
continue;
}
const snippet = generate_collection_stats(collection, collection_key);
lines.push(snippet);
}
return `
<div class="sc-env-stats-container">
${lines.join("\n")}
</div>
`;
}
__name(build_html4, "build_html");
async function render4(env, opts = {}) {
const html = await build_html4.call(this, env, opts);
const frag = this.create_doc_fragment(html);
return await post_process3.call(this, env, frag, opts);
}
__name(render4, "render");
async function post_process3(env, frag, opts = {}) {
return frag;
}
__name(post_process3, "post_process");
function generate_collection_stats(collection, collectionKey) {
const total_items = Object.values(collection.items).length;
const niceName = format_collection_name(collectionKey);
const state = collection.env.collections[collectionKey];
if (state !== "loaded") {
return `
<div class="sc-collection-stats">
<h3>${niceName}</h3>
<p>Not loaded yet (${total_items} items known).</p>
</div>
`;
}
const load_time_html = collection.load_time_ms ? `<p>Load time: ${collection.load_time_ms}ms</p>` : "";
const state_html = `<p>State: ${state}</p>`;
let html = get_generic_collection_stats(collection, niceName, total_items);
let embed_stats = "";
if (typeof collection.process_embed_queue === "function") {
embed_stats = calculate_embed_coverage(collection, total_items);
}
return `
<div class="sc-collection-stats">
<h3>${niceName}</h3>
${embed_stats}
${html}
${load_time_html}
${state_html}
</div>
`;
}
__name(generate_collection_stats, "generate_collection_stats");
function get_generic_collection_stats(collection, niceName, total_items, load_time_html) {
return `
<p><strong>Total:</strong> ${total_items}</p>
`;
}
__name(get_generic_collection_stats, "get_generic_collection_stats");
function calculate_embed_coverage(collection, total_items) {
const embedded_items = Object.values(collection.items).filter((item) => item.vec);
if (!embedded_items.length) return "<p>No items embedded</p>";
const stats = Object.values(collection.items).reduce((acc, i) => {
if (i.should_embed) acc.should_embed += 1;
else acc.should_not_embed += 1;
if (i.vec) acc.embedded += 1;
if (i.should_embed && !i.vec) acc.missing_embed += 1;
if (!i.should_embed && i.vec) acc.extraneous_embed += 1;
return acc;
}, { should_embed: 0, embedded: 0, missing_embed: 0, extraneous_embed: 0, should_not_embed: 0 });
const pct = stats.embedded / stats.should_embed * 100;
const percent = Math.round(pct);
return `<p><strong>Embedding coverage:</strong> ${percent}% (${stats.embedded} / ${stats.should_embed})</p>` + (stats.missing_embed ? `<p><strong>Missing embeddings:</strong> ${stats.missing_embed}</p>` : "") + (stats.extraneous_embed ? `<p><strong>Extraneous embeddings:</strong> ${stats.extraneous_embed}</p>` : "") + (stats.should_not_embed ? `<p><strong>Other items (e.g. less than minimum length to embed):</strong> ${stats.should_not_embed}</p>` : "");
}
__name(calculate_embed_coverage, "calculate_embed_coverage");

var import_obsidian11 = require("obsidian");
function build_html5(scope, params = {}) {
return `<div class="smart-form-dropdown-component"></div>`;
}
__name(build_html5, "build_html");
async function render5(scope, params = {}) {
const html = build_html5.call(this, scope, params);
const frag = this.create_doc_fragment(html);
return await post_process4.call(this, scope, frag, params);
}
__name(render5, "render");
async function post_process4(scope, container, params = {}) {
if (!scope) {
container.textContent = "Error: scope is required for dropdown component.";
return container;
}
const settings = scope.settings;
if (!settings || typeof settings !== "object") {
container.textContent = "Error: scope.settings{} is required for dropdown component.";
return container;
}
const setting_key = params.setting_key;
if (!setting_key) {
container.textContent = "Error: setting_key is required for dropdown component.";
return container;
}
const options = params.options;
if (!Array.isArray(options) || options.length === 0) {
container.textContent = "Error: options[] is required for dropdown component.";
return container;
}
const setting = new import_obsidian11.Setting(container);
if (params.label && typeof setting.setName === "function") {
setting.setName(params.label);
}
if (params.description && typeof setting.setDesc === "function") {
setting.setDesc(params.description);
}
if (params.tooltip && typeof setting.setTooltip === "function") {
setting.setTooltip(params.tooltip);
}
const current_value = get_by_path(settings, setting_key) ?? "";
let select_el = null;
setting.addDropdown((dropdown) => {
console.log({ dropdown, current_value, scope, options });
select_el = dropdown.selectEl;
if (params.required) {
select_el.setAttribute("required", "true");
}
options.forEach((opt) => {
dropdown.addOption(opt.value, opt.label);
});
select_el.childNodes.forEach((option_el) => {
if (option_el.value === current_value) {
option_el.selected = true;
}
if (options.find((o) => o.value === option_el.value)?.disabled) {
option_el.disabled = true;
}
});
if (select_el) {
select_el.value = current_value;
}
});
const handler = /* @__PURE__ */ __name(() => {
const value = select_el.value;
if (typeof params.on_change === "function") {
params.on_change(value, { scope, setting_key, select_el, container });
} else {
set_by_path(scope.settings, setting_key, value);
}
}, "handler");
select_el.addEventListener("change", handler);
this.attach_disposer(select_el, () => {
select_el.removeEventListener("change", handler);
});
return container;
}
__name(post_process4, "post_process");
render5.version = 0.2;

var import_obsidian12 = require("obsidian");
function build_html6(env, opts = {}) {
return `<div class="wrapper">
<div id="lean-coffee-callout" data-callout-metadata="" data-callout-fold="" data-callout="info" class="callout" style="mix-blend-mode: unset;">
<div class="callout-title" style="align-items: center;">
<div class="callout-icon">
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-info">
<circle cx="12" cy="12" r="10"></circle>
<path d="M12 16v-4"></path>
<path d="M12 8h.01"></path>
</svg>
</div>
<div class="callout-title-inner">
<strong>Community Lean Coffee</strong>
</div>
</div>
<div class="callout-content">
<p dir="auto">
<span>Ask questions. Bring challenges. Request features. Show workflows. Be ready to share.</span>
<br>
<i>Join the next <a href="https://lu.ma/calendar/cal-ZJtdnzAdURyouM7" target="_external">Community Lean Coffee</a> meeting.</i> Unable to attend? Submit a question <a href="https://docs.google.com/forms/d/e/1FAIpQLSdqOtTjksMwg1BOuGNCncpMQ_QT-wcd-3AgZGIe3A_isut5aQ/viewform?usp=dialog" target="_external">here</a> \u{1F334}
</p>
</div>
</div>
</div>`;
}
__name(build_html6, "build_html");
function render6(env, opts = {}) {
const html = build_html6.call(this, env, opts);
const frag = this.create_doc_fragment(html);
const callout = frag.querySelector("#lean-coffee-callout");
const icon_container = callout.querySelector(".callout-icon");
const icon = (0, import_obsidian12.getIcon)("smart-chat");
if (icon) {
this.empty(icon_container);
icon_container.appendChild(icon);
}
post_process5.call(this, env, callout, opts);
return callout;
}
__name(render6, "render");
function post_process5(env, callout) {
}
__name(post_process5, "post_process");

var milestones_default = `.sc-events-checklist {\r
display: flex;\r
flex-direction: column;\r
gap: var(--size-4-3);\r
padding: var(--size-4-2);\r
\r
.sc-events-checklist__header {\r
display: flex;\r
align-items: baseline;\r
justify-content: space-between;\r
gap: var(--size-4-3);\r
}\r
\r
.sc-events-checklist__title {\r
margin: 0;\r
font-size: var(--h2-size);\r
}\r
\r
.sc-events-checklist__summary {\r
font-size: var(--font-ui-small);\r
color: var(--text-normal);\r
font-variant-numeric: tabular-nums;\r
\r
padding: 0.15em 0.6em;\r
border-radius: 999px;\r
background-color: var(--background-secondary);\r
border: 1px solid var(--background-modifier-border);\r
white-space: nowrap;\r
}\r
\r
.sc-events-checklist__hint {\r
font-size: var(--font-ui-small);\r
color: var(--text-muted);\r
text-align: right;\r
}\r
\r
.sc-events-checklist__progress {\r
height: 6px;\r
border-radius: 999px;\r
overflow: hidden;\r
background-color: var(--background-secondary);\r
border: 1px solid var(--background-modifier-border);\r
}\r
\r
.sc-events-checklist__progress-fill {\r
height: 100%;\r
width: var(--sc-events-checklist-progress, 0%);\r
background-color: var(--color-green, var(--interactive-accent));\r
}\r
\r
.sc-events-checklist__group {\r
border-top: 1px solid var(--background-modifier-border);\r
padding-top: var(--size-4-3);\r
}\r
\r
.sc-events-checklist__group-title {\r
margin: 0 0 var(--size-4-2) 0;\r
font-size: var(--h3-size);\r
\r
display: flex;\r
align-items: baseline;\r
justify-content: space-between;\r
gap: var(--size-4-2);\r
}\r
\r
.sc-events-checklist__group-name {\r
display: inline-flex;\r
align-items: center;\r
min-width: 0;\r
}\r
\r
.sc-events-checklist__group-count {\r
font-size: var(--font-ui-small);\r
color: var(--text-muted);\r
white-space: nowrap;\r
font-variant-numeric: tabular-nums;\r
flex: 0 0 auto;\r
}\r
\r
/*\r
Group completion badge:\r
- shows only when every item in the group is checked\r
- uses :has() (no JS needed)\r
- avoids false positives on empty groups by requiring at least one item\r
*/\r
.sc-events-checklist__group:has(.sc-events-checklist__item):not(:has(.sc-events-checklist__item[data-checked='false'])) {\r
.sc-events-checklist__group-name::after {\r
content: "DONE";\r
\r
/* layout */\r
display: inline-flex;\r
align-items: center;\r
justify-content: center;\r
margin-left: 0.5em;\r
padding: 0.08em 0.55em;\r
border-radius: 999px;\r
white-space: nowrap;\r
vertical-align: middle;\r
\r
/* typography */\r
font-size: 0.65em;\r
font-weight: 700;\r
letter-spacing: 0.12em;\r
text-transform: uppercase;\r
\r
/* theme vars (with safe fallback) */\r
color: var(--color-green, var(--text-accent));\r
background-color: var(--background-secondary);\r
border: 1px solid var(--background-modifier-border);\r
\r
/* subtle depth, theme-aware */\r
box-shadow:\r
0 0 0 1px var(--background-primary),\r
0 1px 3px rgba(0, 0, 0, 0.25);\r
transform: translateY(-0.03em);\r
}\r
}\r
\r
.sc-events-checklist__items {\r
list-style: none;\r
padding: 0;\r
margin: 0;\r
display: flex;\r
flex-direction: column;\r
gap: var(--size-2-2);\r
}\r
\r
.sc-events-checklist__item {\r
display: flex;\r
flex-direction: column;\r
gap: 2px;\r
padding: 6px 8px;\r
border-radius: var(--radius-s);\r
\r
cursor: pointer;\r
border: 1px solid transparent;\r
\r
transition:\r
background-color 120ms ease,\r
border-color 120ms ease,\r
transform 120ms ease;\r
\r
&:hover {\r
background: var(--background-modifier-hover);\r
border-color: var(--background-modifier-border);\r
}\r
\r
&:active {\r
transform: translateY(1px);\r
}\r
\r
&:focus-visible {\r
outline: 2px solid var(--interactive-accent);\r
outline-offset: 2px;\r
background: var(--background-modifier-hover);\r
border-color: var(--interactive-accent);\r
}\r
}\r
\r
.sc-events-checklist__label {\r
display: flex;\r
align-items: flex-start;\r
gap: var(--size-2-2);\r
cursor: pointer;\r
}\r
\r
.sc-events-checklist__icon {\r
display: inline-flex;\r
align-items: center;\r
justify-content: center;\r
margin-top: 2px;\r
width: 18px;\r
height: 18px;\r
flex: 0 0 auto;\r
color: var(--text-muted);\r
\r
svg {\r
width: 18px;\r
height: 18px;\r
}\r
}\r
\r
.sc-events-checklist__milestone {\r
line-height: 1.3;\r
user-select: text;\r
cursor: text;\r
}\r
\r
.sc-events-checklist__item[data-checked='true'] {\r
.sc-events-checklist__icon {\r
color: var(--color-green, var(--text-accent));\r
}\r
\r
.sc-events-checklist__milestone {\r
color: var(--text-normal);\r
}\r
}\r
}\r
\r
/* 1) Host elements that should get a PRO badge */\r
.sc-events-checklist__label.pro-milestone > .sc-events-checklist__milestone {\r
position: relative; /* safe default, keeps ::after anchored */\r
}\r
\r
/* 2) The PRO badge itself */\r
.sc-events-checklist__label.pro-milestone > .sc-events-checklist__milestone::after {\r
content: "PRO";\r
\r
/* layout */\r
display: inline-flex;\r
align-items: center;\r
justify-content: center;\r
margin-left: 0.4em;\r
padding: 0.08em 0.55em;\r
border-radius: 999px;\r
white-space: nowrap;\r
vertical-align: middle;\r
\r
/* typography */\r
font-size: 0.7em;\r
font-weight: 600;\r
letter-spacing: 0.14em;\r
text-transform: uppercase;\r
line-height: 1;\r
\r
/* color system: only Obsidian variables */\r
background-color: var(--interactive-accent);\r
background-image: linear-gradient(\r
135deg,\r
var(--interactive-accent),\r
var(--interactive-accent-hover)\r
);\r
color: var(--text-on-accent, var(--background-primary));\r
border: 1px solid var(--background-modifier-border);\r
\r
/* subtle separation & depth, theme-aware */\r
box-shadow:\r
0 0 0 1px var(--background-primary),\r
0 1px 3px rgba(0, 0, 0, 0.35);\r
transform: translateY(-0.03em);\r
}\r
\r
/* 3) Interactive refinement: follow Obsidian's accent hover behavior */\r
.sc-events-checklist__label.pro-milestone > .sc-events-checklist__milestone:hover::after {\r
background-color: var(--interactive-accent-hover);\r
filter: brightness(1.05);\r
}\r
\r
/* Milestones modal: title row help icon */\r
.sc-milestones-modal__title {\r
width: 100%;\r
}\r
\r
.sc-milestones-modal__title-row {\r
display: flex;\r
align-items: center;\r
gap: var(--size-4-2);\r
width: 100%;\r
}\r
\r
.sc-milestones-modal__title-text {\r
min-width: 0;\r
}\r
\r
.sc-milestones-modal__help-btn {\r
display: inline-flex;\r
align-items: center;\r
justify-content: center;\r
\r
width: 28px;\r
height: 28px;\r
padding: 0;\r
border-radius: var(--radius-s);\r
\r
background: transparent;\r
border: 1px solid transparent;\r
color: var(--text-muted);\r
\r
cursor: pointer;\r
}\r
\r
.sc-milestones-modal__help-btn svg {\r
width: 18px;\r
height: 18px;\r
}\r
\r
.sc-milestones-modal__help-btn:hover {\r
background: var(--background-modifier-hover);\r
border-color: var(--background-modifier-border);\r
color: var(--text-normal);\r
}\r
\r
.sc-milestones-modal__help-btn:active {\r
transform: translateY(1px);\r
}\r
\r
.sc-milestones-modal__help-btn:focus-visible {\r
outline: 2px solid var(--interactive-accent);\r
outline-offset: 2px;\r
background: var(--background-modifier-hover);\r
border-color: var(--interactive-accent);\r
}\r
`;

var import_obsidian14 = require("obsidian");

var import_obsidian13 = require("obsidian");

var PLUGIN_INSTALL_EVENT_CONFIG = {
"connections:installed": {
ids: ["smart-connections"]
},
"connections_pro:installed": {
ids: ["smart-connections"],
require_pro_name: true
},
"context:installed": {
ids: ["smart-context"]
},
"context_pro:installed": {
ids: ["smart-context"],
require_pro_name: true
},
"chat:installed": {
ids: ["smart-chatgpt", "smart-chat"]
},
"chat_pro:installed": {
ids: ["smart-chat"],
require_pro_name: true
}
};
var EVENTS_CHECKLIST_ITEMS_BY_EVENT_KEY = {
"sources:import_completed": {
group: "Environment",
milestone: "Initial vault import completed (all sources discovered).",
link: "https://smartconnections.app/smart-environment/settings/?utm_source=milestones#sources"
},
"embedding:completed": {
group: "Environment",
milestone: "Initial embedding completed, you are ready to make connections!",
link: "https://smartconnections.app/smart-environment/settings/?utm_source=milestones#embedding-models"
},
"connections:installed": {
group: "Connections",
milestone: "Installed Smart Connections (core plugin).",
link: "https://smartconnections.app/smart-connections/list-feature/?utm_source=milestones"
},
"connections:opened": {
group: "Connections",
milestone: "Opened the connections view.",
link: "https://smartconnections.app/smart-connections/list-feature/?utm_source=milestones#quick-start"
},
"connections:drag_result": {
group: "Connections",
milestone: "Dragged a Smart Connections result into a note to create a link.",
link: "https://smartconnections.app/smart-connections/list-feature/?utm_source=milestones#drag-link"
},
"connections:open_result": {
group: "Connections",
milestone: "Opened a Smart Connections result from the UI (list item or inline popover).",
link: "https://smartconnections.app/smart-connections/list-feature/?utm_source=milestones#core-interactions"
},
"connections:sent_to_context": {
group: "Connections",
milestone: "Sent Connections results to Smart Context (turn discovery into a context pack).",
link: "https://smartconnections.app/smart-connections/list-feature/?utm_source=milestones#send-to-context"
},
"connections:copied_list": {
group: "Connections",
milestone: "Copied Connections results as a list of links.",
link: "https://smartconnections.app/smart-connections/list-feature/?utm_source=milestones#copy-list"
},
"connections:hover_preview": {
group: "Connections",
milestone: "Previewed a connection by holding cmd/ctrl while hovering the result.",
link: "https://smartconnections.app/smart-connections/list-feature/?utm_source=milestones#core-interactions"
},
"connections:open_random": {
group: "Connections",
milestone: "Opened a random connection from Smart Connections.",
link: "https://smartconnections.app/smart-connections/getting-started/?utm_source=milestones#open-a-random-connection"
},
"connections:hidden_item": {
group: "Connections",
milestone: "Hidden a connection item from the list.",
link: "https://smartconnections.app/smart-connections/list-feature/?utm_source=milestones#manage-noise"
},
"connections:pinned_item": {
group: "Connections",
milestone: "Pinned a connection item in the list.",
link: "https://smartconnections.app/smart-connections/list-feature/?utm_source=milestones#manage-noise"
},
"connections_pro:installed": {
group: "Connections Pro",
milestone: "Installed Smart Connections Pro.",
link: "https://smartconnections.app/pro-plugins/?utm_source=milestones#connections-pro",
is_pro: true
},
"lookup:hover_preview": {
group: "Lookup",
milestone: "Previewed a Smart Lookup result by holding cmd/ctrl while hovering.",
link: "https://smartconnections.app/smart-connections/lookup/?utm_source=milestones#understanding-results"
},
"lookup:get_results": {
group: "Lookup",
milestone: "Submitted a lookup query (started a semantic search).",
link: "https://smartconnections.app/smart-connections/lookup/?utm_source=milestones"
},
"lookup:drag_result": {
group: "Lookup",
milestone: "Dragged a Smart Lookup result into a note to create a link.",
link: "https://smartconnections.app/smart-connections/lookup/?utm_source=milestones#understanding-results"
},
"lookup:open_result": {
group: "Lookup",
milestone: "Opened a Lookup result.",
link: "https://smartconnections.app/smart-connections/lookup/?utm_source=milestones#understanding-results"
},
"context:created": {
group: "Context",
milestone: "First context created!",
link: "https://smartconnections.app/smart-context/builder/?utm_source=milestones#quick-start"
},
"context:copied": {
group: "Context",
milestone: "Copied context to clipboard.",
link: "https://smartconnections.app/smart-context/clipboard/?utm_source=milestones#copy-current"
},
"context:file_nav_copied": {
group: "Context",
milestone: "Copied context from the file navigator.",
link: "https://smartconnections.app/smart-context/clipboard/?utm_source=milestones#copy-selected"
},
"context_selector:open": {
group: "Context",
milestone: "Opened the Context Builder selector modal.",
link: "https://smartconnections.app/smart-context/builder/?utm_source=milestones#open-builder"
},
"context:named": {
group: "Context",
milestone: "Named a Smart Context (created a reusable saved context).",
link: "https://smartconnections.app/smart-context/builder/?utm_source=milestones#save-reuse"
},
"context:renamed": {
group: "Context",
milestone: "Renamed a Smart Context (increased clarity).",
link: "https://smartconnections.app/smart-context/builder/?utm_source=milestones#save-reuse"
},
"context:copied_with_media": {
group: "Context Pro",
milestone: "Copied context with media (images/PDF pages) for multimodal workflows.",
link: "https://smartconnections.app/smart-context/clipboard/?utm_source=milestones#copy-modes",
is_pro: true
},
"context_pro:installed": {
group: "Context Pro",
milestone: "Installed Smart Context Pro.",
link: "https://smartconnections.app/pro-plugins/?utm_source=milestones#context-pro",
is_pro: true
},
"chat:installed": {
group: "Chat",
milestone: "Installed Smart ChatGPT.",
link: "https://smartconnections.app/smart-chat/?utm_source=milestones"
},
"chat_codeblock:saved_thread": {
group: "Chat",
milestone: "Started a chat in a Smart Chat codeblock (opened the loop).",
link: "https://smartconnections.app/smart-chat/codeblock/?utm_source=milestones#quick-start"
},
"completion:completed": {
group: "Chat Pro",
milestone: "Received the first Smart Chat response (a completion finished).",
link: "https://smartconnections.app/smart-chat/api-integration/?utm_source=milestones#quick-start",
is_pro: true
},
"chat_codeblock:marked_done": {
group: "Chat",
milestone: "Marked the chat thread as done (closed the loop).",
link: "https://smartconnections.app/smart-chat/codeblock/?utm_source=milestones#chat-inbox"
},
"chat_pro:installed": {
group: "Chat Pro",
milestone: "Installed Smart Chat Pro.",
link: "https://smartconnections.app/pro-plugins/?utm_source=milestones#chat-pro",
is_pro: true
},
"smart_plugins_oauth_completed": {
group: "Pro",
milestone: "Connected account (enabled Pro plugins).",
link: "https://smartconnections.app/pro-plugins/?utm_source=milestones"
},
"inline_connections:show": {
group: "Connections Pro",
milestone: "Opened inline connections in-note (used the inline workflow).",
link: "https://smartconnections.app/smart-connections/inline/?utm_source=milestones",
is_pro: true
},
"inline_connections:open_result": {
group: "Connections Pro",
milestone: "Opened an inline connections result (navigated from discovery to source).",
link: "https://smartconnections.app/smart-connections/inline/?utm_source=milestones",
is_pro: true
},
"inline_connections:drag_result": {
group: "Connections Pro",
milestone: "Inserted an inline link from an inline connection (converted discovery into a durable link).",
link: "https://smartconnections.app/smart-connections/inline/?utm_source=milestones",
is_pro: true
}
};
var EVENTS_CHECKLIST_GROUP_ORDER = [
"Environment",
"Connections",
"Lookup",
"Context",
"Chat",
"Pro",
"Connections Pro",
"Context Pro",
"Chat Pro"
];
function derive_events_checklist_groups(items_by_event_key) {
const group_map = Object.entries(items_by_event_key || {}).reduce(
(acc, [event_key, item]) => {
const group = item?.group || "Other";
if (!acc[group]) acc[group] = [];
acc[group].push({ event_key, group, milestone: item?.milestone || "", ...item });
return acc;
},
/** @type {Record<string, Array<{event_key: string, group: string, milestone: string, link: string, is_pro?: boolean}>>} */
{}
);
const all_groups = Object.keys(group_map);
const order_index = EVENTS_CHECKLIST_GROUP_ORDER.reduce(
(acc, name, idx) => {
acc[name] = idx;
return acc;
},
/** @type {Record<string, number>} */
{}
);
const sorted_groups = all_groups.sort((a, b) => {
const a_has = Object.prototype.hasOwnProperty.call(order_index, a);
const b_has = Object.prototype.hasOwnProperty.call(order_index, b);
if (a_has && b_has) return order_index[a] - order_index[b];
if (a_has) return -1;
if (b_has) return 1;
return a.localeCompare(b);
});
return sorted_groups.map((group) => {
const items = (group_map[group] || []).slice();
return { group, items };
});
}
__name(derive_events_checklist_groups, "derive_events_checklist_groups");
function check_if_event_emitted(env, event_key) {
const plugin_event_state = resolve_plugin_install_event(env, event_key);
if (plugin_event_state === true) return true;
if (env?.event_logs?.items?.[event_key]) return true;
if (plugin_event_state === false) return false;
return false;
}
__name(check_if_event_emitted, "check_if_event_emitted");
function resolve_plugin_install_event(env, event_key) {
const config = PLUGIN_INSTALL_EVENT_CONFIG[event_key];
if (!config) return null;
const manifests = env?.plugin?.app?.plugins?.manifests || {};
const plugin_ids = Array.isArray(config.ids) ? config.ids : [];
for (const plugin_id of plugin_ids) {
const manifest = manifests[plugin_id];
if (!manifest) continue;
if (config.require_pro_name && !is_pro_manifest(manifest)) continue;
return true;
}
return false;
}
__name(resolve_plugin_install_event, "resolve_plugin_install_event");
function is_pro_manifest(manifest) {
const name = manifest?.name;
if (typeof name !== "string") return false;
return name.toLowerCase().includes("pro");
}
__name(is_pro_manifest, "is_pro_manifest");

function register_first_of_event_notifications(env) {
env.events.on("event_log:first", (data) => {
const event_key = data?.first_of_event_key;
if (typeof event_key === "string" && event_key in EVENTS_CHECKLIST_ITEMS_BY_EVENT_KEY) {
const frag = document.createDocumentFragment();
const msg = `You achieved a new Smart Milestone \u{1F389}`;
const msg_el = document.createElement("p");
msg_el.textContent = msg;
frag.appendChild(msg_el);
const milestone_el = document.createElement("p");
milestone_el.textContent = `\u2705 ${EVENTS_CHECKLIST_ITEMS_BY_EVENT_KEY[event_key].milestone}`;
milestone_el.style.color = "var(--color-green)";
milestone_el.style.fontStyle = "italic";
frag.appendChild(milestone_el);
const btn = document.createElement("button");
btn.textContent = "View milestones";
btn.addEventListener("click", () => {
env.open_milestones_modal();
});
frag.appendChild(btn);
new import_obsidian13.Notice(frag, 7e3);
}
});
}
__name(register_first_of_event_notifications, "register_first_of_event_notifications");

function build_html7(env, params = {}) {
const groups = derive_events_checklist_groups(EVENTS_CHECKLIST_ITEMS_BY_EVENT_KEY);
const checked_count = groups.reduce((acc, g) => {
const c = g.items.reduce((inner, item) => {
return inner + (check_if_event_emitted(env, item.event_key) ? 1 : 0);
}, 0);
return acc + c;
}, 0);
const total_count = groups.reduce((acc, g) => acc + g.items.length, 0);
const progress_pct = total_count > 0 ? Math.round(checked_count / total_count * 100) : 0;
const groups_html = groups.map((group) => {
const group_checked_count = group.items.reduce((acc, item) => {
return acc + (check_if_event_emitted(env, item.event_key) ? 1 : 0);
}, 0);
const group_total_count = group.items.length;
const items_html = group.items.map((item) => {
const checked = check_if_event_emitted(env, item.event_key) === true;
return build_item_html(item, { checked });
}).join("\n");
return `
<section class="sc-events-checklist__group" data-group="${escape_html(group.group)}">
<h3 class="sc-events-checklist__group-title">
<span class="sc-events-checklist__group-name">${escape_html(group.group)}</span>
<span class="sc-events-checklist__group-count" aria-label="Group completion">${group_checked_count.toString()} / ${group_total_count.toString()}</span>
</h3>
<ul class="sc-events-checklist__items">
${items_html}
</ul>
</section>
`;
}).join("\n");
return `
<div
class="sc-events-checklist"
data-component="events_checklist"
style="--sc-events-checklist-progress: ${progress_pct.toString()}%;"
>
<div class="sc-events-checklist__header">
<div class="sc-events-checklist__summary" aria-label="Checklist completion">
${checked_count.toString()} / ${total_count.toString()}
</div>
<div class="sc-events-checklist__hint" aria-hidden="true">
Click a milestone to open docs
</div>
</div>

<div
class="sc-events-checklist__progress"
role="progressbar"
aria-label="Overall progress"
aria-valuenow="${checked_count.toString()}"
aria-valuemin="0"
aria-valuemax="${total_count.toString()}"
title="${escape_html(`${progress_pct.toString()}% complete`)}"
>
<div class="sc-events-checklist__progress-fill" aria-hidden="true"></div>
</div>

<div class="sc-events-checklist__body">
${groups_html}
</div>
</div>
`;
}
__name(build_html7, "build_html");
async function render7(env, params = {}) {
this.apply_style_sheet(milestones_default);
const html = build_html7.call(this, env, params);
const frag = this.create_doc_fragment(html);
const container = frag.firstElementChild;
post_process6.call(this, env, container, params);
return container;
}
__name(render7, "render");
async function post_process6(env, container, params = {}) {
attach_item_link_listeners(container);
render_item_state_icons(container);
return container;
}
__name(post_process6, "post_process");
function build_item_html(item, state) {
const checked = state.checked === true;
const checked_flag = checked ? "true" : "false";
const link = typeof item.link === "string" ? item.link : "";
const status_label = checked ? "Completed" : "Incomplete";
const aria_label = `Open docs: ${item.milestone || item.event_key || "milestone"} (${status_label})`;
return `
<li
class="sc-events-checklist__item"
data-event-key="${escape_html(item.event_key)}"
data-link="${escape_html(link)}"
data-checked="${checked_flag}"
tabindex="0"
role="button"
aria-label="${escape_html(aria_label)}"
>
<div class="sc-events-checklist__label${item.is_pro ? " pro-milestone" : ""}">
<span class="sc-events-checklist__icon" aria-hidden="true"></span>
<span class="sc-events-checklist__milestone">${escape_html(item.milestone)}</span>
</div>
</li>
`;
}
__name(build_item_html, "build_item_html");
function attach_item_link_listeners(container) {
if (!container) return;
if (container.getAttribute("data-links-enabled") === "true") return;
container.setAttribute("data-links-enabled", "true");
container.addEventListener("click", (evt) => {
const item_el = get_item_el_from_event(container, evt);
if (!item_el) return;
const selection = window.getSelection();
if (selection && selection.toString().length > 0) return;
open_item_link(item_el);
});
container.addEventListener("keydown", (evt) => {
const key = evt && /** @type {KeyboardEvent} */
evt.key;
if (key !== "Enter" && key !== " ") return;
const item_el = get_item_el_from_event(container, evt);
if (!item_el) return;
evt.preventDefault();
open_item_link(item_el);
});
}
__name(attach_item_link_listeners, "attach_item_link_listeners");
function open_item_link(item_el) {
const link = get_item_link(item_el);
if (typeof link === "string" && link.length > 0) {
window.open(link, "_external");
}
}
__name(open_item_link, "open_item_link");
function render_item_state_icons(container) {
if (!container) return;
const item_els = Array.from(container.querySelectorAll(".sc-events-checklist__item"));
item_els.forEach((item_el) => {
const checked = item_el.getAttribute("data-checked") === "true";
const icon_el = item_el.querySelector(".sc-events-checklist__icon");
if (!icon_el) return;
set_item_icon(
/** @type {HTMLElement} */
icon_el,
checked
);
});
}
__name(render_item_state_icons, "render_item_state_icons");
function set_item_icon(icon_el, checked) {
const icon_ids = checked ? ["circle-check", "check-circle", "check"] : ["circle", "circle-dashed", "dot"];
set_icon_with_fallback2(icon_el, icon_ids);
}
__name(set_item_icon, "set_item_icon");
function set_icon_with_fallback2(icon_el, icon_ids) {
if (!icon_el) return;
const ids = Array.isArray(icon_ids) ? icon_ids : [];
for (const icon_id of ids) {
if (typeof icon_id !== "string" || icon_id.length === 0) continue;
icon_el.textContent = "";
try {
(0, import_obsidian14.setIcon)(icon_el, icon_id);
} catch (err) {
continue;
}
if (icon_el.querySelector("svg")) return;
}
}
__name(set_icon_with_fallback2, "set_icon_with_fallback");
function get_item_el_from_event(container, evt) {
const target = evt && /** @type {any} */
evt.target;
if (!target || typeof target.closest !== "function") return null;
const item_el = target.closest(".sc-events-checklist__item");
if (!item_el) return null;
if (!container.contains(item_el)) return null;
return item_el;
}
__name(get_item_el_from_event, "get_item_el_from_event");
function get_item_link(item_el) {
const data_link = item_el.getAttribute("data-link");
if (typeof data_link === "string" && data_link.length > 0) return data_link;
const event_key = item_el.getAttribute("data-event-key");
if (typeof event_key !== "string" || event_key.length === 0) return "";
const item = EVENTS_CHECKLIST_ITEMS_BY_EVENT_KEY[event_key];
if (!item || typeof item.link !== "string") return "";
return item.link;
}
__name(get_item_link, "get_item_link");

function build_html8() {
return `<div>
<div class="smart-env-notifications-controls">
<button class="copy-all-notifications-btn">Copy All Notifications</button>
</div>
<div class="smart-env-notifications-feed"></div>
<button class="load-more-notifications-btn">Load More</button>
</div>`;
}
__name(build_html8, "build_html");
var default_page_size = 100;
var load_more_step = 100;
function get_visible_entries(entries, params = {}) {
const { limit = default_page_size } = params;
return entries.slice(-limit).reverse();
}
__name(get_visible_entries, "get_visible_entries");
function get_visible_count(entries_length, params = {}) {
const { page_size = default_page_size } = params;
return Math.min(entries_length, page_size);
}
__name(get_visible_count, "get_visible_count");
function get_next_visible_count(entries_length, params = {}) {
const { current_count = 0, step_size = load_more_step } = params;
return Math.min(entries_length, current_count + step_size);
}
__name(get_next_visible_count, "get_next_visible_count");
function should_show_load_more(entries_length, visible_count) {
return entries_length > visible_count;
}
__name(should_show_load_more, "should_show_load_more");
async function render8(env, params = {}) {
const frag = this.create_doc_fragment(build_html8());
const container = frag.firstElementChild;
post_process7.call(this, env, container, params);
return frag;
}
__name(render8, "render");
async function post_process7(env, container, params = {}) {
const feed_container = container.querySelector(".smart-env-notifications-feed");
const copy_btn = container.querySelector(".copy-all-notifications-btn");
const load_more_btn = container.querySelector(".load-more-notifications-btn");
const smart_env2 = this;
this.empty(feed_container);
const entries = Array.isArray(env.event_logs.session_events) ? [...env.event_logs.session_events] : [];
if (!entries.length) {
const empty3 = feed_container.ownerDocument.createElement("p");
empty3.className = "smart-env-notifications-empty";
empty3.textContent = "No Smart Env notifications yet.";
feed_container.appendChild(empty3);
if (load_more_btn) {
load_more_btn.style.display = "none";
}
return;
}
let visible_count = get_visible_count(entries.length, { page_size: default_page_size });
const render_entries = /* @__PURE__ */ __name(() => {
smart_env2.empty(feed_container);
get_visible_entries(entries, { limit: visible_count }).forEach((entry) => {
append_entry(feed_container, entry);
});
update_load_more_button(load_more_btn, {
entries_length: entries.length,
visible_count
});
}, "render_entries");
render_entries();
if (copy_btn) {
copy_btn.addEventListener("click", () => {
const all_text = feed_container.textContent;
navigator.clipboard.writeText(all_text).then(() => {
copy_btn.textContent = "Copied!";
setTimeout(() => {
copy_btn.textContent = "Copy All Notifications";
}, 2e3);
});
});
}
if (load_more_btn) {
load_more_btn.addEventListener("click", () => {
visible_count = get_next_visible_count(entries.length, {
current_count: visible_count,
step_size: load_more_step
});
render_entries();
});
}
}
__name(post_process7, "post_process");
function update_load_more_button(button, params = {}) {
if (!button) return;
const { entries_length = 0, visible_count = 0 } = params;
const is_visible = should_show_load_more(entries_length, visible_count);
button.style.display = is_visible ? "inline-block" : "none";
if (is_visible) {
const remaining_count = entries_length - visible_count;
const next_step = Math.min(load_more_step, remaining_count);
button.textContent = `Load ${next_step} more`;
}
}
__name(update_load_more_button, "update_load_more_button");
function get_level(entry) {
const [event_domain, event_type] = entry.event_key.split(":");
if (event_domain === "notification") {
return event_type;
}
if (event_type === "error") {
return "error";
}
return "info";
}
__name(get_level, "get_level");
function append_entry(feed_container, entry) {
const row = feed_container.ownerDocument.createElement("div");
row.className = "smart-env-notification";
row.dataset.level = get_level(entry);
feed_container.appendChild(row);
const meta = feed_container.ownerDocument.createElement("div");
meta.className = "smart-env-notification__meta";
const timestamp = typeof entry.event.at === "number" ? entry.event.at : Date.now();
meta.textContent = `${entry.event.collection_key ? entry.event.collection_key + " - " : ""}${entry.event_key} - ${to_time_ago(timestamp)}
`;
row.appendChild(meta);
const event_payload_content = Object.entries(entry.event).filter(([k, v]) => !["at", "collection_key"].includes(k)).map(([k, v]) => `  ${k}: ${typeof v === "string" ? v : JSON.stringify(v)}`).join("\n");
if (event_payload_content.trim().length) {
row.style.cursor = "pointer";
const message = feed_container.ownerDocument.createElement("pre");
message.className = "smart-env-notification__message";
message.textContent = event_payload_content;
message.textContent += "\n\n";
message.style.display = "none";
row.appendChild(message);
row.addEventListener("click", () => {
if (message.style.display === "none") {
message.style.display = "block";
} else {
message.style.display = "none";
}
});
} else {
meta.textContent += "\n";
}
}
__name(append_entry, "append_entry");
function to_time_ago(ms) {
const now_ms = Date.now();
const seconds = Math.floor((now_ms - ms) / 1e3);
if (seconds < 60) return `${seconds} seconds ago`;
const minutes = Math.floor(seconds / 60);
if (minutes < 60) return `${minutes} minutes ago`;
const hours = Math.floor(minutes / 60);
if (hours < 24) return `${hours} hours ago`;
const days = Math.floor(hours / 24);
return `${days} days ago`;
}
__name(to_time_ago, "to_time_ago");

var import_obsidian16 = require("obsidian");

var import_obsidian15 = require("obsidian");
function get_smart_server_url() {
if (typeof window !== "undefined" && window.SMART_SERVER_URL_OVERRIDE) {
return window.SMART_SERVER_URL_OVERRIDE;
}
return "https://connect.smartconnections.app";
}
__name(get_smart_server_url, "get_smart_server_url");
function try_get_zlib() {
if (typeof window?.require === "function") {
try {
return window.require("zlib");
} catch {
}
}
return null;
}
__name(try_get_zlib, "try_get_zlib");
function inflate_deflate_data(compressed) {
const zlib = try_get_zlib();
if (!zlib) {
throw new Error("zlib not available (maybe Obsidian mobile?).");
}
const buf = Buffer.from(compressed);
const out = zlib.inflateRawSync(buf);
return new Uint8Array(out.buffer, out.byteOffset, out.length);
}
__name(inflate_deflate_data, "inflate_deflate_data");
async function parse_zip_into_files(zipBuffer) {
const dv = new DataView(zipBuffer);
let offset = 0;
const length = dv.byteLength;
const files = [];
let pluginManifest = null;
while (offset + 4 <= length) {
const localSig = dv.getUint32(offset, true);
if (localSig === 33639248 || localSig === 134695760) {
break;
}
if (localSig !== 67324752) {
break;
}
offset += 4;
const versionNeeded = dv.getUint16(offset, true);
const generalPurposeBitFlag = dv.getUint16(offset + 2, true);
const compressionMethod = dv.getUint16(offset + 4, true);
offset += 6;
const lastModTimeDate = dv.getUint32(offset, true);
offset += 4;
let crc32 = dv.getUint32(offset, true);
let compressedSize = dv.getUint32(offset + 4, true);
let uncompressedSize = dv.getUint32(offset + 8, true);
offset += 12;
const fileNameLen = dv.getUint16(offset, true);
const extraLen = dv.getUint16(offset + 2, true);
offset += 4;
const fileNameBytes = new Uint8Array(zipBuffer.slice(offset, offset + fileNameLen));
const fileName = new TextDecoder("utf-8").decode(fileNameBytes);
offset += fileNameLen;
offset += extraLen;
const hasDataDescriptor = (generalPurposeBitFlag & 8) !== 0;
let compDataStart = offset;
let compDataEnd;
if (!hasDataDescriptor) {
compDataEnd = compDataStart + compressedSize;
} else {
let scanPos = compDataStart;
let foundSig = false;
while (scanPos + 4 <= length) {
const sig = dv.getUint32(scanPos, true);
if (sig === 134695760 || sig === 67324752 || sig === 33639248) {
foundSig = true;
break;
}
scanPos++;
}
compDataEnd = foundSig ? scanPos : length;
}
if (compDataEnd > length) {
break;
}
const fileDataCompressed = new Uint8Array(zipBuffer.slice(compDataStart, compDataEnd));
offset = compDataEnd;
if (hasDataDescriptor) {
if (offset + 4 <= length) {
const ddSig = dv.getUint32(offset, true);
if (ddSig === 134695760) {
offset += 4;
}
if (offset + 12 <= length) {
crc32 = dv.getUint32(offset, true);
compressedSize = dv.getUint32(offset + 4, true);
uncompressedSize = dv.getUint32(offset + 8, true);
offset += 12;
} else {
break;
}
}
}
let rawData;
if (compressionMethod === 0) {
rawData = fileDataCompressed;
} else if (compressionMethod === 8) {
rawData = inflate_deflate_data(fileDataCompressed);
} else {
continue;
}
files.push({ fileName, data: rawData });
if (fileName.toLowerCase().endsWith("manifest.json") && !fileName.includes("/")) {
try {
pluginManifest = JSON.parse(new TextDecoder("utf-8").decode(rawData));
} catch {
}
}
}
return { files, pluginManifest };
}
__name(parse_zip_into_files, "parse_zip_into_files");
function validate_zip_buffer(zip_buffer, source_label = "Response") {
if (!zip_buffer || zip_buffer.byteLength < 4) {
throw new Error(`${source_label} returned too few bytes, not a valid ZIP.`);
}
const dv = new DataView(zip_buffer);
if (dv.getUint32(0, true) !== 67324752) {
const txt = new TextDecoder().decode(new Uint8Array(zip_buffer));
throw new Error(`${source_label} did not return a valid ZIP. Text:
${txt}`);
}
return zip_buffer;
}
__name(validate_zip_buffer, "validate_zip_buffer");
async function write_files_with_adapter(adapter, baseFolder, files) {
const hasWriteBinary = typeof adapter.writeBinary === "function";
if (!await adapter.exists(baseFolder)) {
await adapter.mkdir(baseFolder);
}
for (const { fileName, data } of files) {
const fullPath = baseFolder + "/" + fileName;
if (hasWriteBinary) {
await adapter.writeBinary(fullPath, data);
} else {
const base644 = btoa(String.fromCharCode(...data));
await adapter.write(fullPath, base644);
}
}
}
__name(write_files_with_adapter, "write_files_with_adapter");
function is_server_version_newer(localVer, serverVer) {
if (!serverVer || serverVer === "unknown") return false;
const lv = localVer.replace(/[^\d.]/g, "");
const sv = serverVer.replace(/[^\d.]/g, "");
const la = lv.split(".").map(Number);
const sa = sv.split(".").map(Number);
for (let i = 0; i < Math.max(la.length, sa.length); i++) {
const l = la[i] || 0;
const s = sa[i] || 0;
if (s > l) return true;
if (s < l) return false;
}
return false;
}
__name(is_server_version_newer, "is_server_version_newer");
async function fetch_plugin_zip(repoName, token) {
const resp = await (0, import_obsidian15.requestUrl)({
url: `${get_smart_server_url()}/plugin_download`,
method: "POST",
headers: {
"Content-Type": "application/json",
"Authorization": `Bearer ${token}`
},
body: JSON.stringify({ repo: repoName })
});
if (resp.status !== 200) {
throw new Error(`plugin_download error ${resp.status}: ${resp.text}`);
}
return validate_zip_buffer(resp.arrayBuffer, "Smart Plugins server");
}
__name(fetch_plugin_zip, "fetch_plugin_zip");
async function fetch_zip_from_url(download_url, request_fn = import_obsidian15.requestUrl) {
console.log(`[smart_plugins] download plugin from URL: ${download_url}`);
const resp = await request_fn({
url: download_url,
method: "GET",
headers: { Accept: "application/zip" }
});
if (resp.status && resp.status !== 200) {
throw new Error(`Download error ${resp.status}: ${resp.text || ""}`);
}
return validate_zip_buffer(resp.arrayBuffer, "Download");
}
__name(fetch_zip_from_url, "fetch_zip_from_url");
async function fetch_plugin_readme(repo, token, request_fn = import_obsidian15.requestUrl) {
const resp = await request_fn({
url: `${get_smart_server_url()}/plugin_readme`,
method: "POST",
headers: {
"Content-Type": "application/json",
"Authorization": `Bearer ${token}`
},
body: JSON.stringify({ repo })
});
if (resp.status !== 200) {
throw new Error(`plugin_readme error ${resp.status}: ${resp.text}`);
}
return resp.json.readme;
}
__name(fetch_plugin_readme, "fetch_plugin_readme");
async function enable_plugin(app, plugin_id) {
await app.plugins.enablePlugin(plugin_id);
app.plugins.enabledPlugins.add(plugin_id);
app.plugins.requestSaveConfig();
app.plugins.loadManifests();
}
__name(enable_plugin, "enable_plugin");
function get_oauth_storage_prefix(app) {
const vault_name = app?.vault?.getName?.() || "";
const safe = vault_name.toLowerCase().replace(/[^a-z0-9]/g, "_");
return `${safe}_smart_plugins_oauth_`;
}
__name(get_oauth_storage_prefix, "get_oauth_storage_prefix");
async function fetch_server_plugin_list(token) {
const resp = await (0, import_obsidian15.requestUrl)({
url: `${get_smart_server_url()}/plugin_list`,
method: "POST",
headers: {
"Content-Type": "application/json",
"Authorization": `Bearer ${token}`
},
body: JSON.stringify({})
});
if (resp.status !== 200) {
throw new Error(`plugin_list error ${resp.status}: ${resp.text}`);
}
return resp.json;
}
__name(fetch_server_plugin_list, "fetch_server_plugin_list");
async function fetch_referral_stats(params = {}) {
const token = String(params.token || "").trim();
if (!token) return { ok: false, error: "missing_token" };
const resp = await (0, import_obsidian15.requestUrl)({
url: `${get_smart_server_url()}/api/referrals/stats`,
method: "GET",
headers: {
"Authorization": `Bearer ${token}`
}
});
if (resp.status === 401) {
return { ok: false, unauthorized: true };
}
if (resp.status !== 200) {
throw new Error(`referrals stats error ${resp.status}: ${resp.text}`);
}
return resp.json;
}
__name(fetch_referral_stats, "fetch_referral_stats");

var style_default = ".get-core-link {\r\n  text-wrap: nowrap;\r\n  font-size: var(--font-ui-small);\r\n}\r\n.core-installed-text {\r\n  text-wrap: nowrap;\r\n  font-size: var(--font-ui-small);\r\n  color: var(--text-muted);\r\n}\r\n\r\n.pro-plugins-list {\r\n  display: flex;\r\n  flex-direction: column;\r\n  row-gap: var(--size-4-3);\r\n  margin-top: var(--size-5);\r\n}\r\n\r\n.pro-plugins-list-item {\r\n  display: flex;\r\n  align-items: center;\r\n  padding: 0.75em 0;\r\n  border-top: 1px solid var(--background-modifier-border);\r\n  row-gap: var(--size-4-3);\r\n}\r\n\r\n.pro-plugins-container > .setting-group {\r\n  .setting-item-name.pro-heading {\r\n    font-size: var(--h1-size);\r\n  }\r\n  &> p {\r\n    padding: 0 var(--size-4-4);\r\n  }\r\n\r\n}\r\n\r\n.smart-plugins-login .setting-item {\r\n  gap: var(--size-4-3);\r\n}\r\n\r\n.smart-plugins-login-manual {\r\n  margin-top: var(--size-4-3);\r\n}\r\n\r\n.smart-plugins-login-manual-instructions {\r\n  font-size: var(--font-ui-small);\r\n  color: var(--text-muted);\r\n  margin-bottom: var(--size-2-2);\r\n}\r\n\r\n.smart-plugins-login-manual-controls {\r\n  display: flex;\r\n  gap: var(--size-2-2);\r\n  align-items: center;\r\n}\r\n\r\n.smart-plugins-login-manual-input {\r\n  flex: 1;\r\n  min-width: 240px;\r\n  font-size: var(--font-ui-small);\r\n}\r\n";

var PRO_PLUGINS_DESC = `<a href="https://smartconnections.app/core-plugins/" target="_external">Core plugins</a> provide essential functionality and a "just works" experience. <a href="https://smartconnections.app/pro-plugins/" target="_external">Pro plugins</a> enable advanced configuration and features for Obsidian AI experts.`;
var PRO_PLUGINS_FOOTER = `All Pro plugins include advanced configurations and additional model providers. Pro users get priority support via email. <a href="https://smartconnections.app/introducing-pro-plugins/" target="_external">Learn more</a> about Pro plugins.`;
function derive_fallback_plugins() {
const pro_placeholders = [
{
name: "Chat Pro",
description: "Configure chat to use Local and Cloud API providers (Ollama, LM Studio, OpenAI, Gemini, Anthropic, Open Router, and more).",
core_id: "smart-chatgpt",
url: "https://smartconnections.app/smart-chat/"
},
{
name: "Connections Pro",
description: "More opportunities for connections. Graph view for visualizing. Inline and footer views (great for mobile!). Configurable algorithms and additional embedding model providers.",
core_id: "smart-connections",
url: "https://smartconnections.app/smart-connections/"
},
{
name: "Context Pro",
description: "Advanced tools for context engineering. Utilize Bases, images, and external sources (great for coders!) in your contexts.",
core_id: "smart-context",
url: "https://smartconnections.app/smart-context/"
}
];
return pro_placeholders;
}
__name(derive_fallback_plugins, "derive_fallback_plugins");
function build_html9(env, params = {}) {
return `
<div class="pro-plugins-container setting-item-heading">
<div class="setting-group">
<div class="setting-item setting-item-heading">
<div class="setting-item-name pro-heading">Pro plugins</div>
<div class="setting-item-control">
<section class="smart-plugins-login"></section>
</div>
</div>
<p>${PRO_PLUGINS_DESC}</p>
<div class="setting-items pro-plugins-list">
</div>
<p>${PRO_PLUGINS_FOOTER}</p>
<div class="smart-plugins-referral"></div>
</div>
</div>
`;
}
__name(build_html9, "build_html");
async function render9(env, params = {}) {
this.apply_style_sheet(style_default);
const html = build_html9.call(this, env, params);
const frag = this.create_doc_fragment(html);
const container = frag.firstElementChild;
await post_process8.call(this, env, container, params);
return container;
}
__name(render9, "render");
async function post_process8(env, container, params = {}) {
const plugin = env.plugin || null;
const app = plugin?.app || window.app;
const oauth_storage_prefix = get_oauth_storage_prefix(app);
const login_container = container.querySelector(".smart-plugins-login");
const referral_container = container.querySelector(".smart-plugins-referral");
const pro_list_el = container.querySelector(".pro-plugins-list");
const placeholders = derive_fallback_plugins();
let login_click_count = 0;
let last_login_url = "";
let manual_login_el = null;
const empty_container = /* @__PURE__ */ __name((el) => {
if (!el) return;
if (typeof this.empty === "function") {
this.empty(el);
return;
}
el.innerHTML = "";
}, "empty_container");
const render_manual_login_link = /* @__PURE__ */ __name((login_url) => {
if (!login_container) return;
if (!login_url) return;
if (!manual_login_el || !manual_login_el.isConnected) {
manual_login_el = document.createElement("div");
manual_login_el.classList.add("smart-plugins-login-manual");
login_container.appendChild(manual_login_el);
}
manual_login_el.innerHTML = "";
const instructions = document.createElement("div");
instructions.classList.add("smart-plugins-login-manual-instructions");
instructions.textContent = "If the login page did not open, copy this link and paste it into your browser to open the login page:";
manual_login_el.appendChild(instructions);
const controls = document.createElement("div");
controls.classList.add("smart-plugins-login-manual-controls");
manual_login_el.appendChild(controls);
const input = document.createElement("input");
input.classList.add("smart-plugins-login-manual-input");
input.type = "text";
input.value = login_url;
input.readOnly = true;
input.addEventListener("focus", () => input.select());
controls.appendChild(input);
const btn = document.createElement("button");
btn.classList.add("mod-cta");
btn.textContent = "Copy";
btn.addEventListener("click", async () => {
const ok = await copy_to_clipboard(login_url);
if (ok) {
new import_obsidian16.Notice("Copied login link to clipboard.");
} else {
new import_obsidian16.Notice("Copy failed. Please select and copy the link manually.");
}
});
controls.appendChild(btn);
}, "render_manual_login_link");
const get_installed_info = /* @__PURE__ */ __name(async () => {
const installed_map = {};
let { manifests } = app.plugins;
while (Object.keys(manifests).length === 0) {
manifests = app.plugins.manifests;
await new Promise((resolve) => setTimeout(resolve, 100));
}
for (const plugin_id in manifests) {
if (!Object.prototype.hasOwnProperty.call(manifests, plugin_id)) continue;
const { name, version: version2 } = manifests[plugin_id];
installed_map[plugin_id] = { name, version: version2 };
}
return installed_map;
}, "get_installed_info");
const initiate_oauth_login = /* @__PURE__ */ __name(async () => {
login_click_count++;
if (login_click_count >= 2 && last_login_url) {
render_manual_login_link(last_login_url);
}
if (env && typeof env.initiate_smart_plugins_oauth === "function") {
last_login_url = initiate_smart_plugins_oauth();
}
new import_obsidian16.Notice("Please complete the login in your browser.");
}, "initiate_oauth_login");
const render_oauth_login_section = /* @__PURE__ */ __name(() => {
this.empty(login_container);
manual_login_el = null;
const token = localStorage.getItem(oauth_storage_prefix + "token") || "";
if (!token) {
const setting2 = new import_obsidian16.Setting(login_container).setName("Connect account").setDesc("Log in with the key provided in your Pro welcome email.");
setting2.addButton((btn) => {
btn.setButtonText("Login");
btn.onClick(async () => {
await initiate_oauth_login();
});
});
return;
}
const setting = new import_obsidian16.Setting(login_container);
setting.setDesc("Signed in to Smart Plugins Pro account.");
setting.addButton((btn) => {
btn.setButtonText("Logout");
btn.onClick(() => {
localStorage.removeItem(oauth_storage_prefix + "token");
localStorage.removeItem(oauth_storage_prefix + "refresh");
new import_obsidian16.Notice("Logged out of Smart Plugins");
render_oauth_login_section();
render_referral_section();
render_plugin_list_section();
});
});
}, "render_oauth_login_section");
const render_referral_section = /* @__PURE__ */ __name(async (params2 = {}) => {
empty_container(referral_container);
const token = String(params2.token || "").trim();
if (!token) return;
const sub_exp = Number(params2.sub_exp ?? 0) || 0;
if (sub_exp && sub_exp < Date.now()) return;
try {
const stats = await fetch_referral_stats({ token });
const referral_link = String(stats?.referral_link || "").trim();
if (!referral_link) return;
const setting = new import_obsidian16.Setting(referral_container).setName("Referral link").setDesc("Share your link to give $30 off Pro and earn 30 days of Pro credit.");
setting.addButton((btn) => {
btn.setButtonText("Copy link");
btn.onClick(async () => {
const ok = await copy_to_clipboard(referral_link);
new import_obsidian16.Notice(ok ? "Referral link copied." : "Copy failed. Please try again.");
});
});
setting.addButton((btn) => {
btn.setButtonText("Open referrals");
btn.onClick(() => {
window.open("https://smartconnections.app/my-referrals/", "_external");
});
});
} catch (err) {
console.error("[pro-plugins:list] Failed to load referral stats:", err);
}
}, "render_referral_section");
const render_fallback_plugin_list = /* @__PURE__ */ __name(async () => {
this.empty(pro_list_el);
if (!pro_list_el || placeholders.length === 0) return;
for (const item of placeholders) {
const row = await env.smart_components.render_component("pro_plugins_list_item", item, {
env,
app,
installed_map: {}
});
pro_list_el.appendChild(row);
}
}, "render_fallback_plugin_list");
const add_update_sub_to_login_section = /* @__PURE__ */ __name(() => {
const setting = new import_obsidian16.Setting(login_container).setName("Subscription Expired").setDesc("Your Smart Connections Pro subscription has expired. Please update your subscription to retain access to Pro plugins.");
setting.addButton((btn) => {
btn.setButtonText("Get Pro");
btn.onClick(() => {
window.open("https://smartconnections.app/subscribe/", "_external");
});
});
setting.addButton((btn) => {
btn.setButtonText("Update subscription");
btn.onClick(() => {
window.open("https://smartconnections.app/subscription-update/", "_external");
});
});
setting.addButton((btn) => {
btn.setButtonText("Refresh");
btn.onClick(() => {
env.events.emit("pro_plugins:refresh");
});
});
}, "add_update_sub_to_login_section");
const render_plugin_list_section = /* @__PURE__ */ __name(async () => {
this.empty(pro_list_el);
const token = localStorage.getItem(oauth_storage_prefix + "token") || "";
if (!token) {
await render_fallback_plugin_list();
await render_referral_section();
return;
}
try {
const installed_map = await get_installed_info();
const resp = await fetch_server_plugin_list(token);
const { list = [], unauthorized = [], sub_exp } = resp;
if (typeof sub_exp === "number" && sub_exp < Date.now()) {
add_update_sub_to_login_section();
await render_fallback_plugin_list();
await render_referral_section();
return;
}
await render_referral_section({ token, sub_exp });
if (!Array.isArray(list) || list.length === 0) {
await render_fallback_plugin_list();
return;
}
for (const item of list) {
const row = await env.smart_components.render_component("pro_plugins_list_item", item, {
env,
app,
token,
installed_map,
on_installed: render_plugin_list_section
});
pro_list_el.appendChild(row);
}
} catch (err) {
console.error("[pro-plugins:list] Failed to fetch plugin list:", err);
pro_list_el.textContent = "Error fetching plugin list. Check console.";
}
}, "render_plugin_list_section");
const render_smart_plugins = /* @__PURE__ */ __name(async () => {
render_oauth_login_section();
await render_plugin_list_section();
}, "render_smart_plugins");
env.events.on("smart_plugins_oauth_completed", () => {
render_smart_plugins();
});
await render_smart_plugins();
return container;
}
__name(post_process8, "post_process");
function initiate_smart_plugins_oauth() {
console.log("initiate_smart_plugins_oauth");
const state = Math.random().toString(36).slice(2);
const redirect_uri = encodeURIComponent("obsidian://smart-plugins/callback");
const url = `${get_smart_server_url()}/oauth?client_id=smart-plugins-op&redirect_uri=${redirect_uri}&state=${state}`;
window.open(url, "_external");
return url;
}
__name(initiate_smart_plugins_oauth, "initiate_smart_plugins_oauth");
var copy_to_clipboard = /* @__PURE__ */ __name(async (text) => {
if (!text) return false;
try {
if (navigator?.clipboard?.writeText) {
await navigator.clipboard.writeText(text);
return true;
}
} catch {
}
try {
const ta = document.createElement("textarea");
ta.value = text;
ta.setAttribute("readonly", "true");
ta.style.position = "fixed";
ta.style.left = "-9999px";
ta.style.top = "0";
document.body.appendChild(ta);
ta.select();
const ok = document.execCommand("copy");
document.body.removeChild(ta);
return Boolean(ok);
} catch {
}
return false;
}, "copy_to_clipboard");

var import_obsidian17 = require("obsidian");
var PRO_PLUGINS_URL = "https://smartconnections.app/pro-plugins/";
function build_html10(item, params = {}) {
return `<div class="pro-plugins-list-item"></div>`;
}
__name(build_html10, "build_html");
function is_fallback_item(item) {
return !item || !item.repo;
}
__name(is_fallback_item, "is_fallback_item");
function compute_display_state(item, local_info) {
const repo_name = item.repo;
const server_version = item.version || "unknown";
const plugin_id = item.manifest_id || repo_name.replace("/", "_");
const local_version = local_info?.version || null;
const display_name9 = local_info?.name || item.name || repo_name;
let desc = `Server version: ${server_version}`;
let button_label = "Install";
let is_disabled = false;
if (local_version) {
desc += ` | Installed version: ${local_version}`;
const is_update = is_server_version_newer(local_version, server_version);
if (is_update) {
button_label = "Update";
} else {
button_label = "Installed";
is_disabled = true;
}
}
if (item.description) {
desc += `
${item.description}`;
}
return { plugin_id, display_name: display_name9, desc, button_label, is_disabled, server_version, local_version };
}
__name(compute_display_state, "compute_display_state");
async function render10(item, params = {}) {
const html = build_html10(item, params);
const frag = this.create_doc_fragment(html);
const container = frag.firstElementChild;
await post_process9.call(this, item, container, params);
return container;
}
__name(render10, "render");
async function post_process9(item, container, params = {}) {
const { app, token, installed_map = {}, on_installed } = params;
if (is_fallback_item(item)) {
const row2 = new import_obsidian17.Setting(container).setName(item.name || "Pro plugin").setDesc(item.description || "Login to unlock Pro plugins.");
if (item.core_id) {
if (app.plugins.manifests[item.core_id]) {
const core_installed_text = document.createElement("i");
core_installed_text.classList.add("core-installed-text");
core_installed_text.textContent = "Core installed!";
row2.controlEl.appendChild(core_installed_text);
} else {
const get_core_link = document.createElement("a");
get_core_link.setAttribute("href", `obsidian://show-plugin?id=${item.core_id}`);
get_core_link.setAttribute("target", "_external");
get_core_link.textContent = "Install Core";
get_core_link.style.marginLeft = "10px";
get_core_link.classList.add("get-core-link");
row2.controlEl.appendChild(get_core_link);
}
}
row2.addButton((btn) => {
btn.setButtonText("Get Pro");
btn.onClick(() => {
window.open(PRO_PLUGINS_URL, "_external");
});
});
row2.addButton((btn) => {
btn.setButtonText("Learn more");
btn.onClick(() => {
window.open(item.url, "_external");
});
});
return container;
}
const plugin_id = item.manifest_id || item.repo.replace("/", "_");
const local = installed_map[plugin_id] || null;
const state = compute_display_state(item, local);
const row = new import_obsidian17.Setting(container).setName(state.display_name).setDesc(state.desc);
row.addButton((btn) => {
btn.setButtonText(state.button_label);
btn.setDisabled(state.is_disabled);
btn.onClick(() => install_plugin(item, { app, token, on_installed }));
});
row.addButton((btn) => {
btn.setButtonText("Docs");
if (item.docs_url) {
btn.onClick(() => window.open(item.docs_url, "_external"));
} else {
btn.onClick(() => show_plugin_readme(item, { app, token, display_name: state.display_name }));
}
});
return container;
}
__name(post_process9, "post_process");
var download_plugin_zip = /* @__PURE__ */ __name(async (item, token) => {
const resolved_download_url = typeof item.resolve_download_url === "function" ? await item.resolve_download_url() : item.download_url;
if (resolved_download_url) {
return fetch_zip_from_url(resolved_download_url);
}
if (!token) {
throw new Error("Login required to install this plugin.");
}
return fetch_plugin_zip(item.repo, token);
}, "download_plugin_zip");
var install_plugin = /* @__PURE__ */ __name(async (item, params = {}) => {
const { app, token, on_installed } = params;
try {
new import_obsidian17.Notice(`Installing "${item.repo}" ...`);
const zip_data = await download_plugin_zip(item, token);
const { files, pluginManifest } = await parse_zip_into_files(zip_data);
const folder_name = item.plugin_id;
const base_folder = `${app.vault.configDir}/plugins/${folder_name}`;
await write_files_with_adapter(app.vault.adapter, base_folder, files);
await app.plugins.loadManifests();
const plugin_id = pluginManifest?.id || item.manifest_id || folder_name;
if (app.plugins.enabledPlugins.has(plugin_id)) {
await app.plugins.disablePlugin(plugin_id);
}
await enable_plugin(app, plugin_id);
new import_obsidian17.Notice(`${item.repo} installed successfully.`);
if (typeof on_installed === "function") {
await on_installed();
}
} catch (err) {
console.error("[pro-plugins:list_item] Install error:", err);
new import_obsidian17.Notice(`Install failed: ${err.message}`);
}
}, "install_plugin");
var show_plugin_readme = /* @__PURE__ */ __name(async (item, params = {}) => {
const { app, token, display_name: display_name9 } = params;
try {
const readme = await fetch_plugin_readme(item.repo, token);
const modal = new import_obsidian17.Modal(app);
modal.setTitle(display_name9 || item.name || item.repo);
await import_obsidian17.MarkdownRenderer.render(app, readme, modal.contentEl, "", new import_obsidian17.Component());
modal.open();
} catch (err) {
console.error("[pro-plugins:list_item] Failed to load README:", err);
new import_obsidian17.Notice("Failed to load README");
}
}, "show_plugin_readme");

var import_obsidian18 = require("obsidian");
var SmartModelModal = class extends import_obsidian18.Modal {
static {
__name(this, "SmartModelModal");
}
/**
* @param {App} app
* @param {EditModelModalOpts} opts
*/
constructor(model, params = {}) {
const app = model.env.plugin.app || window.app;
super(app);
this.model = model;
this.collection = this.model.collection;
this.env = this.model.env;
this.params = params;
}
onOpen() {
this.titleEl.setText("Edit model");
this.contentEl.addClass("smart-model-modal");
this.render_form();
}
onClose() {
this.contentEl.empty();
if (typeof this.params.on_close === "function") {
this.params.on_close();
}
}
async render_form() {
const container = this.contentEl;
container.empty();
const model = this.model;
const model_actions_bar = await this.env.smart_components.render_component("settings_model_actions", model, {
on_before_new: /* @__PURE__ */ __name(async () => {
this.close();
}, "on_before_new"),
on_after_delete: /* @__PURE__ */ __name(async () => {
this.close();
}, "on_after_delete")
});
container.appendChild(model_actions_bar);
const settings = model.settings_config;
const form = await this.env.smart_view.render_settings(settings, {
scope: model
});
container.appendChild(form);
const test_btn = container.createEl("button", { text: "Test model" });
const test_results_el = container.createDiv({ cls: "model-test-container" });
test_btn.addEventListener("click", async () => {
await this.run_test(test_results_el, model);
});
if (this.params.test_on_open) {
await this.run_test(test_results_el, model);
}
}
async run_test(test_results_el, model) {
test_results_el.empty();
const test_result_el = test_results_el.createEl("pre", { cls: "model-test-result", text: "Testing..." });
test_results_el.appendChild(test_result_el);
const test_result = await model.test_model();
test_result_el.textContent = JSON.stringify(test_result, null, 2);
}
};

var env_model_default = '.model-settings .model-info {\r\n  border-radius: var(--radius-m);\r\n  padding: 1rem;\r\n  margin-bottom: 1rem;\r\n  background-color: var(--background-secondary);\r\n  pre {\r\n    margin: 0;\r\n    font-size: 0.9rem;\r\n  }\r\n  .test-result-icon {\r\n    vertical-align: middle;\r\n    margin-left: 0.5rem;\r\n  }\r\n  .test-result-icon[data-icon="square-check-big"]{\r\n    color: var(--color-green);\r\n  }\r\n  .test-result-icon[data-icon="circle-x"]{\r\n    color: var(--color-red);\r\n  }\r\n}\r\n\r\n.smart-model-modal{\r\n   pre, .model-note {\r\n    user-select: text;\r\n  }\r\n}';

var import_obsidian19 = require("obsidian");
function build_html11(model, params) {
const details = [
`Provider: ${model.data.provider_key}`,
`Model: ${model.data.model_key || "**MISSING - EDIT & SELECT MODEL**"}`
];
return `<div class="model-info">
<div class="smart-env-settings-header">
<b>Current: ${model.display_name} <span class="test-result-icon" data-icon="${get_test_result_icon_name(model)}"></span></b>
<div>
<button class="edit-model">Edit</button>
<button class="test-model">Test</button>
</div>
</div>
<pre>${details.join("\n")}</pre>
</div>`;
}
__name(build_html11, "build_html");
async function render11(model, params) {
this.apply_style_sheet(env_model_default);
const frag = this.create_doc_fragment(build_html11.call(this, model, params));
const container = frag.firstElementChild;
post_process10.call(this, model, container, params);
return container;
}
__name(render11, "render");
async function post_process10(model, container, params) {
const edit_btn = container.querySelector(".edit-model");
const test_btn = container.querySelector(".test-model");
const icon_el = container.querySelector(".test-result-icon");
(0, import_obsidian19.setIcon)(icon_el, get_test_result_icon_name(model));
edit_btn.addEventListener("click", () => {
new SmartModelModal(model).open();
});
test_btn.addEventListener("click", () => {
new SmartModelModal(model, { test_on_open: true }).open();
});
return container;
}
__name(post_process10, "post_process");
function get_test_result_icon_name(model) {
switch (model.data.test_passed) {
case true:
return "square-check-big";
case false:
return "circle-x";
default:
return "square";
}
}
__name(get_test_result_icon_name, "get_test_result_icon_name");

var import_obsidian20 = require("obsidian");

var provider_options = {
chat_completion_models: [
{
label: "Open Router (cloud)",
value: "open_router"
},
{
label: "PRO: LM Studio (local, requires LM Studio app)",
value: "lm_studio",
disabled: true
},
{
label: "PRO: Ollama (local, requires Ollama app)",
value: "ollama",
disabled: true
},
{
label: "PRO: OpenAI (cloud)",
value: "openai",
disabled: true
},
{
label: "PRO: Google Gemini (cloud)",
value: "google",
disabled: true
},
{
label: "PRO: Cohere (cloud)",
value: "cohere",
disabled: true
},
{
label: "PRO: xAI Grok (cloud)",
value: "xai",
disabled: true
},
{
label: "PRO: Anthropic Claude (cloud)",
value: "anthropic",
disabled: true
},
{
label: "PRO: Deepseek (cloud)",
value: "deepseek",
disabled: true
},
{
label: "PRO: Azure OpenAI (cloud)",
value: "azure",
disabled: true
}
],
embedding_models: [
{
label: "Transformers (easy, local, built-in)",
value: "transformers"
},
{
label: "PRO: LM Studio (local, requires LM Studio app)",
value: "lm_studio",
disabled: true
},
{
label: "PRO: Ollama (local, requires Ollama app)",
value: "ollama",
disabled: true
},
{
label: "PRO: OpenAI (cloud)",
value: "openai",
disabled: true
},
{
label: "PRO: Google Gemini (cloud)",
value: "gemini",
disabled: true
},
{
label: "PRO: Open Router (cloud)",
value: "open_router",
disabled: true
}
],
ranking_models: [
{
label: "PRO: Cohere (cloud)",
value: "cohere",
disabled: true
}
]
};

function show_new_model_menu(models_collection, event, params = {}) {
const providers = (provider_options[models_collection.collection_key] || []).map((p) => ({ ...p, disabled: !models_collection.env_config.providers[p.value] }));
if (providers.length === 0) {
if (event.target.tagName.toLowerCase() === "button") {
event.target.disabled = true;
event.title = "No providers available to create new models.";
}
} else {
const menu = new import_obsidian20.Menu();
providers.forEach((provider) => {
menu.addItem((item) => {
item.setTitle(provider.label);
if (provider.disabled) {
item.setDisabled(true);
}
item.onClick(async () => {
if (typeof params.on_before_new === "function") {
await params.on_before_new();
}
const model = models_collection.new_model({ provider_key: provider.value });
const on_new_close = /* @__PURE__ */ __name(async () => {
}, "on_new_close");
new SmartModelModal(model, { on_close: on_new_close }).open();
});
});
});
menu.showAtMouseEvent(event);
}
}
__name(show_new_model_menu, "show_new_model_menu");

var import_obsidian21 = require("obsidian");

function ensure_settings_config(settings_config40, scope) {
try {
if (typeof settings_config40 === "function") {
settings_config40 = settings_config40(scope);
}
} catch (e) {
console.error("Error evaluating settings_config function:", e);
settings_config40 = { error: { name: "Error", description: `Failed to load settings. ${e.message} (logged to console)` } };
}
return settings_config40;
}
__name(ensure_settings_config, "ensure_settings_config");
function build_settings_group_map(settings_config40, scope, default_group_name) {
const resolved_settings_config = ensure_settings_config(settings_config40, scope);
return Object.entries(resolved_settings_config || {}).reduce((acc, [key, config]) => {
const group = config.group || default_group_name;
if (!acc[group]) acc[group] = {};
acc[group][key] = config;
return acc;
}, { [default_group_name]: {} });
}
__name(build_settings_group_map, "build_settings_group_map");
function resolve_group_settings_config(settings_config40, scope, group_name, default_group_name) {
const group_map = build_settings_group_map(settings_config40, scope, default_group_name);
return group_map[group_name] || {};
}
__name(resolve_group_settings_config, "resolve_group_settings_config");

var SettingGroupPolyfill = class {
static {
__name(this, "SettingGroupPolyfill");
}
constructor(container) {
this.components = [];
this.groupEl = container.createDiv("setting-group");
this.headerEl = this.groupEl.createDiv("setting-item setting-item-heading");
this.headerInnerEl = this.headerEl.createDiv("setting-item-name");
this.controlEl = this.headerEl.createDiv("setting-item-control");
this.listEl = this.groupEl.createDiv("setting-items");
}
setHeading(heading) {
this.headerInnerEl.setText(heading);
}
addSetting(callback) {
const setting = new import_obsidian21.Setting(this.listEl);
this.components.push(setting);
callback(setting);
return setting;
}
addClass(class_name) {
this.groupEl.addClass(class_name);
}
};
function render_settings_config(settings_config40, scope, container, params = {}) {
const {
default_group_name = "Settings"
} = params;
const settings_config_source = settings_config40;
const group_map = build_settings_group_map(settings_config40, scope, default_group_name);
const settings_groups = Object.entries(group_map).sort(([a], [b]) => a === default_group_name ? -1 : b === default_group_name ? 1 : 0).filter(([, group_config]) => Object.keys(group_config).length > 0).map(([group_name, group_config]) => {
const group_container = container.createDiv();
const group_params = {
...params,
...params.group_params?.[group_name] || {},
settings_config_source
};
return render_settings_group(
group_name,
scope,
group_config,
group_container,
group_params
);
});
return settings_groups;
}
__name(render_settings_config, "render_settings_config");
function render_settings_group(group_name, scope, settings_config40, container, params = {}) {
const settings_config_source = params.settings_config_source || settings_config40;
const settings_config_group = params.settings_config_source ? resolve_group_settings_config(
settings_config_source,
scope,
group_name,
params.default_group_name || "Settings"
) : settings_config40;
let SettingGroup;
try {
const obsidian_module = require("obsidian");
if (obsidian_module.SettingGroup) {
SettingGroup = obsidian_module.SettingGroup;
} else {
SettingGroup = SettingGroupPolyfill;
}
} catch (e) {
SettingGroup = SettingGroupPolyfill;
}
settings_config40 = settings_config_group;
const {
heading_btn = null
} = params;
const render_group = params.settings_config_source ? (group_name2, scope2, settings_config41, container2, group_params) => {
const group_config = resolve_group_settings_config(
settings_config41,
scope2,
group_name2,
group_params.default_group_name || "Settings"
);
return render_settings_group(group_name2, scope2, group_config, container2, group_params);
} : render_settings_group;
const rerender_settings_group = create_settings_group_rerender(scope, {
container,
group_name,
settings_config: settings_config_source,
group_params: params,
render_group
});
let setting_group = new SettingGroup(container);
if (heading_btn && typeof heading_btn === "object") {
if (Array.isArray(heading_btn)) {
for (const btn_config of heading_btn) {
render_heading_button(setting_group, scope, btn_config);
}
} else {
render_heading_button(setting_group, scope, heading_btn);
}
}
setting_group.setHeading(group_name);
for (const [setting_path, setting_config] of Object.entries(settings_config40)) {
if (!setting_config || typeof setting_config !== "object") {
console.warn(`Invalid setting config for ${setting_path}:`, setting_config);
continue;
}
const settng_is_pro = setting_config.scope_class === "pro-setting";
const env_is_pro = !!scope.env?.is_pro;
setting_group.addSetting((setting) => {
if (setting_config.name) setting.setName(setting_config.name);
setting.setClass(setting_path.replace(/[^a-zA-Z0-9]/g, "-"));
if (setting_config.type) setting.setClass(`setting-type-${setting_config.type}`);
if (setting_config.description) {
setting.setDesc(setting_config.description);
}
switch (setting_config.type) {
case "button":
setting.addButton((btn) => {
btn.setButtonText(setting_config.name || "Run");
btn.onClick(async (event) => {
if (typeof setting_config.callback === "function") {
await handle_config_callback(setting, event, setting_config.callback, { scope });
}
});
});
break;
case "toggle":
setting.addToggle((toggle) => {
toggle.setValue(get_by_path(scope.settings, setting_path) || false);
toggle.onChange((value) => {
set_by_path(scope.settings, setting_path, value);
if (typeof setting_config.callback === "function") {
handle_config_callback(setting, value, setting_config.callback, { scope });
}
});
});
break;
case "text":
setting.addText((text) => {
text.setValue(String(get_by_path(scope.settings, setting_path) || ""));
text.onChange((value) => {
set_by_path(scope.settings, setting_path, value);
});
});
break;
case "number":
setting.addText((text) => {
text.setValue(String(get_by_path(scope.settings, setting_path) ?? "0"));
text.inputEl.setAttribute("type", "number");
text.onChange((value) => {
const num_value = Number(value);
if (!isNaN(num_value)) {
set_by_path(scope.settings, setting_path, num_value);
}
if (typeof setting_config.callback === "function") {
handle_config_callback(setting, num_value, setting_config.callback, { scope });
}
});
});
break;
case "dropdown":
setting.addDropdown((dropdown) => {
const options_callback = setting_config.options_callback;
if (typeof options_callback === "function") {
const options = options_callback.call(scope, scope);
options.forEach((opt) => {
const label = opt.label || opt.name || opt.value;
dropdown.addOption(opt.value, label);
});
}
dropdown.setValue(get_by_path(scope.settings, setting_path) || "");
dropdown.onChange((value) => {
set_by_path(scope.settings, setting_path, value);
if (typeof setting_config.callback === "function") {
handle_config_callback(setting, value, setting_config.callback, { scope });
}
rerender_settings_group();
});
});
break;
case "textarea":
setting.addTextArea((text) => {
text.setValue(String(get_by_path(scope.settings, setting_path) || ""));
text.onChange((value) => {
if (settng_is_pro && !env_is_pro) {
new import_obsidian21.Notice("Nice try! This is a PRO feature. Please upgrade to access this setting.");
return;
}
set_by_path(scope.settings, setting_path, value);
});
if (settng_is_pro && !env_is_pro) {
text.setDisabled(true);
}
});
break;
case "slider":
setting.addSlider((slider) => {
const min = setting_config.min || 0;
const max = setting_config.max || 100;
const step = setting_config.step || 1;
slider.setLimits(min, max, step);
slider.setValue(get_by_path(scope.settings, setting_path) || min);
slider.setDynamicTooltip();
slider.onChange((value) => {
set_by_path(scope.settings, setting_path, value);
if (typeof setting_config.callback === "function") {
handle_config_callback(setting, value, setting_config.callback, { scope });
}
});
});
break;
case "heading":
setting.setHeading();
break;
case "html":
if (setting_config.value) {
setting.descEl.replaceChildren(
document.createRange().createContextualFragment(setting_config.value)
);
}
break;
default:
console.warn(`Unsupported setting type for ${setting_path}:`, setting_config.type);
break;
}
if (setting_config.scope_class) {
setting.settingEl.addClass(setting_config.scope_class);
}
});
}
return setting_group;
}
__name(render_settings_group, "render_settings_group");
function render_heading_button(setting_group, scope, heading_btn) {
const btn_el = setting_group.controlEl.createEl("button", { cls: "" });
if (heading_btn.btn_icon) {
(0, import_obsidian21.setIcon)(btn_el, heading_btn.btn_icon);
}
if (heading_btn.btn_text) {
btn_el.setText(heading_btn.btn_text);
}
if (heading_btn.label) {
btn_el.setAttr("aria-label", heading_btn.label);
}
btn_el.addEventListener("click", async (event) => {
if (typeof heading_btn.callback === "function") {
await handle_config_callback(null, event, heading_btn.callback, { scope });
} else {
console.warn("No callback defined for heading button");
}
});
setting_group.controlEl.appendChild(btn_el);
}
__name(render_heading_button, "render_heading_button");
async function handle_config_callback(setting, event_or_value, cb, params = {}) {
const {
scope = null
} = params;
if (scope) {
return await cb.call(scope, event_or_value, setting);
} else {
return await cb(event_or_value, setting);
}
}
__name(handle_config_callback, "handle_config_callback");
function create_settings_group_rerender(scope, params = {}) {
const {
container,
group_name,
settings_config: settings_config40,
group_params = {},
render_group
} = params;
return () => {
if (!container || typeof render_group !== "function") return null;
container.replaceChildren();
return render_group(group_name, scope, settings_config40, container, group_params);
};
}
__name(create_settings_group_rerender, "create_settings_group_rerender");

function build_html12(models_collection, params) {
return `<div class="model-settings" data-model-type="${models_collection.collection_key}">
<div class="global-settings"></div>
</div>`;
}
__name(build_html12, "build_html");
async function render12(models_collection, params) {
const frag = this.create_doc_fragment(build_html12.call(this, models_collection, params));
const container = frag.firstElementChild;
post_process11.call(this, models_collection, container, params);
return container;
}
__name(render12, "render");
async function post_process11(models_collection, container, params) {
const disposers = [];
const render_current_model_info = /* @__PURE__ */ __name(async (current_model) => {
this.empty(container);
const [settings_group] = render_settings_config(
models_collection.env_config.settings_config,
models_collection,
container,
{
default_group_name: `${models_collection.model_type} models`,
heading_btn: {
btn_text: "+ New",
callback: /* @__PURE__ */ __name((event, setting) => {
show_new_model_menu(models_collection, event);
}, "callback")
}
}
);
models_collection.env.smart_components.render_component("settings_env_model", current_model, {}).then((model_info_el) => {
settings_group.listEl.appendChild(model_info_el);
});
}, "render_current_model_info");
render_current_model_info(models_collection.default);
disposers.push(models_collection.on_event("settings:changed", async (payload) => {
const default_setting_path = `${models_collection.collection_key}.default_model_key`;
if (payload.path_string === default_setting_path) {
await render_current_model_info(models_collection.default);
}
}));
disposers.push(models_collection.on_event("model:changed", async () => {
await render_current_model_info(models_collection.default);
}));
this.attach_disposer(container, disposers);
}
__name(post_process11, "post_process");

function build_html13(env, params) {
const models_collections = [
env.embedding_models,
env.chat_completion_models,
env.ranking_models
].filter(Boolean);
const type_containers = models_collections.map((models_collection) => {
return `<div data-collection-key="${models_collection.collection_key}"></div>`;
}).join("\n");
return `<div class="env-model-types">
${type_containers}
</div>`;
}
__name(build_html13, "build_html");
async function render13(env, params) {
const frag = this.create_doc_fragment(build_html13(env, params));
const container = frag.firstElementChild;
post_process12.call(this, env, container, params);
return container;
}
__name(render13, "render");
async function post_process12(env, container, params) {
const collection_containers = container.querySelectorAll("div[data-collection-key]");
for (const collection_container of collection_containers) {
const collection_key = collection_container.getAttribute("data-collection-key");
const models_collection = env[collection_key];
env.smart_components.render_component("settings_env_model_type", models_collection).then((model_type_el) => {
this.empty(collection_container);
collection_container.appendChild(model_type_el);
});
}
return container;
}
__name(post_process12, "post_process");

var import_obsidian22 = require("obsidian");

function ensure_smart_sources_settings(env) {
if (!env.settings) env.settings = {};
if (!env.settings.smart_sources) env.settings.smart_sources = {};
const smart_sources_settings = env.settings.smart_sources;
if (!smart_sources_settings.folder_exclusions) smart_sources_settings.folder_exclusions = "";
if (!smart_sources_settings.file_exclusions) smart_sources_settings.file_exclusions = "";
return smart_sources_settings;
}
__name(ensure_smart_sources_settings, "ensure_smart_sources_settings");
function parse_exclusions_csv(exclusions = "") {
return exclusions.split(",").map((value) => value.trim()).filter(Boolean);
}
__name(parse_exclusions_csv, "parse_exclusions_csv");
function add_exclusion(exclusions, value) {
const trimmed = (value ?? "").trim();
if (!trimmed) return exclusions || "";
const current = parse_exclusions_csv(exclusions);
if (!current.includes(trimmed)) current.push(trimmed);
return current.join(",");
}
__name(add_exclusion, "add_exclusion");
function remove_exclusion(exclusions, value) {
const trimmed = (value ?? "").trim();
if (!trimmed) return exclusions?.trim() || "";
const filtered = parse_exclusions_csv(exclusions).filter((entry) => entry !== trimmed);
return filtered.join(",");
}
__name(remove_exclusion, "remove_exclusion");

var ExcludedFoldersFuzzy = class extends import_obsidian22.FuzzySuggestModal {
static {
__name(this, "ExcludedFoldersFuzzy");
}
/**
* @param {App} app - The Obsidian app
* @param {Object} env - An environment-like object, must have .settings and .fs.folder_paths
*/
constructor(app, env) {
super(app);
this.env = env;
this.setPlaceholder("Select a folder to exclude...");
}
/**
* Open the modal with an optional callback invoked after an item is chosen.
* The current exclusion list is rendered at the top of the modal.
* @param {Function} [selection_callback]
*/
open(selection_callback) {
this.callback = selection_callback;
super.open();
this.render_excluded_list();
}
/**
* Return candidate folder paths that are not already excluded.
* @returns {string[]}
*/
getItems() {
const smart_sources_settings = ensure_smart_sources_settings(this.env);
const folder_exclusions3 = parse_exclusions_csv(smart_sources_settings.folder_exclusions);
const candidates = (this.env.smart_sources?.fs?.folder_paths || []).filter((path) => !folder_exclusions3.includes(path));
return candidates;
}
getItemText(item) {
return item;
}
/**
* Handle selecting a folder to exclude.
* @param {string} item
*/
onChooseItem(item) {
this.prevent_close = true;
if (!item) return;
const smart_sources_settings = ensure_smart_sources_settings(this.env);
smart_sources_settings.folder_exclusions = add_exclusion(smart_sources_settings.folder_exclusions, item);
this.render_excluded_list();
this.updateSuggestions();
this.callback?.();
}
/**
* Render the current list of excluded folders at the top of the modal,
* with inline remove buttons.
*/
render_excluded_list() {
if (!this.modalEl) return;
const smart_sources_settings = ensure_smart_sources_settings(this.env);
const excluded_folders = parse_exclusions_csv(smart_sources_settings.folder_exclusions);
let header = this.modalEl.querySelector(".sc-excluded-folders-header");
if (!header) {
header = this.modalEl.createEl("div", { cls: "sc-excluded-folders-header" });
this.modalEl.prepend(header);
}
header.empty();
const title_el = header.createEl("h3");
title_el.setText("Excluded folders");
if (!excluded_folders.length) {
const empty_el = header.createEl("p");
empty_el.setText("No folders excluded yet.");
return;
}
const list_el = header.createEl("ul");
excluded_folders.forEach((folder_path) => {
const li = list_el.createEl("li", { cls: "excluded-folder-item" });
li.setText(folder_path + "  ");
const remove_btn = li.createEl("button", {
text: "(x)",
cls: "remove-excluded-folder-btn"
});
remove_btn.addEventListener("click", () => {
smart_sources_settings.folder_exclusions = remove_exclusion(
smart_sources_settings.folder_exclusions,
folder_path
);
this.env.update_exclusions?.();
this.render_excluded_list();
this.updateSuggestions();
});
});
}
close() {
setTimeout(() => {
if (!this.prevent_close) super.close();
this.prevent_close = false;
}, 10);
}
};

var import_obsidian23 = require("obsidian");
var ExcludedSourcesModal = class extends import_obsidian23.Modal {
static {
__name(this, "ExcludedSourcesModal");
}
/**
* @param {Object} app - Obsidian app
* @param {Object} env - The environment instance
*/
constructor(app, env) {
super(app);
this.env = env;
}
async onOpen() {
this.titleEl.setText("Excluded Sources");
this.contentEl.addClass("excluded-sources-modal");
this.render_excluded_list();
}
async render_excluded_list() {
this.contentEl.empty();
const list_el = this.contentEl.createEl("ul");
const excluded_file_paths = this.env.smart_sources.excluded_file_paths;
const too_long_files = this.app.vault.getMarkdownFiles().filter((file) => file.path.length > 200).map((file) => file.path);
for (const file_path of excluded_file_paths) {
const li = list_el.createEl("li");
li.setText(file_path);
}
this.contentEl.createEl("hr");
this.contentEl.createEl("h3", { text: "Paths too long to import into Smart Environment" });
const too_long_list_ul = this.contentEl.createEl("ul", { cls: "too-long-exclusions" });
for (const file_path of too_long_files) {
const li = too_long_list_ul.createEl("li");
li.setText(file_path);
}
}
};

async function build_html14(env, opts = {}) {
return `
<div class="sources-settings">
</div>
`;
}
__name(build_html14, "build_html");
async function render14(env, opts = {}) {
const html = await build_html14.call(this, env, opts);
const frag = this.create_doc_fragment(html);
const container = frag.firstElementChild;
post_process13.call(this, env, container, opts);
return container;
}
__name(render14, "render");
async function post_process13(env, container, opts = {}) {
const settings_config40 = {
folder_exclusions,
view_exclusions,
re_import_sources
};
render_settings_config(settings_config40, env, container, {
default_group_name: "Sources",
heading_btn: {
btn_icon: "help-circle",
callback: /* @__PURE__ */ __name((event, setting) => {
window.open("https://smartconnections.app/smart-environment/settings/?utm_source=source-settings", "_external");
}, "callback")
}
});
const disposers = [];
disposers.push(env.events?.on("model:changed", highlight_reset_data(env, container)));
this.attach_disposer(container, disposers);
return container;
}
__name(post_process13, "post_process");
function highlight_reset_data(env, container) {
return async (payload) => {
if (payload.collection_key !== "embedding_models") return;
const re_import_setting = container.querySelector(".re-import-sources");
re_import_setting.classList.add("env-setting-highlight");
const notice = re_import_setting.querySelector(".reimport-notice") ? re_import_setting.querySelector(".reimport-notice") : re_import_setting.createEl("div", { cls: "reimport-notice env-setting-note" });
notice.textContent = "Embedding model changed. Please re-import your sources to update their embeddings.";
re_import_setting.appendChild(notice);
env.events.once("sources:reimported", () => {
re_import_setting.classList.remove("env-setting-highlight");
notice.remove();
});
};
}
__name(highlight_reset_data, "highlight_reset_data");
var folder_exclusions = {
type: "button",
name: "Manage excluded folders",
description: "Manage the list of folders excluded from processing.",
btn_text: "Manage folders",
callback: /* @__PURE__ */ __name(async function(value, setting) {
const env = this;
const fuzzy = new ExcludedFoldersFuzzy(env.main.app, env);
const selection_callback = /* @__PURE__ */ __name(() => {
env.update_exclusions();
}, "selection_callback");
fuzzy.open(selection_callback);
}, "callback")
};
var view_exclusions = {
type: "button",
name: "View all exclusions",
description: "View all excluded sources.",
btn_text: "Show",
callback: /* @__PURE__ */ __name(async function(value, setting) {
const env = this;
const modal = new ExcludedSourcesModal(env.main.app, env);
modal.open();
}, "callback")
};
var re_import_sources = {
type: "button",
name: "Reset data",
description: "Clear sources data and re-import.",
btn_text: "Re-import sources",
callback: /* @__PURE__ */ __name(async function(value, setting) {
const env = this;
const container = setting.controlEl;
const confirm_row = container.createEl("div", { cls: "sc-inline-confirm-row" });
const reimport_btn = container.querySelector("button");
reimport_btn.style.display = "none";
confirm_row.setText("Are you sure you want to clear all sources data? This cannot be undone.");
let confirm_cancel = confirm_row.createEl("button", { text: "Cancel" });
let confirm_yes = confirm_row.createEl("button", { text: "Re-import", cls: "mod-warning" });
confirm_yes.addEventListener("click", async (e) => {
confirm_cancel.style.display = "none";
confirm_yes.textContent = "Re-importing...";
confirm_yes.disabled = true;
const confirm_row2 = e.target.closest(".sc-inline-confirm-row");
await env.smart_sources.run_clear_all();
const start = Date.now();
env.smart_sources.unload();
env.smart_blocks.unload();
await env.init_collections();
await env.load_collections();
await env.smart_sources.process_embed_queue();
const end = Date.now();
env.events?.emit("sources:reimported", { time_ms: end - start });
env.main.notices?.show("reload_sources", { time_ms: end - start });
confirm_row2.style.display = "none";
reimport_btn.style.display = "inline-block";
confirm_yes.textContent = "Yes";
confirm_yes.disabled = false;
});
confirm_cancel.addEventListener("click", (e) => {
confirm_row.style.display = "none";
reimport_btn.style.display = "inline-block";
}, { once: true });
}, "callback")
};

function build_html15(model, params = {}) {
return `<div class="smart-model-modal-actions">
<button class="new-model-btn">New</button>
<button class="delete-model-btn">Delete</button>
<div class="confirm-delete-container" style="display:none;">
<span>Are you sure?</span>
<button class="confirm-delete-yes-btn">Yes</button>
<button class="confirm-delete-no-btn">No</button>
</div>
</div>`;
}
__name(build_html15, "build_html");
async function render15(model, params = {}) {
const frag = this.create_doc_fragment(build_html15(model, params));
const container = frag.firstElementChild;
post_process14.call(this, model, container, params);
return container;
}
__name(render15, "render");
async function post_process14(model, container, params = {}) {
const new_model_btn = container.querySelector(".new-model-btn");
new_model_btn.addEventListener("click", async (event) => {
const on_before_new = params.on_before_new;
const opts = {};
if (typeof on_before_new === "function") {
opts.on_before_new = on_before_new;
}
show_new_model_menu(model.collection, event, opts);
});
const delete_model_btn = container.querySelector(".delete-model-btn");
const confirm_delete_container = container.querySelector(".confirm-delete-container");
const confirm_delete_yes_btn = container.querySelector(".confirm-delete-yes-btn");
const confirm_delete_no_btn = container.querySelector(".confirm-delete-no-btn");
delete_model_btn.addEventListener("click", async () => {
confirm_delete_container.style.display = "";
});
confirm_delete_no_btn.addEventListener("click", async () => {
confirm_delete_container.style.display = "none";
});
confirm_delete_yes_btn.addEventListener("click", async () => {
await model.delete_model();
if (typeof params.on_after_delete === "function") {
params.on_after_delete();
}
});
return container;
}
__name(post_process14, "post_process");

async function build_html16(env, opts = {}) {
let html = `<div class="settings-group">
<div class="setting-item setting-item-heading">
<div class="setting-item-name">Muted notices</div>
</div>
<div class="setting-items">
`;
if (Object.keys(env.notices.settings?.muted || {}).length) {
for (const notice in env.notices.settings?.muted) {
html += `<div class="muted-notice setting-item" data-notice="${notice}" style="display: flex; align-items: center; justify-content: space-between; gap: 10px;">
<div class="setting-item-info">
<div class="setting-item-name">
${notice}
</div>
</div>
<div class="setting-item-control">
<button class="unmute-button">Unmute</button>
</div>
</div>`;
}
} else {
html += `<div class="setting-item"><div class="setting-item-info"><div class="setting-item-name">No muted notices.</div></div></div>`;
}
html += `</div>`;
return html;
}
__name(build_html16, "build_html");
async function render16(env, opts = {}) {
let html = await build_html16.call(this, env, opts);
const frag = this.create_doc_fragment(html);
const container = frag.firstElementChild;
post_process15.call(this, env, container, opts);
return container;
}
__name(render16, "render");
async function post_process15(env, frag, opts = {}) {
const unmute_buttons = frag.querySelectorAll(".unmute-button");
unmute_buttons.forEach((button) => {
button.addEventListener("click", () => {
const row = button.closest(".muted-notice");
const notice = row.dataset.notice;
env.notices.settings.muted[notice] = false;
delete env.notices.settings.muted[notice];
row.remove();
});
});
}
__name(post_process15, "post_process");

var style_default2 = ".sc-env-settings-container {\n  margin: 1rem 0;\n}\n\n.smart-env-settings-header {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  margin-bottom: 0.5rem;\n}\n\n.toggle-env-settings-btn {\n  cursor: pointer;\n}\n\n\n.setting-group .setting-items .setting-item.env-setting-highlight {\n  border: 1px solid var(--interactive-accent);\n  background-color: var(--interactive-hover);\n  padding: 0.5rem;\n  margin: 0.5rem 0;\n}\n\n.settings-group {\n  .setting-item {\n    border-top: none;\n  }\n}\n\n.sc-inline-confirm-row {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  margin-top: 0.5rem;\n}\n";

async function build_html17(env, params = {}) {
return `<div class="smart-env-settings-container">
<div class="sources-container">
<h1>Sources</h1>
</div>
<div class="models-container">
<h1>Models</h1>
</div>
<div class="notifications-container">
<h1>Notifications</h1>
</div>
</div>`;
}
__name(build_html17, "build_html");
async function render17(env, params = {}) {
this.apply_style_sheet(style_default2);
const html = await build_html17.call(this, env, params);
const frag = this.create_doc_fragment(html);
const container = frag.firstElementChild;
post_process16.call(this, env, container, params);
return container;
}
__name(render17, "render");
async function post_process16(env, container, opts = {}) {
const models_container = container.querySelector(".models-container");
const sources_container = container.querySelector(".sources-container");
const notifications_container = container.querySelector(".notifications-container");
render_if_available.call(this, "settings_env_sources", env, sources_container);
render_if_available.call(this, "settings_env_models", env, models_container);
render_if_available.call(this, "settings_notifications", env, notifications_container);
return container;
}
__name(post_process16, "post_process");
function render_if_available(component_key, env, container) {
if (env.config.components[component_key]) {
const placeholder = this.create_doc_fragment(`<div data-component="${component_key}"></div>`).firstElementChild;
container.appendChild(placeholder);
env.smart_components.render_component(component_key, env).then((comp_el) => {
this.empty(placeholder);
placeholder.appendChild(comp_el);
});
}
}
__name(render_if_available, "render_if_available");

var import_obsidian24 = require("obsidian");
function build_html18() {
return `
<div class="sc-context-actions">
<div class="sc-context-actions-left">
</div>
<div class="sc-context-actions-right">
</div>
</div>
`;
}
__name(build_html18, "build_html");
async function render18(ctx, opts = {}) {
const html = build_html18();
const frag = this.create_doc_fragment(html);
const container = frag.firstElementChild;
post_process17.call(this, ctx, container, opts);
return container;
}
__name(render18, "render");
async function post_process17(ctx, container, opts = {}) {
const render_ctx_actions = /* @__PURE__ */ __name(() => {
const actions_left = container.querySelector(".sc-context-actions-left");
this.empty(actions_left);
const actions_right = container.querySelector(".sc-context-actions-right");
this.empty(actions_right);
render_btn_open_selector(ctx, actions_right);
render_btn_copy_context(ctx, actions_right);
render_btn_clear_context(ctx, actions_right);
render_btn_help(ctx, actions_right);
}, "render_ctx_actions");
render_ctx_actions();
const disposers = [];
disposers.push(ctx.on_event("context:updated", render_ctx_actions));
this.attach_disposer(container, disposers);
return container;
}
__name(post_process17, "post_process");
function render_btn_open_selector(ctx, container) {
const add_btn = document.createElement("button");
add_btn.type = "button";
add_btn.className = "sc-add-context-btn";
add_btn.textContent = "Add context";
container.appendChild(add_btn);
add_btn.addEventListener("click", () => {
ctx.emit_event("context_selector:open");
});
}
__name(render_btn_open_selector, "render_btn_open_selector");
function render_btn_copy_context(ctx, container) {
const copy_btn = document.createElement("button");
copy_btn.type = "button";
copy_btn.className = "sc-copy-clipboard";
copy_btn.textContent = "Copy to clipboard";
if (!ctx.has_context_items) {
copy_btn.style.display = "none";
}
container.appendChild(copy_btn);
copy_btn.addEventListener("click", async () => {
ctx.actions.context_copy_to_clipboard();
});
}
__name(render_btn_copy_context, "render_btn_copy_context");
function render_btn_clear_context(ctx, container) {
const clear_btn = document.createElement("button");
clear_btn.type = "button";
clear_btn.className = "sc-clear-context-btn";
clear_btn.textContent = "Clear";
if (!ctx.has_context_items) {
clear_btn.style.display = "none";
}
container.appendChild(clear_btn);
clear_btn.addEventListener("click", () => {
ctx.clear_all();
ctx.emit_event("context:cleared");
});
}
__name(render_btn_clear_context, "render_btn_clear_context");
function render_btn_help(ctx, container) {
const help_btn = document.createElement("button");
help_btn.type = "button";
help_btn.className = "sc-help-btn";
help_btn.setAttribute("aria-label", "Learn more");
container.appendChild(help_btn);
(0, import_obsidian24.setIcon)(help_btn, "help-circle");
help_btn.addEventListener("click", () => {
window.open("https://smartconnections.app/smart-context/builder/?utm_source=context-selector-modal", "_external");
ctx.emit_event("context_selector:help");
});
}
__name(render_btn_help, "render_btn_help");

var styles_default = "/* Modal view adjustments */\r\n.modal-container .sc-context-view {\r\n  max-height: 60%;\r\n  display: flex;\r\n  flex-direction: column;\r\n  .sc-context-view-body {\r\n    overflow: auto;\r\n  }\r\n  .sc-add-context-btn {\r\n    display: none;\r\n  }\r\n  .sc-context-view-header {\r\n    padding: var(--size-4-2);\r\n  }\r\n  .sc-context-actions {\r\n    display: flex;\r\n    justify-content: space-between;\r\n  }\r\n  .sc-context-actions-right {\r\n    display: flex;\r\n    gap: var(--size-4-2);\r\n  }\r\n\r\n  .sc-context-view-body {\r\n    padding: var(--size-4-2);\r\n  }\r\n\r\n  .sc-context-view-footer {\r\n    padding: var(--size-4-2);\r\n  }\r\n\r\n}\r\n\r\n/* make hover popover work in builder modal */\r\n.hover-popover {\r\n  z-index: 100;\r\n}\r\n";

var import_obsidian25 = require("obsidian");
async function copy_to_clipboard2(text) {
try {
if (navigator?.clipboard?.writeText) {
await navigator.clipboard.writeText(text);
} else if (!import_obsidian25.Platform.isMobile) {
const { clipboard } = require("electron");
clipboard.writeText(text);
} else {
new import_obsidian25.Notice("Unable to copy text: no valid method found.");
}
} catch (err) {
console.error("Failed to copy text:", err);
new import_obsidian25.Notice("Failed to copy.");
}
}
__name(copy_to_clipboard2, "copy_to_clipboard");

var schedule_next_frame = /* @__PURE__ */ __name((callback) => {
if (typeof requestAnimationFrame === "function") {
requestAnimationFrame(callback);
return;
}
setTimeout(callback, 0);
}, "schedule_next_frame");
var create_render_scheduler = /* @__PURE__ */ __name((render_fn) => {
let render_pending = false;
return () => {
if (render_pending) return;
render_pending = true;
schedule_next_frame(async () => {
render_pending = false;
await render_fn();
});
};
}, "create_render_scheduler");
function build_html19(ctx, opts = {}) {
return `<div>
<div class="sc-context-view" data-context-key="${ctx.data.key}">
<div class="sc-context-view-header">
<div class="sc-context-actions"></div>
</div>
<div class="sc-context-view-body">
<div class="sc-context-tree"></div>
</div>
<div class="sc-context-view-footer">
<div class="sc-context-meta"></div>
</div>
</div>
</div>`;
}
__name(build_html19, "build_html");
async function render19(ctx, opts = {}) {
const html = build_html19(ctx, opts);
this.apply_style_sheet(styles_default);
const frag = this.create_doc_fragment(html);
const container = frag.querySelector(".sc-context-view");
post_process18.call(this, ctx, container, opts);
return container;
}
__name(render19, "render");
async function post_process18(ctx, container, opts = {}) {
const disposers = [];
const render_children = /* @__PURE__ */ __name(async () => {
const header = container.querySelector(".sc-context-view-header");
ctx.env.smart_components.render_component("smart_context_actions", ctx, opts).then((actions) => {
this.empty(header);
header.appendChild(actions);
});
const body = container.querySelector(".sc-context-view-body");
ctx.env.smart_components.render_component("smart_context_tree", ctx, opts).then((tree) => {
this.empty(body);
body.appendChild(tree);
});
const footer = container.querySelector(".sc-context-view-footer");
ctx.env.smart_components.render_component("smart_context_meta", ctx, opts).then((meta) => {
this.empty(footer);
footer.appendChild(meta);
});
}, "render_children");
const schedule_render_children = create_render_scheduler(render_children);
const plugin = ctx.env.plugin;
const app = plugin?.app || window.app;
const register = plugin?.registerDomEvent?.bind(plugin) || ((el, evt, cb) => el.addEventListener(evt, cb));
register(container, "contextmenu", (ev) => {
ev.preventDefault();
ev.stopPropagation();
if (!app) return;
const menu = new Menu(app);
menu.addItem(
(mi) => mi.setTitle("Copy link tree").setIcon("copy").onClick(async () => {
const md = tree_dom_to_wikilinks(container);
await copy_to_clipboard2(md);
})
);
menu.showAtMouseEvent(ev);
});
await render_children();
disposers.push(ctx.on_event("context:updated", schedule_render_children));
this.attach_disposer(container, disposers);
return container;
}
__name(post_process18, "post_process");
function tree_dom_to_wikilinks(container) {
const lines = [];
const walk = /* @__PURE__ */ __name((li, depth) => {
const path = li.dataset.path;
if (!path) return;
let rel = path.replace(/^external:/, "").replace(/^selection:/, "");
const label = li.querySelector(":scope > .sc-tree-label")?.textContent?.trim() || "";
if (li.classList.contains("file")) {
let file = rel.split("/").pop().replace(/\.md$/, "");
lines.push(`${"	".repeat(depth)}- [[${file}]]`);
} else if (li.classList.contains("dir")) {
lines.push(`${"	".repeat(depth)}- ${label}`);
}
li.querySelectorAll(":scope > ul > li").forEach((child) => walk(child, depth + 1));
}, "walk");
container.querySelectorAll(":scope > ul > li").forEach((li) => walk(li, 0));
return lines.join("\n");
}
__name(tree_dom_to_wikilinks, "tree_dom_to_wikilinks");

function estimate_tokens(char_count) {
return Math.ceil((char_count || 0) / 4);
}
__name(estimate_tokens, "estimate_tokens");
function build_html20() {
return `
<div class="sc-context-meta" aria-live="polite"></div>
`;
}
__name(build_html20, "build_html");
async function render20(ctx, params = {}) {
const html = build_html20();
const frag = this.create_doc_fragment(html);
const container = frag.firstElementChild;
post_process19.call(this, ctx, container, params);
return container;
}
__name(render20, "render");
async function post_process19(ctx, container, params = {}) {
const render_meta = /* @__PURE__ */ __name(() => {
if (ctx?.has_context_items) {
const chars = ctx.size || 0;
const tokens = estimate_tokens(chars);
container.textContent = `\u2248 ${chars.toLocaleString()} chars \xB7 ${tokens.toLocaleString()} tokens`;
} else {
container.textContent = "No context items selected";
}
}, "render_meta");
render_meta();
const disposers = [];
disposers.push(ctx.on_event("context:updated", render_meta));
this.attach_disposer(container, disposers);
return container;
}
__name(post_process19, "post_process");

function build_tree_item(item, selected_paths, child_html = "") {
let { key, path, name, is_file } = item;
const has_children = child_html.trim() !== "";
let remove_btn = "";
let connections_btn = "";
let links_btn = "";
if (!key) key = path;
if (selected_paths.has(key) || has_children) {
remove_btn = `<span class="sc-context-item-remove" data-path="${key}">\xD7</span>`;
}
if (selected_paths.has(key) && !key.startsWith("external:../")) {
connections_btn = `<span class="sc-tree-connections" data-path="${key}" title="Connections for ${name}"></span>`;
links_btn = `<span class="sc-tree-links" data-path="${key}" title="Links for ${name}"></span>`;
}
const label_classes = ["sc-tree-label"];
if (item.exists === false) label_classes.push("missing");
return `<li data-path="${key}" class="sc-tree-item ${is_file ? "file" : "dir"}${key.startsWith("external:") ? " sc-external" : ""}">
${remove_btn}
<span class="${label_classes.join(" ")}">${name}</span>
${connections_btn}
${links_btn}
${child_html}
</li>`;
}
__name(build_tree_item, "build_tree_item");

function build_tree_html(items) {
const tree_root = build_path_tree(items);
const selected_set = new Set(items.map((it) => it.key || it.path));
const tree_list_html = tree_to_html(tree_root, selected_set);
return tree_list_html;
}
__name(build_tree_html, "build_tree_html");
function build_path_tree(selected_items = []) {
const get_item_key = /* @__PURE__ */ __name((item) => item?.key || item?.path || "", "get_item_key");
const split_path_segments = /* @__PURE__ */ __name((item_path) => {
const BLOCK_ID_RE = /#\{\d+\}$/u;
let remainder = item_path;
let block_id_seg = null;
let block_key_seg = null;
let has_block = false;
const id_match = remainder.match(BLOCK_ID_RE);
if (id_match) {
block_id_seg = id_match[0];
remainder = remainder.slice(0, -block_id_seg.length);
has_block = true;
}
const key_idx = remainder.indexOf("##");
if (key_idx !== -1) {
block_key_seg = remainder.slice(key_idx);
remainder = remainder.slice(0, key_idx);
has_block = true;
}
const segments = [];
if (remainder) {
let seg = "";
let in_wikilink = false;
for (let i = 0; i < remainder.length; i++) {
if (!in_wikilink && remainder.slice(i, i + 2) === "[[") {
in_wikilink = true;
seg += "[[";
i++;
} else if (in_wikilink && remainder.slice(i, i + 2) === "]]") {
in_wikilink = false;
seg += "]]";
i++;
} else if (!in_wikilink && remainder[i] === "/") {
segments.push(seg);
seg = "";
} else {
seg += remainder[i];
}
}
if (seg) segments.push(seg);
}
if (block_key_seg) segments.push(block_key_seg);
if (block_id_seg) segments.push(block_id_seg);
return { segments, has_block };
}, "split_path_segments");
const root = { name: "", children: {}, selected: false };
const is_redundant = /* @__PURE__ */ __name((p, selected_folders2) => selected_folders2.some((folder) => p.startsWith(`${folder}/`)), "is_redundant");
const selected_folders = selected_items.filter((it) => {
const item_key = get_item_key(it);
if (!item_key) return false;
const for_ext_check = item_key.includes("#") ? item_key.split("#")[0] : item_key;
return !for_ext_check.match(/\.[a-zA-Z0-9]+$/u);
}).map((it) => get_item_key(it)).filter(Boolean);
for (const item of selected_items) {
const item_key = get_item_key(item);
const exists = item?.exists;
if (!item_key) continue;
if (is_redundant(item_key, selected_folders.filter((p) => p !== item_key))) continue;
const { segments, has_block } = split_path_segments(item_key);
let node = root;
let running = "";
segments.forEach((seg, idx) => {
running = running ? `${running}/${seg}` : seg;
if (seg.startsWith("external:..")) return;
const is_last = idx === segments.length - 1;
const is_block_leaf = is_last && has_block;
if (!node.children[seg]) {
node.children[seg] = {
name: seg,
path: is_block_leaf ? item_key : running,
children: is_block_leaf ? [] : {},
selected: false,
is_file: is_block_leaf || is_last && seg.includes(".")
};
}
node = node.children[seg];
if (is_last) {
node.selected = true;
node.exists = exists;
}
});
}
return root;
}
__name(build_path_tree, "build_path_tree");
function tree_to_html(node, selected_paths) {
if (!node.children || !Object.keys(node.children).length) return "";
const child_html = Object.values(node.children).sort((a, b) => {
if (a.is_file !== b.is_file) return a.is_file ? 1 : -1;
return a.name.localeCompare(b.name);
}).map((child) => build_tree_item(child, selected_paths, tree_to_html(child, selected_paths))).join("");
return `<ul>${child_html}</ul>`;
}
__name(tree_to_html, "tree_to_html");

var tree_default = ".sc-context-tree {\r\n  ul {\r\n    padding-inline-start: 1.7rem;\r\n  }\r\n  li:has(> .sc-context-item-leaf > .sc-context-item-remove) {\r\n    list-style-type: none;\r\n  }\r\n  .sc-context-item-remove:hover {\r\n    font-weight: bold;\r\n    filter: brightness(1.8);\r\n  }\r\n  .sc-context-item-remove {\r\n    padding: 0 0.2rem;\r\n    margin-left: -1.4rem;\r\n  }\r\n}\r\n.sc-context-item-leaf, .sc-context-item-remove {\r\n  cursor: pointer;\r\n}\r\n.sc-context-item-score,\r\n.sc-context-item-size {\r\n  display: inline-block;\r\n  min-width: 4.5ch;\r\n  height: 1.7em;\r\n  line-height: 1.7em;\r\n  text-align: center;\r\n  font-weight: 600 !important;\r\n  font-size: 0.8em !important;\r\n  color: var(--nav-item-color) !important;\r\n  background: var(--background-modifier-hover);\r\n  border-radius: 6px;\r\n  padding: 0 0.4em;\r\n  margin-right: 0.35em;\r\n}\r\n.sc-context-item-size {\r\n  min-width: 0;\r\n}";

var is_nested_context_item = /* @__PURE__ */ __name((item_key, target_path) => {
if (!item_key || !target_path) return false;
if (item_key === target_path) return true;
if (item_key.startsWith(`${target_path}/`)) return true;
return item_key.startsWith(`${target_path}#`);
}, "is_nested_context_item");
function get_nested_context_item_keys(ctx, params = {}) {
const { target_path } = params;
if (!target_path) return [];
const context_item_keys = Object.keys(ctx?.data?.context_items || {});
const nested_keys = context_item_keys.filter((item_key) => is_nested_context_item(item_key, target_path));
return [...new Set(nested_keys)];
}
__name(get_nested_context_item_keys, "get_nested_context_item_keys");

var schedule_next_frame2 = /* @__PURE__ */ __name((callback) => {
if (typeof requestAnimationFrame === "function") {
requestAnimationFrame(callback);
return;
}
setTimeout(callback, 0);
}, "schedule_next_frame");
var create_render_scheduler2 = /* @__PURE__ */ __name((render_fn) => {
let render_pending = false;
return () => {
if (render_pending) return;
render_pending = true;
schedule_next_frame2(() => {
render_pending = false;
render_fn();
});
};
}, "create_render_scheduler");
var remove_nested_context_items = /* @__PURE__ */ __name((ctx, params = {}) => {
const { target_path } = params;
const nested_keys = get_nested_context_item_keys(ctx, { target_path });
ctx.remove_items(nested_keys);
}, "remove_nested_context_items");
function build_html21(ctx, params = {}) {
return `
<div class="sc-context-tree" data-context-key="${ctx.data.key}"></div>
`;
}
__name(build_html21, "build_html");
async function render21(ctx, params = {}) {
this.apply_style_sheet(tree_default);
const html = build_html21(ctx, params);
const frag = this.create_doc_fragment(html);
const container = frag.firstElementChild;
post_process20.call(this, ctx, container, params);
return container;
}
__name(render21, "render");
async function post_process20(ctx, container, params = {}) {
const plugin = ctx?.env?.plugin;
const register_dom_event = plugin?.registerDomEvent?.bind(plugin) || ((el, evt, cb) => el.addEventListener(evt, cb));
const render_tree_leaves = /* @__PURE__ */ __name(() => {
const env = ctx.env;
const items = ctx.context_items.filter(params.filter);
const list_html = build_tree_html(items);
const list_frag = this.create_doc_fragment(list_html);
this.empty(container);
container.appendChild(list_frag);
for (let i = 0; i < items.length; i++) {
const item = items[i];
const li = container.querySelector(`.sc-tree-item[data-path="${item.key}"]`);
if (!li) {
console.warn(`Smart Context: Could not find tree item for path: ${item.key}`);
continue;
}
env.smart_components.render_component("context_item_leaf", item).then((leaf) => {
this.empty(li);
li.appendChild(leaf);
});
}
}, "render_tree_leaves");
const schedule_render_tree_leaves = create_render_scheduler2(render_tree_leaves);
render_tree_leaves();
register_dom_event(container, "click", (event) => {
const target = event.target.closest(".sc-context-item-remove");
if (!target) return;
event.preventDefault();
event.stopPropagation();
const target_path = target.getAttribute("data-path");
remove_nested_context_items(ctx, { target_path });
});
const disposers = [];
disposers.push(ctx.on_event("context:updated", schedule_render_tree_leaves));
this.attach_disposer(container, disposers);
return container;
}
__name(post_process20, "post_process");

var source_inspector_default = ".source-inspector {\r\n  background-color: var(--background-secondary-alt);\r\n  margin: var(--size-4-3) 0;\r\n  padding: var(--size-4-3);\r\n  border-radius: var(--radius-m);\r\n}\r\n\r\n.source-inspector-blocks-container {\r\n  margin-top: var(--size-4-2);\r\n  display: flex;\r\n  flex-direction: column;\r\n  gap: var(--size-4-3);\r\n}\r\n\r\n.source-inspector-blocks-container blockquote {\r\n  margin-left: var(--size-4-3);\r\n  padding-left: var(--size-4-3);\r\n  border-left: 2px solid var(--text-faint);\r\n}\r\n";

function build_html22(source, opts = {}) {
return `<div>
<div class="source-inspector-source-info">
<button class="source-inspector-show-data-btn" type="button">Show source data</button>
<div class="source-inspector-source-data" style="display:none; margin: 0.5em 0;">
<pre style="max-height:300px; overflow:auto; background:#222; color:#fff; padding:0.5em; border-radius:4px;"></pre>
</div>
</div>
<div class="smart-chat-message source-inspector">
<h2>Blocks</h2>
<div class="source-inspector-blocks-container"></div>
</div>
</div>`;
}
__name(build_html22, "build_html");
async function render22(source, opts = {}) {
const html = build_html22(source, opts);
const frag = this.create_doc_fragment(html);
this.apply_style_sheet(source_inspector_default);
await post_process21.call(this, source, frag, opts);
return frag;
}
__name(render22, "render");
async function post_process21(source, frag, opts = {}) {
const container = frag.querySelector(".source-inspector .source-inspector-blocks-container");
if (!container) return frag;
const source_info = frag.querySelector(".source-inspector-source-info");
const btn = frag.querySelector(".source-inspector-show-data-btn");
const data_div = frag.querySelector(".source-inspector-source-data");
const pre = data_div?.querySelector("pre");
if (btn && data_div && pre) {
btn.addEventListener("click", () => {
if (data_div.style.display === "none") {
pre.textContent = JSON.stringify(source.data, null, 2);
data_div.style.display = "";
btn.textContent = "Hide source data";
} else {
data_div.style.display = "none";
btn.textContent = "Show source data";
}
});
}
const source_should_embed = source.should_embed ? `<span style="color: green;">should embed</span>` : `<span style="color: orange;">embedding skipped</span>`;
const source_embed_status = source.vec ? `<span style="color: green;">vectorized</span>` : `<span style="color: orange;">not vectorized</span>`;
const source_info_frag = this.create_doc_fragment(`<p>${source_should_embed} | ${source_embed_status}</p>`);
source_info.appendChild(source_info_frag);
if (!source || !source.blocks || source.blocks.length === 0) {
this.safe_inner_html(container, `<p>No blocks</p>`);
return frag;
}
const sorted_blocks = source.blocks.sort((a, b) => a.line_start - b.line_start);
for (const block of sorted_blocks) {
const sub_key_display = block.sub_key.split("#").join(" > ");
const block_info = `${sub_key_display} (${block.size} chars; lines: ${block.line_start}-${block.line_end})`;
const should_embed = block.should_embed ? `<span style="color: green;">should embed</span>` : `<span style="color: orange;">embedding skipped</span>`;
const embed_status = block.vec ? `<span style="color: green;">vectorized</span>` : `<span style="color: orange;">not vectorized</span>`;
let block_content = "";
let embed_input = "";
try {
const raw = await block.read();
block_content = raw.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\n/g, "<br>").replace(/\t/g, "&nbsp;&nbsp;");
const embed_raw = await block.get_embed_input(raw);
embed_input = embed_raw.replace(/</g, "&lt;").replace(/>/g, "&gt;");
} catch (err) {
console.error("[source_inspector] Error reading block:", err);
block_content = `<em style="color:red;">Error reading block content</em>`;
}
const block_frag = this.create_doc_fragment(`
<p>
${block_info}<br>
${should_embed} | ${embed_status}
</p>
<details class="source-inspector-embed-input">
<summary>Embed input</summary>
<pre style="max-height:300px; overflow:auto; background:#222; color:#fff; padding:0.5em; border-radius:4px;">${embed_input}</pre>
</details>
<blockquote>${block_content}</blockquote>
<hr>
`);
container.appendChild(block_frag);
}
return frag;
}
__name(post_process21, "post_process");

var import_obsidian29 = require("obsidian");

var import_obsidian28 = require("obsidian");

var import_obsidian26 = require("obsidian");
var SmartNoteInspectModal = class extends import_obsidian26.Modal {
static {
__name(this, "SmartNoteInspectModal");
}
constructor(smart_connections_plugin, entity) {
super(smart_connections_plugin.app);
this.smart_connections_plugin = smart_connections_plugin;
this.entity = entity;
}
get env() {
return this.smart_connections_plugin.env;
}
onOpen() {
this.titleEl.innerText = this.entity.key;
this.render();
}
async render() {
this.contentEl.empty();
const frag = await this.env.render_component("source_inspector", this.entity);
this.contentEl.appendChild(frag);
}
};

var import_obsidian27 = require("obsidian");
var EnvStatsModal = class extends import_obsidian27.Modal {
static {
__name(this, "EnvStatsModal");
}
constructor(app, env) {
super(app);
this.env = env;
}
onOpen() {
this.titleEl.setText("Smart Environment");
this.contentEl.empty();
this.contentEl.createEl("p", { text: "Loading stats..." });
setTimeout(this.render.bind(this), 100);
}
async render() {
const frag = await this.env.render_component("env_stats", this.env);
this.contentEl.empty();
if (frag) {
this.contentEl.appendChild(frag);
} else {
this.contentEl.createEl("p", { text: "Failed to load stats." });
}
}
};

function register_status_bar_context_menu(env, status_container, deps = {}) {
const { Menu: MenuClass = import_obsidian28.Menu } = deps;
const plugin = env.main;
const on_context_menu = /* @__PURE__ */ __name((ev) => {
ev.preventDefault();
ev.stopPropagation();
const menu = new MenuClass(plugin.app);
menu.addItem(
(item) => item.setTitle("Inspect active note").setIcon("search").onClick(async () => {
const active_file = plugin.app.workspace.getActiveFile();
if (!active_file) {
new import_obsidian28.Notice("No active note found");
return;
}
const src = env.smart_sources?.get(active_file.path);
if (!src) {
new import_obsidian28.Notice("Active note is not indexed by Smart Environment");
return;
}
new SmartNoteInspectModal(plugin, src).open();
})
);
menu.addItem(
(item) => item.setTitle("Show stats").setIcon("chart-pie").onClick(() => {
const modal = new EnvStatsModal(plugin.app, env);
modal.open();
})
);
menu.addItem(
(item) => item.setTitle("Export data").setIcon("download").onClick(() => {
env.export_json();
new import_obsidian28.Notice("Smart Env exported");
})
);
menu.addItem(
(item) => item.setTitle("Milestones").setIcon("flag").onClick(() => {
env.open_milestones_modal();
})
);
menu.addItem(
(item) => item.setTitle("Notifications").setIcon("bell").onClick(() => {
env.open_notifications_feed_modal();
})
);
menu.addSeparator();
menu.addItem(
(item) => item.setTitle("Learn about Community Supporters").setIcon("hand-heart").onClick(() => {
const url = "https://smartconnections.app/community-supporters/?utm_source=status-bar";
window.open(url, "_external");
})
);
menu.showAtPosition({ x: ev.pageX, y: ev.pageY });
}, "on_context_menu");
plugin.registerDomEvent(status_container, "contextmenu", on_context_menu);
return on_context_menu;
}
__name(register_status_bar_context_menu, "register_status_bar_context_menu");

var status_bar_default = ".status-bar-item:has(.smart-env-status-container) {\n  padding: 0 0.5em;\n\n  &:hover {\n    background-color: var(--background-modifier-hover);\n  }\n  &> .smart-env-status-container {\n    display: flex;\n    align-items: center;\n    gap: 0.5em;\n    text-decoration: none;\n    color: var(--status-bar-text-color);\n  }\n}\n\n.smart-env-status-indicator {\n  width: 0.6em;\n  height: 0.6em;\n  border-radius: 999px;\n  background-color: var(--interactive-accent);\n  opacity: 0;\n  transform: scale(0.3);\n  transition: opacity 150ms ease, transform 150ms ease;\n}\n.smart-env-status-indicator[data-level='info'] {\n  background-color: var(--interactive-accent);\n}\n.smart-env-status-indicator[data-level='attention'] {\n  background-color: var(--color-yellow);\n}\n.smart-env-status-indicator[data-level='warning'] {\n  background-color: var(--color-orange);\n}\n.smart-env-status-indicator[data-level='error'] {\n  background-color: var(--color-red);\n}\n\n.smart-env-status-indicator[data-count] {\n  opacity: 1;\n  transform: scale(1);\n}\n\n.smart-env-notifications-feed {\n  display: flex;\n  flex-direction: column;\n  padding: 0.5rem 0;\n  gap: 0.42rem;\n}\n\n.smart-env-notifications-empty {\n  margin: 0;\n  color: var(--text-muted);\n}\n\n.smart-env-notification {\n  font-size: var(--font-smaller);\n  display: flex;\n  flex-direction: column;\n  border-left: 3px solid var(--interactive-accent);\n  padding-left: 0.75rem;\n}\n\n.smart-env-notification[data-level='attention'] {\n  border-color: var(--color-yellow);\n}\n\n.smart-env-notification[data-level='warning'] {\n  border-color: var(--color-orange);\n}\n\n.smart-env-notification[data-level='error'] {\n  border-color: var(--color-red);\n}\n\n.smart-env-notification__message {\n  margin: 0;\n  font-weight: 500;\n  white-space: pre-wrap;\n}\n\n.smart-env-notification__meta {\n  color: var(--text-muted);\n  padding: 0.37rem 0;\n}\n\n.status-bar-mobile {\n  position: var(--status-bar-position);\n  bottom: 0;\n  border-radius: 0 8px 0 0;\n  border-style: solid;\n  border-width: 1px;\n  border-color: var(--status-bar-border-color);\n  background-color: var(--status-bar-background);\n  color: var(--status-bar-text-color);\n  font-size: var(--status-bar-font-size);\n  min-height: 18px;\n  padding: var(--size-4-1);\n  user-select: none;\n  z-index: var(--layer-status-bar);\n  font-variant-numeric: tabular-nums;\n  &> .smart-env-status-container {\n    padding: 5px 5px 5px 0;\n  }\n}\n\n/* footer view on mobile */\n.embedded-backlinks > .status-bar-mobile {\n  position: relative;\n  border-style: none;\n}";

function build_html23() {
return `
<a
class="smart-env-status-container"
role="button"
title="Smart Environment status"
aria-label="Smart Environment status"
tabindex="0"
>
<span class="smart-env-status-icon" aria-hidden="true"></span>
<span class="smart-env-status-msg" aria-live="polite"></span>
<span
class="smart-env-status-indicator"
title="Open notifications"
aria-label="Open notifications feed"
role="button"
tabindex="0"
></span>
</a>
`;
}
__name(build_html23, "build_html");
async function render23(env, opts = {}) {
this.apply_style_sheet(status_bar_default);
const frag = this.create_doc_fragment(build_html23());
const anchor = frag.firstElementChild;
post_process22.call(this, env, anchor, opts);
return anchor;
}
__name(render23, "render");
function post_process22(env, container, opts = {}) {
const icon_slot = container?.querySelector?.(".smart-env-status-icon");
const status_indicator = container?.querySelector?.(".smart-env-status-indicator");
const status_msg = container?.querySelector?.(".smart-env-status-msg");
const version2 = env.is_pro ? "Pro" : env.constructor?.version;
const get_session_event_count = /* @__PURE__ */ __name(() => {
return env.event_logs?.session_events?.length || 0;
}, "get_session_event_count");
const get_embed_queue = /* @__PURE__ */ __name(() => {
return Object.keys(env.smart_sources.sources_re_import_queue || {}).length;
}, "get_embed_queue");
const render_status_elm = /* @__PURE__ */ __name(() => {
const embed_queue = get_embed_queue();
let message = `Smart Env${version2 ? " " + version2 : ""}`;
let title = "Smart Environment status";
let indicator_count = get_session_event_count();
let indicator_level = env.event_logs?.notification_status || "info";
if (embed_queue > 0) {
message = `Embed now (${embed_queue})`;
title = "Click to re-import.";
indicator_level = "attention";
}
if (icon_slot) {
(0, import_obsidian29.setIcon)(icon_slot, "smart-connections");
}
if (status_indicator) {
if (!status_indicator._click_handler) {
status_indicator._click_handler = (event) => {
event.stopPropagation();
env.open_notifications_feed_modal?.();
};
status_indicator.addEventListener("click", status_indicator._click_handler);
}
if (indicator_count > 0) {
status_indicator.dataset.count = String(indicator_count);
} else {
delete status_indicator.dataset.count;
}
if (indicator_level) {
status_indicator.dataset.level = String(indicator_level);
} else {
delete status_indicator.dataset.level;
}
}
status_msg.setText?.(message);
container.setAttribute?.("title", title);
container.removeAttribute?.("href");
container.removeAttribute?.("target");
if (!container._click_handler) {
container._click_handler = (event) => {
const curr_embed_queue = get_embed_queue();
if (curr_embed_queue > 0) {
event.preventDefault();
event.stopPropagation();
status_msg?.setText?.("Embedding...");
env.run_re_import?.();
} else {
const context_event = new MouseEvent("contextmenu", event);
container.dispatchEvent?.(context_event);
}
};
container.addEventListener("click", container._click_handler);
}
}, "render_status_elm");
register_status_bar_context_menu(env, container);
render_status_elm();
let debounce_timeout = null;
const debounce_refresh_status_bar = /* @__PURE__ */ __name(() => {
if (debounce_timeout) clearTimeout(debounce_timeout);
debounce_timeout = setTimeout(() => {
render_status_elm();
debounce_timeout = null;
}, 100);
}, "debounce_refresh_status_bar");
const disposers = [];
disposers.push(env.events.on("*", debounce_refresh_status_bar));
this.attach_disposer(container, disposers);
}
__name(post_process22, "post_process");

var import_obsidian30 = require("obsidian");
function build_html24(plugin, opts = {}) {
const { plugin_name = plugin.manifest.name } = opts;
return `<div class="wrapper">
<div id="footer-callout" data-callout-metadata="" data-callout-fold="" data-callout="info" class="callout" style="mix-blend-mode: unset;">
<div class="callout-title" style="align-items: center;">
<div class="callout-icon">
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-info">
<circle cx="12" cy="12" r="10"></circle>
<path d="M12 16v-4"></path>
<path d="M12 8h.01"></path>
</svg>
</div>
<div class="callout-title-inner"><strong>Become a Supporter</strong></div>
</div>
<div class="callout-content">
<p>Try early &amp; experimental features:
<ul>
<li><b>Smart Connections Early Release:</b>
<ul>
<li>Inline block connections</li>
<li>Footer connections view</li>
<li>Connections re-ranking</li>
</ul>
</li>
<li><b>Smart Context Early Release:</b>
<ul>
<li>Named contexts</li>
<li>External sources: include code from external repositories</li>
<li>Context codeblocks: embed context in notes ("My most valuable workflow" - \u{1F334} Brian)</li>
</ul>
</li>
<li><b>Smart Editor:</b>
<ul>
<li>Generate &amp; review changes</li>
</ul>
</li>
<li><em>Be the first to know what's coming next!</em></li>
</ul>
</p>
<p>Access the Supporter Community Campfire Chat:
<ul>
<li>Supporter-only private discussions</li>
<li>Share workflows</li>
<li>Get priority help &amp; support</li>
</ul>
</p>
<p>Guaranteed seat in the Community Lean Coffee meetings.</p>
<p><i>Your support shapes the future of ${plugin_name}.</i></p>
<p>
<strong>Fuel the circle of empowerment.</strong> <a href="https://smartconnections.app/community-supporters?utm_source=obsidian-${plugin_name.replace(/[^a-zA-Z0-9]/g, "-").toLowerCase()}" class="button" target="_external">Become a Supporter</a>
</p>
</div>
</div>
</div>`;
}
__name(build_html24, "build_html");
function render24(plugin, opts = {}) {
const html = build_html24.call(this, plugin, opts);
const frag = this.create_doc_fragment(html);
const container = frag.querySelector(".wrapper");
post_process23.call(this, plugin, container, opts);
return container;
}
__name(render24, "render");
async function post_process23(plugin, container) {
const icon_container = container.querySelector(".callout-icon");
const icon = (0, import_obsidian30.getIcon)("hand-heart");
if (icon) {
this.empty(icon_container);
icon_container.appendChild(icon);
}
const oauth_storage_prefix = plugin.app.vault.getName().toLowerCase().replace(/[^a-z0-9]/g, "_") + "_smart_plugins_oauth_";
const is_logged_in = !!localStorage.getItem(oauth_storage_prefix + "token");
if (is_logged_in) container.querySelector("#footer-callout").style.display = "none";
await this.render_setting_components(container, { scope: plugin.env });
}
__name(post_process23, "post_process");

var import_obsidian31 = require("obsidian");
function build_html25(plugin, opts = {}) {
const { plugin_name = plugin.manifest.name } = opts;
return `<div class="wrapper">
<div id="footer-callout" data-callout-metadata="" data-callout-fold="" data-callout="info" class="callout" style="mix-blend-mode: unset;">
<div class="callout-title" style="align-items: center;">
<div class="callout-icon">
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-info">
<circle cx="12" cy="12" r="10"></circle>
<path d="M12 16v-4"></path>
<path d="M12 8h.01"></path>
</svg>
</div>
<div class="callout-title-inner"><strong>User Agreement</strong></div>
</div>
<div class="callout-content">
<p>By using ${plugin_name} you agree to share how it helps you with at least one other person \u{1F60A}\u{1F334}</p>
</div>
</div>
</div>`;
}
__name(build_html25, "build_html");
function render25(plugin, opts = {}) {
const html = build_html25.call(this, plugin, opts);
const frag = this.create_doc_fragment(html);
const callout = frag.querySelector("#footer-callout");
const icon_container = callout.querySelector(".callout-icon");
const icon = (0, import_obsidian31.getIcon)("smart-connections");
if (icon) {
this.empty(icon_container);
icon_container.appendChild(icon);
}
post_process24.call(this, plugin, callout, opts);
return callout;
}
__name(render25, "render");
function post_process24(plugin, callout) {
}
__name(post_process24, "post_process");

var import_obsidian32 = require("obsidian");
async function copy_to_clipboard3(params = {}) {
const context_items = this.context_items.filter(params.filter);
if (!context_items.length) {
this.emit_event("notification:warning", { message: "No context items to copy." });
return new import_obsidian32.Notice("No context items to copy.");
}
const content = await this.get_text(params);
await copy_to_clipboard2(content);
const message = format_stats_message({
item_count: context_items.length,
char_count: content.length,
max_depth: params.max_depth,
exclusions: params.exclusions
});
this.emit_event("context:copied");
new import_obsidian32.Notice(message);
}
__name(copy_to_clipboard3, "copy_to_clipboard");
function format_stats_message(stats = {}) {
const item_count = Number.isFinite(stats.item_count) ? stats.item_count : 0;
const char_count = Number.isFinite(stats.char_count) ? stats.char_count : 0;
const segments = [];
segments.push(`${item_count} file(s)`);
segments.push(`${format_char_count(char_count)} chars`);
if (Number.isFinite(stats.max_depth)) {
segments.push(`depth\u2264${stats.max_depth}`);
}
const excluded_total = sum_exclusions(stats.exclusions);
if (excluded_total > 0) {
segments.push(`${excluded_total} section(s) excluded`);
}
return `Copied to clipboard! (${segments.join(", ")})`;
}
__name(format_stats_message, "format_stats_message");
function format_char_count(char_count) {
if (!Number.isFinite(char_count)) return "0";
if (char_count >= 1e5) {
return `~${Math.round(char_count / 1e3)}k`;
}
return char_count.toLocaleString();
}
__name(format_char_count, "format_char_count");
function sum_exclusions(exclusions) {
if (!exclusions) return 0;
return Object.values(exclusions).reduce((total, value) => {
const numeric = Number.isFinite(value) ? value : 0;
return total + numeric;
}, 0);
}
__name(sum_exclusions, "sum_exclusions");

var DEFAULT_TEMPLATE_PRESET = "xml_structured";
var template_presets = {
xml_structured: {
label: "XML-style (default)",
context_template_before: "<context>\n{{FILE_TREE}}",
context_template_after: "</context>",
item_template_before: '<item loc="{{KEY}}" at="{{TIME_AGO}}" depth="{{LINK_DEPTH}}">',
item_template_after: "</item>"
},
markdown_headings: {
label: "Markdown headings",
context_template_before: "{{FILE_TREE}}",
context_template_after: "",
item_template_before: [
"## {{KEY}}",
"Updated: {{TIME_AGO}} | Depth: {{LINK_DEPTH}}",
"````{{EXT}}"
].join("\n"),
item_template_after: "````\n"
},
json_structured: {
label: "JSON structured",
context_template_before: '{\n  "context": {',
context_template_after: "  }\n}",
item_template_before: '    "{{KEY}}": { "name": "{{ITEM_NAME}}", "updated": "{{TIME_AGO}}", "depth": {{LINK_DEPTH}}, "content": ',
item_template_after: "    },",
json_stringify: true
},
custom: {
label: "Custom (PRO)"
}
};
var get_preset_key = /* @__PURE__ */ __name((settings = {}) => {
const preset_key = settings.template_preset || DEFAULT_TEMPLATE_PRESET;
if (template_presets[preset_key]) return preset_key;
return "custom";
}, "get_preset_key");
var get_template_value = /* @__PURE__ */ __name((settings, defaults, preset_field_key, settings_field_key) => {
const preset_key = get_preset_key(settings);
const preset = template_presets[preset_key];
const value_from_settings = settings?.[settings_field_key];
if (preset_key !== "custom" && preset && typeof preset[preset_field_key] === "string") {
return preset[preset_field_key];
}
if (preset_key === "custom" && typeof value_from_settings === "string") {
return value_from_settings;
}
return defaults?.[settings_field_key];
}, "get_template_value");
function get_template_preset_options() {
return Object.entries(template_presets).map(([value, config]) => ({
value,
label: config.label || value
}));
}
__name(get_template_preset_options, "get_template_preset_options");
function get_context_templates(settings = {}, defaults = {}) {
return {
template_before: get_template_value(settings, defaults, "context_template_before", "template_before"),
template_after: get_template_value(settings, defaults, "context_template_after", "template_after")
};
}
__name(get_context_templates, "get_context_templates");
function get_item_templates(settings = {}, defaults = {}) {
const preset_key = get_preset_key(settings);
const preset = template_presets[preset_key];
const include_json_stringify = preset_key === "custom" && typeof settings.json_stringify === "boolean";
return {
...preset && typeof preset === "object" ? preset : {},
...include_json_stringify ? { json_stringify: settings.json_stringify } : {},
template_before: get_template_value(settings, defaults, "item_template_before", "template_before"),
template_after: get_template_value(settings, defaults, "item_template_after", "template_after")
};
}
__name(get_item_templates, "get_item_templates");

var derive_item_name_from_key = /* @__PURE__ */ __name((key = "") => {
if (typeof key !== "string" || key.trim().length === 0) return "";
const [filename_with_fragment] = key.split(/[\\/]/).slice(-1);
const [source_name, ...block_parts] = (filename_with_fragment || "").split("#");
const src_no_ext = source_name.includes(".") ? source_name.slice(0, source_name.lastIndexOf(".")) : source_name;
if (block_parts.length > 0) {
return `${src_no_ext}#${block_parts.join("#")}`;
}
return src_no_ext;
}, "derive_item_name_from_key");
var get_item_name = /* @__PURE__ */ __name((context_item) => {
return derive_item_name_from_key(context_item.key);
}, "get_item_name");
async function merge_template(item_text, params = {}) {
const MERGE_VARS = {
"KEY": this.key,
"ITEM_NAME": get_item_name(this),
"TIME_AGO": convert_to_time_ago(this.mtime) || "Missing",
"LINK_DEPTH": this.data.d || "0",
"EXT": this.item_ref?.file_type || ""
};
const replace_vars = /* @__PURE__ */ __name(async (template) => {
const re_var = /{{([\w_]+)}}/g;
const number_of_var_matches = (template.match(re_var) || []).length;
for (let i = 0; i < number_of_var_matches; i++) {
template = template.replace(/{{(\w+)}}/g, (match, p1) => {
return MERGE_VARS[p1] || "";
});
}
return template;
}, "replace_vars");
const templates = get_item_templates(this.settings, default_settings2);
if (params.json_stringify || templates.json_stringify) {
item_text = JSON.stringify(item_text);
}
const before = await replace_vars(templates.template_before);
const after = await replace_vars(templates.template_after);
return ["", before, item_text, after, ""].join("\n");
}
__name(merge_template, "merge_template");
var settings_config7 = {
template_preset: {
group: "Item templates",
type: "dropdown",
name: "Select template",
description: "Wraps each context item with a pre-configured template.",
options_callback: /* @__PURE__ */ __name(() => get_template_preset_options(), "options_callback")
},
template_before: {
group: "Item templates",
type: "textarea",
name: "Template Before",
description: "Template to wrap before the context item content.",
scope_class: "pro-setting"
},
template_after: {
group: "Item templates",
type: "textarea",
name: "Template After",
description: "Template to wrap after the context item content.",
scope_class: "pro-setting"
},
item_explanation: {
type: "html",
group: "Item templates",
value: `
<b>Available variables:</b>
<ul>
<li><code>{{KEY}}</code> - Full path of the item</li>
<li><code>{{ITEM_NAME}}</code> - Source file or block name without folder path or file extension</li>
<li><code>{{TIME_AGO}}</code> - Time since the item was last modified</li>
<li><code>{{LINK_DEPTH}}</code> - Depth level of the item</li>
<li><code>{{EXT}}</code> - File extension of the item</li>
</ul>
`
},
json_stringify: {
group: "Item templates",
type: "toggle",
name: "JSON Stringify",
description: "Convert the item content to a JSON string (forces full content into single line in quotes).",
scope_class: "pro-setting"
}
};
var default_settings2 = {
template_preset: "xml_structured",
template_before: '<item loc="{{KEY}}" at="{{TIME_AGO}}">',
template_after: "</item>"
};

function build_file_tree_string(paths = []) {
if (!Array.isArray(paths) || paths.length === 0) return "";
const root = {};
for (const path of paths) {
const isFolder = is_folder_path(path);
const parts = path.split("/").filter(Boolean);
let node = root;
for (let i = 0; i < parts.length; i++) {
const part = parts[i];
const isLast = i === parts.length - 1;
if (isLast) {
if (isFolder) {
node[part] = node[part] ?? { __isExplicitFolder: true };
} else {
node[part] = null;
}
} else {
node = node[part] ??= {};
}
}
}
compress_single_child_dirs(root);
return build_tree_string(root).trimEnd();
}
__name(build_file_tree_string, "build_file_tree_string");
function is_folder_path(path) {
return typeof path === "string" && path.endsWith("/");
}
__name(is_folder_path, "is_folder_path");
function compress_single_child_dirs(node) {
if (!node || typeof node !== "object") return;
for (const key of Object.keys(node)) {
const child = node[key];
if (child && typeof child === "object") {
if (child.__isExplicitFolder) {
delete child.__isExplicitFolder;
compress_single_child_dirs(child);
continue;
}
const childKeys = Object.keys(child);
if (childKeys.length === 1 && child[childKeys[0]] !== null && !child[childKeys[0]].__isExplicitFolder) {
const mergedKey = `${key}/${childKeys[0]}`;
node[mergedKey] = child[childKeys[0]];
delete node[key];
compress_single_child_dirs(node[mergedKey]);
} else {
compress_single_child_dirs(child);
}
}
}
}
__name(compress_single_child_dirs, "compress_single_child_dirs");
function build_tree_string(node, prefix = "") {
let output = "";
const entries = Object.entries(node).sort((a, b) => {
const aIsDir = a[1] !== null;
const bIsDir = b[1] !== null;
if (aIsDir && !bIsDir) return -1;
if (!aIsDir && bIsDir) return 1;
return a[0].localeCompare(b[0]);
});
entries.forEach(([name, child], idx) => {
const isLast = idx === entries.length - 1;
const connector = isLast ? "\u2514\u2500\u2500 " : "\u251C\u2500\u2500 ";
if (child === null) {
output += `${prefix}${connector}${name}
`;
} else {
output += `${prefix}${connector}${name}/
`;
output += build_tree_string(child, prefix + (isLast ? "    " : "\u2502   "));
}
});
return output;
}
__name(build_tree_string, "build_tree_string");

async function merge_template2(context_items_text, params = {}) {
const context_items = params.context_items || [];
const MERGE_VARS = {
"FILE_TREE": /* @__PURE__ */ __name(() => {
return build_file_tree_string(context_items.map((c) => c.key));
}, "FILE_TREE")
};
const replace_vars = /* @__PURE__ */ __name(async (template) => {
const number_of_var_matches = (template.match(/{{(\w+)}}/g) || []).length;
for (let i = 0; i < number_of_var_matches; i++) {
template = template.replace(/{{(\w+)}}/gi, (match, p1) => {
return MERGE_VARS[p1]?.() || "";
});
}
return template;
}, "replace_vars");
const templates = get_context_templates(this.settings, default_settings3);
const before = await replace_vars(templates.template_before);
const after = await replace_vars(templates.template_after);
return [before, context_items_text, after].join("\n");
}
__name(merge_template2, "merge_template");
var settings_config8 = {
template_preset: {
type: "dropdown",
group: "Context templates",
name: "Select template",
description: "Wraps the full context with a pre-configured template.",
options_callback: /* @__PURE__ */ __name(() => get_template_preset_options(), "options_callback")
},
template_before: {
type: "textarea",
group: "Context templates",
name: "Template Before",
description: "Template to wrap before the context.",
scope_class: "pro-setting"
},
template_after: {
type: "textarea",
group: "Context templates",
name: "Template After",
description: "Template to wrap after the context.",
scope_class: "pro-setting"
},
context_explanation: {
type: "html",
group: "Context templates",
value: `<b>Available variables:</b>
<ul>
<li><code>{{FILE_TREE}}</code> - Shows hierarchical view of all files</li>
</ul>
`
}
};
var default_settings3 = {
template_preset: "xml_structured",
template_before: "<context>\n{{FILE_TREE}}",
template_after: "</context>"
};

function context_suggest_blocks(params = {}) {
params?.modal?.setInstructions([
{ command: "Enter", purpose: "Add block to context" },
{ command: "\u2190", purpose: "Back to sources" }
]);
let blocks = [];
if (params.source_key) {
const src = this.env.smart_sources.get(params.source_key);
blocks = src.blocks;
} else {
blocks = Object.values(this.env.smart_blocks.items);
}
return blocks.sort((a, b) => {
const a_line = Array.isArray(a.lines) && a.lines.length ? a.lines[0] : Infinity;
const b_line = Array.isArray(b.lines) && b.lines.length ? b.lines[0] : Infinity;
return a_line - b_line;
}).map((block) => ({
key: block.key,
display: get_block_display_name2(block, { show_full_path: false }),
select_action: /* @__PURE__ */ __name(() => {
this.add_item(block.key);
}, "select_action"),
arrow_left_action: /* @__PURE__ */ __name(({ modal }) => {
modal.update_suggestions("context_suggest_sources");
}, "arrow_left_action")
}));
}
__name(context_suggest_blocks, "context_suggest_blocks");
function get_block_display_name2(item, settings = {}) {
if (!item?.key) return "";
const show_full_path = settings.show_full_path ?? true;
if (show_full_path) {
return item.key.replace(/#/g, " > ").replace(/\//g, " > ");
}
const pcs = [];
const [source_key, ...block_parts] = item.key.split("#");
const filename = source_key.split("/").pop();
pcs.push(filename);
if (block_parts.length) {
const last = block_parts[block_parts.length - 1];
if (last.startsWith("{") && last.endsWith("}")) {
block_parts.pop();
pcs.push(block_parts.pop());
if (item.lines) pcs.push(`Lines: ${item.lines.join("-")}`);
} else {
pcs.push(block_parts.pop());
}
}
return pcs.filter(Boolean).join(" > ");
}
__name(get_block_display_name2, "get_block_display_name");
var display_name = "Add blocks";

var import_obsidian33 = require("obsidian");
var MOD_CHAR = import_obsidian33.Platform.isMacOS ? "\u2318" : "Ctrl";
function normalize_folder_path(folder_path) {
if (typeof folder_path !== "string") return "";
return folder_path.replace(/\/+$/g, "");
}
__name(normalize_folder_path, "normalize_folder_path");
function is_source_in_folder(source_key, folder_path) {
const normalized_folder_path = normalize_folder_path(folder_path);
if (!normalized_folder_path) return true;
if (source_key === normalized_folder_path) return true;
return source_key.startsWith(`${normalized_folder_path}/`);
}
__name(is_source_in_folder, "is_source_in_folder");
function reset_modal_input(modal) {
if (!modal?.inputEl) return;
modal.last_input_value = modal.inputEl.value;
modal.inputEl.value = "";
}
__name(reset_modal_input, "reset_modal_input");
function get_sources_list(ctx, folder_path) {
const items = Object.values(ctx.env?.smart_sources?.items || {});
return items.filter((source) => is_source_in_folder(source.key, folder_path));
}
__name(get_sources_list, "get_sources_list");
function build_source_suggestions(ctx, sources) {
return sources.map((source) => ({
key: source.key,
display: source.key,
select_action: /* @__PURE__ */ __name(() => {
ctx.add_item(source.key);
}, "select_action"),
mod_select_action: /* @__PURE__ */ __name(({ modal } = {}) => {
reset_modal_input(modal);
return context_suggest_blocks.call(ctx, { source_key: source.key, modal });
}, "mod_select_action"),
arrow_right_action: /* @__PURE__ */ __name(({ modal } = {}) => {
reset_modal_input(modal);
return context_suggest_blocks.call(ctx, { source_key: source.key, modal });
}, "arrow_right_action")
}));
}
__name(build_source_suggestions, "build_source_suggestions");
function context_suggest_sources(params = {}) {
console.log("context_suggest_sources", params);
const modal = params?.modal;
if (modal) {
modal.setInstructions([
{ command: "Enter", purpose: "Add source to context" },
{ command: `${MOD_CHAR} + Enter / \u2192`, purpose: "Suggest source blocks" }
]);
}
const sources = get_sources_list(this, params?.folder_path || "");
return build_source_suggestions(this, sources);
}
__name(context_suggest_sources, "context_suggest_sources");
var display_name2 = "Add sources";

async function pre_process(params) {
const query = params.query;
if (!query || typeof query !== "string" || query.trim().length === 0) {
throw new Error("Invalid or empty query provided to lookup list.");
}
const embed_model = this.env.smart_sources.embed_model;
if (!embed_model) {
throw new Error("No embed model available in environment for lookup list.");
}
const embedding = await embed_model.embed(query);
params.to_item = { ...embedding };
if (!params.score_algo_key) params.score_algo_key = "similarity";
return params;
}
__name(pre_process, "pre_process");

function similarity(params) {
if (!this.vec) return { score: null, error: `Missing this.vec for ${this.key}` };
if (!params.to_item?.vec) return { score: null, error: "Missing params.to_item.vec" };
return {
score: cos_sim(this.vec || [], params.to_item.vec || [])
};
}
__name(similarity, "similarity");
similarity.action_type = "score";
var display_name3 = "Cosine Similarity";
var display_description = "Ranks by cosine similarity between the current note and candidates.";
var settings_config9 = {
similarity_algo_description: {
group: "Score algorithm",
type: "html",
name: `${display_name3} algorithm`,
value: `${display_description}`
}
};

var import_obsidian34 = require("obsidian");
async function open_source(item, event = null) {
try {
const env = item.env;
const obsidian_app = env.obsidian_app;
let target_path = item.key;
if (target_path.endsWith("#")) target_path = target_path.slice(0, -1);
let target_file;
if (target_path.includes("#")) {
const [file_path] = target_path.split("#");
target_file = obsidian_app.metadataCache.getFirstLinkpathDest(file_path, "");
} else {
target_file = obsidian_app.metadataCache.getFirstLinkpathDest(target_path, "");
}
if (!target_file) {
console.warn(`[open_note] Unable to resolve file for ${target_path}`);
return;
}
let leaf;
if (event) {
const is_mod = import_obsidian34.Keymap.isModEvent(event);
const is_alt = import_obsidian34.Keymap.isModifier(event, "Alt");
if (is_mod && is_alt) {
leaf = obsidian_app.workspace.splitActiveLeaf("vertical");
} else if (is_mod) {
leaf = obsidian_app.workspace.getLeaf(true);
} else {
leaf = obsidian_app.workspace.getMostRecentLeaf();
}
} else {
leaf = obsidian_app.workspace.getMostRecentLeaf();
}
await leaf.openFile(target_file);
if (typeof item?.line_start === "number") {
const { editor } = leaf.view;
const pos = { line: item.line_start, ch: 0 };
editor.setCursor(pos);
editor.scrollIntoView({ to: pos, from: pos }, true);
}
item.emit_event("sources:opened", { event_source: "open_source method" });
} catch (e) {
console.error("Error in open_source:", e);
item.emit_event("notification:error", { message: e.message, event_source: "open_source method" });
}
}
__name(open_source, "open_source");

async function source_open(event = null) {
await open_source(this, event);
}
__name(source_open, "source_open");

var smart_env_config = {
collections: {
embedding_models: embedding_models_default2,
lookup_lists: lookup_lists_default
},
item_types: {
EmbeddingModel,
LookupList
},
items: {
embedding_model: { class: EmbeddingModel },
lookup_list: { class: LookupList }
},
modules: {},
components: {
collection_settings: { render: render2 },
context_item_leaf: { render: render3 },
env_stats: { render: render4 },
form_dropdown: { render: render5 },
lean_coffee_callout: { render: render6 },
milestones: { render: render7 },
notifications_feed: { render: render8 },
pro_plugins_list: { render: render9 },
pro_plugins_list_item: { render: render10 },
settings_env_model: { render: render11 },
settings_env_model_type: { render: render12 },
settings_env_models: { render: render13 },
settings_env_sources: { render: render14 },
settings_model_actions: { render: render15 },
settings_notifications: { render: render16 },
settings_smart_env: { render: render17 },
smart_context_actions: { render: render18 },
smart_context_item: { render: render19 },
smart_context_meta: { render: render20 },
smart_context_tree: { render: render21 },
source_inspector: { render: render22 },
status_bar: { render: render23 },
supporter_callout: { render: render24 },
user_agreement_callout: { render: render25 }
},
actions: {
context_copy_to_clipboard: { action: copy_to_clipboard3 },
context_item_merge_template: { action: merge_template, settings_config: settings_config7, default_settings: default_settings2 },
context_merge_template: { action: merge_template2, settings_config: settings_config8, default_settings: default_settings3 },
context_suggest_blocks: { action: context_suggest_blocks, display_name },
context_suggest_sources: { action: context_suggest_sources, display_name: display_name2 },
lookup_list_pre_process: { action: pre_process, pre_process },
similarity: { action: similarity, settings_config: settings_config9, display_name: display_name3, display_description },
source_open: { action: source_open }
}
};

var smart_env_config2 = {
env_path: "",
modules: {
smart_fs: {
class: SmartFs,
adapter: ObsidianFsAdapter
},
smart_view: {
class: SmartView,
adapter: SmartViewObsidianAdapter
},
smart_embed_model: {
class: SmartEmbedModel,
adapters: {
transformers: SmartEmbedTransformersIframeAdapter,
openai: SmartEmbedOpenAIAdapter,
ollama: SmartEmbedOllamaAdapter,
gemini: GeminiEmbedModelAdapter,
lm_studio: LmStudioEmbedModelAdapter
}
},
smart_chat_model: {
class: SmartChatModel,
adapters: {
anthropic: SmartChatModelAnthropicAdapter,
azure: SmartChatModelAzureAdapter,
custom: SmartChatModelCustomAdapter,
google: SmartChatModelGoogleAdapter,
gemini: SmartChatModelGeminiAdapter,
groq: SmartChatModelGroqAdapter,
lm_studio: SmartChatModelLmStudioAdapter,
ollama: SmartChatModelOllamaAdapter,
open_router: SmartChatModelOpenRouterAdapter,
openai: SmartChatModelOpenaiAdapter,
xai: SmartChatModelXaiAdapter,
deepseek: SmartChatModelDeepseekAdapter
},
http_adapter: new SmartHttpRequest({
adapter: SmartHttpObsidianRequestAdapter,
obsidian_request_url: import_obsidian37.requestUrl
})
},
http_adapter: {
class: SmartHttpRequest,
adapter: SmartHttpObsidianRequestAdapter,
obsidian_request_url: import_obsidian37.requestUrl
}
},
collections: {
context_items: context_items_default,
event_logs: event_logs_default,
smart_components: smart_components_default2,
smart_contexts: smart_contexts_default,
smart_sources: {
collection_key: "smart_sources",
class: SmartSources,
data_adapter: AjsonMultiFileSourcesDataAdapter,
source_adapters: {
"md": ObsidianMarkdownSourceContentAdapter,
"txt": ObsidianMarkdownSourceContentAdapter,
"excalidraw.md": ExcalidrawSourceContentAdapter,
"base": BasesSourceContentAdapter,
"canvas": CanvasSourceContentAdapter,
"rendered": RenderedSourceContentAdapter
},
content_parsers: [
parse_blocks
],
process_embed_queue: true,
load_order: 100
},
smart_blocks: {
collection_key: "smart_blocks",
class: SmartBlocks,
data_adapter: AjsonMultiFileBlocksDataAdapter,
block_adapters: {
"md": MarkdownBlockContentAdapter,
"txt": MarkdownBlockContentAdapter,
"excalidraw.md": MarkdownBlockContentAdapter
}
}
},
item_types: {
SmartSource,
SmartBlock
},
items: {
smart_source: smart_source_default,
smart_block: smart_block_default
},
default_settings,
modals: {
context_selector: {
class: ContextModal,
default_suggest_action_keys: [
"context_suggest_sources"
]
},
milestones_modal: {
class: MilestonesModal
},
notifications_feed_modal: {
class: NotificationsFeedModal
}
}
};
merge_env_config(smart_env_config2, smart_env_config);
var default_config_default = smart_env_config2;

var import_obsidian38 = require("obsidian");
function add_smart_chat_icon() {
(0, import_obsidian38.addIcon)("smart-chat", `<defs>
<symbol id="smart-chat-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round">
<path d="M2 4c0-1.1.9-2 2-2h16c1.1 0 2 .9 2 2v11c0 1.1-.9 2-2 2h-8l-5 4v-4H4c-1.1 0-2-.9-2-2Z" stroke-width="2"></path>
<path d="M7 8c.5.3 1.3.3 1.8 0" stroke-width="2"></path>
<path d="M15.2 8c.5.3 1.3.3 1.8 0" stroke-width="2"></path>
<path d="M8 11.5c1 .8 2.5 1.2 4 1.2s3-.4 4-1.2" stroke-width="2"></path>
</symbol>
</defs>
<use href="#smart-chat-icon" />`);
}
__name(add_smart_chat_icon, "add_smart_chat_icon");
function add_smart_connections_icon() {
(0, import_obsidian38.addIcon)("smart-connections", `<path d="M50,20 L80,40 L80,60 L50,100" stroke="currentColor" stroke-width="4" fill="none"/>
<path d="M30,50 L55,70" stroke="currentColor" stroke-width="5" fill="none"/>
<circle cx="50" cy="20" r="9" fill="currentColor"/>
<circle cx="80" cy="40" r="9" fill="currentColor"/>
<circle cx="80" cy="70" r="9" fill="currentColor"/>
<circle cx="50" cy="100" r="9" fill="currentColor"/>
<circle cx="30" cy="50" r="9" fill="currentColor"/>`);
}
__name(add_smart_connections_icon, "add_smart_connections_icon");
function add_smart_lookup_icon() {
(0, import_obsidian38.addIcon)("smart-lookup", `<defs>
<clipPath id="sc-in-search-clip" clipPathUnits="userSpaceOnUse">
<circle cx="11" cy="11" r="8"></circle>
</clipPath>
<symbol id="smart-lookup-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round">
<g clip-path="url(#sc-in-search-clip)">
<path d="M10.3,5.4 L14.5,8.2 L14.5,11.0 L10.3,16.6" stroke="currentColor" stroke-width="0.56" fill="none"></path>
<path d="M7.5,9.6 L11.0,12.4" stroke="currentColor" stroke-width="0.7" fill="none"></path>
<circle cx="10.3" cy="5.4" r="0.3" fill="currentColor"></circle>
<circle cx="14.5" cy="8.2" r="0.3" fill="currentColor"></circle>
<circle cx="14.5" cy="12.4" r="0.3" fill="currentColor"></circle>
<circle cx="10.3" cy="16.6" r="0.3" fill="currentColor"></circle>
<circle cx="7.5" cy="9.6" r="0.3" fill="currentColor"></circle>
</g>
<circle cx="11" cy="11" r="8"></circle>
<path d="m21 21-4.3-4.3"></path>
</symbol>
</defs>
<use href="#smart-lookup-icon" />`);
}
__name(add_smart_lookup_icon, "add_smart_lookup_icon");

var import_obsidian39 = require("obsidian");

var NOTICES = {
item_excluded: {
en: "Cannot show Smart Connections for excluded entity: {{entity_key}}"
},
load_env: {
en: "Mobile detected: to prevent performance issues, click to load Smart Environment when ready.",
button: {
en: `Load Smart Env`,
callback: /* @__PURE__ */ __name((env) => {
env.load(true);
}, "callback")
},
timeout: 1e4
},
/** @deprecated in favor of in-component insctructions (2025-06-22) */
missing_entity: {
en: "No entity found for key: {{key}}"
},
notice_muted: {
en: "Notice muted"
},
new_version_available: {
en: "A new version is available! (v{{version}})",
timeout: 15e3,
button: {
en: "Release notes",
callback: /* @__PURE__ */ __name((scope) => {
window.open("https://github.com/brianpetro/obsidian-smart-connections/releases", "_blank");
}, "callback")
}
},
new_early_access_version_available: {
en: "A new early access version is available! (v{{version}})"
},
supporter_key_required: {
en: "Supporter license key required for early access update"
},
revert_to_stable_release: {
en: 'Click "Check for Updates" in the community plugins tab and complete the update for Smart Connections to finish reverting to the stable release.',
timeout: 0
},
action_installed: {
en: 'Installed action "{{name}}"'
},
action_install_error: {
en: 'Error installing action "{{name}}": {{error}}',
timeout: 0
},
embed_model_not_loaded: {
en: "Embed model not loaded. Please wait for the model to load and try again."
},
embed_search_text_failed: {
en: "Failed to embed search text."
},
error_in_embedding_search: {
en: "Error in embedding search. See console for details."
},
copied_to_clipboard: {
en: "Message: {{content}} copied successfully."
},
copy_failed: {
en: "Unable to copy message to clipboard."
},
copied_chatgpt_url_to_clipboard: {
en: "ChatGPT URL copied to clipboard."
},
loading_collection: {
en: "Loading {{collection_key}}..."
},
done_loading_collection: {
en: "{{collection_key}} loaded."
},
saving_collection: {
en: "Saving {{collection_key}}..."
},
initial_scan: {
en: "[{{collection_key}}] Starting initial scan...",
timeout: 0
},
done_initial_scan: {
en: "[{{collection_key}}] Initial scan complete.",
timeout: 3e3
},
pruning_collection: {
en: "Pruning {{collection_key}}..."
},
done_pruning_collection: {
en: "Pruned {{count}} items from {{collection_key}}."
},
embedding_progress: {
en: "Embedding progress: {{progress}} / {{total}}\n{{tokens_per_second}} tokens/sec using {{model_name}}",
button: {
en: "Pause",
callback: /* @__PURE__ */ __name((env) => {
console.log("pausing");
env.smart_sources.entities_vector_adapter.halt_embed_queue_processing();
}, "callback")
},
timeout: 0
},
embedding_complete: {
en: "Embedding complete. {{total_embeddings}} embeddings created. {{tokens_per_second}} tokens/sec using {{model_name}}",
timeout: 0
},
embedding_paused: {
en: "Embedding paused. Progress: {{progress}} / {{total}}\n{{tokens_per_second}} tokens/sec using {{model_name}}",
button: {
en: "Resume",
callback: /* @__PURE__ */ __name((env) => {
env.smart_sources.entities_vector_adapter.resume_embed_queue_processing(100);
}, "callback")
},
timeout: 0
},
embedding_error: {
en: "Error embedding: {{error}}",
timeout: 0
},
import_progress: {
en: "Importing... {{progress}} / {{total}} sources",
timeout: 0
},
done_import: {
en: "Import complete. {{count}} sources imported in {{time_in_seconds}}s",
timeout: 0
},
no_import_queue: {
en: "No items in import queue"
},
clearing_all: {
en: "Clearing all data...",
timeout: 0
},
done_clearing_all: {
en: "All data cleared and reimported",
timeout: 3e3
},
image_extracting: {
en: "Extracting text from Image(s)",
timeout: 0
},
pdf_extracting: {
en: "Extracting text from PDF(s)",
timeout: 0
},
insufficient_settings: {
en: "Insufficient settings for {{key}}, missing: {{missing}}",
timeout: 0
},
unable_to_init_source: {
en: "Unable to initialize source: {{key}}",
timeout: 0
},
reload_sources: {
en: "Reloaded sources in {{time_ms}}ms"
}
};

function define_default_create_methods(notices) {
for (const key of Object.keys(notices)) {
const notice_obj = notices[key];
if (typeof notice_obj.create !== "function") {
notice_obj.create = function(opts = {}) {
let text = this.en ?? key;
for (const [k, v] of Object.entries(opts)) {
text = text.replace(new RegExp(`{{${k}}}`, "g"), String(v));
}
let button;
if (!opts.button && this.button) {
const btn_label = typeof this.button.en === "string" ? this.button.en : "OK";
button = {
text: btn_label,
callback: typeof this.button.callback === "function" ? this.button.callback : () => {
}
};
} else {
button = opts.button;
}
let final_timeout = opts.timeout ?? this.timeout ?? 5e3;
return {
text,
button,
timeout: final_timeout,
confirm: opts.confirm,
immutable: opts.immutable
};
};
}
}
return notices;
}
__name(define_default_create_methods, "define_default_create_methods");
var SmartNotices = class {
static {
__name(this, "SmartNotices");
}
/**
* @param {Object} scope - The main plugin instance
*/
constructor(env, opts = {}) {
env?.create_env_getter(this);
this.active = {};
this.adapter = opts.adapter || this.env.config.modules.smart_notices.adapter;
define_default_create_methods(NOTICES);
}
/** plugin settings for notices (muted, etc.) */
get settings() {
if (!this.env?.settings?.smart_notices) {
this.env.settings.smart_notices = {};
}
if (!this.env?.settings?.smart_notices?.muted) {
this.env.settings.smart_notices.muted = {};
}
return this.env?.settings?.smart_notices;
}
/**
* Displays a notice by key or custom message.
* Usage:
*   notices.show('load_env', { scope: this });
*
* @param {string} id - The notice key or custom ID
* @param {object} opts - Additional user opts
*/
show(id, opts = {}) {
let message = null;
if (typeof opts === "string") {
message = opts;
} else {
opts = opts || {};
}
const normalized_id = this._normalize_notice_key(id);
if (this.settings?.muted?.[normalized_id]) {
if (opts.confirm?.callback) {
opts.confirm.callback();
}
return;
}
const notice_entry = NOTICES[id];
let derived = {
text: message || id,
timeout: opts.timeout ?? 5e3,
button: opts.button,
immutable: opts.immutable,
confirm: opts.confirm
};
if (notice_entry?.create) {
const result = notice_entry.create({ ...opts });
derived.text = message || result.text;
derived.timeout = result.timeout;
derived.button = result.button;
derived.immutable = result.immutable;
derived.confirm = result.confirm;
}
const content_fragment = this._build_fragment(normalized_id, derived.text, derived);
if (this.active[normalized_id]?.noticeEl?.isConnected) {
return this.active[normalized_id].setMessage(content_fragment, derived.timeout);
}
return this._render_notice(normalized_id, content_fragment, derived);
}
/**
* Normalizes the notice key to a safe string.
*/
_normalize_notice_key(key) {
return key.replace(/[^a-zA-Z0-9_-]/g, "_");
}
/**
* Creates and tracks the notice instance
*/
_render_notice(normalized_id, content_fragment, { timeout }) {
this.active[normalized_id] = new this.adapter(content_fragment, timeout);
return this.active[normalized_id];
}
/**
* Builds a DocumentFragment with notice text & possible buttons
*/
_build_fragment(id, text, { button, confirm: confirm2, immutable }) {
const frag = document.createDocumentFragment();
frag.createEl("p", {
cls: "sc-notice-head",
text: `[Smart Env v${this.env.constructor.version}]`
});
const content = frag.createEl("p", { cls: "sc-notice-content", text });
const actions = frag.createEl("div", { cls: "sc-notice-actions" });
if (confirm2?.text && typeof confirm2.callback === "function") {
this._add_button(confirm2, actions);
}
if (button?.text && typeof button.callback === "function") {
this._add_button(button, actions);
}
if (!immutable) {
this._add_mute_button(id, actions);
}
return frag;
}
/**
* Creates a <button> appended to the container
*/
_add_button(btnConfig, container) {
const btn = document.createElement("button");
this.env.smart_view.safe_inner_html(btn, btnConfig.text);
btn.addEventListener("click", (e) => {
if (btnConfig.stay_open) {
e.preventDefault();
e.stopPropagation();
}
btnConfig.callback?.(this.env);
});
container.appendChild(btn);
}
/**
* Mute button
*/
_add_mute_button(id, container) {
const btn = document.createElement("button");
(0, import_obsidian39.setIcon)(btn, "bell-off");
btn.addEventListener("click", () => {
if (!this.settings.muted) this.settings.muted = {};
this.settings.muted[id] = true;
if (NOTICES["notice muted"]) {
this.show("notice muted", null, { timeout: 2e3 });
}
});
container.appendChild(btn);
}
/**
* Hides & clears all active notices
*/
unload() {
for (const id in this.active) {
this.remove(id);
}
}
/**
* Removes an active notice by key
*/
remove(id) {
const normalized_id = this._normalize_notice_key(id);
this.active[normalized_id]?.hide();
delete this.active[normalized_id];
}
};

var import_obsidian41 = require("obsidian");

var import_obsidian40 = require("obsidian");
function get_smart_server_url2() {
if (typeof window !== "undefined" && window.SMART_SERVER_URL_OVERRIDE) {
return window.SMART_SERVER_URL_OVERRIDE;
}
return "https://connect.smartconnections.app";
}
__name(get_smart_server_url2, "get_smart_server_url");

var CLIENT_ID = "smart-plugins-op";
var CLIENT_SECRET = "smart-plugins-op-secret";
function set_local_storage_token({ access_token, refresh_token }, oauth_storage_prefix) {
localStorage.setItem(oauth_storage_prefix + "token", access_token);
if (refresh_token) {
localStorage.setItem(oauth_storage_prefix + "refresh", refresh_token);
}
}
__name(set_local_storage_token, "set_local_storage_token");
async function exchange_code_for_tokens(code, plugin) {
const oauth_storage_prefix = build_oauth_storage_prefix(plugin.app.vault.getName());
const url = `${get_smart_server_url2()}/auth/oauth_exchange2`;
const resp = await (0, import_obsidian41.requestUrl)({
url,
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({
client_id: CLIENT_ID,
client_secret: CLIENT_SECRET,
code
})
});
if (resp.status !== 200) {
throw new Error(`OAuth exchange error ${resp.status} ${resp.text}`);
}
const { access_token, refresh_token } = resp.json;
if (!access_token) {
throw new Error("No access_token in response");
}
set_local_storage_token({ access_token, refresh_token }, oauth_storage_prefix);
}
__name(exchange_code_for_tokens, "exchange_code_for_tokens");
var OAUTH_SUFFIX = "_smart_plugins_oauth_";
function build_oauth_storage_prefix(vault_name) {
const safe_name = String(vault_name || "").toLowerCase().replace(/[^a-z0-9]/g, "_");
return `${safe_name}${OAUTH_SUFFIX}`;
}
__name(build_oauth_storage_prefix, "build_oauth_storage_prefix");

function replace_folder_tree_var(prompt) {
const env = this;
let paths = env.smart_sources?.fs?.folder_paths ?? [];
paths = paths.map((p) => p.endsWith("/") ? p : p + "/");
const tree = build_file_tree_string([...new Set(paths)]);
return prompt.replace(/{{\s*folder_tree\s*}}/gi, tree);
}
__name(replace_folder_tree_var, "replace_folder_tree_var");

function replace_folders_top_var(prompt) {
const env = this;
let paths = env.smart_sources?.fs?.folder_paths ?? [];
paths = paths.map((p) => (p.split("/")[0] || "") + "/");
const tree = build_file_tree_string([...new Set(paths)]);
return prompt.replace(/{{\s*folders_top\s*}}/gi, tree);
}
__name(replace_folders_top_var, "replace_folders_top_var");

function replace_recent_n_var(prompt) {
console.log("replace_recent_n_var", prompt);
const env = this;
return prompt.replace(/{{\s*recent_(\d+)\s*}}/gi, (_, count) => {
const n = parseInt(count, 10) || 0;
const files = Object.values(env.smart_sources?.fs?.files ?? {}).sort((a, b) => b.stat.mtime - a.stat.mtime).slice(0, n).map((f) => f.path).join("\n  - ");
console.log("replace_recent_n_var", n, files);
return files ? `
- ${files}` : "";
}).trim();
}
__name(replace_recent_n_var, "replace_recent_n_var");

function replace_vault_tags_var(prompt) {
const appRef = this.app;
const tags = appRef?.metadataCache?.getTags?.() || {};
const vault_tags = Object.keys(tags).map((tag) => tag.replace("#", "")).join("\n  - ");
return prompt.replace(/{{\s*(?:vault_tags|tags)\s*}}/gi, `
- ${vault_tags}
`).trim();
}
__name(replace_vault_tags_var, "replace_vault_tags_var");

function register_completion_variable_adapter_replacements(variable_adapter_class) {
variable_adapter_class.register(
(txt) => /{{\s*folder_tree\s*}}/i.test(txt),
replace_folder_tree_var,
"{{ folder_tree }}"
);
variable_adapter_class.register(
(txt) => /{{\s*folders_top\s*}}/i.test(txt),
replace_folders_top_var,
"{{ folders_top }}"
);
variable_adapter_class.register(
(txt) => /{{\s*(?:tags|vault_tags)\s*}}/i.test(txt),
replace_vault_tags_var,
"{{ tags }}"
);
variable_adapter_class.register(
(txt) => /{{\s*recent_(\d+)\s*}}/i.test(txt),
replace_recent_n_var,
"{{ recent_10 }}"
);
}
__name(register_completion_variable_adapter_replacements, "register_completion_variable_adapter_replacements");

async function remove_smart_plugins_plugin({ app, plugin_ids = [] } = {}) {
if (!app) return;
const adapter = app.vault?.adapter;
for (const plugin_id of plugin_ids) {
const disabled = await disable_plugin_if_present(app.plugins, plugin_id);
if (disabled) console.warn(`Disabled legacy plugin: ${plugin_id}`);
const removed = await remove_plugin_folder(adapter, plugin_id);
if (removed) console.warn(`Removed legacy plugin: ${plugin_id}`);
}
}
__name(remove_smart_plugins_plugin, "remove_smart_plugins_plugin");
async function disable_plugin_if_present(app_plugins, plugin_id) {
if (!app_plugins) return;
const has_plugin = Boolean(
app_plugins.plugins?.[plugin_id] || app_plugins.enabledPlugins?.has?.(plugin_id) || app_plugins.manifests && plugin_id in app_plugins.manifests
);
if (!has_plugin) return;
if (app_plugins.plugins?.[plugin_id]) {
await app_plugins.unloadPlugin?.(plugin_id);
}
if (app_plugins.disablePluginAndSave) {
await app_plugins.disablePluginAndSave(plugin_id);
}
if (app_plugins.enabledPlugins?.has?.(plugin_id)) {
app_plugins.enabledPlugins.delete(plugin_id);
}
if (app_plugins.manifests && plugin_id in app_plugins.manifests) {
delete app_plugins.manifests[plugin_id];
}
await app_plugins.loadManifests?.();
return true;
}
__name(disable_plugin_if_present, "disable_plugin_if_present");
async function remove_plugin_folder(adapter, plugin_id) {
if (!adapter?.exists) return;
const plugin_path = `.obsidian/plugins/${plugin_id}`;
const exists = await adapter.exists(plugin_path);
if (!exists) return;
if (adapter.rmdir) {
await adapter.rmdir(plugin_path, true);
return;
}
if (adapter.list && adapter.remove) {
const stack = [plugin_path];
while (stack.length) {
const current_path = stack.pop();
const listing = await adapter.list(current_path);
for (const file of listing?.files || []) {
await adapter.remove(`${current_path}/${file}`);
}
for (const folder of listing?.folders || []) {
stack.push(`${current_path}/${folder}`);
}
}
await adapter.remove(plugin_path);
return true;
}
}
__name(remove_plugin_folder, "remove_plugin_folder");

var SmartEnv2 = class extends SmartEnv {
static {
__name(this, "SmartEnv");
}
/**
* Creates and initializes a SmartEnv instance tailored for Obsidian.
* @param {Object} plugin - The Obsidian plugin instance.
* @param {Object} [env_config] - Required environment configuration object.
* @returns {Promise<SmartEnv>} The initialized SmartEnv instance.
*/
static async create(plugin, env_config) {
if (!plugin) throw new Error("SmartEnv.create: 'plugin' parameter is required.");
if (!env_config) throw new Error("SmartEnv.create: 'env_config' parameter is required.");
env_config.version = this.version;
add_smart_chat_icon();
add_smart_connections_icon();
add_smart_lookup_icon();
if (window.smart_env && !window.smart_env.constructor.version) {
const update_notice = "Detected ancient SmartEnv. Removing it to prevent issues with new plugins. Make sure your Smart Plugins are up-to-date!";
console.warn(update_notice);
new import_obsidian42.Notice(update_notice, 0);
window.smart_env = null;
}
const opts = merge_env_config(env_config, default_config_default);
opts.env_path = "";
return await super.create(plugin, opts);
}
async load(force_load = false) {
this.run_migrations();
if (!this.plugin.app.workspace.protocolHandlers.has("smart-plugins/callback")) {
this.plugin.registerObsidianProtocolHandler("smart-plugins/callback", async (params) => {
await this.handle_smart_plugins_oauth_callback(params);
});
}
if (import_obsidian42.Platform.isMobile && !force_load) {
const frag = this.smart_view.create_doc_fragment(`<div><p>Smart Environment loading deferred on mobile.</p><button>Load Environment</button></div>`);
frag.querySelector("button").addEventListener("click", this.load.bind(this, true));
new import_obsidian42.Notice(frag, 0);
return;
}
await super.load();
this.smart_sources?.register_source_watchers?.(this.smart_sources);
const plugin = this.main;
plugin.registerEvent(
plugin.app.workspace.on("active-leaf-change", (leaf) => {
this.smart_sources?.debounce_re_import_queue?.();
const current_path = leaf.view?.file?.path;
this.emit_source_opened(current_path, "active-leaf-change");
})
);
plugin.registerEvent(
plugin.app.workspace.on("file-open", (file) => {
this.smart_sources?.debounce_re_import_queue?.();
const current_path = file?.path;
this.emit_source_opened(current_path, "file-open");
})
);
if (this._config.collections.smart_completions?.completion_adapters?.SmartCompletionVariableAdapter) {
register_completion_variable_adapter_replacements(this._config.collections.smart_completions.completion_adapters.SmartCompletionVariableAdapter);
}
const ContextModal3 = this._config.modals.context_selector.class;
ContextModal3.register_modal(this.main);
this.register_status_bar();
register_first_of_event_notifications(this);
}
emit_source_opened(current_path, event_source = null) {
if (this._current_opened_source === current_path) return;
const current_source = this.smart_sources.get(current_path);
if (current_source) {
this._current_opened_source = current_path;
current_source.emit_event("sources:opened", { event_source });
}
}
queue_source_re_import(source) {
this.smart_sources?.queue_source_re_import?.(source);
}
debounce_re_import_queue() {
this.smart_sources?.debounce_re_import_queue?.();
}
async run_re_import() {
await this.smart_sources?.run_re_import?.();
}
register_status_bar() {
const status_container = this.main?.app?.statusBar?.containerEl;
status_container?.querySelector?.(".smart-env-status-container")?.closest?.(".status-bar-item")?.remove?.();
this.status_elm = this.main.addStatusBarItem();
this.smart_components?.render_component("status_bar", this).then((container) => {
this.status_elm.empty?.();
this.status_elm.appendChild(container);
});
}
/**
* @deprecated see events
*/
get notices() {
if (!this._notices) {
this._notices = new SmartNotices(this, {
adapter: import_obsidian42.Notice
});
}
return this._notices;
}
/**
* This is the function that is called by the new "Sign in with Smart Plugins" button.
* @deprecated 2025-12-13 moved to components/pro-plugins/list.js
* It replicates the old 'initiate_oauth()' logic from sc_settings_tab.js
*/
initiate_smart_plugins_oauth() {
console.log("initiate_smart_plugins_oauth");
const state = Math.random().toString(36).slice(2);
const redirect_uri = encodeURIComponent("obsidian://smart-plugins/callback");
const url = `${get_smart_server_url2()}/oauth?client_id=smart-plugins-op&redirect_uri=${redirect_uri}&state=${state}`;
window.open(url, "_external");
return url;
}
/**
* Handles the OAuth callback from the Smart Plugins server.
* @param {Object} params - The URL parameters from the OAuth callback.
*/
async handle_smart_plugins_oauth_callback(params) {
const code = params.code;
if (!code) {
new import_obsidian42.Notice("No OAuth code provided in URL. Login failed.");
return;
}
try {
await exchange_code_for_tokens(code, this.plugin);
this.events.emit("smart_plugins_oauth_completed");
} catch (err) {
console.error("OAuth callback error", err);
new import_obsidian42.Notice(`OAuth callback error: ${err.message}`);
}
}
/**
* Serializes the environment and, when in a browser, triggers a download.
* @param {string} [filename='smart_env.json']
* @returns {string} stringified JSON
*/
export_json(filename = "smart_env.json") {
const json = JSON.stringify(this.to_json(), null, 2);
if (typeof document !== "undefined") {
download_json(json, filename);
}
return json;
}
async ready_to_load_collections() {
await new Promise((r) => setTimeout(r, 3e3));
await this.wait_for_obsidian_sync();
}
async wait_for_obsidian_sync() {
while (this.obsidian_is_syncing) {
console.log("Smart Connections: Waiting for Obsidian Sync to finish");
await new Promise((r) => setTimeout(r, 1e3));
if (!this.plugin) throw new Error("Plugin disabled while waiting for obsidian sync, reload required.");
}
}
get obsidian_is_syncing() {
const obsidian_sync_instance = this.plugin?.app?.internalPlugins?.plugins?.sync?.instance;
if (!obsidian_sync_instance) return false;
if (obsidian_sync_instance?.syncStatus.startsWith("Uploading")) return false;
if (obsidian_sync_instance?.syncStatus.startsWith("Fully synced")) return false;
return obsidian_sync_instance?.syncing;
}
get obsidian_app() {
return this.plugin?.app ?? window.app;
}
open_notifications_feed_modal() {
const NotificationsModalClass = this.config.modals.notifications_feed_modal.class;
const modal = new NotificationsModalClass(this.obsidian_app, this);
modal.open();
}
open_milestones_modal() {
const MilestonesModalClass = this.config.modals.milestones_modal.class;
const modal = new MilestonesModalClass(this.obsidian_app, this);
modal.open();
}
run_migrations() {
remove_smart_plugins_plugin({ app: this.plugin.app, plugin_ids: ["smart-plugins"] });
remove_smart_plugins_plugin({ app: this.plugin.app, plugin_ids: ["smart-editor"] });
remove_smart_plugins_plugin({ app: this.plugin.app, plugin_ids: ["smart-sources"] });
remove_smart_plugins_plugin({ app: this.plugin.app, plugin_ids: ["smart-claude"] });
remove_smart_plugins_plugin({ app: this.plugin.app, plugin_ids: ["smart-gemini"] });
remove_smart_plugins_plugin({ app: this.plugin.app, plugin_ids: ["smart-deepseek"] });
remove_smart_plugins_plugin({ app: this.plugin.app, plugin_ids: ["smart-perplexity"] });
remove_smart_plugins_plugin({ app: this.plugin.app, plugin_ids: ["smart-grok"] });
remove_smart_plugins_plugin({ app: this.plugin.app, plugin_ids: ["smart-aistudio"] });
}
};
function download_json(json, filename) {
const blob = new Blob([json], { type: "application/json" });
const url = URL.createObjectURL(blob);
const anchor = document.createElement("a");
anchor.href = url;
anchor.download = filename;
document.body.appendChild(anchor);
anchor.click();
document.body.removeChild(anchor);
URL.revokeObjectURL(url);
}
__name(download_json, "download_json");

var import_obsidian44 = require("obsidian");

var import_obsidian43 = require("obsidian");
async function wait_for_env_to_load(scope, opts = {}) {
const { wait_for_states = ["loaded"] } = opts;
const container = scope.container || scope.containerEl;
if (!wait_for_states.includes(scope.env?.state)) {
let clicked_load_env = false;
while (scope.env.state === "init" && import_obsidian43.Platform.isMobile && !clicked_load_env) {
if (container) {
container.empty();
scope.env.smart_view.safe_inner_html(container, "<button>Load Smart Environment</button>");
container.querySelector("button").addEventListener("click", () => {
scope.env.load(true);
clicked_load_env = true;
});
} else {
console.log("Waiting for env to load (mobile)...");
}
await new Promise((r) => setTimeout(r, 2e3));
}
while (!wait_for_states.includes(scope.env.state)) {
if (container) {
const loading_msg = scope.env?.obsidian_is_syncing ? "Waiting for Obsidian Sync to finish..." : "Loading Obsidian Smart Environment...";
container.empty();
scope.env.smart_view.safe_inner_html(container, loading_msg);
} else {
console.log("Waiting for env to load...");
}
await new Promise((r) => setTimeout(r, 2e3));
}
}
}
__name(wait_for_env_to_load, "wait_for_env_to_load");

var settings_default = `/* 1) Host elements that should get a PRO badge */\r
:is(\r
.pro-setting .setting-item-name\r
) {\r
position: relative; /* safe default, keeps ::after anchored */\r
}\r
\r
/* 2) The PRO badge itself */\r
:is(\r
.pro-setting .setting-item-name:not(:empty)\r
)::after {\r
content: "PRO";\r
\r
/* layout */\r
display: inline-flex;\r
align-items: center;\r
justify-content: center;\r
margin-left: 0.4em;\r
padding: 0.08em 0.55em;\r
border-radius: 999px;\r
white-space: nowrap;\r
vertical-align: middle;\r
\r
/* typography */\r
font-size: 0.7em;\r
font-weight: 600;\r
letter-spacing: 0.14em;\r
text-transform: uppercase;\r
line-height: 1;\r
\r
/* color system: only Obsidian variables */\r
background-color: var(--interactive-accent);\r
background-image: linear-gradient(\r
135deg,\r
var(--interactive-accent),\r
var(--interactive-accent-hover)\r
);\r
color: var(--text-on-accent, var(--background-primary));\r
border: 1px solid var(--background-modifier-border);\r
\r
/* subtle separation & depth, theme-aware */\r
box-shadow:\r
0 0 0 1px var(--background-primary),\r
0 1px 3px rgba(0, 0, 0, 0.35);\r
transform: translateY(-0.03em);\r
}\r
\r
/* 3) Interactive refinement: follow Obsidian's accent hover behavior */\r
:is(\r
.pro-setting .setting-item-name\r
):hover::after {\r
background-color: var(--interactive-accent-hover);\r
filter: brightness(1.05);\r
}\r
\r
.pro-plugins-container {\r
border: 1px solid var(--interactive-accent);\r
border-radius: var(--radius-m);\r
padding: 1rem;\r
margin-top: 1rem;\r
background-color: var(--background-secondary);\r
}\r
\r
.smart-plugin-settings-header .actions-container {\r
display: flex;\r
flex-wrap: wrap;\r
gap: var(--pill-padding-y);\r
}\r
\r
.setting-component:has(.dropdown-no-options) {\r
display: none;\r
}\r
\r
/* wrap Obsidian native styles within smart plugin settings main class */\r
.smart-plugin-settings-main, .smart-plugin-settings-env {\r
.setting-group {\r
margin-top: var(--size-4-6);\r
margin-bottom: var(--size-4-6);\r
}\r
/* polyfill */\r
.setting-group .setting-items {\r
background-color: var(--setting-items-background, var(--background-primary-alt));\r
padding: var(--setting-items-padding, var(--size-4-5));\r
border-radius: var(--setting-items-radius, var(--radius-l));\r
border: var(--setting-items-border-width, 0) solid var(--setting-items-border-color, var(--background-modifier-border));\r
}\r
}\r
`;

var SmartPluginSettingsTab = class extends import_obsidian44.PluginSettingTab {
static {
__name(this, "SmartPluginSettingsTab");
}
constructor(app, plugin) {
super(app, plugin);
this.plugin = plugin;
this.header_container = null;
this.plugin_container = null;
this.global_settings_container = null;
this.plugin?.env?.create_env_getter?.(this);
if (this.env.is_pro && !this.env_settings_tab) this.plugin.addSettingTab(new SmartEnvSettingTab(this.plugin.app, this.plugin));
this.icon = "smart-connections";
if (this.env.is_pro) {
this.name = this.name.replace("Smart ", "");
}
}
get smart_view() {
return this.env?.smart_view;
}
async display() {
await this.render();
}
async render() {
this.containerEl.empty();
render_pre_env_load(this);
await this.env.constructor.wait_for({ loaded: true });
this.prepare_layout();
await this.render_header(this.header_container);
await this.render_plugin_settings(this.plugin_container);
await this.render_global_settings(this.global_settings_container);
}
prepare_layout() {
this.smart_view.apply_style_sheet(settings_default);
this.containerEl.empty();
this.header_container = this.containerEl.createDiv({ cls: "smart-plugin-settings-header" });
this.plugin_container = this.containerEl.createDiv({ cls: "smart-plugin-settings-main" });
this.global_settings_container = this.containerEl.createDiv({ cls: "smart-plugin-settings-env" });
this.pro_plugins_container = this.containerEl.createDiv({ cls: "smart-plugin-settings-pro-plugins" });
}
/**
* @abstract
*/
async render_header(container) {
}
/**
* @abstract
*/
async render_plugin_settings(container) {
}
async render_global_settings(container) {
if (!container) return;
container.empty?.();
if (!this.env) return;
if (this.env.is_pro) {
const settings_item_div = container.createDiv({ cls: "setting-item" });
const info_div = settings_item_div.createDiv({ cls: "setting-item-info" });
info_div.createDiv({ cls: "setting-item-name", text: "Smart Environment" });
info_div.createDiv({
cls: "setting-item-description",
text: "Manage global settings in the dedicated Smart Environment settings tab."
});
const control_div = settings_item_div.createDiv({ cls: "setting-item-control" });
const button = control_div.createEl("button", { text: "Open settings" });
button.addEventListener("click", () => {
this.app.setting.openTabById("smart-environment");
});
} else {
const settings_smart_env = await this.render_component("settings_smart_env", this.env);
if (settings_smart_env) container.appendChild(settings_smart_env);
}
const smart_plugins_settings = await this.render_component("pro_plugins_list", this.env);
this.pro_plugins_container.empty?.();
this.pro_plugins_container.appendChild(smart_plugins_settings);
}
async render_component(name, scope, params = {}) {
return await this.env.smart_components.render_component(name, scope, params);
}
get env_settings_tab() {
const app = this.plugin.app || window.app;
return app.setting.pluginTabs.find((t) => t.id === "smart-environment");
}
};
var SmartEnvSettingTab = class extends import_obsidian44.PluginSettingTab {
static {
__name(this, "SmartEnvSettingTab");
}
constructor(app, plugin) {
super(app, plugin);
this.plugin = plugin;
this.header_container = null;
this.plugin_container = null;
this.global_settings_container = null;
this.plugin?.env?.create_env_getter?.(this);
this.plugin = plugin;
this.name = "Smart Env Pro";
this.id = "smart-environment";
this.icon = "smart-connections";
}
get smart_view() {
return this.env?.smart_view;
}
display() {
this.render();
}
async render_component(name, scope, params = {}) {
return await this.env.smart_components.render_component(name, scope, params);
}
async render() {
this.containerEl.empty();
this.smart_view.apply_style_sheet(settings_default);
render_pre_env_load(this);
await this.env.constructor.wait_for({ loaded: true });
this.containerEl.empty();
this.header_container = this.containerEl.createDiv({ cls: "smart-plugin-settings-header" });
this.plugin_container = this.containerEl.createDiv({ cls: "smart-plugin-settings-main" });
this.pro_plugins_container = this.containerEl.createDiv({ cls: "smart-plugin-settings-pro-plugins" });
this.header_container.createEl("p", { text: "Manage all global Smart Environment settings from one tab. These settings apply to all Smart Plugins." });
const settings_smart_env = await this.render_component("settings_smart_env", this.env);
if (settings_smart_env) this.plugin_container.appendChild(settings_smart_env);
const smart_plugins_settings = await this.render_component("pro_plugins_list", this.env);
this.pro_plugins_container.empty?.();
this.pro_plugins_container.appendChild(smart_plugins_settings);
}
};
function render_pre_env_load(scope) {
const container = scope.containerEl;
const env = scope.env;
if (env.state !== "loaded") {
if (env.state === "loading") {
container.createEl("p", { text: "Smart Environment is loading\u2026" });
} else {
container.createEl("p", { text: "Smart Environment not yet initialized." });
const load_btn = container.createEl("button", { text: "Load Smart Environment" });
load_btn.addEventListener("click", async () => {
load_btn.disabled = true;
load_btn.textContent = "Loading Smart Environment\u2026";
await env.load(true);
});
}
}
}
__name(render_pre_env_load, "render_pre_env_load");

var import_obsidian45 = require("obsidian");
var SmartPlugin = class extends import_obsidian45.Plugin {
static {
__name(this, "SmartPlugin");
}
SmartEnv = SmartEnv2;
/**
* override in subclass to provide commands.
* use property key to override commands in further subclasses.
*/
get commands() {
return {
show_release_notes: {
id: "show-release-notes",
name: "Show release notes",
callback: /* @__PURE__ */ __name(() => this.show_release_notes(), "callback")
}
};
}
register_commands() {
Object.values(this.commands).forEach((cmd) => {
this.addCommand(cmd);
});
}
/**
* override in subclass to provide ribbon icons.
* use property key to override ribbon icons in further subclasses.
*/
get ribbon_icons() {
return {};
}
register_ribbon_icons() {
const icons = Object.values(this.ribbon_icons);
for (let i = 0; i < icons.length; i++) {
const ri = icons[i];
this.addRibbonIcon(ri.icon_name, ri.description, ri.callback);
}
}
get item_views() {
return {};
}
register_item_views() {
const views = Object.values(this.item_views);
for (let i = 0; i < views.length; i++) {
const ViewClass = views[i];
if (typeof ViewClass.register_item_view === "function") {
ViewClass.register_item_view(this);
}
}
}
/**
* user version and first seen handling
*/
async is_new_user() {
const data = await this.loadData() || {};
if (!data.installed_at) {
data.installed_at = Date.now();
await this.saveData(data);
return true;
}
return false;
}
/**
* Returns the last saved plugin version or an empty string.
* @returns {Promise<string>}
*/
async get_last_known_version() {
const data = await this.loadData() || {};
return data.last_version || "";
}
/**
* Persists the provided plugin version as last shown.
* @param {string} version
* @returns {Promise<void>}
*/
async set_last_known_version(version2) {
const data = await this.loadData() || {};
data.last_version = version2;
await this.saveData(data);
}
/**
* Determines if release notes should be shown for `current_version`.
* @param {string} current_version
* @returns {Promise<boolean>}
*/
async is_new_plugin_version(current_version) {
return await this.get_last_known_version() !== current_version;
}
/**
* @deprecated use SmartEnv.notices instead
*/
get notices() {
if (this.env?.notices) return this.env.notices;
if (!this._notices) this._notices = new SmartNotices(this.env, import_obsidian45.Notice);
return this._notices;
}
};

function collection_instance_name_from2(class_name) {
if (class_name.endsWith("Item")) {
return class_name.replace(/Item$/, "").replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
}
return class_name.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase().replace(/y$/, "ie") + "s";
}
__name(collection_instance_name_from2, "collection_instance_name_from");

function deep_merge2(target = {}, source = {}) {
for (const key in source) {
if (!Object.prototype.hasOwnProperty.call(source, key)) continue;
if (is_plain_object4(source[key]) && is_plain_object4(target[key])) {
deep_merge2(target[key], source[key]);
} else {
target[key] = source[key];
}
}
return target;
}
__name(deep_merge2, "deep_merge");
function is_plain_object4(o) {
return o && typeof o === "object" && !Array.isArray(o);
}
__name(is_plain_object4, "is_plain_object");

function create_uid2(data) {
const str = JSON.stringify(data);
let hash = 0;
if (str.length === 0) return hash;
for (let i = 0; i < str.length; i++) {
const char = str.charCodeAt(i);
hash = (hash << 5) - hash + char;
hash = hash & hash;
if (hash < 0) hash = hash * -1;
}
return hash.toString() + str.length;
}
__name(create_uid2, "create_uid");

function camel_case_to_snake_case2(str = "") {
return str.replace(/([A-Z])/g, (m) => `_${m.toLowerCase()}`).replace(/^_/, "").replace(/2$/, "");
}
__name(camel_case_to_snake_case2, "camel_case_to_snake_case");

function deep_equal2(obj1, obj2, visited = /* @__PURE__ */ new WeakMap()) {
if (obj1 === obj2) return true;
if (obj1 === null || obj2 === null || obj1 === void 0 || obj2 === void 0) return false;
if (typeof obj1 !== typeof obj2 || Array.isArray(obj1) !== Array.isArray(obj2)) return false;
if (Array.isArray(obj1)) {
if (obj1.length !== obj2.length) return false;
return obj1.every((item, index) => deep_equal2(item, obj2[index], visited));
}
if (typeof obj1 === "object") {
if (visited.has(obj1)) return visited.get(obj1) === obj2;
visited.set(obj1, obj2);
const keys1 = Object.keys(obj1);
const keys2 = Object.keys(obj2);
if (keys1.length !== keys2.length) return false;
return keys1.every((key) => deep_equal2(obj1[key], obj2[key], visited));
}
return obj1 === obj2;
}
__name(deep_equal2, "deep_equal");

function get_item_display_name2(key, show_full_path) {
if (show_full_path) {
return key.split("/").join(" > ").replace(".md", "");
}
return key.split("/").pop().replace(".md", "");
}
__name(get_item_display_name2, "get_item_display_name");

function create_actions_proxy2(ctx, actions_source) {
const input = actions_source || {};
const is_plain_object9 = /* @__PURE__ */ __name((val) => typeof val === "object" && val !== null && !Array.isArray(val), "is_plain_object");
const is_function = /* @__PURE__ */ __name((val) => typeof val === "function", "is_function");
const is_class_export = /* @__PURE__ */ __name((val) => is_function(val) && /^class\s/.test(Function.prototype.toString.call(val)), "is_class_export");
const is_action_object = /* @__PURE__ */ __name((val) => is_plain_object9(val) && is_function(val.action), "is_action_object");
const is_action_candidate = /* @__PURE__ */ __name((val) => is_function(val) || is_action_object(val) || is_class_export(val), "is_action_candidate");
const ignored_meta_keys = /* @__PURE__ */ new Set(["length", "name", "prototype"]);
const clone_with_descriptors = /* @__PURE__ */ __name((obj) => {
if (!is_plain_object9(obj)) return obj;
const out = Object.create(Object.getPrototypeOf(obj) || null);
for (const key of Reflect.ownKeys(obj)) {
const descriptor = Object.getOwnPropertyDescriptor(obj, key);
if (!descriptor) continue;
const next = { ...descriptor };
if ("value" in next && is_plain_object9(next.value)) {
next.value = clone_with_descriptors(next.value);
}
try {
Object.defineProperty(out, key, next);
} catch {
out[key] = next.value;
}
}
return out;
}, "clone_with_descriptors");
const should_bucket_actions = /* @__PURE__ */ __name((val) => {
if (!is_plain_object9(val)) return false;
if (is_action_object(val)) return false;
const keys = Reflect.ownKeys(val);
if (keys.length === 0) return false;
let found_candidate = false;
for (const key of keys) {
const descriptor = Object.getOwnPropertyDescriptor(val, key);
if (!descriptor) continue;
if ("value" in descriptor) {
const entry = descriptor.value;
if (is_action_candidate(entry)) {
found_candidate = true;
continue;
}
if (is_plain_object9(entry)) {
if (should_bucket_actions(entry)) {
found_candidate = true;
continue;
}
return false;
}
if (typeof entry === "undefined") continue;
return false;
}
return false;
}
return found_candidate;
}, "should_bucket_actions");
const clone_descriptor = /* @__PURE__ */ __name((descriptor) => {
if (!descriptor) return descriptor;
if (!("value" in descriptor)) return { ...descriptor };
const cloned = is_plain_object9(descriptor.value) ? clone_with_descriptors(descriptor.value) : descriptor.value;
return { ...descriptor, value: cloned };
}, "clone_descriptor");
const build_sources = /* @__PURE__ */ __name((src) => {
const global_source2 = /* @__PURE__ */ Object.create(null);
const scoped_sources2 = /* @__PURE__ */ new Map();
for (const key of Reflect.ownKeys(src)) {
const descriptor = Object.getOwnPropertyDescriptor(src, key);
if (!descriptor) continue;
if ("value" in descriptor && should_bucket_actions(descriptor.value)) {
scoped_sources2.set(key, clone_with_descriptors(descriptor.value));
continue;
}
try {
Object.defineProperty(global_source2, key, clone_descriptor(descriptor));
} catch {
global_source2[key] = descriptor.value;
}
}
return { global_source: global_source2, scoped_sources: scoped_sources2 };
}, "build_sources");
const { global_source, scoped_sources } = build_sources(input);
const has_own = /* @__PURE__ */ __name((obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop), "has_own");
const cache = /* @__PURE__ */ Object.create(null);
const copy_metadata = /* @__PURE__ */ __name((source, target, omit = []) => {
if (!source || !target) return;
const skips = /* @__PURE__ */ new Set([...ignored_meta_keys, ...omit]);
for (const key of Reflect.ownKeys(source)) {
if (skips.has(key)) continue;
const descriptor = Object.getOwnPropertyDescriptor(source, key);
if (!descriptor) continue;
try {
Object.defineProperty(target, key, descriptor);
} catch {
target[key] = descriptor.value;
}
}
}, "copy_metadata");
const instantiate_class = /* @__PURE__ */ __name((Ctor) => {
const instance = new Ctor(ctx);
const candidate = instance.action || instance.run || instance.execute || instance.call;
if (is_function(candidate)) {
const bound = candidate.bind(instance);
copy_metadata(Ctor, bound);
copy_metadata(instance, bound);
bound.instance = instance;
return bound;
}
copy_metadata(Ctor, instance);
return instance;
}, "instantiate_class");
const bind_or_clone = /* @__PURE__ */ __name((val) => {
if (is_class_export(val)) {
return instantiate_class(val);
}
if (is_action_object(val)) {
const bound = val.action.bind(ctx);
copy_metadata(val, bound, ["action"]);
return bound;
}
if (is_function(val)) {
const bound = val.bind(ctx);
copy_metadata(val, bound);
return bound;
}
if (is_plain_object9(val)) {
return clone_with_descriptors(val);
}
return val;
}, "bind_or_clone");
const scope_actions_for = /* @__PURE__ */ __name(() => {
const scope_key = ctx?.constructor?.key;
if (typeof scope_key === "undefined" || scope_key === null) return null;
const bucket = scoped_sources.get(scope_key);
return bucket && is_plain_object9(bucket) ? bucket : null;
}, "scope_actions_for");
const cache_result = /* @__PURE__ */ __name((target, prop, value) => {
target[prop] = value;
return value;
}, "cache_result");
const compute_and_cache = /* @__PURE__ */ __name((target, prop) => {
const scoped = scope_actions_for();
if (scoped && has_own(scoped, prop)) {
return cache_result(target, prop, bind_or_clone(scoped[prop]));
}
if (has_own(global_source, prop)) {
return cache_result(target, prop, bind_or_clone(global_source[prop]));
}
return cache_result(target, prop, void 0);
}, "compute_and_cache");
const union_keys = /* @__PURE__ */ __name(() => {
const scoped = scope_actions_for();
const keys = new Set(Reflect.ownKeys(cache));
for (const key of Reflect.ownKeys(global_source)) {
keys.add(key);
}
if (scoped) {
for (const key of Reflect.ownKeys(scoped)) {
keys.add(key);
}
}
return Array.from(keys);
}, "union_keys");
const descriptor_for = /* @__PURE__ */ __name((target, prop) => ({
configurable: true,
enumerable: true,
value: target[prop]
}), "descriptor_for");
return new Proxy(cache, {
get: /* @__PURE__ */ __name((target, prop) => {
if (prop === Symbol.toStringTag) return "ActionsProxy";
if (prop in target) return target[prop];
return compute_and_cache(target, prop);
}, "get"),
has: /* @__PURE__ */ __name((target, prop) => {
if (prop in target) return true;
const scoped = scope_actions_for();
if (scoped && has_own(scoped, prop)) return true;
return has_own(global_source, prop);
}, "has"),
ownKeys: /* @__PURE__ */ __name(() => union_keys(), "ownKeys"),
getOwnPropertyDescriptor: /* @__PURE__ */ __name((target, prop) => {
if (has_own(target, prop)) {
return descriptor_for(target, prop);
}
const scoped = scope_actions_for();
if (scoped && has_own(scoped, prop)) {
if (!has_own(target, prop)) {
compute_and_cache(target, prop);
}
return descriptor_for(target, prop);
}
if (has_own(global_source, prop)) {
if (!has_own(target, prop)) {
compute_and_cache(target, prop);
}
return descriptor_for(target, prop);
}
return void 0;
}, "getOwnPropertyDescriptor"),
defineProperty: /* @__PURE__ */ __name((target, prop, descriptor) => {
if ("value" in descriptor) {
target[prop] = descriptor.value;
return true;
}
return false;
}, "defineProperty"),
set: /* @__PURE__ */ __name((target, prop, value) => {
target[prop] = value;
return true;
}, "set"),
deleteProperty: /* @__PURE__ */ __name((target, prop) => {
if (has_own(target, prop)) {
delete target[prop];
}
return true;
}, "deleteProperty")
});
}
__name(create_actions_proxy2, "create_actions_proxy");

var CollectionItem2 = class _CollectionItem {
static {
__name(this, "CollectionItem");
}
static version = 2e-3;
/**
* Default properties for an instance of CollectionItem.
* Override in subclasses to define different defaults.
* @returns {Object}
*/
static get defaults() {
return {
data: {}
};
}
/**
* @param {Object} env - The environment/context.
* @param {Object|null} [data=null] - Initial data for the item.
*/
constructor(env, data = null) {
env.create_env_getter(this);
this.config = this.env?.config;
this.merge_defaults();
if (data) deep_merge2(this.data, data);
if (!this.data.class_name) this.data.class_name = this.collection.item_class_name;
}
/**
* Loads an item from data and initializes it.
* @param {Object} env
* @param {Object} data
* @returns {CollectionItem}
*/
static load(env, data) {
const item = new this(env, data);
item.init();
return item;
}
/**
* Merge default properties from the entire inheritance chain.
* @private
*/
merge_defaults() {
let current_class = this.constructor;
while (current_class) {
for (let key in current_class.defaults) {
const default_val = current_class.defaults[key];
if (typeof default_val === "object") {
this[key] = { ...default_val, ...this[key] };
} else {
this[key] = this[key] === void 0 ? default_val : this[key];
}
}
current_class = Object.getPrototypeOf(current_class);
}
}
/**
* Generates or retrieves a unique key for the item.
* Key syntax supports:
* - `[i]` for sequences
* - `/` for super-sources (groups, directories, clusters)
* - `#` for sub-sources (blocks)
* @returns {string} The unique key
*/
get_key() {
return create_uid2(this.data);
}
/**
* Updates the item data and returns true if changed.
* @param {Object} data
* @returns {boolean} True if data changed.
*/
update_data(data) {
const sanitized_data = this.sanitize_data(data);
const current_data = { ...this.data };
deep_merge2(current_data, sanitized_data);
const changed = !deep_equal2(this.data, current_data);
if (!changed) return false;
this.data = current_data;
return true;
}
/**
* Sanitizes data for saving. Ensures no circular references.
* @param {*} data
* @returns {*} Sanitized data.
*/
sanitize_data(data) {
if (data instanceof _CollectionItem) return data.ref;
if (Array.isArray(data)) return data.map((val) => this.sanitize_data(val));
if (typeof data === "object" && data !== null) {
return Object.keys(data).reduce((acc, key) => {
acc[key] = this.sanitize_data(data[key]);
return acc;
}, {});
}
return data;
}
/**
* Initializes the item. Override as needed.
* @param {Object} [input_data] - Additional data that might be provided on creation.
*/
init(input_data) {
}
/**
* Queues this item for saving.
*/
queue_save() {
this._queue_save = true;
}
/**
* Saves this item using its data adapter.
* @returns {Promise<void>}
*/
async save() {
try {
await this.data_adapter.save_item(this);
this.init();
} catch (err) {
this._queue_save = true;
console.error(err, err.stack);
}
}
/**
* Queues this item for loading.
*/
queue_load() {
this._queue_load = true;
}
/**
* Loads this item using its data adapter.
* @returns {Promise<void>}
*/
async load() {
try {
await this.data_adapter.load_item(this);
this.init();
} catch (err) {
this._load_error = err;
this.on_load_error(err);
}
}
/**
* Handles load errors by re-queuing for load.
* Override if needed.
* @param {Error} err
*/
on_load_error(err) {
this.queue_load();
}
/**
* Validates the item before saving. Checks for presence and validity of key.
* @deprecated should be better handled 2025-12-17 (wrong scope?)
* @returns {boolean}
*/
validate_save() {
if (!this.key) return false;
if (this.key.trim() === "") return false;
if (this.key === "undefined") return false;
return true;
}
/**
* Marks this item as deleted. This does not immediately remove it from memory,
* but queues a save that will result in the item being removed from persistent storage.
*/
delete() {
this.deleted = true;
this.queue_save();
}
/**
* Filters items in the collection based on provided options.
* functional filter (returns true or false) for filtering items in collection; called by collection class
* @param {Object} filter_opts - Filtering options.
* @param {string} [filter_opts.exclude_key] - A single key to exclude.
* @param {string[]} [filter_opts.exclude_keys] - An array of keys to exclude. If exclude_key is provided, it's added to this array.
* @param {string} [filter_opts.exclude_key_starts_with] - Exclude keys starting with this string.
* @param {string[]} [filter_opts.exclude_key_starts_with_any] - Exclude keys starting with any of these strings.
* @param {string} [filter_opts.exclude_key_includes] - Exclude keys that include this string.
* @param {string[]} [filter_opts.exclude_key_includes_any] - Exclude keys that include any of these strings.
* @param {string} [filter_opts.exclude_key_ends_with] - Exclude keys ending with this string.
* @param {string[]} [filter_opts.exclude_key_ends_with_any] - Exclude keys ending with any of these strings.
* @param {string} [filter_opts.key_ends_with] - Include only keys ending with this string.
* @param {string} [filter_opts.key_starts_with] - Include only keys starting with this string.
* @param {string[]} [filter_opts.key_starts_with_any] - Include only keys starting with any of these strings.
* @param {string} [filter_opts.key_includes] - Include only keys that include this string.
* @returns {boolean} True if the item passes the filter, false otherwise.
*/
filter(filter_opts = {}) {
const {
exclude_key,
exclude_keys = exclude_key ? [exclude_key] : [],
exclude_key_starts_with,
exclude_key_starts_with_any,
exclude_key_includes,
exclude_key_includes_any,
exclude_key_ends_with,
exclude_key_ends_with_any,
key_ends_with,
key_starts_with,
key_starts_with_any,
key_includes,
key_includes_any
} = filter_opts;
if (exclude_keys?.includes(this.key)) return false;
if (exclude_key_starts_with && this.key.startsWith(exclude_key_starts_with)) return false;
if (exclude_key_starts_with_any && exclude_key_starts_with_any.some((prefix) => this.key.startsWith(prefix))) return false;
if (exclude_key_includes && this.key.includes(exclude_key_includes)) return false;
if (exclude_key_includes_any && exclude_key_includes_any.some((include) => this.key.includes(include))) return false;
if (exclude_key_ends_with && this.key.endsWith(exclude_key_ends_with)) return false;
if (exclude_key_ends_with_any && exclude_key_ends_with_any.some((suffix) => this.key.endsWith(suffix))) return false;
if (key_ends_with && !this.key.endsWith(key_ends_with)) return false;
if (key_starts_with && !this.key.startsWith(key_starts_with)) return false;
if (key_starts_with_any && !key_starts_with_any.some((prefix) => this.key.startsWith(prefix))) return false;
if (key_includes && !this.key.includes(key_includes)) return false;
if (key_includes_any && !key_includes_any.some((include) => this.key.includes(include))) return false;
return true;
}
filter_and_score(params = {}) {
if (this.filter(params.filter) === false) return null;
return this.score(params);
}
score(params = {}) {
const score_action = this.actions[params.score_algo_key];
if (typeof score_action !== "function") throw new Error(`Missing score action: ${params.score_algo_key}`);
return {
...score_action(params) || {},
item: this
};
}
/**
* Parses item data for additional processing. Override as needed.
* @deprecated is this used anywhere?
*/
parse() {
}
get actions() {
if (!this._actions) {
this._actions = create_actions_proxy2(this, {
...this.env.config.actions || {},
...this.env.opts.items?.[this.item_type_key]?.actions || {}
});
}
return this._actions;
}
/**
* Derives the collection key from the class name.
* @returns {string}
*/
static get collection_key() {
let name = this.name;
if (name.match(/\d$/)) name = name.slice(0, -1);
return collection_instance_name_from2(name);
}
/**
* @returns {string} The collection key for this item.
*/
get collection_key() {
let name = this.constructor.name;
if (name.match(/\d$/)) name = name.slice(0, -1);
return collection_instance_name_from2(name);
}
/**
* Retrieves the parent collection from the environment.
* @returns {Collection}
*/
get collection() {
return this.env[this.collection_key];
}
/**
* @returns {string} The item's key.
*/
get key() {
return this.data?.key || this.get_key();
}
get item_type_key() {
let name = this.constructor.name;
if (name.match(/\d$/)) name = name.slice(0, -1);
return camel_case_to_snake_case2(name);
}
/**
* Emits an event with item metadata.
*
* @param {string} event_key
* @param {Object} [payload={}]
* @returns {void}
*/
emit_event(event_key, payload = {}) {
this.env.events?.emit(event_key, { collection_key: this.collection_key, item_key: this.key, ...payload });
}
on_event(event_key, callback) {
return this.env.events?.on(event_key, (payload) => {
if (payload?.item_key && payload.item_key !== this.key) return;
callback(payload);
});
}
once_event(event_key, callback) {
return this.env.events?.once(event_key, (payload) => {
if (payload?.item_key && payload.item_key !== this.key) return;
callback(payload);
});
}
/**
* @returns {Object} The data adapter for this item's collection.
*/
get data_adapter() {
return this.collection.data_adapter;
}
/**
* @returns {Object} The filesystem adapter.
*/
get data_fs() {
return this.collection.data_fs;
}
/**
* Access to collection-level settings.
* @returns {Object}
*/
get settings() {
if (!this.env.settings[this.collection_key]) this.env.settings[this.collection_key] = {};
return this.env.settings[this.collection_key];
}
set settings(settings) {
this.env.settings[this.collection_key] = settings;
this.env.smart_settings.save();
}
/**
* A simple reference object for this item.
* @deprecated 2025-11-11 lacks adoption
* @returns {{collection_key: string, key: string}}
*/
get ref() {
return { collection_key: this.collection_key, key: this.key };
}
/**
* @deprecated use env.smart_components~~env.smart_view~~ instead
*/
get smart_view() {
if (!this._smart_view) this._smart_view = this.env.init_module("smart_view");
return this._smart_view;
}
/**
* Retrieves the display name of the collection item.
* @readonly
* @deprecated Use `get_item_display_name(key, show_full_path)` instead (keep UI logic out of collections).
* @returns {string} The display name.
*/
get name() {
return get_item_display_name2(
this.key,
this.env.settings.smart_view_filter?.show_full_path
);
}
};

var AsyncFunction2 = Object.getPrototypeOf(async function() {
}).constructor;
var Collection2 = class {
static {
__name(this, "Collection");
}
static version = 1e-3;
/**
* Constructs a new Collection instance.
*
* @param {Object} env - The environment context containing configurations and adapters.
* @param {Object} [opts={}] - Optional configuration.
* @param {string} [opts.collection_key] - Custom key to override default collection name.
* @param {string} [opts.data_dir] - Custom data directory path.
*/
constructor(env, opts = {}) {
env.create_env_getter(this);
this.opts = opts;
if (opts.collection_key) this.collection_key = opts.collection_key;
this.env[this.collection_key] = this;
this.config = this.env.config;
this.items = {};
this.loaded = null;
this._loading = false;
this.load_time_ms = null;
this.settings_container = null;
}
/**
* Initializes a new collection in the environment. Override in subclass if needed.
*
* @param {Object} env
* @param {Object} [opts={}]
* @returns {Promise<void>}
*/
static async init(env, opts = {}) {
env[this.collection_key] = new this(env, opts);
await env[this.collection_key].init();
env.collections[this.collection_key] = "init";
}
/**
* The unique collection key derived from the class name.
* @returns {string}
*/
static get collection_key() {
let name = this.name;
if (name.match(/\d$/)) name = name.slice(0, -1);
return name.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
}
/**
* Instance-level init. Override in subclasses if necessary.
* @returns {Promise<void>}
*/
async init() {
}
/**
* Creates or updates an item in the collection.
* - If `data` includes a key that matches an existing item, that item is updated.
* - Otherwise, a new item is created.
* After updating or creating, the item is validated. If validation fails, the item is logged and returned without being saved.
* If validation succeeds for a new item, it is added to the collection and marked for saving.
*
* If the item’s `init()` method is async, a promise is returned that resolves once init completes.
*
* NOTE: wrapping in try/catch seems to fail to catch errors thrown in async init functions when awaiting create_or_update
*
* @param {Object} [data={}] - Data for creating/updating an item.
* @returns {Promise<Item>|Item} The created or updated item. May return a promise if `init()` is async.
*/
create_or_update(data = {}) {
const existing_item = this.find_by(data);
const item = existing_item ? existing_item : new this.item_type(this.env);
item._queue_save = !existing_item;
const data_changed = item.update_data(data);
if (!existing_item && !item.validate_save()) {
return item;
}
if (!existing_item) {
this.set(item);
}
if (existing_item && !data_changed) return existing_item;
if (item.init instanceof AsyncFunction2) {
return new Promise((resolve) => {
item.init(data).then(() => resolve(item));
});
}
item.init(data);
return item;
}
/**
* Finds an item by partial data match (first checks key). If `data.key` provided,
* returns the item with that key; otherwise attempts a match by merging data.
*
* @param {Object} data - Data to match against.
* @returns {Item|null}
*/
find_by(data) {
if (data.key) return this.get(data.key);
const temp = new this.item_type(this.env);
const temp_data = JSON.parse(JSON.stringify(data, temp.sanitize_data(data)));
deep_merge2(temp.data, temp_data);
return temp.key ? this.get(temp.key) : null;
}
/**
* Filters items based on provided filter options or a custom function.
*
* @param {Object|Function} [filter_opts={}] - Filter options or a predicate function.
* @returns {Item[]} Array of filtered items.
*/
filter(filter_opts = {}) {
if (typeof filter_opts === "function") {
return Object.values(this.items).filter(filter_opts);
}
const results = [];
const { first_n } = filter_opts;
for (const item of Object.values(this.items)) {
if (first_n && results.length >= first_n) break;
if (item.filter(filter_opts)) results.push(item);
}
return results;
}
/**
* Alias for `filter()`
* @param {Object|Function} filter_opts
* @returns {Item[]}
*/
list(filter_opts) {
return this.filter(filter_opts);
}
/**
* Retrieves an item by key.
* @param {string} key
* @returns {Item|undefined}
*/
get(key) {
return this.items[key];
}
/**
* Retrieves multiple items by an array of keys.
* @param {string[]} keys
* @returns {Item[]}
*/
get_many(keys = []) {
if (!Array.isArray(keys)) {
console.error("get_many called with non-array keys:", keys);
return [];
}
return keys.map((key) => this.get(key)).filter(Boolean);
}
/**
* Retrieves a random item from the collection, optionally filtered by options.
* @param {Object} [opts]
* @returns {Item|undefined}
*/
get_rand(opts = null) {
if (opts) {
const filtered = this.filter(opts);
return filtered[Math.floor(Math.random() * filtered.length)];
}
const keys = this.keys;
return this.items[keys[Math.floor(Math.random() * keys.length)]];
}
/**
* Adds or updates an item in the collection.
* @param {Item} item
*/
set(item) {
if (!item.key) throw new Error("Item must have a key property");
this.items[item.key] = item;
}
/**
* Updates multiple items by their keys.
* @param {string[]} keys
* @param {Object} data
*/
update_many(keys = [], data = {}) {
this.get_many(keys).forEach((item) => item.update_data(data));
}
/**
* Clears all items from the collection.
*/
clear() {
this.items = {};
}
/**
* @returns {string} The collection key, can be overridden by opts.collection_key
*/
get collection_key() {
return this._collection_key ? this._collection_key : this.constructor.collection_key;
}
set collection_key(key) {
this._collection_key = key;
}
/**
* Lazily initializes and returns the data adapter instance for this collection.
* @returns {Object} The data adapter instance.
*/
get data_adapter() {
if (!this._data_adapter) {
const AdapterClass = this.get_adapter_class("data");
this._data_adapter = new AdapterClass(this);
}
return this._data_adapter;
}
get_adapter_class(type) {
const config = this.env.opts.collections?.[this.collection_key];
const adapter_key = type + "_adapter";
const adapter_module = config?.[adapter_key] ?? this.env.opts.collections?.smart_collections?.[adapter_key];
if (typeof adapter_module === "function") return adapter_module;
if (typeof adapter_module?.collection === "function") return adapter_module.collection;
throw new Error(`No '${type}' adapter class found for ${this.collection_key} or smart_collections`);
}
/**
* Data directory strategy for this collection. Defaults to 'multi'.
* @deprecated should be handled in adapters (2025-12-09)
* @returns {string}
*/
get data_dir() {
return this.collection_key;
}
/**
* File system adapter from the environment.
* @returns {Object}
*/
get data_fs() {
return this.env.data_fs;
}
/**
* Derives the corresponding item class name based on this collection's class name.
* @returns {string}
*/
get item_class_name() {
let name = this.constructor.name;
if (name.match(/\d$/)) name = name.slice(0, -1);
if (name.endsWith("ies")) return name.slice(0, -3) + "y";
else if (name.endsWith("s")) return name.slice(0, -1);
return name + "Item";
}
/**
* Derives a readable item name from the item class name.
* @returns {string}
*/
get item_name() {
return this.item_class_name.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
}
/**
* Retrieves the item type (constructor) from the environment.
* @deprecated replace with item_class with strict adherence to conventions (2025-10-28)
* @returns {Function} Item constructor.
*/
get item_type() {
if (!this._item_type) this._item_type = this.resolve_item_type();
return this._item_type;
}
resolve_item_type() {
const available = [
this.env.config?.items?.[this.item_name],
this.opts.item_type,
this.env.item_types?.[this.item_class_name]
].filter(Boolean).sort((a, b) => {
const a_version = a?.class?.version || a.version || 0;
const b_version = b?.class?.version || b.version || 0;
return b_version - a_version;
});
if (available.length === 0) {
throw new Error(`No item_type found for collection '${this.collection_key}' with item_name '${this.item_name}' or class_name '${this.item_class_name}'`);
}
return available[0].class || available[0];
}
/**
* Returns an array of all keys in the collection.
* @returns {string[]}
*/
get keys() {
return Object.keys(this.items);
}
/**
* @deprecated use data_adapter instead (2024-09-14)
*/
get adapter() {
return this.data_adapter;
}
/**
* @method process_save_queue
* @description
* Saves items flagged for saving (_queue_save) back to AJSON or SQLite. This ensures persistent storage
* of any updates made since last load/import. This method also writes changes to disk (AJSON files or DB).
*/
async process_save_queue(opts = {}) {
if (opts.force) {
Object.values(this.items).forEach((item) => item._queue_save = true);
}
await this.data_adapter.process_save_queue(opts);
}
/**
* @alias process_save_queue
* @returns {Promise<void>}
*/
async save(opts = {}) {
await this.process_save_queue(opts);
}
/**
* @method process_load_queue
* @description
* Loads items that have been flagged for loading (_queue_load). This may involve
* reading from AJSON/SQLite or re-importing from markdown if needed.
* Called once initial environment is ready and collections are known.
*/
async process_load_queue() {
await this.data_adapter.process_load_queue();
}
/**
* Retrieves processed settings configuration.
* @returns {Object}
*/
get settings_config() {
return this.process_settings_config({});
}
/**
* Processes given settings config, adding prefixes and handling conditionals.
* @deprecated removing settings_config from collections (2025-11-24)
*
* @private
* @param {Object} _settings_config
* @param {string} [prefix='']
* @returns {Object}
*/
process_settings_config(_settings_config, prefix = "") {
const add_prefix = /* @__PURE__ */ __name((key) => prefix && !key.includes(`${prefix}.`) ? `${prefix}.${key}` : key, "add_prefix");
return Object.entries(_settings_config).reduce((acc, [key, val]) => {
let new_val = { ...val };
if (new_val.conditional) {
if (!new_val.conditional(this)) return acc;
delete new_val.conditional;
}
if (new_val.callback) new_val.callback = add_prefix(new_val.callback);
if (new_val.btn_callback) new_val.btn_callback = add_prefix(new_val.btn_callback);
if (new_val.options_callback) new_val.options_callback = add_prefix(new_val.options_callback);
const new_key = add_prefix(this.process_setting_key(key));
acc[new_key] = new_val;
return acc;
}, {});
}
/**
* Processes an individual setting key. Override if needed.
* @param {string} key
* @returns {string}
*/
process_setting_key(key) {
return key;
}
/**
* Default settings for this collection. Override in subclasses as needed.
* @returns {Object}
*/
get default_settings() {
return {};
}
/**
* Current settings for the collection.
* Initializes with default settings if none exist.
* @returns {Object}
*/
get settings() {
if (!this.env.settings[this.collection_key]) {
this.env.settings[this.collection_key] = this.default_settings;
}
return this.env.settings[this.collection_key];
}
/**
* Unloads collection data from memory.
*/
unload() {
this.clear();
this.unloaded = true;
this.env.collections[this.collection_key] = null;
}
/**
* Displays a process notice if the operation exceeds one second.
*
* @param {string} process - Identifier for the ongoing process.
* @param {Object} [opts={}] - Additional options passed to the notice.
*/
show_process_notice(process, opts = {}) {
if (!this.debounce_process_notice) this.debounce_process_notice = {};
this.debounce_process_notice[process] = setTimeout(() => {
this.debounce_process_notice[process] = null;
this.env.notices?.show(process, { collection_key: this.collection_key, ...opts });
}, 1e3);
}
/**
* Clears any pending process notice timers and removes active notices.
*
* @param {string} process - Identifier for the process notice to clear.
*/
clear_process_notice(process) {
if (this.debounce_process_notice?.[process]) {
clearTimeout(this.debounce_process_notice[process]);
this.debounce_process_notice[process] = null;
} else {
this.env.notices?.remove(process);
}
}
/**
* Emits an event with collection metadata.
*
* @param {string} event_key
* @param {Object} [payload={}]
* @returns {void}
*/
emit_event(event_key, payload = {}) {
this.env.events?.emit(event_key, { collection_key: this.collection_key, ...payload });
}
on_event(event_key, callback) {
return this.env.events?.on(event_key, (payload) => {
if (payload?.collection_key && payload.collection_key !== this.collection_key) return;
callback(payload);
});
}
/**
* Lazily binds action functions to the collection instance.
*
* @returns {Object} Bound action functions keyed by name.
*/
get actions() {
if (!this.constructor.key) this.constructor.key = this.collection_key;
if (!this._actions) {
const actions_modules = {
...this.env?.config?.actions || {},
...this.env?.config?.collections?.[this.collection_key]?.actions || {},
...this.env?.opts?.collections?.[this.collection_key]?.actions || {},
...this.opts?.actions || {}
};
this._actions = create_actions_proxy2(this, actions_modules);
}
return this._actions;
}
/**
* Clears cached actions proxy and rebuilds on next access.
* @returns {Object} Rebuilt proxy with latest source snapshot.
*/
refresh_actions() {
this._actions = null;
return this.actions;
}
queue_save() {
if (this._debounce_queue_save) clearTimeout(this._debounce_queue_save);
this._debounce_queue_save = setTimeout(() => {
this.process_save_queue();
}, 750);
}
/**
* @deprecated use env.smart_components~~env.smart_view~~ instead
* @returns {Object} smart_view instance
*/
get smart_view() {
if (!this._smart_view) this._smart_view = this.env.init_module("smart_view");
return this._smart_view;
}
/**
* Renders the settings for the collection into a given container.
* @deprecated use env.render_component('collection_settings', this) instead (2025-05-25: decouple UI from collections)
* @param {HTMLElement} [container=this.settings_container]
* @param {Object} opts
* @returns {Promise<HTMLElement>}
*/
async render_settings(container = this.settings_container, opts = {}) {
return await this.render_collection_settings(container, opts);
}
/**
* Helper function to render collection settings.
* @deprecated use env.render_component('collection_settings', this) instead (2025-05-25: decouple UI from collections)
* @param {HTMLElement} [container=this.settings_container]
* @param {Object} opts
* @returns {Promise<HTMLElement>}
*/
async render_collection_settings(container = this.settings_container, opts = {}) {
if (container && (!this.settings_container || this.settings_container !== container)) {
this.settings_container = container;
} else if (!container) {
container = this.env.smart_view.create_doc_fragment("<div></div>");
}
this.env.smart_view.safe_inner_html(container, `<div class="sc-loading">Loading ${this.collection_key} settings...</div>`);
const frag = await this.env.render_component("settings", this, opts);
this.env.smart_view.empty(container);
container.appendChild(frag);
return container;
}
};

var CollectionDataAdapter2 = class {
static {
__name(this, "CollectionDataAdapter");
}
/**
* @constructor
* @param {Object} collection - The collection instance that this adapter manages.
*/
constructor(collection) {
this.collection = collection;
this.env = collection.env;
}
/**
* The class to use for item adapters.
* @type {typeof ItemDataAdapter}
*/
ItemDataAdapter = ItemDataAdapter2;
/**
* Optional factory method to create item adapters.
* If `this.item_adapter_class` is not null, it uses that; otherwise can be overridden by subclasses.
* @param {Object} item - The item to create an adapter for.
* @returns {ItemDataAdapter}
*/
create_item_adapter(item) {
if (!this.ItemDataAdapter) {
throw new Error("No item_adapter_class specified and create_item_adapter not overridden.");
}
return new this.ItemDataAdapter(item);
}
/**
* Load a single item by its key using an `ItemDataAdapter`.
* @async
* @abstract
* @param {string} key - The key of the item to load.
* @returns {Promise<void>} Resolves when the item is loaded.
*/
async load_item(key) {
throw new Error("Not implemented");
}
/**
* Save a single item by its key using its associated `ItemDataAdapter`.
* @async
* @abstract
* @param {string} key - The key of the item to save.
* @returns {Promise<void>} Resolves when the item is saved.
*/
async save_item(key) {
throw new Error("Not implemented");
}
/**
* Delete a single item by its key. This may involve updating or removing its file,
* as handled by the `ItemDataAdapter`.
* @async
* @abstract
* @param {string} key - The key of the item to delete.
* @returns {Promise<void>} Resolves when the item is deleted.
*/
async delete_item(key) {
throw new Error("Not implemented");
}
/**
* Process any queued load operations. Typically orchestrates calling `load_item()`
* on items that have been flagged for loading.
* @async
* @abstract
* @returns {Promise<void>}
*/
async process_load_queue() {
throw new Error("Not implemented");
}
/**
* Process any queued save operations. Typically orchestrates calling `save_item()`
* on items that have been flagged for saving.
* @async
* @abstract
* @returns {Promise<void>}
*/
async process_save_queue() {
throw new Error("Not implemented");
}
/**
* Load the item's data from storage if it has been updated externally.
* @async
* @param {string} key - The key of the item to load.
* @returns {Promise<void>} Resolves when the item is loaded.
*/
async load_item_if_updated(item) {
const adapter = this.create_item_adapter(item);
await adapter.load_if_updated();
}
/**
* Clear all data associated with this collection.
* @async
* @abstract
* @returns {Promise<void>}
*/
async clear_all() {
throw new Error("Not implemented");
}
};
var ItemDataAdapter2 = class {
static {
__name(this, "ItemDataAdapter");
}
/**
* @constructor
* @param {Object} item - The collection item instance that this adapter manages.
*/
constructor(item) {
this.item = item;
}
/**
* Load the item's data from storage. May involve reading a file and parsing
* its contents, then updating `item.data`.
* @async
* @abstract
* @returns {Promise<void>} Resolves when the item is fully loaded.
*/
async load() {
throw new Error("Not implemented");
}
/**
* Save the item's data to storage. May involve writing to a file or appending
* lines in an append-only format.
* @async
* @abstract
* @param {string|null} [ajson=null] - An optional serialized representation of the item’s data.
*                                     If not provided, the adapter should derive it from the item.
* @returns {Promise<void>} Resolves when the item is saved.
*/
async save(ajson = null) {
throw new Error("Not implemented");
}
/**
* Delete the item's data from storage. May involve removing a file or writing
* a `null` entry in an append-only file to signify deletion.
* @async
* @abstract
* @returns {Promise<void>} Resolves when the item’s data is deleted.
*/
async delete() {
throw new Error("Not implemented");
}
/**
* Returns the file path or unique identifier used by this adapter to locate and store
* the item's data. This may be a file name derived from the item's key.
* @abstract
* @returns {string} The path or identifier for the item's data.
*/
get data_path() {
throw new Error("Not implemented");
}
/**
* @returns {CollectionDataAdapter} The collection data adapter that this item data adapter belongs to.
*/
get collection_adapter() {
return this.item.collection.data_adapter;
}
get env() {
return this.item.env;
}
/**
* Load the item's data from storage if it has been updated externally.
* @async
* @abstract
* @returns {Promise<void>} Resolves when the item is loaded.
*/
async load_if_updated() {
throw new Error("Not implemented");
}
};

var FileCollectionDataAdapter2 = class extends CollectionDataAdapter2 {
static {
__name(this, "FileCollectionDataAdapter");
}
/**
* The class to use for item adapters.
* @type {typeof ItemDataAdapter}
*/
ItemDataAdapter = FileItemDataAdapter2;
/**
* @returns {Object} Filesystem interface derived from environment or collection settings.
*/
get fs() {
return this.collection.data_fs || this.collection.env.data_fs;
}
async clear_all() {
await this.fs.remove_dir(this.collection.data_dir, true);
}
};
var FileItemDataAdapter2 = class extends ItemDataAdapter2 {
static {
__name(this, "FileItemDataAdapter");
}
/**
* @returns {Object} Filesystem interface derived from environment or collection settings.
*/
get fs() {
return this.item.collection.data_fs || this.item.collection.env.data_fs;
}
/**
* Resolve the file path for the item's data.
* @abstract
* @returns {string} Path to the persisted item data.
*/
get data_path() {
throw new Error("Not implemented");
}
async load_if_updated() {
const data_path = this.data_path;
if (await this.fs.exists(data_path)) {
const loaded_at = this.item.loaded_at || 0;
const data_file_stat = await this.fs.stat(data_path);
if (data_file_stat.mtime > loaded_at + 1 * 60 * 1e3) {
console.log(`Smart Collections: Re-loading item ${this.item.key} because it has been updated on disk`);
await this.load();
}
}
}
};

var class_to_collection_key3 = {
"SmartSource": "smart_sources",
"SmartNote": "smart_sources",
"SmartBlock": "smart_blocks",
"SmartDirectory": "smart_directories"
};
var AjsonMultiFileCollectionDataAdapter2 = class extends FileCollectionDataAdapter2 {
static {
__name(this, "AjsonMultiFileCollectionDataAdapter");
}
/**
* The class to use for item adapters.
* @type {typeof ItemDataAdapter}
*/
ItemDataAdapter = AjsonMultiFileItemDataAdapter2;
/**
* Load a single item by its key.
* @async
* @param {string} key
* @returns {Promise<void>}
*/
async load_item(key) {
const item = this.collection.get(key);
if (!item) return;
const adapter = this.create_item_adapter(item);
await adapter.load();
}
/**
* Save a single item by its key.
* @async
* @param {string} key
* @returns {Promise<void>}
*/
async save_item(key) {
const item = this.collection.get(key);
if (!item) return;
const adapter = this.create_item_adapter(item);
await adapter.save();
}
/**
* Process any queued load operations.
* @async
* @returns {Promise<void>}
*/
async process_load_queue() {
this.collection.emit_event("collection:load_started");
this.collection.show_process_notice("loading_collection");
if (!await this.fs.exists(this.collection.data_dir)) {
await this.fs.mkdir(this.collection.data_dir);
}
const load_queue = Object.values(this.collection.items).filter((item) => item._queue_load);
if (!load_queue.length) {
this.collection.clear_process_notice("loading_collection");
return;
}
const now = Date.now();
console.log(`Loading ${this.collection.collection_key}: ${load_queue.length} items from disk`);
const batch_size = 100;
for (let i = 0; i < load_queue.length; i += batch_size) {
const batch = load_queue.slice(i, i + batch_size);
await Promise.all(batch.map((item) => {
const adapter = this.create_item_adapter(item);
return adapter.load().catch((err) => {
console.warn(`Error loading item ${item.key}`, err);
item.queue_load();
});
}));
}
console.log(`Loaded ${this.collection.collection_key} from disk in ${Date.now() - now}ms`);
this.collection.loaded = load_queue.length;
this.collection.clear_process_notice("loading_collection");
this.collection.emit_event("collection:load_completed");
}
/**
* Process any queued save operations.
* @async
* @returns {Promise<void>}
*/
async process_save_queue() {
this.collection.emit_event("collection:save_started");
this.collection.show_process_notice("saving_collection");
const save_queue = Object.values(this.collection.items).filter((item) => item._queue_save);
console.log(`Saving ${this.collection.collection_key}: ${save_queue.length} items`);
const time_start = Date.now();
const batch_size = 50;
for (let i = 0; i < save_queue.length; i += batch_size) {
const batch = save_queue.slice(i, i + batch_size);
await Promise.all(batch.map((item) => {
const adapter = this.create_item_adapter(item);
return adapter.save().catch((err) => {
console.warn(`Error saving item ${item.key}`, err);
item.queue_save();
});
}));
}
const deleted_items = Object.values(this.collection.items).filter((item) => item.deleted);
if (deleted_items.length) {
deleted_items.forEach((item) => {
delete this.collection.items[item.key];
});
}
console.log(`Saved ${this.collection.collection_key} in ${Date.now() - time_start}ms`);
this.collection.clear_process_notice("saving_collection");
this.collection.emit_event("collection:save_completed");
}
get_item_data_path(key) {
return [
this.collection.data_dir || "multi",
this.fs?.sep || "/",
this.get_data_file_name(key) + ".ajson"
].join("");
}
/**
* Transforms the item key into a safe filename.
* Replaces spaces, slashes, and dots with underscores.
* @returns {string} safe file name
*/
get_data_file_name(key) {
return key.split("#")[0].replace(/[\s\/\.]/g, "_").replace(".md", "");
}
/**
* Build a single AJSON line for the given item and data.
* @param {Object} item
* @returns {string}
*/
get_item_ajson(item) {
const collection_key = item.collection_key;
const key = item.key;
const data_value = item.deleted ? "null" : JSON.stringify(item.data);
return `${JSON.stringify(`${collection_key}:${key}`)}: ${data_value},`;
}
};
var AjsonMultiFileItemDataAdapter2 = class extends FileItemDataAdapter2 {
static {
__name(this, "AjsonMultiFileItemDataAdapter");
}
/**
* Derives the `.ajson` file path from the collection's data_dir and item key.
* @returns {string}
*/
get data_path() {
return this.collection_adapter.get_item_data_path(this.item.key);
}
/**
* Load the item from its `.ajson` file.
* @async
* @returns {Promise<void>}
*/
async load() {
try {
const raw_data = await this.fs.adapter.read(this.data_path, "utf-8", { no_cache: true });
if (!raw_data) {
this.item.queue_import();
return;
}
const { rewrite, file_data } = this._parse(raw_data);
if (rewrite) {
if (file_data.length) await this.fs.write(this.data_path, file_data);
else await this.fs.remove(this.data_path);
}
const last_import_mtime = this.item.data.last_import?.at || 0;
if (last_import_mtime && this.item.init_file_mtime > last_import_mtime) {
this.item.queue_import();
}
} catch (e) {
this.item.queue_import();
}
}
/**
* Parse the entire AJSON content as a JSON object, handle legacy keys, and extract final state.
* @private
* @param {string} ajson
* @returns {boolean}
*/
_parse(ajson) {
try {
let rewrite = false;
if (!ajson.length) return false;
ajson = ajson.trim();
const original_line_count = ajson.split("\n").length;
const json_str = "{" + ajson.slice(0, -1) + "}";
const data = JSON.parse(json_str);
const entries = Object.entries(data);
for (let i = 0; i < entries.length; i++) {
const [ajson_key, value] = entries[i];
if (!value) {
delete data[ajson_key];
rewrite = true;
continue;
}
const { collection_key, item_key, changed } = this._parse_ajson_key(ajson_key);
if (changed) {
rewrite = true;
data[collection_key + ":" + item_key] = value;
delete data[ajson_key];
}
const collection = this.env[collection_key];
if (!collection) continue;
const existing_item = collection.get(item_key);
if (!value.key) value.key = item_key;
if (existing_item) {
existing_item.data = value;
existing_item._queue_load = false;
existing_item.loaded_at = Date.now();
} else {
const ItemClass = collection.item_type;
const new_item = new ItemClass(this.env, value);
new_item._queue_load = false;
new_item.loaded_at = Date.now();
collection.set(new_item);
}
}
if (rewrite || original_line_count > entries.length) {
rewrite = true;
}
return {
rewrite,
file_data: rewrite ? Object.entries(data).map(([key, value]) => `${JSON.stringify(key)}: ${JSON.stringify(value)},`).join("\n") : null
};
} catch (e) {
if (ajson.split("\n").some((line) => !line.endsWith(","))) {
console.warn("fixing trailing comma error");
ajson = ajson.split("\n").map((line) => line.endsWith(",") ? line : line + ",").join("\n");
return this._parse(ajson);
}
console.warn("Error parsing JSON:", e);
return { rewrite: true, file_data: null };
}
}
_parse_ajson_key(ajson_key) {
let changed;
let [collection_key, ...item_key] = ajson_key.split(":");
if (class_to_collection_key3[collection_key]) {
collection_key = class_to_collection_key3[collection_key];
changed = true;
}
return {
collection_key,
item_key: item_key.join(":"),
changed
};
}
/**
* Save the current state of the item by appending a new line to its `.ajson` file.
* @async
* @returns {Promise<void>}
*/
async save(retries = 0) {
try {
const ajson_line = this.get_item_ajson();
await this.fs.append(this.data_path, "\n" + ajson_line);
this.item._queue_save = false;
} catch (e) {
if (e.code === "ENOENT" && retries < 1) {
const dir = this.collection_adapter.collection.data_dir;
if (!await this.fs.exists(dir)) {
await this.fs.mkdir(dir);
}
return await this.save(retries + 1);
}
console.warn("Error saving item", this.data_path, this.item.key, e);
}
}
/**
* Build a single AJSON line for the given item and data.
* @param {Object} item
* @returns {string}
*/
get_item_ajson() {
return this.collection_adapter.get_item_ajson(this.item);
}
};

function ajson_merge2(existing, new_obj) {
if (new_obj === null) return null;
if (new_obj === void 0) return existing;
if (typeof new_obj !== "object") return new_obj;
if (typeof existing !== "object" || existing === null) existing = {};
const keys = Object.keys(new_obj);
const length = keys.length;
for (let i = 0; i < length; i++) {
const key = keys[i];
const new_val = new_obj[key];
const existing_val = existing[key];
if (Array.isArray(new_val)) {
existing[key] = new_val.slice();
} else if (is_object2(new_val)) {
existing[key] = ajson_merge2(is_object2(existing_val) ? existing_val : {}, new_val);
} else if (new_val !== void 0) {
existing[key] = new_val;
}
}
return existing;
}
__name(ajson_merge2, "ajson_merge");
function is_object2(obj) {
return obj !== null && typeof obj === "object" && !Array.isArray(obj);
}
__name(is_object2, "is_object");

var class_to_collection_key4 = {
"SmartSource": "smart_sources",
"SmartNote": "smart_sources",
"SmartBlock": "smart_blocks",
"SmartDirectory": "smart_directories"
};
function _parse_ajson_key2(ajson_key) {
let changed = false;
let [collection_key, ...item_key] = ajson_key.split(":");
if (class_to_collection_key4[collection_key]) {
collection_key = class_to_collection_key4[collection_key];
changed = true;
}
return {
collection_key,
item_key: item_key.join(":"),
changed
};
}
__name(_parse_ajson_key2, "_parse_ajson_key");
var AjsonSingleFileCollectionDataAdapter2 = class extends AjsonMultiFileCollectionDataAdapter2 {
static {
__name(this, "AjsonSingleFileCollectionDataAdapter");
}
/**
* Returns the single shared `.ajson` file path for this collection.
* @param {string} [key] - (unused) Item key, ignored in single-file mode.
* @returns {string} The single .ajson file path for the entire collection.
*/
get_item_data_path(key) {
const file_name = (this.collection?.collection_key || "collection") + ".ajson";
const sep = this.fs?.sep || "/";
const dir = this.collection.data_dir || "data";
return [dir, file_name].join(sep);
}
/**
* Override process_load_queue to parse the entire single-file .ajson once,
* distributing final states to items.
*
* @async
* @returns {Promise<void>}
*/
async process_load_queue() {
this.collection.emit_event("collection:load_started");
this.collection.show_process_notice("loading_collection");
if (!await this.fs.exists(this.collection.data_dir)) {
await this.fs.mkdir(this.collection.data_dir);
}
const path = this.get_item_data_path();
if (!await this.fs.exists(path)) {
for (const item of Object.values(this.collection.items)) {
if (item._queue_load) {
item.queue_import?.();
}
}
this.collection.clear_process_notice("loading_collection");
this.collection.emit_event("collection:load_halted");
return;
}
const raw_data = await this.fs.read(path, "utf-8", { no_cache: true });
if (!raw_data) {
for (const item of Object.values(this.collection.items)) {
if (item._queue_load) {
item.queue_import?.();
}
}
this.collection.clear_process_notice("loading_collection");
this.collection.emit_event("collection:load_halted");
return;
}
const { rewrite, file_data } = this.parse_single_file_ajson(raw_data);
if (rewrite) {
if (file_data.length) {
await this.fs.write(path, file_data);
} else {
await this.fs.remove(path);
}
}
for (const item of Object.values(this.collection.items)) {
item._queue_load = false;
item.loaded_at = Date.now();
}
this.collection.clear_process_notice("loading_collection");
this.collection.emit_event("collection:load_completed");
}
/**
* Helper to parse single-file .ajson content, distributing states to items.
*
* @param {string} raw
* @returns {{ rewrite: boolean, file_data: string }}
*/
parse_single_file_ajson(raw) {
let rewrite = false;
const lines = raw.trim().split("\n").filter(Boolean);
let data_map = {};
let line_count = 0;
for (let i = 0; i < lines.length; i++) {
const line = lines[i].trim();
if (!line.endsWith(",")) {
rewrite = true;
}
const trimmed = line.replace(/,$/, "");
const combined = "{" + trimmed + "}";
try {
const obj = JSON.parse(combined);
const [fullKey, value] = Object.entries(obj)[0];
let { collection_key, item_key, changed } = _parse_ajson_key2(fullKey);
const newKey = `${collection_key}:${item_key}`;
if (!value) {
delete data_map[newKey];
if (changed || newKey !== fullKey) {
delete data_map[fullKey];
}
rewrite = true;
} else {
data_map[newKey] = value;
if (changed || newKey !== fullKey) {
delete data_map[fullKey];
rewrite = true;
}
}
} catch (err) {
console.warn("parse error for line: ", line, err);
rewrite = true;
}
line_count++;
}
for (const [ajson_key, val] of Object.entries(data_map)) {
const [collection_key, ...rest] = ajson_key.split(":");
const item_key = rest.join(":");
const collection = this.collection.env[collection_key];
if (!collection) continue;
let item = collection.get(item_key);
if (!item) {
const ItemClass = collection.item_type;
item = new ItemClass(this.env, val);
collection.set(item);
} else {
item.data = ajson_merge2(item.data, val);
}
item.loaded_at = Date.now();
item._queue_load = false;
if (!val.key) val.key = item_key;
}
if (line_count > Object.keys(data_map).length) {
rewrite = true;
}
let minimal_lines = [];
for (const [ajson_key, val] of Object.entries(data_map)) {
minimal_lines.push(`${JSON.stringify(ajson_key)}: ${JSON.stringify(val)},`);
}
return {
rewrite,
file_data: minimal_lines.join("\n")
};
}
/**
* Override process_save_queue for single-file approach.
* We'll simply call save_item for each queued item, which appends a line to the same `.ajson`.
*
* @async
* @returns {Promise<void>}
*/
async process_save_queue() {
this.collection.emit_event("collection:save_started");
this.collection.show_process_notice("saving_collection");
const save_queue = Object.values(this.collection.items).filter((item) => item._queue_save);
const time_start = Date.now();
const batch_size = 50;
for (let i = 0; i < save_queue.length; i += batch_size) {
const batch = save_queue.slice(i, i + batch_size);
await Promise.all(batch.map((item) => {
const adapter = this.create_item_adapter(item);
return adapter.save().catch((err) => {
console.warn(`Error saving item ${item.key}`, err);
item.queue_save();
});
}));
}
const deleted_items = Object.values(this.collection.items).filter((item) => item.deleted);
if (deleted_items.length) {
deleted_items.forEach((item) => {
delete this.collection.items[item.key];
});
}
console.log(`Saved (single-file) ${this.collection.collection_key} in ${Date.now() - time_start}ms`);
this.collection.clear_process_notice("saving_collection");
this.collection.emit_event("collection:save_completed");
}
};
var AjsonSingleFileItemDataAdapter2 = class extends AjsonMultiFileItemDataAdapter2 {
static {
__name(this, "AjsonSingleFileItemDataAdapter");
}
/**
* Overridden to always return the single file path from the parent collection adapter.
* @returns {string}
*/
get data_path() {
return this.collection_adapter.get_item_data_path(this.item.key);
}
/**
* Load logic:
* In single-file mode, we typically rely on the collection's `process_load_queue()`
* to parse the entire file. This direct `load()` will do a naive re-parse as well
* if used individually.
*/
async load() {
const path = this.data_path;
if (!await this.fs.exists(path)) {
this.item.queue_import?.();
return;
}
try {
const raw_data = await this.fs.read(path, "utf-8", { no_cache: true });
if (!raw_data) {
this.item.queue_import?.();
return;
}
const { rewrite } = this.collection_adapter.parse_single_file_ajson(raw_data);
} catch (err) {
console.warn(`Error loading single-file item ${this.item.key}`, err);
this.item.queue_import?.();
}
}
};
var ajson_single_file_default2 = {
collection: AjsonSingleFileCollectionDataAdapter2,
item: AjsonSingleFileItemDataAdapter2
};

function stringify_cell(value) {
if (value == null) return "";
let str;
if (Array.isArray(value)) {
str = value.map((v) => v == null ? "" : String(v)).join(", ");
} else if (typeof value === "object") {
try {
str = JSON.stringify(value);
} catch {
str = String(value);
}
} else {
str = String(value);
}
if (str.startsWith("formula.")) str = str.replace("formula.", "");
if (str.startsWith("note.")) str = str.replace("note.", "");
if (str.startsWith("file.")) str = str.replace("file.", "");
return str.replace(/\|/g, "\\|").replace(/\r?\n/g, "<br>");
}
__name(stringify_cell, "stringify_cell");
function normalize_table(table) {
if (!Array.isArray(table) || table.length === 0) return [];
const rows = table.map((row) => Array.isArray(row) ? row : [row]);
const col_count = rows.reduce((m, r) => Math.max(m, r.length), 0);
return rows.map(
(row) => Array.from({ length: col_count }, (_, i) => stringify_cell(row[i]))
);
}
__name(normalize_table, "normalize_table");
function compute_col_widths(rows) {
if (rows.length === 0) return [];
const col_count = rows[0].length;
const widths = Array.from({ length: col_count }, () => 0);
rows.forEach((r) => {
for (let i = 0; i < col_count; i++) {
const len = (r[i] ?? "").length;
if (len > widths[i]) widths[i] = len;
}
});
return widths.map((w) => Math.max(w, 3));
}
__name(compute_col_widths, "compute_col_widths");
function pad_cell(cell, width) {
const value = cell ?? "";
if (value.length >= width) return value;
return value + " ".repeat(width - value.length);
}
__name(pad_cell, "pad_cell");
function build_row(cells, widths) {
const padded = cells.map((c, i) => pad_cell(c, widths[i]));
return `| ${padded.join(" | ")} |`;
}
__name(build_row, "build_row");
function to_markdown_table(table) {
const normalized = normalize_table(table);
if (normalized.length === 0) return "";
const widths = compute_col_widths(normalized);
const header = build_row(normalized[0], widths);
const separator_cells = widths.map((w) => "-".repeat(w));
const separator = build_row(separator_cells, widths);
const body = normalized.slice(1).map((r) => build_row(r, widths));
return [header, separator, ...body].join("\n");
}
__name(to_markdown_table, "to_markdown_table");
function get_value_from_path(obj, path) {
if (typeof path !== "string" || path.length === 0) return void 0;
return path.split(".").reduce((acc, key) => {
if (acc == null) return void 0;
if (key === "formula") {
return acc?.formulaResults?.cachedFormulaOutputs;
}
if (key === "note") {
return acc?.note?.data ?? acc?.note;
}
if (["size", "mtime", "ctime"].includes(key)) {
return acc?.stat?.[key];
}
if (key === "links") {
try {
const outlinks = globalThis.smart_env?.smart_sources?.get?.(obj?.file?.path)?.outlinks || [];
return outlinks.map((link) => `[[${link?.key ?? link}]]`).join(", ");
} catch {
return "";
}
}
if (key === "name") {
const name = acc?.name ?? "";
return `[[${name}]]`;
}
return acc?.[key];
}, obj);
}
__name(get_value_from_path, "get_value_from_path");
function is_bases_child(child) {
return child?.linkText?.includes(".base") ?? false;
}
__name(is_bases_child, "is_bases_child");
async function get_base_file_view(file_view, wait_ms = 300) {
await new Promise((resolve) => setTimeout(resolve, wait_ms));
const base_view = file_view?._children?.[0]?.view;
return base_view?.data ? base_view : null;
}
__name(get_base_file_view, "get_base_file_view");
function get_bases_output(base_view_data) {
const columns = base_view_data?.propertiesCache;
if (!Array.isArray(columns) || columns.length === 0) return [];
const groups = base_view_data?.groupedDataCache;
if (!Array.isArray(groups) || groups.length === 0) return [];
const last_group = groups[groups.length - 1];
if (!last_group || !Array.isArray(last_group.entries)) return [];
const header = columns.map((c) => c);
const rows = last_group.entries.map(
(row) => columns.map((c) => {
const val = get_value_from_path(row, c);
if (Array.isArray(val?.data) && typeof val.data?.[0]?.data === "string") {
return val.data.map((v) => v?.sourcePath ? `[[${v.data}]]` : v?.data ?? "").join(", ");
}
if (val && typeof val === "object" && "data" in val) return val.data ?? "";
if (typeof val !== "object") return val ?? "";
return "";
})
);
return [header, ...rows];
}
__name(get_bases_output, "get_bases_output");
function get_base_links(links_meta) {
if (!Array.isArray(links_meta)) return /* @__PURE__ */ new Set();
const link_targets = links_meta.map((link) => link?.link ?? link?.path ?? link?.displayText ?? link?.original ?? link?.rawText ?? "").filter((link_target) => typeof link_target === "string" && link_target.includes(".base"));
return new Set(link_targets);
}
__name(get_base_links, "get_base_links");
var BasesCache = class extends CollectionItem2 {
static {
__name(this, "BasesCache");
}
get collection() {
return this.env.bases_caches;
}
/**
* Convert cached bases output to a well-formatted markdown table.
*
* @returns {string}
*/
get markdown_table() {
const table = this.data?.bases_output;
return to_markdown_table(table);
}
};
var BasesCaches = class extends Collection2 {
static {
__name(this, "BasesCaches");
}
static version = 1;
#child_timer = null;
#child_watchers = /* @__PURE__ */ new Map();
#source_key = "";
#seen_children = /* @__PURE__ */ new WeakSet();
#active_base_view = null;
#scan_interval_ms = 200;
#max_child_poll_ms = 3e4;
#max_file_poll_ms = 3e4;
#watch_generation = 0;
#initialized = false;
init() {
if (this.#initialized) return;
this.#initialized = true;
const workspace = globalThis.app?.workspace;
if (!workspace) {
console.warn("BasesCaches.init: no app.workspace available");
return;
}
const handler = /* @__PURE__ */ __name(() => this.start_watchers(), "handler");
this.env.plugin.registerEvent(workspace.on("active-leaf-change", handler));
if (typeof this.env.plugin.register === "function") {
this.env.plugin.register(() => this.stop_watchers());
}
this.start_watchers();
}
/**
* Injectable seam for tests.
*
* @param {any} file_view
* @returns {Promise<any|null>}
*/
get_base_file_view(file_view) {
return get_base_file_view(file_view);
}
/**
* Begin watching the current file view for Bases embeds.
*/
start_watchers() {
this.stop_watchers();
const watch_generation = this.#watch_generation;
const file_view = globalThis.app?.workspace?.getActiveFileView?.();
if (!file_view) return console.warn("No file view");
const source = file_view.file ? this.env.smart_sources?.get(file_view.file.path) : null;
this.#source_key = source?.key || file_view.file?.path || "";
this.#seen_children = /* @__PURE__ */ new WeakSet();
this.prune_missing_base_caches({ source });
const editor = file_view?.editor?.editorComponent;
if (editor) {
const scan_children = /* @__PURE__ */ __name(() => {
if (watch_generation !== this.#watch_generation) return;
let children = [];
try {
children = editor._children || [];
} catch {
children = [];
}
const current_children = /* @__PURE__ */ new Set();
children.forEach((child) => {
if (!is_bases_child(child)) return;
current_children.add(child);
if (this.#seen_children.has(child)) return;
this.#seen_children.add(child);
this.watch_base_child(child, watch_generation);
});
this.sweep_orphan_watchers(current_children);
}, "scan_children");
scan_children();
this.#child_timer = this.set_interval(scan_children, this.#scan_interval_ms);
}
this.get_base_file_view(file_view).then((base_view) => {
if (watch_generation !== this.#watch_generation) return;
if (base_view) {
this.#active_base_view = base_view;
this.watch_base_file(base_view, watch_generation);
} else {
this.#active_base_view = null;
}
}).catch((err) => {
if (watch_generation !== this.#watch_generation) return;
console.warn("BasesCaches: get_base_file_view failed", err);
});
}
/**
* Schedule an interval. Override in tests.
*
* @param {Function} callback
* @param {number} delay
* @returns {any}
*/
set_interval(callback, delay) {
return setInterval(callback, delay);
}
/**
* Clear an interval. Override in tests.
*
* @param {any} id
*/
clear_interval(id) {
clearInterval(id);
}
/**
* Clear watchers for children that are no longer present or connected.
*
* Also clears any watcher created under an older watch_generation to prevent
* stale async/polling from leaking across leaf changes.
*
* @param {Set<any>} current_children
*/
sweep_orphan_watchers(current_children) {
const keep = new Set(current_children);
if (this.#active_base_view) keep.add(this.#active_base_view);
this.#child_watchers.forEach((meta, key) => {
if (meta?.generation !== this.#watch_generation) {
this.clear_interval(meta.id);
this.#child_watchers.delete(key);
return;
}
const still_present = keep.has(key);
let connected = true;
try {
const container = key?.containerEl || key?._children?.[0]?.viewContainerEl || key?.viewContainerEl || null;
if (container && typeof container.isConnected === "boolean") {
connected = container.isConnected;
}
} catch {
connected = false;
}
if (!still_present || !connected) {
this.clear_interval(meta.id);
this.#child_watchers.delete(key);
}
});
}
/**
* Watch a Bases child until its view data is available.
*
* @param {any} child
* @param {number} watch_generation
*/
watch_base_child(child, watch_generation = this.#watch_generation) {
if (this.#child_watchers.has(child)) return;
const embedded_path = child?.linkText ?? "";
const started_at = Date.now();
const poll = this.set_interval(() => {
if (watch_generation !== this.#watch_generation) {
this.clear_interval(poll);
this.#child_watchers.delete(child);
return;
}
const container = child?.containerEl || child?._children?.[0]?.viewContainerEl || null;
if (container && container.isConnected === false) {
this.clear_interval(poll);
this.#child_watchers.delete(child);
return;
}
if (Date.now() - started_at > this.#max_child_poll_ms) {
this.clear_interval(poll);
this.#child_watchers.delete(child);
return;
}
const base_view_data = child?._children?.[0]?.view?.data;
if (!base_view_data) return;
let bases_output = [];
try {
bases_output = get_bases_output(base_view_data);
} catch (err) {
console.warn("BasesCaches: get_bases_output failed for embedded base", err);
bases_output = [];
}
if (bases_output.length) {
this.clear_interval(poll);
this.#child_watchers.delete(child);
this.cache_bases_output({ key: `${this.#source_key}#${embedded_path}`, bases_output });
}
}, this.#scan_interval_ms);
this.#child_watchers.set(child, { id: poll, started: started_at, generation: watch_generation });
}
/**
* Watch an active Bases file view until its data is available.
*
* @param {any} base_view
* @param {number} watch_generation
*/
watch_base_file(base_view, watch_generation = this.#watch_generation) {
if (this.#child_watchers.has(base_view)) return;
const started_at = Date.now();
const poll = this.set_interval(() => {
if (watch_generation !== this.#watch_generation) {
this.clear_interval(poll);
this.#child_watchers.delete(base_view);
return;
}
const container = base_view?.containerEl || base_view?.viewContainerEl || null;
if (container && container.isConnected === false) {
this.clear_interval(poll);
this.#child_watchers.delete(base_view);
return;
}
if (Date.now() - started_at > this.#max_file_poll_ms) {
this.clear_interval(poll);
this.#child_watchers.delete(base_view);
return;
}
const data = base_view?.data;
if (!data) return;
let bases_output = [];
try {
bases_output = get_bases_output(data);
} catch (err) {
console.warn("BasesCaches: get_bases_output failed for base file", err);
bases_output = [];
}
if (bases_output.length) {
this.clear_interval(poll);
this.#child_watchers.delete(base_view);
this.cache_bases_output({ key: this.#source_key, bases_output });
}
}, this.#scan_interval_ms);
this.#child_watchers.set(base_view, { id: poll, started: started_at, generation: watch_generation });
}
/**
* Stop all active watchers and invalidate any pending async callbacks.
*/
stop_watchers() {
this.#watch_generation += 1;
if (this.#child_timer) {
this.clear_interval(this.#child_timer);
this.#child_timer = null;
}
this.#child_watchers.forEach((meta) => this.clear_interval(meta.id));
this.#child_watchers.clear();
this.#active_base_view = null;
}
/**
* Remove caches for bases no longer present in source links metadata.
*
* @param {Object} params
* @param {any} params.source
* @param {string} [params.source_key]
*/
prune_missing_base_caches(params = {}) {
const { source = null, source_key = this.#source_key } = params;
const meta_links = source?.data?.meta?.links || source?.meta?.links || [];
const base_links = get_base_links(meta_links);
if (!source_key) return;
const prefix = `${source_key}#`;
let deleted_any = false;
Object.entries(this.items).forEach(([key, item]) => {
if (!key.startsWith(prefix)) return;
const base_name = key.slice(prefix.length);
if (!base_links.has(base_name)) {
deleted_any = true;
item.delete();
}
});
if (deleted_any) this.process_save_queue();
}
/**
* Cache bases output in the collection and persist immediately.
*
* @param {Object} params
* @param {string} params.key
* @param {any[][]} params.bases_output
*/
cache_bases_output(params = {}) {
const { key, bases_output } = params;
if (!key || !Array.isArray(bases_output) || bases_output.length === 0) return;
const item = new BasesCache(this.env, { key, bases_output });
this.set(item);
item.queue_save();
this.process_save_queue();
}
};
var bases_caches_default = {
class: BasesCaches,
collection_key: "bases_caches",
data_adapter: AjsonSingleFileCollectionDataAdapter2,
item_type: BasesCache
};

var Model2 = class extends CollectionItem2 {
static {
__name(this, "Model");
}
/**
* Default properties for an instance of CollectionItem.
* @returns {Object}
*/
static get defaults() {
return {
data: {
api_key: "",
provider_key: "",
model_key: ""
}
};
}
get_key() {
if (!this.data.key) {
this.data.created_at = Date.now();
this.data.key = `${this.data.provider_key}#${this.data.created_at}`;
}
return this.data.key;
}
get provider_key() {
return this.data.provider_key;
}
get env_config() {
return this.collection.env_config;
}
get provider_config() {
return this.env_config.providers?.[this.provider_key] || {};
}
get ProviderAdapterClass() {
return this.provider_config.class;
}
get instance() {
if (!this._instance) {
if (!this.ProviderAdapterClass) {
const new_default_model = this.collection.new_model({ provider_key: this.collection.default_provider_key });
return new_default_model.instance;
}
const Class = this.ProviderAdapterClass;
this._instance = new Class(this);
this._instance.load();
this.once_event("model:changed", () => {
this._instance.unload?.();
this._instance = null;
});
}
return this._instance;
}
async count_tokens(text) {
return this.instance.count_tokens(text);
}
get api_key() {
return this.data.api_key;
}
/**
* Create (or reuse) a proxy around a target settings object so that
* any mutations trigger queue_save on the model.
* Proxies are cached per-target via WeakMap to support deep nested objects.
*
* @param {Object} target - The settings object or nested object to wrap.
* @returns {Object} Proxied object or original value if not an object.
* @private
*/
create_settings_proxy(target) {
if (!target || typeof target !== "object") return target;
if (!this._settings_proxy_map) {
this._settings_proxy_map = /* @__PURE__ */ new WeakMap();
}
const existing = this._settings_proxy_map.get(target);
if (existing) return existing;
const self = this;
const handler = {
get(target_obj, prop, receiver) {
const value = Reflect.get(target_obj, prop, receiver);
if (value && typeof value === "object") {
return self.create_settings_proxy(value);
}
return value;
},
set(target_obj, prop, value, receiver) {
const previous = target_obj[prop];
const result = Reflect.set(target_obj, prop, value, receiver);
if (previous !== value) {
self.debounce_save();
}
return result;
},
deleteProperty(target_obj, prop) {
const had = Object.prototype.hasOwnProperty.call(target_obj, prop);
const result = Reflect.deleteProperty(target_obj, prop);
if (had) {
self.debounce_save();
}
return result;
}
};
const proxy = new Proxy(target, handler);
this._settings_proxy_map.set(target, proxy);
return proxy;
}
debounce_save(ms = 100) {
this.emit_event("model:changed");
if (this._debounce_save_timeout) {
clearTimeout(this._debounce_save_timeout);
}
this._debounce_save_timeout = setTimeout(() => {
this.queue_save();
this.collection.process_save_queue();
this._debounce_save_timeout = null;
}, ms);
}
async get_model_key_options() {
const model_configs = await this.instance.get_models();
return Object.entries(model_configs).map(([key, model_config]) => ({
label: model_config.name || key,
value: model_config.key || key
})).sort((a, b) => {
if (a.label.toLowerCase().includes("free") && !b.label.toLowerCase().includes("free")) {
return -1;
}
if (!a.label.toLowerCase().includes("free") && b.label.toLowerCase().includes("free")) {
return 1;
}
return a.label.localeCompare(b.label);
});
}
model_changed(key, value, elm) {
if (key === "model_key") {
this.data.model_key = value;
const model_defaults = this.data.provider_models?.[this.data.model_key] || {};
const adapter_defaults = this.ProviderAdapterClass.defaults || {};
delete this.data.test_passed;
this.data = {
...this.data,
...adapter_defaults,
...model_defaults
};
}
if (!["api_key", "meta.name"].includes(key)) {
this.emit_event("model:changed");
}
}
/**
* @abstract should be implemented by subclasses
*/
async test_model() {
}
get display_name() {
return this.data.meta?.name || `${this.data.provider_key} - ${this.data.model_key}`;
}
get settings_config() {
return {
provider_key: {
type: "html",
value: `<p><strong>Provider:</strong> ${this.data.provider_key}</p>`
},
"meta.name": {
type: "text",
name: "Name",
description: "A friendly name for this model configuration."
},
model_key: {
type: "dropdown",
name: "Model",
description: "The model to use from the selected provider.",
options_callback: "get_model_key_options",
callback: "model_changed"
},
...Object.fromEntries(
Object.entries(this.provider_config.settings_config || {}).map(
([setting_key, setting_config]) => [setting_key, { ...setting_config, callback: setting_config.callback || "model_changed" }]
)
)
};
}
delete_model() {
this.delete();
this.debounce_save();
}
/**
* Reactive settings view for this model.
* Mutating any property (including nested objects/arrays) via this proxy
* will call queue_save().
*
* @returns {Object} Proxied view of this.data.
*/
get settings() {
return this.create_settings_proxy(this.data);
}
get model_key() {
return this.data.model_key;
}
/**
* @deprecated included for backward compatibility
*/
get opts() {
return this.settings;
}
};

var Models2 = class extends Collection2 {
static {
__name(this, "Models");
}
model_type = "Model type";
new_model(data = {}) {
if (!data.provider_key) throw new Error("provider_key is required to create a new model");
const existing_from_provider = this.filter((m) => m.provider_key === data.provider_key).sort((a, b) => b.data.created_at - a.data.created_at)[0];
if (existing_from_provider) {
if (!data.api_key && existing_from_provider.data.api_key) {
data.api_key = existing_from_provider.data.api_key;
}
}
const item = new this.item_type(this.env, {
...data
});
this.set(item);
this.settings.default_model_key = item.key;
this.emit_event("model:changed");
item.queue_save();
return item;
}
/**
* Retrieve the provider key used when creating a default model.
* @abstract
* @returns {string} provider key for the default model.
*/
get default_provider_key() {
throw new Error("default_provider_key not implemented");
}
get default_model_key() {
const should_update_default = !this.settings.default_model_key || !this.get(this.settings.default_model_key) || this.get(this.settings.default_model_key).deleted;
if (should_update_default) {
const existing = this.filter((m) => !m.deleted).sort((a, b) => b.data.created_at - a.data.created_at)[0];
if (existing) {
this.settings.default_model_key = existing.key;
} else {
const new_default = this.new_model({ provider_key: this.default_provider_key });
new_default.queue_save();
this.process_save_queue();
this.settings.default_model_key = new_default.key;
}
}
return this.settings.default_model_key;
}
get default() {
return this.get(this.default_model_key);
}
get env_config() {
return this.env.config.collections[this.collection_key];
}
get_model_key_options() {
return this.filter((i) => !i.deleted && i.ProviderAdapterClass).map((model) => ({
label: model.data.meta?.name || `${model.provider_key} - ${model.data.model_key}`,
value: model.key
}));
}
};
function settings_config10(scope) {
return {
default_model_key: {
type: "dropdown",
name: `Default ${scope.model_type.toLowerCase()} model`,
description: `Used as the default ${scope.model_type.toLowerCase()} model when no other is specified.`,
options_callback: /* @__PURE__ */ __name(() => {
return scope.get_model_key_options();
}, "options_callback"),
callback: /* @__PURE__ */ __name(async (value, setting) => {
scope.emit_event("model:changed");
}, "callback")
}
};
}
__name(settings_config10, "settings_config");

var ChatCompletionModel = class extends Model2 {
static {
__name(this, "ChatCompletionModel");
}
async complete(req) {
return this.instance.complete(req);
}
async stream(req, handlers = {}) {
return this.instance.stream(req, handlers);
}
async test_model() {
try {
const resp = await this.complete({
messages: [
{ role: "user", content: "2+2=" }
]
});
const success = !resp.error;
this.data.test_passed = success;
this.debounce_save();
return { success, response: resp };
} catch (e) {
this.data.test_passed = false;
return { error: e.message || String(e) };
}
}
};

var SmartHttpRequest2 = class {
static {
__name(this, "SmartHttpRequest");
}
/**
* @param {object} opts - Options for the SmartHttpRequest class
* @param {SmartHttpRequestAdapter} opts.adapter - The adapter constructor to use for making HTTP requests
* @param {Obsidian.requestUrl} opts.obsidian_request_adapter - For use with Obsidian adapter
*/
constructor(opts = {}) {
this.opts = opts;
if (!opts.adapter) throw new Error("HttpRequestAdapter is required");
this.adapter = new opts.adapter(this);
}
/**
* Returns a well-formed response object
* @param {object} request_params - Parameters for the HTTP request
* @param {string} request_params.url - The URL to make the request to
* @param {string} [request_params.method='GET'] - The HTTP method to use
* @param {object} [request_params.headers] - Headers to include in the request
* @param {*} [request_params.body] - The body of the request (for POST, PUT, etc.)
* @returns {SmartHttpResponseAdapter} instance of the SmartHttpResponseAdapter class
* @example
* const response = await smart_http_request.request({
*   url: 'https://api.example.com/data',
*   method: 'GET',
*   headers: { 'Content-Type': 'application/json' }
* });
* console.log(await response.json());
*/
async request(request_params, throw_on_error = false) {
return await this.adapter.request(request_params, throw_on_error);
}
};

var SmartHttpRequestAdapter2 = class {
static {
__name(this, "SmartHttpRequestAdapter");
}
constructor(main) {
this.main = main;
}
/**
* Execute an HTTP request using adapter-specific transport.
* @abstract
* @param {Object} request_params - Parameters for the outbound request.
* @returns {Promise<SmartHttpResponseAdapter>} Adapter-specific response wrapper.
*/
async request(request_params) {
throw new Error("request not implemented");
}
};
var SmartHttpResponseAdapter2 = class {
static {
__name(this, "SmartHttpResponseAdapter");
}
constructor(response) {
this.response = response;
}
/**
* Retrieve response headers.
* @abstract
* @returns {Promise<Object>} Headers object for the response.
*/
async headers() {
throw new Error("headers not implemented");
}
/**
* Parse the response body as JSON.
* @abstract
* @returns {Promise<*>} Parsed JSON payload.
*/
async json() {
throw new Error("json not implemented");
}
/**
* Get the HTTP status code.
* @abstract
* @returns {Promise<number>} Response status code.
*/
async status() {
throw new Error("status not implemented");
}
/**
* Read the raw text body.
* @abstract
* @returns {Promise<string>} Response body as text.
*/
async text() {
throw new Error("text not implemented");
}
};

var SmartHttpRequestFetchAdapter2 = class extends SmartHttpRequestAdapter2 {
static {
__name(this, "SmartHttpRequestFetchAdapter");
}
async request(request_params) {
const { url, ...opts } = request_params;
const resp = await fetch(url, opts);
return new SmartHttpResponseFetchAdapter2(resp);
}
};
var SmartHttpResponseFetchAdapter2 = class extends SmartHttpResponseAdapter2 {
static {
__name(this, "SmartHttpResponseFetchAdapter");
}
async headers() {
return this.response.headers;
}
async json() {
if (!this._json) {
this._json = await this.response.json();
}
return this._json;
}
async status() {
return this.response.status;
}
async text() {
if (!this._text) {
this._text = await this.response.text();
}
return this._text;
}
};

var SmartStreamer2 = class {
static {
__name(this, "SmartStreamer");
}
constructor(url, options = {}) {
const {
method = "GET",
headers = {},
body = null,
withCredentials = false
} = options;
this.url = url;
this.method = method;
this.headers = headers;
this.body = body;
this.withCredentials = withCredentials;
this.listeners = {};
this.readyState = this.CONNECTING;
this.progress = 0;
this.chunk = "";
this.last_event_id = "";
this.xhr = null;
this.FIELD_SEPARATOR = ":";
this.INITIALIZING = -1;
this.CONNECTING = 0;
this.OPEN = 1;
this.CLOSED = 2;
this.chunk_accumulator = "";
this.chunk_splitting_regex = options.chunk_splitting_regex || /(\r\n|\n|\r)/g;
}
/**
* Adds an event listener for the specified event type.
*
* @param {string} type - The type of the event.
* @param {Function} listener - The listener function to be called when the event is triggered.
*/
addEventListener(type, listener) {
if (!this.listeners[type]) this.listeners[type] = [];
if (!this.listeners[type].includes(listener)) this.listeners[type].push(listener);
}
/**
* Removes an event listener from the SmartStreamer instance.
*
* @param {string} type - The type of event to remove the listener from.
* @param {Function} listener - The listener function to remove.
*/
removeEventListener(type, listener) {
if (!this.listeners[type]) return;
this.listeners[type] = this.listeners[type].filter((callback) => callback !== listener);
if (this.listeners[type].length === 0) delete this.listeners[type];
}
/**
* Dispatches an event to the appropriate event handlers.
*
* @param {Event} event - The event to be dispatched.
* @returns {boolean} - Returns true if the event was successfully dispatched, false otherwise.
*/
dispatchEvent(event) {
if (!event) return true;
event.source = this;
const onHandler = "on" + event.type;
if (Object.prototype.hasOwnProperty.call(this, onHandler)) {
this[onHandler].call(this, event);
if (event.defaultPrevented) return false;
}
if (this.listeners[event.type]) {
this.listeners[event.type].forEach((callback) => {
callback(event);
return !event.defaultPrevented;
});
}
return true;
}
/**
* Initiates the streaming process.
*/
stream() {
this.#setReadyState(this.CONNECTING);
this.xhr = new XMLHttpRequest();
this.xhr.addEventListener("progress", this.#onStreamProgress.bind(this));
this.xhr.addEventListener("load", this.#onStreamLoaded.bind(this));
this.xhr.addEventListener("readystatechange", this.#checkStreamClosed.bind(this));
this.xhr.addEventListener("error", this.#onStreamFailure.bind(this));
this.xhr.addEventListener("abort", this.#onStreamAbort.bind(this));
this.xhr.open(this.method, this.url);
for (const header in this.headers) {
this.xhr.setRequestHeader(header, this.headers[header]);
}
if (this.last_event_id) this.xhr.setRequestHeader("Last-Event-ID", this.last_event_id);
this.xhr.withCredentials = this.withCredentials;
this.xhr.send(this.body);
}
/**
* Ends the streamer connection.
* Aborts the current XHR request and sets the ready state to CLOSED.
*/
end() {
if (this.readyState === this.CLOSED) return;
this.xhr.abort();
this.xhr = null;
this.#setReadyState(this.CLOSED);
}
#setReadyState(state) {
const event = new CustomEvent("readyStateChange");
event.readyState = state;
this.readyState = state;
this.dispatchEvent(event);
}
#onStreamFailure(e) {
const event = new CustomEvent("error");
try {
const parsed = JSON.parse(e.currentTarget.response);
if (typeof parsed === "object") {
event.data = parsed;
} else {
event.data = e.currentTarget.response;
}
} catch {
event.data = e.currentTarget.response;
}
this.dispatchEvent(event);
this.end();
}
#onStreamAbort(e) {
const event = new CustomEvent("abort");
this.end();
}
#onStreamProgress(e) {
if (!this.xhr) return;
if (this.xhr.status !== 200) {
this.#onStreamFailure(e);
return;
}
if (this.readyState === this.CONNECTING) {
this.dispatchEvent(new CustomEvent("open"));
this.#setReadyState(this.OPEN);
}
const data = this.xhr.responseText.substring(this.progress);
this.progress += data.length;
const parts = data.split(this.chunk_splitting_regex);
parts.forEach((part, index) => {
if (part.trim().length === 0) {
if (this.chunk) {
this.dispatchEvent(this.#parseEventChunk(this.chunk.trim()));
this.chunk = "";
}
} else {
this.chunk += part;
if (index === parts.length - 1 && this.xhr.readyState === XMLHttpRequest.DONE) {
this.dispatchEvent(this.#parseEventChunk(this.chunk.trim()));
this.chunk = "";
}
}
});
}
#onStreamLoaded(e) {
this.#onStreamProgress(e);
this.dispatchEvent(this.#parseEventChunk(this.chunk));
this.chunk = "";
}
#parseEventChunk(chunk) {
if (!chunk) return console.log("no chunk");
const event = new CustomEvent("message");
event.data = chunk;
event.last_event_id = this.last_event_id;
return event;
}
#checkStreamClosed() {
if (!this.xhr) return;
if (this.xhr.readyState === XMLHttpRequest.DONE) this.#setReadyState(this.CLOSED);
}
};

var SmartModelAdapter2 = class {
static {
__name(this, "SmartModelAdapter");
}
/**
* Create a SmartModelAdapter instance.
* @param {SmartModel} model - The parent SmartModel instance
*/
constructor(model) {
this.model = model;
this.state = "unloaded";
}
/**
* Load the adapter.
* @async
* @returns {Promise<void>}
*/
async load() {
this.set_state("loaded");
}
/**
* Unload the adapter.
* @returns {void}
*/
unload() {
this.set_state("unloaded");
}
/**
* Get all settings.
* @returns {Object} All settings
*/
get settings() {
return this.model.settings;
}
/**
* Get the current model key.
* @returns {string} Current model identifier
*/
get model_key() {
return this.model.model_key;
}
/**
* Get the models.
* @returns {Object} Map of model objects
*/
get models() {
const models = this.model.data.provider_models;
if (typeof models === "object" && Object.keys(models || {}).length > 0) return models;
else {
return {};
}
}
/**
* Get available models from the API.
* @abstract
* @param {boolean} [refresh=false] - Whether to refresh cached models
* @returns {Promise<Object>} Map of model objects
*/
async get_models(refresh = false) {
throw new Error("get_models not implemented");
}
/**
* Get available models as dropdown options synchronously.
* @returns {Array<Object>} Array of model options.
*/
get_models_as_options() {
const models = this.models;
if (!Object.keys(models || {}).length) {
this.get_models(true);
return [{ value: "", name: "No models currently available" }];
}
return Object.entries(models).map(([id, model]) => ({ value: id, name: model.name || id })).sort((a, b) => a.name.localeCompare(b.name));
}
/**
* Set the adapter's state.
* @deprecated should be handled in SmartModel (only handle once)
* @param {('unloaded'|'loading'|'loaded'|'unloading')} new_state - The new state
* @throws {Error} If the state is invalid
*/
set_state(new_state) {
const valid_states = ["unloaded", "loading", "loaded", "unloading"];
if (!valid_states.includes(new_state)) {
throw new Error(`Invalid state: ${new_state}`);
}
this.state = new_state;
}
get is_loading() {
return this.state === "loading";
}
get is_loaded() {
return this.state === "loaded";
}
get is_unloading() {
return this.state === "unloading";
}
get is_unloaded() {
return this.state === "unloaded";
}
};

var SmartChatModelAdapter2 = class extends SmartModelAdapter2 {
static {
__name(this, "SmartChatModelAdapter");
}
/**
* @override in sub-class with adapter-specific default configurations
* @property {string} id - The adapter identifier
* @property {string} description - Human-readable description
* @property {string} type - Adapter type ("API")
* @property {string} endpoint - API endpoint
* @property {boolean} streaming - Whether streaming is supported
* @property {string} adapter - Adapter identifier
* @property {string} models_endpoint - Endpoint for retrieving models
* @property {string} default_model - Default model to use
* @property {string} signup_url - URL for API key signup
*/
static defaults = {};
/**
* Create a SmartChatModelAdapter instance.
* @param {SmartChatModel} model - The parent SmartChatModel instance
*/
constructor(model) {
super(model);
this.smart_chat = model;
this.main = model;
}
/**
* Complete a chat request.
* @abstract
* @param {Object} req - Request parameters
* @returns {Promise<Object>} Completion result
*/
async complete(req) {
throw new Error("complete not implemented");
}
/**
* Count tokens in input text.
* @abstract
* @param {string|Object} input - Text to count tokens for
* @returns {Promise<number>} Token count
*/
async count_tokens(input) {
throw new Error("count_tokens not implemented");
}
/**
* Stream chat responses.
* @abstract
* @param {Object} req - Request parameters
* @param {Object} handlers - Event handlers for streaming
* @returns {Promise<string>} Complete response text
*/
async stream(req, handlers = {}) {
throw new Error("stream not implemented");
}
/**
* Test if API key is valid.
* @abstract
* @returns {Promise<boolean>} True if API key is valid
*/
async test_api_key() {
throw new Error("test_api_key not implemented");
}
/**
* Refresh available models.
*/
refresh_models() {
console.log("refresh_models");
this.get_models(true);
}
/**
* Get settings configuration.
* @returns {Object} Settings configuration object
*/
get settings_config() {
return {
"[CHAT_ADAPTER].model_key": {
name: "Chat Model",
type: "dropdown",
description: "Select a chat model.",
options_callback: "adapter.get_models_as_options",
callback: "reload_model",
default: this.constructor.defaults.default_model
},
"[CHAT_ADAPTER].refresh_models": {
name: "Refresh Models",
type: "button",
description: "Refresh the list of available models.",
callback: "adapter.refresh_models"
}
};
}
};

function is_json_compatible2(value) {
if (value === null) {
return true;
}
const type = typeof value;
if (type === "string" || type === "number" || type === "boolean") {
return true;
}
if (Array.isArray(value)) {
return value.every(is_json_compatible2);
}
if (type === "object") {
const obj = (
/** @type {Record<string, unknown>} */
value
);
return Object.values(obj).every(is_json_compatible2);
}
return false;
}
__name(is_json_compatible2, "is_json_compatible");
function extract_json_details2(source, exclude_keys) {
const details = {};
for (const [key, value] of Object.entries(source)) {
if (exclude_keys.includes(key)) {
continue;
}
if (!is_json_compatible2(value)) {
continue;
}
details[key] = value;
}
return details;
}
__name(extract_json_details2, "extract_json_details");
function is_empty_object2(obj) {
return Object.keys(obj).length === 0;
}
__name(is_empty_object2, "is_empty_object");
function merge_details2(first, second) {
if (is_empty_object2(first)) {
return second;
}
if (is_empty_object2(second)) {
return first;
}
return { ...first, ...second };
}
__name(merge_details2, "merge_details");
function get_message_from_object2(value) {
const raw = value.message;
if (typeof raw === "string") {
const trimmed = raw.trim();
if (trimmed.length > 0) {
return trimmed;
}
}
return null;
}
__name(get_message_from_object2, "get_message_from_object");
function normalize_error2(error, http_status = null) {
if (Array.isArray(error) && error.length > 0) {
return normalize_error2(error[0], http_status);
}
if (error == null) {
return { message: "Unknown error", details: null, http_status };
}
if (typeof error === "string") {
return { message: error, details: null, http_status };
}
if (error instanceof Error) {
const message = (error.message || "").trim() || "Unknown error";
const extra_details = extract_json_details2(
/** @type {Record<string, unknown>} */
error,
["message"]
);
return {
message,
details: is_empty_object2(extra_details) ? null : extra_details,
http_status
};
}
if (typeof error === "object") {
const obj = (
/** @type {Record<string, unknown>} */
error
);
if ("error" in obj && obj.error != null) {
const nested_error = obj.error;
if (typeof nested_error === "object") {
const nested_obj = (
/** @type {Record<string, unknown>} */
nested_error
);
const nested_message = get_message_from_object2(nested_obj);
const nested_details = extract_json_details2(nested_obj, ["message"]);
const outer_details = extract_json_details2(obj, ["message", "error"]);
const combined_details = merge_details2(outer_details, nested_details);
const message = nested_message || get_message_from_object2(obj) || "Unknown error";
return {
message,
details: is_empty_object2(combined_details) ? null : combined_details,
http_status
};
}
return normalize_error2(nested_error);
}
const object_message = get_message_from_object2(obj);
if (object_message) {
const details = extract_json_details2(obj, ["message"]);
return {
message: object_message,
details: is_empty_object2(details) ? null : details,
http_status
};
}
}
return { message: "Unknown error", details: null, http_status };
}
__name(normalize_error2, "normalize_error");

var MODEL_ADAPTER_CACHE2 = {};
var MODELS_DEV_CACHE2 = { data: null, fetched_at: 0 };
var SmartChatModelApiAdapter2 = class extends SmartChatModelAdapter2 {
static {
__name(this, "SmartChatModelApiAdapter");
}
constructor(model) {
super(model);
this.model_data_loaded_at = 0;
}
/**
* Get the request adapter class.
* @returns {SmartChatModelRequestAdapter} The request adapter class
*/
get req_adapter() {
return SmartChatModelRequestAdapter2;
}
/**
* Get the response adapter class.
* @returns {SmartChatModelResponseAdapter} The response adapter class
*/
get res_adapter() {
return SmartChatModelResponseAdapter2;
}
/**
* Get or initialize the HTTP adapter.
* @returns {SmartHttpRequest} The HTTP adapter instance
*/
get http_adapter() {
if (!this._http_adapter) {
if (this.model.http_adapter) this._http_adapter = this.model.http_adapter;
else if (this.model.opts.http_adapter) this._http_adapter = this.model.opts.http_adapter;
else this._http_adapter = new SmartHttpRequest2({ adapter: SmartHttpRequestFetchAdapter2 });
}
return this._http_adapter;
}
/**
* Get the settings configuration for the API adapter.
* @deprecated migrating to module export
* @returns {Object} Settings configuration object with API key and other settings
*/
get settings_config() {
return {
...super.settings_config,
"[CHAT_ADAPTER].api_key": {
name: "API Key",
type: "password",
description: "Enter your API key for the chat model platform.",
callback: "test_api_key",
is_scope: true
}
};
}
/**
* Count tokens in the input text.
* @abstract
* @param {string|Object} input - Text or message object to count tokens for
* @returns {Promise<number>} Number of tokens in the input
*/
async count_tokens(input) {
throw new Error("count_tokens not implemented");
}
/**
* Get the parameters for requesting available models.
* @returns {Object} Request parameters for models endpoint
*/
get models_request_params() {
return {
url: this.models_endpoint,
method: this.models_endpoint_method,
headers: {
"Authorization": `Bearer ${this.api_key}`
}
};
}
async get_enriched_model_data() {
const provider_key = this.constructor.models_dev_key || this.constructor.key;
await this.get_models_dev_index();
const provider_data = MODELS_DEV_CACHE2.data[provider_key] || {};
const get_limit_i = /* @__PURE__ */ __name((model) => model.limit?.context || 1e4, "get_limit_i");
const get_limit_o = /* @__PURE__ */ __name((model) => model.limit?.output || 1e4, "get_limit_o");
const get_multimodal = /* @__PURE__ */ __name((model) => model.modalities?.input?.includes("image") || false, "get_multimodal");
if (Object.keys(this.model_data || {}).length > 0) {
for (const [key, model] of Object.entries(this.model_data)) {
const enriched = provider_data?.models?.[model.id];
if (!enriched) continue;
this.model_data[key].models_dev = enriched;
this.model_data[key].name = enriched.name || model.name;
this.model_data[key].max_input_tokens = get_limit_i(enriched);
this.model_data[key].max_output_tokens = get_limit_o(enriched);
this.model_data[key].multimodal = get_multimodal(enriched);
this.model_data[key].cost = enriched.cost;
}
} else {
for (const [key, model] of Object.entries(provider_data?.models || {})) {
this.model_data[key] = {
...model,
model_name: model.name,
description: model.name,
max_input_tokens: get_limit_i(model),
max_output_tokens: get_limit_o(model),
multimodal: get_multimodal(model)
};
}
}
return this.model_data;
}
valid_model_data() {
return typeof this.model_data === "object" && Object.keys(this.model_data || {}).length > 0 && this.model_data_loaded_at && Date.now() - this.model_data_loaded_at < 1 * 60 * 60 * 1e3;
}
/**
* Get available models from the API.
* @param {boolean} [refresh=false] - Whether to refresh cached models
* @returns {Promise<Object>} Map of model objects
*/
async get_models(refresh = false) {
if (!refresh && this.valid_model_data()) return this.model_data;
if (this.api_key) {
let response;
try {
response = await this.http_adapter.request(this.models_request_params);
this.model_data = this.parse_model_data(await response.json());
} catch (error) {
console.error("Failed to fetch model data:", { error, response });
}
}
this.model_data = await this.get_enriched_model_data();
this.model_data_loaded_at = Date.now();
if (this.model.data) {
this.model.data.provider_models = this.model_data;
}
if (this.valid_model_data() && typeof this.model.re_render_settings === "function") setTimeout(() => {
this.model.re_render_settings();
}, 100);
else console.warn("Invalid model data, not re-rendering settings");
return this.model_data;
}
/**
* Parses the raw model data from OpenAI API and transforms it into a more usable format.
* @param {Object} model_data - The raw model data received from OpenAI API.
* @abstract
* @returns {Array<Object>} An array of parsed model objects with the following properties:
*   @property {string} model_name - The name/ID of the model as returned by the API.
*   @property {string} id - The id used to identify the model (usually same as model_name).
*   @property {boolean} multimodal - Indicates if the model supports multimodal inputs.
*   @property {number} [max_input_tokens] - The maximum number of input tokens the model can process.
*   @property {string} [description] - A description of the model's context and output capabilities.
*/
parse_model_data(model_data) {
throw new Error("parse_model_data not implemented");
}
/**
* Complete a chat request.
* @param {Object} req - Request parameters
* @returns {Promise<Object>} Completion response in OpenAI format
*/
async complete(req) {
const _req = new this.req_adapter(this, {
...req,
stream: false
});
const request_params = _req.to_platform();
const http_resp = await this.http_adapter.request(request_params);
if (!http_resp) return null;
const _res = new this.res_adapter(this, await http_resp.json());
try {
const resp = _res.to_openai();
return resp;
} catch (error) {
const normalized_error = normalize_error2(error?.data || error);
console.error("Error in SmartChatModelApiAdapter.complete():", { normalized_error, error });
console.error(http_resp);
return normalized_error;
}
}
/**
* Stream chat responses.
* @param {Object} req - Request parameters
* @param {Object} handlers - Event handlers for streaming
* @param {Function} handlers.chunk - Handler for response objects
* @param {Function} handlers.error - Handler for errors
* @param {Function} handlers.done - Handler for completion
* @returns {Promise<Object>} Complete response object
*/
async stream(req, handlers = {}) {
const _req = new this.req_adapter(this, req);
const request_params = _req.to_platform(true);
if (this.streaming_chunk_splitting_regex) request_params.chunk_splitting_regex = this.streaming_chunk_splitting_regex;
return await new Promise((resolve, reject) => {
try {
this.active_stream = new SmartStreamer2(this.endpoint_streaming, request_params);
const resp_adapter = new this.res_adapter(this);
this.active_stream.addEventListener("message", async (e) => {
if (this.is_end_of_stream(e)) {
await resp_adapter.handle_chunk(e.data);
this.stop_stream();
const final_resp = resp_adapter.to_openai();
handlers.done && await handlers.done(final_resp);
resolve(final_resp);
return;
}
try {
const raw = resp_adapter.handle_chunk(e.data);
handlers.chunk && await handlers.chunk({ ...resp_adapter.to_openai(), raw });
} catch (error) {
const normalized_error = normalize_error2({ ...e.data, ...error });
console.error("Error processing stream chunk:", { e, error, normalized_error });
handlers.error && handlers.error(normalized_error);
this.stop_stream();
reject(normalized_error);
}
});
this.active_stream.addEventListener("error", (e) => {
console.error("Stream error:", e);
const normalized_error = normalize_error2(e?.data || e);
handlers.error && handlers.error(normalized_error);
this.stop_stream();
reject(normalized_error);
});
this.active_stream.stream();
} catch (err) {
console.error("Failed to start stream:", err);
const normalized_error = normalize_error2(err?.data || err);
handlers.error && handlers.error(normalized_error);
this.stop_stream();
reject(normalized_error);
}
});
}
/**
* Check if a stream event indicates end of stream.
* @param {Event} event - Stream event
* @returns {boolean} True if end of stream
*/
is_end_of_stream(event) {
return event.data === "data: [DONE]";
}
/**
* Stop active stream.
*/
stop_stream() {
if (this.active_stream) {
this.active_stream.end();
this.active_stream = null;
}
}
/**
* Get the API key.
* @returns {string} The API key.
*/
get api_key() {
return this.model.api_key || this.main.opts.api_key;
}
get models_endpoint() {
return this.constructor.defaults.models_endpoint;
}
get models_endpoint_method() {
return "POST";
}
/**
* Get the endpoint URL.
* @returns {string} The endpoint URL.
*/
get endpoint() {
return this.constructor.defaults.endpoint;
}
/**
* Get the streaming endpoint URL.
* @returns {string} The streaming endpoint URL.
*/
get endpoint_streaming() {
return this.constructor.defaults.endpoint_streaming || this.endpoint;
}
/**
* Get the maximum output tokens.
* @returns {number} The maximum output tokens.
*/
get max_output_tokens() {
return this.model.data.max_output_tokens || 3e3;
}
async get_models_dev_index(ttl_ms = 60 * 60 * 1e3) {
const now = Date.now();
if (MODELS_DEV_CACHE2?.data && now - MODELS_DEV_CACHE2?.fetched_at < ttl_ms) {
return MODELS_DEV_CACHE2.data;
}
try {
const req = {
url: "https://models.dev/api.json",
method: "GET",
headers: { "Content-Type": "application/json" }
};
const resp = await this.http_adapter.request(req);
const data = await resp.json();
MODELS_DEV_CACHE2.data = data;
MODELS_DEV_CACHE2.fetched_at = now;
console.log({ MODELS_DEV_CACHE: MODELS_DEV_CACHE2 });
return data;
} catch (err) {
console.warn("models.dev fetch failed; continuing without enrichment", err);
return MODELS_DEV_CACHE2.data || [];
}
}
/**
* Get available models as dropdown options synchronously.
* @returns {Array<Object>} Array of model options.
*/
get_models_as_options() {
if (Object.keys(this.model_data || {}).length) {
return Object.entries(this.model_data).map(([id, model]) => ({ value: id, name: model.name || id })).sort((a, b) => a.name.localeCompare(b.name));
}
this.get_models(true);
return [{ value: "", name: "No models currently available" }];
}
get model_data() {
if (!MODEL_ADAPTER_CACHE2[this.constructor.key]) MODEL_ADAPTER_CACHE2[this.constructor.key] = {};
return MODEL_ADAPTER_CACHE2[this.constructor.key];
}
set model_data(data) {
if (!MODEL_ADAPTER_CACHE2[this.constructor.key]) MODEL_ADAPTER_CACHE2[this.constructor.key] = {};
MODEL_ADAPTER_CACHE2[this.constructor.key] = data;
}
};
var SmartChatModelRequestAdapter2 = class {
static {
__name(this, "SmartChatModelRequestAdapter");
}
/**
* @constructor
* @param {SmartChatModelAdapter} adapter - The SmartChatModelAdapter instance
* @param {Object} req - The incoming request object
*/
constructor(adapter, req = {}) {
this.adapter = adapter;
this._req = req;
}
/**
* Get the messages array from the request
* @returns {Array<Object>} Array of message objects
*/
get messages() {
return this._req.messages || [];
}
/**
* Get the model identifier
* @returns {string} Model ID
*/
get model_id() {
return this._req.model || this.adapter.model.model_key || this.adapter.model.data.id;
}
/**
* Get the temperature setting
* @returns {number} Temperature value
*/
get temperature() {
return this._req.temperature;
}
/**
* Get the maximum tokens setting
* @returns {number} Max tokens value
*/
get max_tokens() {
return this._req.max_tokens || this.adapter.max_output_tokens;
}
/**
* Get the streaming flag
* @returns {boolean} Whether to stream responses
*/
get stream() {
return this._req.stream;
}
/**
* Get the tools array
* @returns {Array<Object>|null} Array of tool objects or null
*/
get tools() {
return this._req.tools || null;
}
/**
* Get the tool choice setting
* @returns {string|Object|null} Tool choice configuration
*/
get tool_choice() {
return this._req.tool_choice || null;
}
get frequency_penalty() {
return this._req.frequency_penalty;
}
get presence_penalty() {
return this._req.presence_penalty;
}
get top_p() {
return this._req.top_p;
}
/**
* Get request headers
* @returns {Object} Headers object
*/
get_headers() {
const headers = {
"Content-Type": "application/json",
...this.adapter.constructor.defaults.headers || {}
};
const api_key_header = this.adapter.constructor.defaults.api_key_header;
if (api_key_header !== "none") {
if (api_key_header) {
headers[api_key_header] = this.adapter.api_key;
} else if (this.adapter.api_key) {
headers["Authorization"] = `Bearer ${this.adapter.api_key}`;
}
}
return headers;
}
/**
* Convert request to platform-specific format
* @returns {Object} Platform-specific request parameters
*/
to_platform(streaming = false) {
return this.to_openai(streaming);
}
/**
* Convert request to OpenAI format
* @returns {Object} Request parameters in OpenAI format
*/
to_openai(streaming = false) {
const body = {
messages: this._transform_messages_to_openai(),
model: this.model_id,
temperature: this.temperature,
stream: streaming,
...this.tools && { tools: this._transform_tools_to_openai() }
};
if (body.tools?.length > 0 && this.tool_choice && this.tool_choice !== "none") {
body.tool_choice = this.tool_choice;
}
if (this.model_id?.startsWith("o1-")) {
body.messages = body.messages.filter((m) => m.role !== "system");
delete body.temperature;
}
if (typeof this._req.top_p === "number") body.top_p = this._req.top_p;
if (typeof this._req.presence_penalty === "number") body.presence_penalty = this._req.presence_penalty;
if (typeof this._req.frequency_penalty === "number") body.frequency_penalty = this._req.frequency_penalty;
return {
url: this.adapter.endpoint,
method: "POST",
headers: this.get_headers(),
body: JSON.stringify(body)
};
}
/**
* Transform messages to OpenAI format
* @returns {Array<Object>} Transformed messages array
* @private
*/
_transform_messages_to_openai() {
return this.messages.map((message) => this._transform_single_message_to_openai(message));
}
/**
* Transform a single message to OpenAI format
* @param {Object} message - Message object to transform
* @returns {Object} Transformed message object
* @private
*/
_transform_single_message_to_openai(message) {
const transformed = {
role: this._get_openai_role(message.role),
content: this._get_openai_content(message)
};
if (message.name) transformed.name = message.name;
if (message.tool_calls) transformed.tool_calls = this._transform_tool_calls_to_openai(message.tool_calls);
if (message.image_url) transformed.image_url = message.image_url;
if (message.tool_call_id) transformed.tool_call_id = message.tool_call_id;
return transformed;
}
/**
* Get the OpenAI role for a given role.
* @param {string} role - The role to transform.
* @returns {string} The transformed role.
* @private
*/
_get_openai_role(role) {
return role;
}
/**
* Get the OpenAI content for a given content.
* @param {string} content - The content to transform.
* @returns {string} The transformed content.
* @private
*/
_get_openai_content(message) {
return message.content;
}
/**
* Transform tool calls to OpenAI format.
* @param {Array} tool_calls - Array of tool call objects.
* @returns {Array} Transformed tool calls array.
* @private
*/
_transform_tool_calls_to_openai(tool_calls) {
return tool_calls.map((tool_call) => ({
id: tool_call.id,
type: tool_call.type,
function: {
name: tool_call.function.name,
arguments: tool_call.function.arguments
}
}));
}
/**
* Transform tools to OpenAI format.
* @returns {Array} Transformed tools array.
* @private
*/
_transform_tools_to_openai() {
return this.tools.map((tool2) => ({
type: tool2.type,
function: {
name: tool2.function.name,
description: tool2.function.description,
parameters: tool2.function.parameters
}
}));
}
};
var SmartChatModelResponseAdapter2 = class {
static {
__name(this, "SmartChatModelResponseAdapter");
}
static get platform_res() {
return {
id: "",
object: "chat.completion",
created: 0,
model: "",
choices: [],
usage: {}
};
}
/**
* @constructor
* @param {SmartChatModelAdapter} adapter - The SmartChatModelAdapter instance
* @param {Object} res - The response object
*/
constructor(adapter, res, status = null) {
this.adapter = adapter;
this._res = res || this.constructor.platform_res;
this.status = status;
}
/**
* Get response ID
* @returns {string|null} Response ID
*/
get id() {
return this._res.id || null;
}
/**
* Get response object type
* @returns {string|null} Object type
*/
get object() {
return this._res.object || null;
}
/**
* Get creation timestamp
* @returns {number|null} Creation timestamp
*/
get created() {
return this._res.created || null;
}
/**
* Get response choices
* @returns {Array<Object>} Array of choice objects
*/
get choices() {
return this._res.choices || [];
}
/**
* Get first tool call if present
* @returns {Object|null} Tool call object
*/
get tool_call() {
return this.message.tool_calls?.[0] || null;
}
/**
* Get tool name from first tool call
* @returns {string|null} Tool name
*/
get tool_name() {
return this.tool_call?.tool_name || null;
}
/**
* Get tool call parameters
* @returns {Object|null} Tool parameters
*/
get tool_call_content() {
return this.tool_call?.parameters || null;
}
/**
* Get token usage statistics
* @returns {Object|null} Usage statistics
*/
get usage() {
return this._res.usage || null;
}
get error() {
return this._res.error || null;
}
/**
* Convert response to OpenAI format
* @returns {Object} Response in OpenAI format
*/
to_openai() {
if (this.error) return { error: normalize_error2(this.error, this.status) };
const res = {
id: this.id,
object: this.object,
created: this.created,
choices: this._transform_choices_to_openai(),
usage: this._transform_usage_to_openai(),
raw: this._res
};
return res;
}
/**
* Parse chunk adds delta to content as expected output format
*/
handle_chunk(chunk) {
if (chunk === "data: [DONE]") return;
chunk = JSON.parse(chunk.split("data: ")[1] || "{}");
if (Object.keys(chunk).length === 0) return;
if (!this._res.choices[0]) {
this._res.choices.push({
message: {
index: 0,
role: "assistant",
content: ""
}
});
}
if (!this._res.id) {
this._res.id = chunk.id;
}
let raw;
if (chunk.choices?.[0]?.delta?.content) {
const content = chunk.choices[0].delta.content;
raw = content;
this._res.choices[0].message.content += content;
}
if (chunk.choices?.[0]?.delta?.tool_calls) {
if (!this._res.choices[0].message.tool_calls) {
this._res.choices[0].message.tool_calls = [{
id: "",
type: "function",
function: {
name: "",
arguments: ""
}
}];
}
if (chunk.choices[0].delta.tool_calls[0].id) {
this._res.choices[0].message.tool_calls[0].id += chunk.choices[0].delta.tool_calls[0].id;
}
if (chunk.choices[0].delta.tool_calls[0].function.name) {
this._res.choices[0].message.tool_calls[0].function.name += chunk.choices[0].delta.tool_calls[0].function.name;
}
if (chunk.choices[0].delta.tool_calls[0].function.arguments) {
this._res.choices[0].message.tool_calls[0].function.arguments += chunk.choices[0].delta.tool_calls[0].function.arguments;
}
}
return raw;
}
/**
* Transform choices to OpenAI format.
* @returns {Array} Transformed choices array.
* @private
*/
_transform_choices_to_openai() {
return this.choices.map((choice) => ({
index: choice.index,
message: this._transform_message_to_openai(choice.message),
finish_reason: this._get_openai_finish_reason(choice.finish_reason)
}));
}
/**
* Transform a single message to OpenAI format.
* @param {Object} message - The message object to transform.
* @returns {Object} Transformed message object.
* @private
*/
_transform_message_to_openai(message = {}) {
const transformed = {
role: this._get_openai_role(message.role),
content: this._get_openai_content(message)
};
if (message.name) transformed.name = message.name;
if (message.tool_calls) transformed.tool_calls = this._transform_tool_calls_to_openai(message.tool_calls);
if (message.image_url) transformed.image_url = message.image_url;
return transformed;
}
/**
* Get the OpenAI role for a given role.
* @param {string} role - The role to transform.
* @returns {string} The transformed role.
* @private
*/
_get_openai_role(role) {
return role;
}
/**
* Get the OpenAI content for a given content.
* @param {string} content - The content to transform.
* @returns {string} The transformed content.
* @private
*/
_get_openai_content(message) {
return message.content;
}
/**
* Get the OpenAI finish reason for a given finish reason.
* @param {string} finish_reason - The finish reason to transform.
* @returns {string} The transformed finish reason.
* @private
*/
_get_openai_finish_reason(finish_reason) {
return finish_reason;
}
/**
* Transform usage to OpenAI format.
* @returns {Object} Transformed usage object.
* @private
*/
_transform_usage_to_openai() {
return this.usage;
}
/**
* Transform tool calls to OpenAI format.
* @param {Array} tool_calls - Array of tool call objects.
* @returns {Array} Transformed tool calls array.
* @private
*/
_transform_tool_calls_to_openai(tool_calls) {
return tool_calls.map((tool_call) => ({
id: tool_call.id,
type: tool_call.type,
function: {
name: tool_call.function.name,
arguments: tool_call.function.arguments
}
}));
}
};

var SmartChatModelOpenRouterAdapter2 = class extends SmartChatModelApiAdapter2 {
static {
__name(this, "SmartChatModelOpenRouterAdapter");
}
static key = "open_router";
static models_dev_key = "openrouter";
static defaults = {
description: "Open Router",
type: "API",
endpoint: "https://openrouter.ai/api/v1/chat/completions",
streaming: true,
adapter: "OpenRouter",
models_endpoint: "https://openrouter.ai/api/v1/models",
default_model: "mistralai/mistral-7b-instruct:free",
signup_url: "https://accounts.openrouter.ai/sign-up?redirect_url=https%3A%2F%2Fopenrouter.ai%2Fkeys"
};
/**
* Get request adapter class
* @returns {typeof SmartChatModelOpenRouterRequestAdapter} Request adapter class
*/
get req_adapter() {
return SmartChatModelOpenRouterRequestAdapter2;
}
/**
* Get response adapter class
* @returns {typeof SmartChatModelOpenRouterResponseAdapter} Response adapter class
*/
get res_adapter() {
return SmartChatModelOpenRouterResponseAdapter2;
}
/**
* Count tokens in input text (rough estimate)
* @param {string|Object} input - Text to count tokens for
* @returns {Promise<number>} Estimated token count
*/
async count_tokens(input) {
const text = typeof input === "string" ? input : JSON.stringify(input);
return Math.ceil(text.length / 4);
}
get models_request_params() {
return {
url: this.models_endpoint,
method: "GET"
};
}
/**
* Parse model data from OpenRouter API response
* @param {Object} model_data - Raw model data
* @returns {Object} Map of model objects with capabilities and limits
*/
parse_model_data(model_data) {
if (model_data.data) {
model_data = model_data.data;
}
if (model_data.error) throw new Error(model_data.error);
return model_data.reduce((acc, model) => {
acc[model.id] = {
model_name: model.id,
id: model.id,
max_input_tokens: model.context_length,
name: model.name,
description: model.name,
long_desc: model.description,
multimodal: model.architecture.modality === "multimodal",
raw: model
};
return acc;
}, {});
}
};
var SmartChatModelOpenRouterRequestAdapter2 = class extends SmartChatModelRequestAdapter2 {
static {
__name(this, "SmartChatModelOpenRouterRequestAdapter");
}
to_platform(stream = false) {
const req = this.to_openai(stream);
return req;
}
_get_openai_content(message) {
if (message.role === "user") {
if (Array.isArray(message.content) && message.content.every((part) => part.type === "text")) {
return message.content.map((part) => part.text).join("\n");
}
}
return message.content;
}
};
var SmartChatModelOpenRouterResponseAdapter2 = class extends SmartChatModelResponseAdapter2 {
static {
__name(this, "SmartChatModelOpenRouterResponseAdapter");
}
static get platform_res() {
return {
id: "",
object: "chat.completion",
created: 0,
model: "",
choices: [],
usage: {}
};
}
to_platform() {
return this.to_openai();
}
get object() {
return "chat.completion";
}
get error() {
if (!this._res.error) return null;
const error = this._res.error;
if (!error.message) error.message = "";
if (this._res.error.metadata?.raw) {
if (typeof this._res.error.metadata.raw === "string") {
error.message += `

${this._res.error.metadata.raw}`;
} else {
error.message += `

${JSON.stringify(this._res.error.metadata.raw, null, 2)}`;
}
}
if (error.message.startsWith("No cookie auth")) {
error.suggested_action = "Ensure your Open Router API key is set correctly.";
}
return error;
}
};

var OpenRouterChatCompletionModelAdapter = class extends SmartChatModelOpenRouterAdapter2 {
static {
__name(this, "OpenRouterChatCompletionModelAdapter");
}
constructor(model_item) {
super(model_item);
}
get http_adapter() {
if (!this._http_adapter) {
const HttpClass = this.model.env.config.modules.http_adapter.class;
const http_params = { ...this.model.env.config.modules.http_adapter, class: void 0 };
this._http_adapter = new HttpClass(http_params);
}
return this._http_adapter;
}
};
var settings_config11 = {
"api_key": {
name: "API Key",
type: "password",
description: "Enter your API key for the chat model provider."
}
};
var open_router_default = {
class: OpenRouterChatCompletionModelAdapter,
settings_config: settings_config11
};

var ChatCompletionModels = class extends Models2 {
static {
__name(this, "ChatCompletionModels");
}
model_type = "Chat";
get default_provider_key() {
return "open_router";
}
};
var chat_completion_models_collection = {
class: ChatCompletionModels,
data_dir: "chat_completion_models",
collection_key: "chat_completion_models",
data_adapter: ajson_single_file_default2,
item_type: ChatCompletionModel,
providers: {
open_router: open_router_default
},
settings_config: settings_config10
};
var chat_completion_models_default = chat_completion_models_collection;

var chat_completion_models_default2 = chat_completion_models_default;

var RankingModel = class extends Model2 {
static {
__name(this, "RankingModel");
}
/**
* Default properties for an instance of RankingModel.
* @returns {Object}
*/
static get defaults() {
return {
data: {
api_key: "",
provider_key: "cohere",
model_key: "rerank-v3.5"
}
};
}
/**
* Rank documents based on a query using the underlying provider instance.
* @param {string} query - The query string.
* @param {Array<string>} documents - Documents to rank.
* @param {Object} [options={}] - Optional provider specific options.
* @returns {Promise<Array<Object>>} Ranked documents: [{ index, score, ... }, ...]
*/
async rank(query, documents, options = {}) {
return this.instance.rank(query, documents, options);
}
async test_model() {
try {
const resp = await this.rank("alphabetical order", ["z", "y", "x", "a", "b", "c"]);
const success = Boolean(!resp.error && Array.isArray(resp) && resp.length);
this.data.test_passed = success;
this.debounce_save();
return { success, response: resp };
} catch (e) {
this.data.test_passed = false;
return { error: e.message || String(e) };
}
}
};

var settings_config12 = {
"[ADAPTER].model_key": {
name: "Ranking Model",
type: "dropdown",
description: "Select a ranking model to use.",
options_callback: "adapter.get_models_as_options",
callback: "reload_model"
}
};
var SmartRankAdapter = class extends SmartModelAdapter2 {
static {
__name(this, "SmartRankAdapter");
}
/**
* Create a SmartRankAdapter instance.
* @param {SmartRankModel} model - The parent SmartRankModel instance
*/
constructor(model) {
super(model);
this.smart_rank = model;
}
/**
* Rank documents based on a query.
* @abstract
* @param {string} query - The query string
* @param {Array<string>} documents - The documents to rank
* @returns {Promise<Array<Object>>} Array of ranking results {index, score, ...}
* @throws {Error} If the method is not implemented by subclass
*/
async rank(query, documents) {
throw new Error("rank method not implemented");
}
get settings_config() {
return settings_config12;
}
};

var SmartRankModelApiAdapter = class extends SmartRankAdapter {
static {
__name(this, "SmartRankModelApiAdapter");
}
/**
* Get the API endpoint URL
* @returns {string} Endpoint URL
*/
get endpoint() {
return this.model.data.endpoint || this.constructor.defaults.endpoint;
}
/**
* Get the API key for authentication
* @returns {string} API key
*/
get api_key() {
return this.model.data.api_key;
}
/**
* Get HTTP request adapter instance
* @returns {SmartHttpRequest} HTTP request handler
*/
get http_adapter() {
if (!this._http_adapter) {
if (this.model.opts.http_adapter) this._http_adapter = this.model.opts.http_adapter;
else this._http_adapter = new SmartHttpRequest2({ adapter: SmartHttpRequestFetchAdapter2 });
}
return this._http_adapter;
}
/**
* Load the adapter
* @async
* @returns {Promise<void>}
*/
async load() {
this.model.model_loaded = true;
if (this.api_key) this.set_state("loaded");
return;
}
/**
* Make an API request with retry logic
* @param {Object} req - Request configuration
* @param {number} [retries=0] - Number of retries attempted
* @returns {Promise<Object>} API response JSON
*/
async request(req, retries = 0) {
try {
req.throw = false;
req.url = this.endpoint;
console.log("API Request:", req);
const resp = await this.http_adapter.request(req);
console.log("API Response:", resp);
const resp_json = await this.get_resp_json(resp);
return resp_json;
} catch (error) {
return await this.handle_request_err(error, req, retries);
}
}
/**
* Handle API request errors with retry logic
* @param {Error|Object} error - Error object
* @param {Object} req - Original request
* @param {number} retries - Number of retries attempted
* @returns {Promise<Object|null>} Retry response or null
*/
async handle_request_err(error, req, retries) {
if (error.status === 429 && retries < 3) {
const backoff = Math.pow(retries + 1, 2);
console.log(`Retrying request (429) in ${backoff} seconds...`);
await new Promise((r) => setTimeout(r, 1e3 * backoff));
return await this.request(req, retries + 1);
}
console.error(error);
return null;
}
/**
* Parse response body as JSON
* @param {Response} resp - Response object
* @returns {Promise<Object>} Parsed JSON
*/
async get_resp_json(resp) {
return typeof resp.json === "function" ? await resp.json() : await resp.json;
}
/**
* Validate API key by making a test request
* @returns {Promise<boolean>} True if API key is valid
*/
async validate_api_key() {
const resp = await this.rank("test query", ["Test document"]);
return Array.isArray(resp) && resp.length > 0 && resp[0].score !== null;
}
};
var SmartRankModelRequestAdapter = class {
static {
__name(this, "SmartRankModelRequestAdapter");
}
/**
* Create request adapter instance
* @param {SmartRankModelApiAdapter} adapter - The SmartRankModelApiAdapter instance
* @param {string} query - The query string
* @param {Array<string>} documents - Array of documents
*/
constructor(adapter, query, documents) {
this.adapter = adapter;
this.query = query;
this.documents = documents;
}
/**
* Get request headers
* @returns {Object} Headers object
*/
get_headers() {
let headers = {
"Content-Type": "application/json"
};
if (this.adapter.api_key) {
headers["Authorization"] = `Bearer ${this.adapter.api_key}`;
}
return headers;
}
/**
* Convert request to platform-specific format
* @returns {Object} Platform-specific request parameters
*/
to_platform() {
return {
method: "POST",
headers: this.get_headers(),
body: JSON.stringify(this.prepare_request_body())
};
}
/**
* Prepare request body for API call
* @abstract
* @returns {Object} Request body object
* @throws {Error} If not implemented by subclass
*/
prepare_request_body() {
throw new Error("prepare_request_body not implemented");
}
};
var SmartRankModelResponseAdapter = class {
static {
__name(this, "SmartRankModelResponseAdapter");
}
/**
* @constructor
* @param {SmartRankModelApiAdapter} adapter - The SmartRankModelApiAdapter instance
* @param {Object} response - The response object
*/
constructor(adapter, response) {
this.adapter = adapter;
this.response = response;
}
/**
* Convert response to standard format
* @returns {Array<Object>} Array of ranking results {index, score, ...}
*/
to_standard() {
return this.parse_response();
}
/**
* Parse API response
* @abstract
* @returns {Array<Object>} Parsed ranking results
* @throws {Error} If not implemented by subclass
*/
parse_response() {
throw new Error("parse_response not implemented");
}
};

var SmartRankCohereAdapter = class extends SmartRankModelApiAdapter {
static {
__name(this, "SmartRankCohereAdapter");
}
static defaults = {
adapter: "cohere",
description: "Cohere",
default_model: "rerank-v3.5",
endpoint: "https://api.cohere.ai/v2/rerank"
};
/**
* Get the request adapter class.
* @returns {typeof SmartRankCohereRequestAdapter} The request adapter class
*/
get req_adapter() {
return SmartRankCohereRequestAdapter;
}
/**
* Get the response adapter class.
* @returns {typeof SmartRankCohereResponseAdapter} The response adapter class
*/
get res_adapter() {
return SmartRankCohereResponseAdapter;
}
/**
* Load the adapter
* @async
* @returns {Promise<void>}
*/
async load() {
this.model.model_loaded = true;
this.set_state("loaded");
return;
}
/**
* Rank documents using Cohere API
* @param {string} query - The query
* @param {Array<string>} documents - Documents to rank
* @returns {Promise<Array<Object>>} Ranked documents
*/
async rank(query, documents) {
const request_adapter = new this.req_adapter(this, query, documents);
const request_params = request_adapter.to_platform();
const resp_json = await this.request(request_params);
if (!resp_json || !resp_json.results) {
return {
message: resp_json?.message || "Invalid response from Cohere API",
resp: resp_json
};
}
const response_adapter = new this.res_adapter(this, resp_json);
return response_adapter.to_standard();
}
/**
* Handle API request errors with specific logic for Cohere
* @param {Error|Object} error - Error object
* @param {Object} req - Original request
* @param {number} retries - Number of retries attempted
* @returns {Promise<Object|null>} Retry response or null
*/
async handle_request_err(error, req, retries) {
if (error && error.status === 429 && retries < 3) {
const backoff = Math.pow(retries + 1, 2);
console.log(`Cohere API rate limit exceeded. Retrying in ${backoff} seconds...`);
await new Promise((resolve) => setTimeout(resolve, 1e3 * backoff));
return await this.request(req, retries + 1);
}
console.error("Cohere API Error:", error);
return null;
}
get settings_config() {
return settings_config13;
}
get models() {
return cohere_models;
}
};
var settings_config13 = {
...settings_config12,
"[ADAPTER].api_key": {
name: "Cohere API Key",
type: "password",
description: "Enter your Cohere API key for ranking.",
placeholder: "Enter Cohere API Key"
}
};
var cohere_models = {
"rerank-v3.5": {
id: "rerank-v3.5",
description: "State-of-the-art performance in English and non-English languages. Supports documents and semi-structured data (JSON). Context length: 4096 tokens"
},
"rerank-english-v3.0": {
id: "rerank-english-v3.0",
description: "English language documents and semi-structured data (JSON). Context length: 4096 tokens"
},
"rerank-multilingual-v3.0": {
id: "rerank-multilingual-v3.0",
description: "Non-English documents and semi-structured data (JSON). Supports same languages as embed-multilingual-v3.0. Context length: 4096 tokens"
}
};
var SmartRankCohereRequestAdapter = class extends SmartRankModelRequestAdapter {
static {
__name(this, "SmartRankCohereRequestAdapter");
}
/**
* Prepare request body for Cohere API
* @returns {Object} Request body for API
*/
prepare_request_body() {
return {
query: this.query,
documents: this.documents,
model: this.adapter.model_key,
top_n: 1e3,
max_tokens_per_doc: 4096
};
}
};
var SmartRankCohereResponseAdapter = class extends SmartRankModelResponseAdapter {
static {
__name(this, "SmartRankCohereResponseAdapter");
}
/**
* Parse Cohere API response into standard ranking results.
* @returns {Array<Object>} Parsed ranking results
*/
parse_response() {
if (!this.response.results) {
console.error("Invalid response format from Cohere API:", this.response);
return [];
}
return this.response.results.map((result) => ({
index: result.index,
score: result.relevance_score
}));
}
};

var CohereRankingModelAdapter = class extends SmartRankCohereAdapter {
static {
__name(this, "CohereRankingModelAdapter");
}
constructor(model_item) {
super(model_item);
}
get http_adapter() {
if (!this._http_adapter) {
const HttpClass = this.model.env.config.modules.http_adapter.class;
const http_params = { ...this.model.env.config.modules.http_adapter, class: void 0 };
this._http_adapter = new HttpClass(http_params);
}
return this._http_adapter;
}
get_models() {
return this.models;
}
};
var settings_config14 = {
api_key: {
name: "Cohere API Key",
type: "password",
description: "Enter your Cohere API key for ranking.",
placeholder: "Enter Cohere API Key"
}
};
var cohere_default = {
class: CohereRankingModelAdapter,
settings_config: settings_config14
};

var RankingModels = class extends Models2 {
static {
__name(this, "RankingModels");
}
model_type = "Ranking";
get default_provider_key() {
return "cohere";
}
};
var ranking_models_collection = {
class: RankingModels,
data_dir: "ranking_models",
collection_key: "ranking_models",
data_adapter: ajson_single_file_default2,
item_type: RankingModel,
providers: {
cohere: cohere_default
},
settings_config: settings_config10
};
var ranking_models_default = ranking_models_collection;

var ranking_models_default2 = ranking_models_default;

var EntitiesVectorAdapter2 = class {
static {
__name(this, "EntitiesVectorAdapter");
}
/**
* @constructor
* @param {import('smart-entities').SmartEntities} collection - The collection (SmartEntities or derived class) instance.
*/
constructor(collection) {
this.collection = collection;
}
/**
* Find the nearest entities to the given vector.
* @async
* @param {number[]} vec - The reference vector.
* @param {Object} [filter={}] - Optional filters (limit, exclude, etc.)
* @returns {Promise<Array<{item: import('smart-entities').SmartEntity, score:number}>>} Array of results sorted by score descending.
* @abstract
* @throws {Error} Not implemented by default.
*/
async nearest(vec, filter = {}) {
throw new Error("EntitiesVectorAdapter.nearest() not implemented");
}
/**
* Find the furthest entities from the given vector.
* @async
* @param {number[]} vec - The reference vector.
* @param {Object} [filter={}] - Optional filters (limit, exclude, etc.)
* @returns {Promise<Array<{item: import('smart-entities').SmartEntity, score:number}>>} Array of results sorted by score ascending (furthest).
* @abstract
* @throws {Error} Not implemented by default.
*/
async furthest(vec, filter = {}) {
throw new Error("EntitiesVectorAdapter.furthest() not implemented");
}
/**
* Embed a batch of entities.
* @async
* @param {Object[]} entities - Array of entity instances to embed.
* @returns {Promise<void>}
* @abstract
* @throws {Error} Not implemented by default.
*/
async embed_batch(entities) {
throw new Error("EntitiesVectorAdapter.embed_batch() not implemented");
}
/**
* Process a queue of entities waiting to be embedded.
* Typically, this will call embed_batch in batches and update entities.
* @async
* @param {Object[]} embed_queue - Array of entities to embed.
* @returns {Promise<void>}
* @abstract
* @throws {Error} Not implemented by default.
*/
async process_embed_queue(embed_queue) {
throw new Error("EntitiesVectorAdapter.process_embed_queue() not implemented");
}
};

function cos_sim2(vector1 = [], vector2 = []) {
if (vector1.length !== vector2.length) {
throw new Error("Vectors must have the same length");
}
let dot_product = 0;
let magnitude1 = 0;
let magnitude2 = 0;
const epsilon = 1e-8;
for (let i = 0; i < vector1.length; i++) {
dot_product += vector1[i] * vector2[i];
magnitude1 += vector1[i] * vector1[i];
magnitude2 += vector2[i] * vector2[i];
}
magnitude1 = Math.sqrt(magnitude1);
magnitude2 = Math.sqrt(magnitude2);
if (magnitude1 < epsilon || magnitude2 < epsilon) return 0;
return dot_product / (magnitude1 * magnitude2);
}
__name(cos_sim2, "cos_sim");

function results_acc2(_acc, result, ct = 10) {
if (_acc.results.size < ct) {
_acc.results.add(result);
if (_acc.results.size === ct && _acc.min === Number.POSITIVE_INFINITY) {
let { minScore, minObj } = find_min2(_acc.results);
_acc.min = minScore;
_acc.minResult = minObj;
}
} else if (result.score > _acc.min) {
_acc.results.add(result);
_acc.results.delete(_acc.minResult);
let { minScore, minObj } = find_min2(_acc.results);
_acc.min = minScore;
_acc.minResult = minObj;
}
}
__name(results_acc2, "results_acc");
function furthest_acc2(_acc, result, ct = 10) {
if (_acc.results.size < ct) {
_acc.results.add(result);
if (_acc.results.size === ct && _acc.max === Number.NEGATIVE_INFINITY) {
let { maxScore, maxObj } = find_max2(_acc.results);
_acc.max = maxScore;
_acc.maxResult = maxObj;
}
} else if (result.score < _acc.max) {
_acc.results.add(result);
_acc.results.delete(_acc.maxResult);
let { maxScore, maxObj } = find_max2(_acc.results);
_acc.max = maxScore;
_acc.maxResult = maxObj;
}
}
__name(furthest_acc2, "furthest_acc");
function find_min2(results) {
let minScore = Number.POSITIVE_INFINITY;
let minObj = null;
for (const obj of results) {
if (obj.score < minScore) {
minScore = obj.score;
minObj = obj;
}
}
return { minScore, minObj };
}
__name(find_min2, "find_min");
function find_max2(results) {
let maxScore = Number.NEGATIVE_INFINITY;
let maxObj = null;
for (const obj of results) {
if (obj.score > maxScore) {
maxScore = obj.score;
maxObj = obj;
}
}
return { maxScore, maxObj };
}
__name(find_max2, "find_max");

function sort_by_score2(a, b) {
const epsilon = 1e-9;
const score_diff = a.score - b.score;
if (Math.abs(score_diff) < epsilon) return 0;
return score_diff > 0 ? -1 : 1;
}
__name(sort_by_score2, "sort_by_score");
function sort_by_score_descending2(a, b) {
return sort_by_score2(a, b);
}
__name(sort_by_score_descending2, "sort_by_score_descending");
function sort_by_score_ascending2(a, b) {
return sort_by_score2(a, b) * -1;
}
__name(sort_by_score_ascending2, "sort_by_score_ascending");

var DefaultEntitiesVectorAdapter2 = class extends EntitiesVectorAdapter2 {
static {
__name(this, "DefaultEntitiesVectorAdapter");
}
constructor(collection) {
super(collection);
this._is_processing_embed_queue = false;
this._reset_embed_queue_stats();
}
/**
* Find the nearest entities to the given vector.
* @async
* @param {number[]} vec - The reference vector.
* @param {Object} [filter={}] - Optional filters (limit, exclude, etc.)
* @returns {Promise<Array<{item:Object, score:number}>>} Array of results sorted by score descending.
*/
async nearest(vec, filter = {}) {
if (!vec || !Array.isArray(vec)) {
throw new Error("Invalid vector input to nearest()");
}
const {
limit = 50
} = filter;
const nearest = this.collection.filter(filter).reduce((acc, item) => {
if (!item.vec) return acc;
const result = { item, score: cos_sim2(vec, item.vec) };
results_acc2(acc, result, limit);
return acc;
}, { min: 0, results: /* @__PURE__ */ new Set() });
return Array.from(nearest.results).sort(sort_by_score_descending2);
}
/**
* Find the furthest entities from the given vector.
* @async
* @param {number[]} vec - The reference vector.
* @param {Object} [filter={}] - Optional filters (limit, exclude, etc.)
* @returns {Promise<Array<{item:Object, score:number}>>} Array of results sorted by score ascending (furthest).
*/
async furthest(vec, filter = {}) {
if (!vec || !Array.isArray(vec)) {
throw new Error("Invalid vector input to furthest()");
}
const {
limit = 50
} = filter;
const furthest = this.collection.filter(filter).reduce((acc, item) => {
if (!item.vec) return acc;
const result = { item, score: cos_sim2(vec, item.vec) };
furthest_acc2(acc, result, limit);
return acc;
}, { max: 0, results: /* @__PURE__ */ new Set() });
return Array.from(furthest.results).sort(sort_by_score_ascending2);
}
/**
* Embed a batch of entities.
* @async
* @param {Object[]} entities - Array of entity instances to embed.
* @returns {Promise<void>}
*/
async embed_batch(entities) {
if (!this.collection.embed_model) {
throw new Error("No embed_model found in collection for embedding");
}
await Promise.all(entities.map((e) => e.get_embed_input()));
const embeddings = await this.collection.embed_model.embed_batch(entities);
embeddings.forEach((emb, i) => {
const entity = entities[i];
entity.vec = emb.vec;
entity.data.last_embed = entity.data.last_read;
if (emb.tokens !== void 0) entity.tokens = emb.tokens;
entity.emit_event("item:embedded");
});
}
/**
* Process a queue of entities waiting to be embedded.
* Prevents multiple concurrent runs by using `_is_processing_embed_queue`.
* @async
* @returns {Promise<void>}
*/
async process_embed_queue() {
if (this._is_processing_embed_queue) {
console.log("process_embed_queue is already running, skipping concurrent call.");
return;
}
this._is_processing_embed_queue = true;
try {
if (!this.collection.embed_model.is_loaded) {
await this.collection.embed_model.load();
}
} catch (e) {
this.collection.emit_event("embed_model:load_failed");
this.notices?.show("Failed to load embed_model");
return;
}
try {
const datetime_start = Date.now();
console.log(`Getting embed queue for ${this.collection.collection_key}...`);
await new Promise((resolve) => setTimeout(resolve, 1));
const embed_queue = this.collection.embed_queue;
this._reset_embed_queue_stats();
if (this.collection.embed_model_key === "None") {
console.log(`Smart Connections: No active embedding model for ${this.collection.collection_key}, skipping embedding`);
return;
}
if (!this.collection.embed_model) {
console.log(`Smart Connections: No active embedding model for ${this.collection.collection_key}, skipping embedding`);
return;
}
if (!embed_queue.length) {
console.log(`Smart Connections: No items in ${this.collection.collection_key} embed queue`);
return;
}
console.log(`Time spent getting embed queue: ${Date.now() - datetime_start}ms`);
console.log(`Processing ${this.collection.collection_key} embed queue: ${embed_queue.length} items`);
for (let i = 0; i < embed_queue.length; i += this.collection.embed_model.batch_size) {
if (this.is_queue_halted) {
this.is_queue_halted = false;
break;
}
this._show_embed_progress_notice(embed_queue.length);
const batch = embed_queue.slice(i, i + this.collection.embed_model.batch_size);
await Promise.all(batch.map((item) => item.get_embed_input()));
try {
const start_time = Date.now();
await this.embed_batch(batch);
this.total_time += Date.now() - start_time;
} catch (e) {
if (e && e.message && e.message.includes("API key not set")) {
this.halt_embed_queue_processing(`API key not set for ${this.collection.embed_model_key}
Please set the API key in the settings.`);
}
console.error(e);
console.error(`Error processing ${this.collection.collection_key} embed queue: ` + JSON.stringify(e || {}, null, 2));
}
batch.forEach((item) => {
item.embed_hash = item.read_hash;
item._queue_save = true;
});
this.embedded_total += batch.length;
this.total_tokens += batch.reduce((acc, item) => acc + (item.tokens || 0), 0);
if (this.embedded_total - this.last_save_total > 1e3) {
this.last_save_total = this.embedded_total;
await this.collection.process_save_queue();
if (this.collection.block_collection) {
console.log(`Saving ${this.collection.block_collection.collection_key} block collection`);
await this.collection.block_collection.process_save_queue();
}
}
}
this._show_embed_completion_notice(embed_queue.length);
await this.collection.process_save_queue();
if (this.collection.block_collection) {
await this.collection.block_collection.process_save_queue();
}
} finally {
this._is_processing_embed_queue = false;
}
}
get should_show_embed_progress_notice() {
if (Date.now() - (this.last_notice_time ?? 0) > 3e4) {
return true;
}
return this.embedded_total - this.last_notice_embedded_total >= 100;
}
/**
* Displays the embedding progress notice.
* @private
* @returns {void}
*/
_show_embed_progress_notice(embed_queue_length) {
if (embed_queue_length < 100) return;
if (!this.should_show_embed_progress_notice) return;
this.last_notice_time = Date.now();
this.last_notice_embedded_total = this.embedded_total;
this.collection.emit_event("embedding:progress_reported", {
progress: this.embedded_total,
total: embed_queue_length,
tokens_per_second: this._calculate_embed_tokens_per_second(),
model_name: this.collection.embed_model_key
});
this.notices?.show("embedding_progress", {
progress: this.embedded_total,
total: embed_queue_length,
tokens_per_second: this._calculate_embed_tokens_per_second(),
model_name: this.collection.embed_model_key
});
}
/**
* Displays the embedding completion notice.
* @private
* @returns {void}
*/
_show_embed_completion_notice() {
this.notices?.remove("embedding_progress");
if (this.embedded_total > 100) {
this.collection.emit_event("embedding:completed", {
total_embeddings: this.embedded_total,
tokens_per_second: this._calculate_embed_tokens_per_second(),
model_name: this.collection.embed_model_key
});
this.notices?.show("embedding_complete", {
total_embeddings: this.embedded_total,
tokens_per_second: this._calculate_embed_tokens_per_second(),
model_name: this.collection.embed_model_key
});
}
}
/**
* Halts the embed queue processing.
* @param {string|null} msg - Optional message.
*/
halt_embed_queue_processing(msg = null) {
this.is_queue_halted = true;
console.log("Embed queue processing halted");
this.notices?.remove("embedding_progress");
this.collection.emit_event("embedding:paused", {
progress: this.embedded_total,
total: this.collection._embed_queue.length,
tokens_per_second: this._calculate_embed_tokens_per_second(),
model_name: this.collection.embed_model_key
});
this.notices?.show("embedding_paused", {
progress: this.embedded_total,
total: this.collection._embed_queue.length,
tokens_per_second: this._calculate_embed_tokens_per_second(),
model_name: this.collection.embed_model_key
});
}
/**
* Resumes the embed queue processing after a delay.
* @param {number} [delay=0] - The delay in milliseconds before resuming.
* @returns {void}
*/
resume_embed_queue_processing(delay = 0) {
console.log("resume_embed_queue_processing");
this.notices?.remove("embedding_paused");
setTimeout(() => {
this.embedded_total = 0;
this.process_embed_queue();
}, delay);
}
/**
* Calculates the number of tokens processed per second.
* @private
* @returns {number} Tokens per second.
*/
_calculate_embed_tokens_per_second() {
const elapsed_time = this.total_time / 1e3;
return Math.round(this.total_tokens / (elapsed_time || 1));
}
/**
* Resets the statistics related to embed queue processing.
* @private
* @returns {void}
*/
_reset_embed_queue_stats() {
this.collection._embed_queue = [];
this.embedded_total = 0;
this.is_queue_halted = false;
this.last_save_total = 0;
this.last_notice_embedded_total = 0;
this.total_tokens = 0;
this.total_time = 0;
}
get notices() {
return this.collection.env.notices;
}
};

function murmur_hash_322(input_string, seed = 0) {
let remainder = input_string.length & 3;
let bytes = input_string.length - remainder;
let h1 = seed;
let c1 = 3432918353;
let c2 = 461845907;
let i = 0;
let k1 = 0;
let chunk = 0;
while (i < bytes) {
chunk = input_string.charCodeAt(i) & 255 | (input_string.charCodeAt(i + 1) & 255) << 8 | (input_string.charCodeAt(i + 2) & 255) << 16 | (input_string.charCodeAt(i + 3) & 255) << 24;
i += 4;
k1 = chunk;
k1 = multiply_322(k1, c1);
k1 = rotate_left_322(k1, 15);
k1 = multiply_322(k1, c2);
h1 ^= k1;
h1 = rotate_left_322(h1, 13);
h1 = h1 * 5 + 3864292196 | 0;
}
k1 = 0;
switch (remainder) {
case 3:
k1 ^= (input_string.charCodeAt(i + 2) & 255) << 16;
case 2:
k1 ^= (input_string.charCodeAt(i + 1) & 255) << 8;
case 1:
k1 ^= input_string.charCodeAt(i) & 255;
k1 = multiply_322(k1, c1);
k1 = rotate_left_322(k1, 15);
k1 = multiply_322(k1, c2);
h1 ^= k1;
break;
}
h1 ^= input_string.length;
h1 = fmix_322(h1);
return h1 | 0;
}
__name(murmur_hash_322, "murmur_hash_32");
function murmur_hash_32_alphanumeric2(input_string, seed = 0) {
const signed_hash = murmur_hash_322(input_string, seed);
const unsigned_hash = signed_hash >>> 0;
return unsigned_hash.toString(36);
}
__name(murmur_hash_32_alphanumeric2, "murmur_hash_32_alphanumeric");
function multiply_322(a, b) {
return (a & 65535) * b + ((a >>> 16) * b << 16) | 0;
}
__name(multiply_322, "multiply_32");
function rotate_left_322(value, shift) {
return value << shift | value >>> 32 - shift;
}
__name(rotate_left_322, "rotate_left_32");
function fmix_322(h) {
h ^= h >>> 16;
h = multiply_322(h, 2246822507);
h ^= h >>> 13;
h = multiply_322(h, 3266489909);
h ^= h >>> 16;
return h | 0;
}
__name(fmix_322, "fmix_32");

var FRONTMATTER_SUFFIX2 = "---frontmatter---";
var to_array2 = /* @__PURE__ */ __name((value) => {
if (Array.isArray(value)) {
return value.map((entry) => typeof entry === "string" ? entry.trim() : "").filter((entry) => entry.length > 0);
}
if (typeof value === "string") {
const parts = value.includes(",") ? value.split(",") : [value];
return parts.map((part) => part.trim()).filter((part) => part.length > 0);
}
return [];
}, "to_array");
var merge_settings_with_params2 = /* @__PURE__ */ __name((entity, params = {}) => ({
...entity.env.settings.smart_view_filter || {},
...params,
entity
}), "merge_settings_with_params");
var remove_limit_fields2 = /* @__PURE__ */ __name((filter_opts) => {
const next = { ...filter_opts };
if (typeof next.limit !== "undefined") delete next.limit;
if (next.filter) {
next.filter = { ...next.filter };
if (typeof next.filter.limit !== "undefined") delete next.filter.limit;
}
return next;
}, "remove_limit_fields");
var apply_frontmatter_exclusion2 = /* @__PURE__ */ __name((filter_opts) => {
if (!filter_opts.exclude_frontmatter_blocks) return filter_opts;
const next = { ...filter_opts };
const suffixes = Array.isArray(next.exclude_key_ends_with_any) ? [...next.exclude_key_ends_with_any] : [];
suffixes.push(FRONTMATTER_SUFFIX2);
next.exclude_key_ends_with_any = suffixes;
return next;
}, "apply_frontmatter_exclusion");
var append_entity_filters2 = /* @__PURE__ */ __name((filter_opts, entity) => {
if (!entity) return filter_opts;
const next = { ...filter_opts };
let exclude_starts = Array.isArray(next.exclude_key_starts_with_any) ? [...next.exclude_key_starts_with_any] : [];
if (typeof next.exclude_key_starts_with === "string") {
exclude_starts.push(next.exclude_key_starts_with);
delete next.exclude_key_starts_with;
}
const entity_key = entity.source_key || entity.key;
if (entity_key) exclude_starts.push(entity_key);
if (next.exclude_inlinks && Array.isArray(entity.inlinks) && entity.inlinks.length) {
exclude_starts = [...exclude_starts, ...entity.inlinks];
}
if (next.exclude_outlinks && Array.isArray(entity.outlinks) && entity.outlinks.length) {
exclude_starts = [...exclude_starts, ...entity.outlinks.map((o) => o.key)];
}
if (exclude_starts.length) next.exclude_key_starts_with_any = exclude_starts;
if (next.exclude_filter) {
const exclude_values = to_array2(next.exclude_filter);
const current = Array.isArray(next.exclude_key_includes_any) ? [...next.exclude_key_includes_any] : [];
next.exclude_key_includes_any = [...current, ...exclude_values];
}
if (next.include_filter) {
const include_values = to_array2(next.include_filter);
const current = Array.isArray(next.key_includes_any) ? [...next.key_includes_any] : [];
next.key_includes_any = [...current, ...include_values];
}
return next;
}, "append_entity_filters");
var create_find_connections_filter_opts2 = /* @__PURE__ */ __name((entity, params = {}) => {
const merged = merge_settings_with_params2(entity, params);
const without_limits = remove_limit_fields2(merged);
const with_frontmatter = apply_frontmatter_exclusion2(without_limits);
return append_entity_filters2(with_frontmatter, entity);
}, "create_find_connections_filter_opts");
async function find_connections3(params = {}) {
const limit = params.filter?.limit || params.limit || this.env.settings.smart_view_filter?.results_limit || 10;
const filter_opts = create_find_connections_filter_opts2(this, params);
if (params.filter?.limit) delete params.filter.limit;
if (params.limit) delete params.limit;
const cache_key = this.key + murmur_hash_32_alphanumeric2(JSON.stringify({ ...filter_opts, entity: null }));
if (!this.env.connections_cache) this.env.connections_cache = {};
if (!this.env.connections_cache[cache_key]) {
const connections = (await this.nearest(filter_opts)).sort(sort_by_score2).slice(0, limit);
this.connections_to_cache(cache_key, connections);
}
return this.connections_from_cache(cache_key);
}
__name(find_connections3, "find_connections");
find_connections3.action_type = "connections";

var SmartEntities2 = class extends Collection2 {
static {
__name(this, "SmartEntities");
}
/**
* Creates an instance of SmartEntities.
* @constructor
* @param {Object} env - The environment instance.
* @param {Object} opts - Configuration options.
*/
constructor(env, opts) {
super(env, opts);
this.entities_vector_adapter = new DefaultEntitiesVectorAdapter2(this);
this.model_instance_id = null;
this._embed_queue = [];
}
/**
* Unloads the smart embedding model.
* @async
* @returns {Promise<void>}
*/
async unload() {
if (typeof this.embed_model?.unload === "function") {
this.embed_model.unload();
}
super.unload();
}
/**
* Gets the key of the embedding model.
* @readonly
* @returns {string} The embedding model key.
*/
get embed_model_key() {
return this.embed_model?.model_key;
}
/**
* Gets the embedding model instance.
* @readonly
* @returns {Object|null} The embedding model instance or null if none.
*/
get embed_model() {
if (this.env.embedding_models.default) {
return this.env.embedding_models.default.instance;
}
throw new Error("DEPRECATED SMART ENVIRONMENT LOADED: UPDATE SMART PLUGINS.");
}
set embed_model(embed_model) {
this.env._embed_model = embed_model;
}
reload_embed_model() {
console.log("reload_embed_model");
this.embed_model.unload();
this.env._embed_model = null;
}
/**
* Finds the nearest entities to a given entity.
* @async
* @param {Object} entity - The reference entity.
* @deprecated moved to action (type=score) and retrieve using filter_and_score()/get_results() patterns
* @param {Object} [filter={}] - Optional filters to apply.
* @returns {Promise<Array<{item:Object, score:number}>>} An array of result objects with score and item.
*/
async nearest_to(entity, filter = {}) {
return await this.nearest(entity.vec, filter);
}
/**
* Finds the nearest entities to a vector using the default adapter.
* @async
* @deprecated moved to action (type=score) and retrieve using filter_and_score()/get_results() patterns
* @param {Array<number>} vec - The vector to compare against.
* @param {Object} [filter={}] - Optional filters to apply.
* @returns {Promise<Array<{item:Object, score:number}>>} An array of result objects with score and item.
*/
async nearest(vec, filter = {}) {
if (!vec) {
console.warn("nearest: no vec");
return [];
}
return await this.entities_vector_adapter.nearest(vec, filter);
}
/**
* Finds the furthest entities from a vector using the default adapter.
* @async
* @deprecated moved to action (type=score) and retrieve using filter_and_score()/get_results() patterns
* @param {Array<number>} vec - The vector to compare against.
* @param {Object} [filter={}] - Optional filters to apply.
* @returns {Promise<Array<{item:Object, score:number}>>} An array of result objects with score and item.
*/
async furthest(vec, filter = {}) {
if (!vec) return console.warn("furthest: no vec");
return await this.entities_vector_adapter.furthest(vec, filter);
}
/**
* Gets the file name based on collection key and embedding model key.
* @readonly
* @deprecated likely unused (2025-09-29)
* @returns {string} The constructed file name.
*/
get file_name() {
return this.collection_key + "-" + this.embed_model_key.split("/").pop();
}
/**
* Looks up entities based on hypothetical content.
* @deprecated moved to action (type=score) and retrieve using get_results() (pre-process generates hypothetical vecs)
* @async
* @param {Object} [params={}] - The parameters for the lookup.
* @param {Array<string>} [params.hypotheticals=[]] - The hypothetical content to lookup.
* @param {Object} [params.filter] - The filter to use for the lookup.
* @param {number} [params.k] - Deprecated: Use `filter.limit` instead.
* @returns {Promise<Array<Result>|Object>} The lookup results or an error object.
*/
async lookup(params = {}) {
const { hypotheticals = [] } = params;
if (!hypotheticals?.length) return { error: "hypotheticals is required" };
if (!this.embed_model) return { error: "Embedding search is not enabled." };
const hyp_vecs = await this.embed_model.embed_batch(hypotheticals.map((h) => ({ embed_input: h })));
const limit = params.filter?.limit || params.k || this.env.settings.lookup_k || 10;
if (params.filter?.limit) delete params.filter.limit;
const filter = {
...this.env.chats?.current?.scope || {},
...params.filter || {}
};
const results = await hyp_vecs.reduce(async (acc_promise, embedding, i) => {
const acc = await acc_promise;
const results2 = await this.nearest(embedding.vec, filter);
results2.forEach((result) => {
if (!acc[result.item.path] || result.score > acc[result.item.path].score) {
acc[result.item.path] = {
key: result.item.key,
score: result.score,
item: result.item,
hypothetical_i: i
};
} else {
result.score = acc[result.item.path].score;
}
});
return acc;
}, Promise.resolve({}));
const top_k = Object.values(results).sort(sort_by_score2).slice(0, limit);
console.log(`Found and returned ${top_k.length} ${this.collection_key}.`);
return top_k;
}
/**
* Gets the configuration for settings.
* @readonly
* @returns {Object} The settings configuration.
*/
get settings_config() {
return settings_config15;
}
/**
* @deprecated use env.render_component('collection_settings', this) instead (2025-05-25: decouple UI from collections)
*/
async render_settings(container = this.settings_container, opts = {}) {
container = await this.render_collection_settings(container, opts);
const embed_model_settings_frag = await this.env.render_component("settings", this.embed_model, opts);
container.appendChild(embed_model_settings_frag);
return container;
}
/**
* Gets the notices from the environment.
* @readonly
* @returns {Object} The notices object.
*/
get notices() {
return this.env.smart_connections_plugin?.notices || this.env.main?.notices;
}
/**
* Gets the embed queue containing items to be embedded.
* @readonly
* @returns {Array<Object>} The embed queue.
*/
get embed_queue() {
if (!this._embed_queue?.length) {
console.time(`Building embed queue`);
this._embed_queue = Object.values(this.items).filter((item) => item._queue_embed || item.is_unembedded && item.should_embed);
console.timeEnd(`Building embed queue`);
}
return this._embed_queue;
}
/**
* Processes the embed queue by delegating to the default vector adapter.
* @async
* @returns {Promise<void>}
*/
async process_embed_queue() {
await this.entities_vector_adapter.process_embed_queue();
}
/**
* Handles changes to the embedding model by reinitializing and processing the load queue.
* @async
* @returns {Promise<void>}
*/
async embed_model_changed() {
await this.unload();
await this.init();
this.render_settings();
await this.process_load_queue();
}
/**
* @deprecated since v4 2025-11-28
*/
get connections_filter_config() {
return connections_filter_config2;
}
};
var settings_config15 = {
"min_chars": {
name: "Minimum length",
type: "number",
description: "Minimum length of entity to embed (in characters).",
placeholder: "Enter number ex. 300",
default: 300
}
};
var connections_filter_config2 = {
"smart_view_filter.show_full_path": {
"name": "Show full path",
"type": "toggle",
"description": "Turning on will include the folder path in the connections results."
},
"smart_view_filter.results_limit": {
"name": "Results limit",
"type": "number",
"description": "Adjust the number of connections displayed in the connections view (default 20).",
"default": 20
},
"smart_view_filter.exclude_inlinks": {
"name": "Exclude inlinks (backlinks)",
"type": "toggle",
"description": "Exclude notes that already link to the current note from the connections results."
},
"smart_view_filter.exclude_outlinks": {
"name": "Exclude outlinks",
"type": "toggle",
"description": "Exclude notes that are already linked from within the current note from appearing in the connections results."
},
"smart_view_filter.include_filter": {
"name": "Include filter",
"type": "text",
"description": "Notes must match this value in their file/folder path. Matching notes will be included in the connections results. Separate multiple values with commas."
},
"smart_view_filter.exclude_filter": {
"name": "Exclude filter",
"type": "text",
"description": "Notes must *not* match this value in their file/folder path. Matching notes will be *excluded* from the connections results. Separate multiple values with commas."
},
"smart_view_filter.exclude_blocks_from_source_connections": {
"name": "Hide blocks in results",
"type": "toggle",
"description": "Show only sources in the connections results (no blocks)."
}
};

var SmartBlocks2 = class extends SmartEntities2 {
static {
__name(this, "SmartBlocks");
}
/**
* Initializes the SmartBlocks instance. Currently muted as processing is handled by SmartSources.
* @returns {void}
*/
init() {
}
get fs() {
return this.env.smart_sources.fs;
}
/**
* Retrieves the embedding model associated with the SmartSources collection.
* @readonly
* @returns {Object|undefined} The embedding model instance or `undefined` if not set.
*/
get embed_model() {
return this.source_collection?.embed_model;
}
/**
* Retrieves the embedding model key from the SmartSources collection.
* @readonly
* @returns {string|undefined} The embedding model key or `undefined` if not set.
*/
get embed_model_key() {
return this.source_collection?.embed_model_key;
}
/**
* Calculates the expected number of blocks based on the SmartSources collection.
* @readonly
* @returns {number} The expected count of blocks.
*/
get expected_blocks_ct() {
return Object.values(this.source_collection.items).reduce((acc, item) => acc += Object.keys(item.data.blocks || {}).length, 0);
}
/**
* Retrieves the notices system from the environment.
* @readonly
* @returns {Object} The notices object.
*/
get notices() {
return this.env.smart_connections_plugin?.notices || this.env.main?.notices;
}
/**
* Retrieves the settings configuration for SmartBlocks.
* @readonly
* @returns {Object} The settings configuration object.
*/
get settings_config() {
return this.process_settings_config({
"embed_blocks": {
name: "Embed blocks",
type: "toggle",
description: "Blocks represent parts/sections of notes. Get more granular results.",
default: true
},
...super.settings_config
});
}
render_settings(container, opts = {}) {
return this.render_collection_settings(container, opts);
}
get data_dir() {
return "multi";
}
/**
* Retrieves the SmartSources collection instance.
* @readonly
* @returns {SmartSources} The SmartSources collection.
*/
get source_collection() {
return this.env.smart_sources;
}
/**
* Processes the embed queue. Currently handled by SmartSources, so this method is muted.
* @async
* @returns {Promise<void>}
*/
async process_embed_queue() {
}
/**
* Processes the load queue. Currently muted as processing is handled by SmartSources.
* @async
* @returns {Promise<void>}
*/
async process_load_queue() {
}
/**
* @async
* @abstract
* @throws {Error} Throws an error indicating the method is not implemented.
* @returns {Promise<void>}
*/
async prune() {
throw "Not implemented: prune";
}
/**
* @throws {Error} Throws an error indicating the method is not implemented.
* @abstract
* @returns {void}
*/
build_links_map() {
throw "Not implemented: build_links_map";
}
/**
* @async
* @abstract
* @throws {Error} Throws an error indicating the method is not implemented.
* @returns {Promise<void>}
*/
async refresh() {
throw "Not implemented: refresh";
}
/**
* @async
* @abstract
* @throws {Error} Throws an error indicating the method is not implemented.
* @returns {Promise<void>}
*/
async search() {
throw "Not implemented: search";
}
/**
* @async
* @abstract
* @throws {Error} Throws an error indicating the method is not implemented.
* @returns {Promise<void>}
*/
async run_refresh() {
throw "Not implemented: run_refresh";
}
/**
* @async
* @abstract
* @throws {Error} Throws an error indicating the method is not implemented.
* @returns {Promise<void>}
*/
async run_force_refresh() {
throw "Not implemented: run_force_refresh";
}
async cleanup_blocks() {
const expired_blocks = Object.values(this.items).filter((i) => i.is_gone);
console.log(`Removing ${expired_blocks.length} expired blocks`);
expired_blocks.forEach((i) => i.delete());
await this.process_save_queue();
expired_blocks.forEach((i) => {
delete this.items[i.key];
});
this.emit_event("blocks:cleaned", { expired_blocks_ct: expired_blocks.length });
}
};

var settings_config17 = /* @__PURE__ */ __name((scope) => {
const config = {
"embed_blocks": {
name: "Embed blocks",
type: "toggle",
description: "Blocks represent parts/sections of notes. Get more granular results.",
default: true
},
...settings_config15
};
if (scope.settings.embed_blocks === false && config.min_chars) {
config.min_chars.disabled = true;
}
return config;
}, "settings_config");
var smart_blocks_default = {
class: SmartBlocks2,
collection_key: "smart_blocks",
settings_config: settings_config17
};

var import_obsidian47 = require("obsidian");

function escape_html2(str = "") {
return String(str).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}
__name(escape_html2, "escape_html");

function murmur_hash_323(input_string, seed = 0) {
let remainder = input_string.length & 3;
let bytes = input_string.length - remainder;
let h1 = seed;
let c1 = 3432918353;
let c2 = 461845907;
let i = 0;
let k1 = 0;
let chunk = 0;
while (i < bytes) {
chunk = input_string.charCodeAt(i) & 255 | (input_string.charCodeAt(i + 1) & 255) << 8 | (input_string.charCodeAt(i + 2) & 255) << 16 | (input_string.charCodeAt(i + 3) & 255) << 24;
i += 4;
k1 = chunk;
k1 = multiply_323(k1, c1);
k1 = rotate_left_323(k1, 15);
k1 = multiply_323(k1, c2);
h1 ^= k1;
h1 = rotate_left_323(h1, 13);
h1 = h1 * 5 + 3864292196 | 0;
}
k1 = 0;
switch (remainder) {
case 3:
k1 ^= (input_string.charCodeAt(i + 2) & 255) << 16;
case 2:
k1 ^= (input_string.charCodeAt(i + 1) & 255) << 8;
case 1:
k1 ^= input_string.charCodeAt(i) & 255;
k1 = multiply_323(k1, c1);
k1 = rotate_left_323(k1, 15);
k1 = multiply_323(k1, c2);
h1 ^= k1;
break;
}
h1 ^= input_string.length;
h1 = fmix_323(h1);
return h1 | 0;
}
__name(murmur_hash_323, "murmur_hash_32");
function murmur_hash_32_alphanumeric3(input_string, seed = 0) {
const signed_hash = murmur_hash_323(input_string, seed);
const unsigned_hash = signed_hash >>> 0;
return unsigned_hash.toString(36);
}
__name(murmur_hash_32_alphanumeric3, "murmur_hash_32_alphanumeric");
function multiply_323(a, b) {
return (a & 65535) * b + ((a >>> 16) * b << 16) | 0;
}
__name(multiply_323, "multiply_32");
function rotate_left_323(value, shift) {
return value << shift | value >>> 32 - shift;
}
__name(rotate_left_323, "rotate_left_32");
function fmix_323(h) {
h ^= h >>> 16;
h = multiply_323(h, 2246822507);
h ^= h >>> 13;
h = multiply_323(h, 3266489909);
h ^= h >>> 16;
return h | 0;
}
__name(fmix_323, "fmix_32");

function camel_case_to_snake_case3(str = "") {
return str.replace(/([A-Z])/g, (m) => `_${m.toLowerCase()}`).replace(/^_/, "").replace(/2$/, "");
}
__name(camel_case_to_snake_case3, "camel_case_to_snake_case");

function convert_to_time_ago2(timestamp) {
const now = Date.now();
const ms = timestamp < 1e12 ? timestamp * 1e3 : timestamp;
const diff_ms = now - ms;
const is_future = diff_ms < 0;
const seconds = Math.floor(Math.abs(diff_ms) / 1e3);
const intervals = [
{ label: "year", seconds: 31536e3 },
{ label: "month", seconds: 2592e3 },
{ label: "day", seconds: 86400 },
{ label: "hour", seconds: 3600 },
{ label: "minute", seconds: 60 },
{ label: "second", seconds: 1 }
];
for (const interval of intervals) {
const count = Math.floor(seconds / interval.seconds);
if (count >= 1) {
const suffix = `${count} ${interval.label}${count > 1 ? "s" : ""}`;
return is_future ? `in ${suffix}` : `${suffix} ago`;
}
}
return "just now";
}
__name(convert_to_time_ago2, "convert_to_time_ago");

function deep_merge3(target = {}, source = {}) {
for (const key in source) {
if (!Object.prototype.hasOwnProperty.call(source, key)) continue;
if (is_plain_object5(source[key]) && is_plain_object5(target[key])) {
deep_merge3(target[key], source[key]);
} else {
target[key] = source[key];
}
}
return target;
}
__name(deep_merge3, "deep_merge");
function is_plain_object5(o) {
return o && typeof o === "object" && !Array.isArray(o);
}
__name(is_plain_object5, "is_plain_object");

function cos_sim3(vector1 = [], vector2 = []) {
if (vector1.length !== vector2.length) {
throw new Error("Vectors must have the same length");
}
let dot_product = 0;
let magnitude1 = 0;
let magnitude2 = 0;
const epsilon = 1e-8;
for (let i = 0; i < vector1.length; i++) {
dot_product += vector1[i] * vector2[i];
magnitude1 += vector1[i] * vector1[i];
magnitude2 += vector2[i] * vector2[i];
}
magnitude1 = Math.sqrt(magnitude1);
magnitude2 = Math.sqrt(magnitude2);
if (magnitude1 < epsilon || magnitude2 < epsilon) return 0;
return dot_product / (magnitude1 * magnitude2);
}
__name(cos_sim3, "cos_sim");

function get_by_path2(obj, path, scope = null) {
if (!path) return "";
const keys = path.split(".");
if (scope) {
keys.unshift(scope);
}
const final_key = keys.pop();
const instance = keys.reduce((acc, key) => acc && acc[key], obj);
if (instance && typeof instance[final_key] === "function") {
return instance[final_key].bind(instance);
}
return instance ? instance[final_key] : void 0;
}
__name(get_by_path2, "get_by_path");

function set_by_path2(obj, path, value, scope = null) {
const keys = path.split(".");
if (scope) {
keys.unshift(scope);
}
const final_key = keys.pop();
const target = keys.reduce((acc, key) => {
if (!acc[key] || typeof acc[key] !== "object") {
acc[key] = {};
}
return acc[key];
}, obj);
target[final_key] = value;
}
__name(set_by_path2, "set_by_path");

function delete_by_path2(obj, path, scope = null) {
const keys = path.split(".");
if (scope) {
keys.unshift(scope);
}
const final_key = keys.pop();
const instance = keys.reduce((acc, key) => acc && acc[key], obj);
if (instance) {
delete instance[final_key];
}
}
__name(delete_by_path2, "delete_by_path");

function compute_centroid2(points) {
if (!points || points.length === 0) {
return null;
}
const n = points.length;
const dim = points[0].length;
const sums = new Float64Array(dim);
for (let i = 0; i < n; i++) {
const p = points[i];
for (let d = 0; d < dim; d++) {
sums[d] += p[d];
}
}
for (let d = 0; d < dim; d++) {
sums[d] /= n;
}
return Array.from(sums);
}
__name(compute_centroid2, "compute_centroid");
function compute_medoid2(points) {
if (!points || points.length === 0) {
return null;
}
if (points.length === 1) {
return points[0];
}
const n = points.length;
const dim = points[0].length;
const sum_of_distances = new Float64Array(n);
for (let i = 0; i < n - 1; i++) {
const p_i = points[i];
for (let j = i + 1; j < n; j++) {
const p_j = points[j];
let dist_sq = 0;
for (let d = 0; d < dim; d++) {
const diff = p_i[d] - p_j[d];
dist_sq += diff * diff;
}
const dist = Math.sqrt(dist_sq);
sum_of_distances[i] += dist;
sum_of_distances[j] += dist;
}
}
let min_index = 0;
let min_sum = sum_of_distances[0];
for (let i = 1; i < n; i++) {
if (sum_of_distances[i] < min_sum) {
min_sum = sum_of_distances[i];
min_index = i;
}
}
return points[min_index];
}
__name(compute_medoid2, "compute_medoid");

function ensure_settings_config2(settings_config40, scope) {
try {
if (typeof settings_config40 === "function") {
settings_config40 = settings_config40(scope);
}
} catch (e) {
console.error("Error evaluating settings_config function:", e);
settings_config40 = { error: { name: "Error", description: `Failed to load settings. ${e.message} (logged to console)` } };
}
return settings_config40;
}
__name(ensure_settings_config2, "ensure_settings_config");
function build_settings_group_map2(settings_config40, scope, default_group_name) {
const resolved_settings_config = ensure_settings_config2(settings_config40, scope);
return Object.entries(resolved_settings_config || {}).reduce((acc, [key, config]) => {
const group = config.group || default_group_name;
if (!acc[group]) acc[group] = {};
acc[group][key] = config;
return acc;
}, { [default_group_name]: {} });
}
__name(build_settings_group_map2, "build_settings_group_map");
function resolve_group_settings_config2(settings_config40, scope, group_name, default_group_name) {
const group_map = build_settings_group_map2(settings_config40, scope, default_group_name);
return group_map[group_name] || {};
}
__name(resolve_group_settings_config2, "resolve_group_settings_config");

var SettingGroupPolyfill2 = class {
static {
__name(this, "SettingGroupPolyfill");
}
constructor(container) {
this.components = [];
this.groupEl = container.createDiv("setting-group");
this.headerEl = this.groupEl.createDiv("setting-item setting-item-heading");
this.headerInnerEl = this.headerEl.createDiv("setting-item-name");
this.controlEl = this.headerEl.createDiv("setting-item-control");
this.listEl = this.groupEl.createDiv("setting-items");
}
setHeading(heading) {
this.headerInnerEl.setText(heading);
}
addSetting(callback) {
const setting = new import_obsidian47.Setting(this.listEl);
this.components.push(setting);
callback(setting);
return setting;
}
addClass(class_name) {
this.groupEl.addClass(class_name);
}
};
function render_settings_config2(settings_config40, scope, container, params = {}) {
const {
default_group_name = "Settings"
} = params;
const settings_config_source = settings_config40;
const group_map = build_settings_group_map2(settings_config40, scope, default_group_name);
const settings_groups = Object.entries(group_map).sort(([a], [b]) => a === default_group_name ? -1 : b === default_group_name ? 1 : 0).filter(([, group_config]) => Object.keys(group_config).length > 0).map(([group_name, group_config]) => {
const group_container = container.createDiv();
const group_params = {
...params,
...params.group_params?.[group_name] || {},
settings_config_source
};
return render_settings_group2(
group_name,
scope,
group_config,
group_container,
group_params
);
});
return settings_groups;
}
__name(render_settings_config2, "render_settings_config");
function render_settings_group2(group_name, scope, settings_config40, container, params = {}) {
const settings_config_source = params.settings_config_source || settings_config40;
const settings_config_group = params.settings_config_source ? resolve_group_settings_config2(
settings_config_source,
scope,
group_name,
params.default_group_name || "Settings"
) : settings_config40;
let SettingGroup;
try {
const obsidian_module = require("obsidian");
if (obsidian_module.SettingGroup) {
SettingGroup = obsidian_module.SettingGroup;
} else {
SettingGroup = SettingGroupPolyfill2;
}
} catch (e) {
SettingGroup = SettingGroupPolyfill2;
}
settings_config40 = settings_config_group;
const {
heading_btn = null
} = params;
const render_group = params.settings_config_source ? (group_name2, scope2, settings_config41, container2, group_params) => {
const group_config = resolve_group_settings_config2(
settings_config41,
scope2,
group_name2,
group_params.default_group_name || "Settings"
);
return render_settings_group2(group_name2, scope2, group_config, container2, group_params);
} : render_settings_group2;
const rerender_settings_group = create_settings_group_rerender2(scope, {
container,
group_name,
settings_config: settings_config_source,
group_params: params,
render_group
});
let setting_group = new SettingGroup(container);
if (heading_btn && typeof heading_btn === "object") {
if (Array.isArray(heading_btn)) {
for (const btn_config of heading_btn) {
render_heading_button2(setting_group, scope, btn_config);
}
} else {
render_heading_button2(setting_group, scope, heading_btn);
}
}
setting_group.setHeading(group_name);
for (const [setting_path, setting_config] of Object.entries(settings_config40)) {
if (!setting_config || typeof setting_config !== "object") {
console.warn(`Invalid setting config for ${setting_path}:`, setting_config);
continue;
}
const settng_is_pro = setting_config.scope_class === "pro-setting";
const env_is_pro = !!scope.env?.is_pro;
setting_group.addSetting((setting) => {
if (setting_config.name) setting.setName(setting_config.name);
setting.setClass(setting_path.replace(/[^a-zA-Z0-9]/g, "-"));
if (setting_config.type) setting.setClass(`setting-type-${setting_config.type}`);
if (setting_config.description) {
setting.setDesc(setting_config.description);
}
switch (setting_config.type) {
case "button":
setting.addButton((btn) => {
btn.setButtonText(setting_config.name || "Run");
btn.onClick(async (event) => {
if (typeof setting_config.callback === "function") {
await handle_config_callback2(setting, event, setting_config.callback, { scope });
}
});
});
break;
case "toggle":
setting.addToggle((toggle) => {
toggle.setValue(get_by_path2(scope.settings, setting_path) || false);
toggle.onChange((value) => {
set_by_path2(scope.settings, setting_path, value);
if (typeof setting_config.callback === "function") {
handle_config_callback2(setting, value, setting_config.callback, { scope });
}
});
});
break;
case "text":
setting.addText((text) => {
text.setValue(String(get_by_path2(scope.settings, setting_path) || ""));
text.onChange((value) => {
set_by_path2(scope.settings, setting_path, value);
});
});
break;
case "number":
setting.addText((text) => {
text.setValue(String(get_by_path2(scope.settings, setting_path) ?? "0"));
text.inputEl.setAttribute("type", "number");
text.onChange((value) => {
const num_value = Number(value);
if (!isNaN(num_value)) {
set_by_path2(scope.settings, setting_path, num_value);
}
if (typeof setting_config.callback === "function") {
handle_config_callback2(setting, num_value, setting_config.callback, { scope });
}
});
});
break;
case "dropdown":
setting.addDropdown((dropdown) => {
const options_callback = setting_config.options_callback;
if (typeof options_callback === "function") {
const options = options_callback.call(scope, scope);
options.forEach((opt) => {
const label = opt.label || opt.name || opt.value;
dropdown.addOption(opt.value, label);
});
}
dropdown.setValue(get_by_path2(scope.settings, setting_path) || "");
dropdown.onChange((value) => {
set_by_path2(scope.settings, setting_path, value);
if (typeof setting_config.callback === "function") {
handle_config_callback2(setting, value, setting_config.callback, { scope });
}
rerender_settings_group();
});
});
break;
case "textarea":
setting.addTextArea((text) => {
text.setValue(String(get_by_path2(scope.settings, setting_path) || ""));
text.onChange((value) => {
if (settng_is_pro && !env_is_pro) {
new import_obsidian47.Notice("Nice try! This is a PRO feature. Please upgrade to access this setting.");
return;
}
set_by_path2(scope.settings, setting_path, value);
});
if (settng_is_pro && !env_is_pro) {
text.setDisabled(true);
}
});
break;
case "slider":
setting.addSlider((slider) => {
const min = setting_config.min || 0;
const max = setting_config.max || 100;
const step = setting_config.step || 1;
slider.setLimits(min, max, step);
slider.setValue(get_by_path2(scope.settings, setting_path) || min);
slider.setDynamicTooltip();
slider.onChange((value) => {
set_by_path2(scope.settings, setting_path, value);
if (typeof setting_config.callback === "function") {
handle_config_callback2(setting, value, setting_config.callback, { scope });
}
});
});
break;
case "heading":
setting.setHeading();
break;
case "html":
if (setting_config.value) {
setting.descEl.replaceChildren(
document.createRange().createContextualFragment(setting_config.value)
);
}
break;
default:
console.warn(`Unsupported setting type for ${setting_path}:`, setting_config.type);
break;
}
if (setting_config.scope_class) {
setting.settingEl.addClass(setting_config.scope_class);
}
});
}
return setting_group;
}
__name(render_settings_group2, "render_settings_group");
function render_heading_button2(setting_group, scope, heading_btn) {
const btn_el = setting_group.controlEl.createEl("button", { cls: "" });
if (heading_btn.btn_icon) {
(0, import_obsidian47.setIcon)(btn_el, heading_btn.btn_icon);
}
if (heading_btn.btn_text) {
btn_el.setText(heading_btn.btn_text);
}
if (heading_btn.label) {
btn_el.setAttr("aria-label", heading_btn.label);
}
btn_el.addEventListener("click", async (event) => {
if (typeof heading_btn.callback === "function") {
await handle_config_callback2(null, event, heading_btn.callback, { scope });
} else {
console.warn("No callback defined for heading button");
}
});
setting_group.controlEl.appendChild(btn_el);
}
__name(render_heading_button2, "render_heading_button");
async function handle_config_callback2(setting, event_or_value, cb, params = {}) {
const {
scope = null
} = params;
if (scope) {
return await cb.call(scope, event_or_value, setting);
} else {
return await cb(event_or_value, setting);
}
}
__name(handle_config_callback2, "handle_config_callback");
function create_settings_group_rerender2(scope, params = {}) {
const {
container,
group_name,
settings_config: settings_config40,
group_params = {},
render_group
} = params;
return () => {
if (!container || typeof render_group !== "function") return null;
container.replaceChildren();
return render_group(group_name, scope, settings_config40, container, group_params);
};
}
__name(create_settings_group_rerender2, "create_settings_group_rerender");

var import_obsidian48 = require("obsidian");

function ensure_smart_sources_settings2(env) {
if (!env.settings) env.settings = {};
if (!env.settings.smart_sources) env.settings.smart_sources = {};
const smart_sources_settings = env.settings.smart_sources;
if (!smart_sources_settings.folder_exclusions) smart_sources_settings.folder_exclusions = "";
if (!smart_sources_settings.file_exclusions) smart_sources_settings.file_exclusions = "";
return smart_sources_settings;
}
__name(ensure_smart_sources_settings2, "ensure_smart_sources_settings");
function parse_exclusions_csv2(exclusions = "") {
return exclusions.split(",").map((value) => value.trim()).filter(Boolean);
}
__name(parse_exclusions_csv2, "parse_exclusions_csv");
function add_exclusion2(exclusions, value) {
const trimmed = (value ?? "").trim();
if (!trimmed) return exclusions || "";
const current = parse_exclusions_csv2(exclusions);
if (!current.includes(trimmed)) current.push(trimmed);
return current.join(",");
}
__name(add_exclusion2, "add_exclusion");
function remove_exclusion2(exclusions, value) {
const trimmed = (value ?? "").trim();
if (!trimmed) return exclusions?.trim() || "";
const filtered = parse_exclusions_csv2(exclusions).filter((entry) => entry !== trimmed);
return filtered.join(",");
}
__name(remove_exclusion2, "remove_exclusion");

var ExcludedFoldersFuzzy2 = class extends import_obsidian48.FuzzySuggestModal {
static {
__name(this, "ExcludedFoldersFuzzy");
}
/**
* @param {App} app - The Obsidian app
* @param {Object} env - An environment-like object, must have .settings and .fs.folder_paths
*/
constructor(app, env) {
super(app);
this.env = env;
this.setPlaceholder("Select a folder to exclude...");
}
/**
* Open the modal with an optional callback invoked after an item is chosen.
* The current exclusion list is rendered at the top of the modal.
* @param {Function} [selection_callback]
*/
open(selection_callback) {
this.callback = selection_callback;
super.open();
this.render_excluded_list();
}
/**
* Return candidate folder paths that are not already excluded.
* @returns {string[]}
*/
getItems() {
const smart_sources_settings = ensure_smart_sources_settings2(this.env);
const folder_exclusions3 = parse_exclusions_csv2(smart_sources_settings.folder_exclusions);
const candidates = (this.env.smart_sources?.fs?.folder_paths || []).filter((path) => !folder_exclusions3.includes(path));
return candidates;
}
getItemText(item) {
return item;
}
/**
* Handle selecting a folder to exclude.
* @param {string} item
*/
onChooseItem(item) {
this.prevent_close = true;
if (!item) return;
const smart_sources_settings = ensure_smart_sources_settings2(this.env);
smart_sources_settings.folder_exclusions = add_exclusion2(smart_sources_settings.folder_exclusions, item);
this.render_excluded_list();
this.updateSuggestions();
this.callback?.();
}
/**
* Render the current list of excluded folders at the top of the modal,
* with inline remove buttons.
*/
render_excluded_list() {
if (!this.modalEl) return;
const smart_sources_settings = ensure_smart_sources_settings2(this.env);
const excluded_folders = parse_exclusions_csv2(smart_sources_settings.folder_exclusions);
let header = this.modalEl.querySelector(".sc-excluded-folders-header");
if (!header) {
header = this.modalEl.createEl("div", { cls: "sc-excluded-folders-header" });
this.modalEl.prepend(header);
}
header.empty();
const title_el = header.createEl("h3");
title_el.setText("Excluded folders");
if (!excluded_folders.length) {
const empty_el = header.createEl("p");
empty_el.setText("No folders excluded yet.");
return;
}
const list_el = header.createEl("ul");
excluded_folders.forEach((folder_path) => {
const li = list_el.createEl("li", { cls: "excluded-folder-item" });
li.setText(folder_path + "  ");
const remove_btn = li.createEl("button", {
text: "(x)",
cls: "remove-excluded-folder-btn"
});
remove_btn.addEventListener("click", () => {
smart_sources_settings.folder_exclusions = remove_exclusion2(
smart_sources_settings.folder_exclusions,
folder_path
);
this.env.update_exclusions?.();
this.render_excluded_list();
this.updateSuggestions();
});
});
}
close() {
setTimeout(() => {
if (!this.prevent_close) super.close();
this.prevent_close = false;
}, 10);
}
};

var import_obsidian49 = require("obsidian");
var ExcludedSourcesModal2 = class extends import_obsidian49.Modal {
static {
__name(this, "ExcludedSourcesModal");
}
/**
* @param {Object} app - Obsidian app
* @param {Object} env - The environment instance
*/
constructor(app, env) {
super(app);
this.env = env;
}
async onOpen() {
this.titleEl.setText("Excluded Sources");
this.contentEl.addClass("excluded-sources-modal");
this.render_excluded_list();
}
async render_excluded_list() {
this.contentEl.empty();
const list_el = this.contentEl.createEl("ul");
const excluded_file_paths = this.env.smart_sources.excluded_file_paths;
const too_long_files = this.app.vault.getMarkdownFiles().filter((file) => file.path.length > 200).map((file) => file.path);
for (const file_path of excluded_file_paths) {
const li = list_el.createEl("li");
li.setText(file_path);
}
this.contentEl.createEl("hr");
this.contentEl.createEl("h3", { text: "Paths too long to import into Smart Environment" });
const too_long_list_ul = this.contentEl.createEl("ul", { cls: "too-long-exclusions" });
for (const file_path of too_long_files) {
const li = too_long_list_ul.createEl("li");
li.setText(file_path);
}
}
};

async function build_html26(env, opts = {}) {
return `
<div class="sources-settings">
</div>
`;
}
__name(build_html26, "build_html");
async function render26(env, opts = {}) {
const html = await build_html26.call(this, env, opts);
const frag = this.create_doc_fragment(html);
const container = frag.firstElementChild;
post_process25.call(this, env, container, opts);
return container;
}
__name(render26, "render");
async function post_process25(env, container, opts = {}) {
const settings_config40 = {
folder_exclusions: folder_exclusions2,
view_exclusions: view_exclusions2,
re_import_sources: re_import_sources2
};
render_settings_config2(settings_config40, env, container, {
default_group_name: "Sources",
heading_btn: {
btn_icon: "help-circle",
callback: /* @__PURE__ */ __name((event, setting) => {
window.open("https://smartconnections.app/smart-environment/settings/?utm_source=source-settings", "_external");
}, "callback")
}
});
const disposers = [];
disposers.push(env.events?.on("model:changed", highlight_reset_data2(env, container)));
this.attach_disposer(container, disposers);
return container;
}
__name(post_process25, "post_process");
function highlight_reset_data2(env, container) {
return async (payload) => {
if (payload.collection_key !== "embedding_models") return;
const re_import_setting = container.querySelector(".re-import-sources");
re_import_setting.classList.add("env-setting-highlight");
const notice = re_import_setting.querySelector(".reimport-notice") ? re_import_setting.querySelector(".reimport-notice") : re_import_setting.createEl("div", { cls: "reimport-notice env-setting-note" });
notice.textContent = "Embedding model changed. Please re-import your sources to update their embeddings.";
re_import_setting.appendChild(notice);
env.events.once("sources:reimported", () => {
re_import_setting.classList.remove("env-setting-highlight");
notice.remove();
});
};
}
__name(highlight_reset_data2, "highlight_reset_data");
var folder_exclusions2 = {
type: "button",
name: "Manage excluded folders",
description: "Manage the list of folders excluded from processing.",
btn_text: "Manage folders",
callback: /* @__PURE__ */ __name(async function(value, setting) {
const env = this;
const fuzzy = new ExcludedFoldersFuzzy2(env.main.app, env);
const selection_callback = /* @__PURE__ */ __name(() => {
env.update_exclusions();
}, "selection_callback");
fuzzy.open(selection_callback);
}, "callback")
};
var view_exclusions2 = {
type: "button",
name: "View all exclusions",
description: "View all excluded sources.",
btn_text: "Show",
callback: /* @__PURE__ */ __name(async function(value, setting) {
const env = this;
const modal = new ExcludedSourcesModal2(env.main.app, env);
modal.open();
}, "callback")
};
var re_import_sources2 = {
type: "button",
name: "Reset data",
description: "Clear sources data and re-import.",
btn_text: "Re-import sources",
callback: /* @__PURE__ */ __name(async function(value, setting) {
const env = this;
const container = setting.controlEl;
const confirm_row = container.createEl("div", { cls: "sc-inline-confirm-row" });
const reimport_btn = container.querySelector("button");
reimport_btn.style.display = "none";
confirm_row.setText("Are you sure you want to clear all sources data? This cannot be undone.");
let confirm_cancel = confirm_row.createEl("button", { text: "Cancel" });
let confirm_yes = confirm_row.createEl("button", { text: "Re-import", cls: "mod-warning" });
confirm_yes.addEventListener("click", async (e) => {
confirm_cancel.style.display = "none";
confirm_yes.textContent = "Re-importing...";
confirm_yes.disabled = true;
const confirm_row2 = e.target.closest(".sc-inline-confirm-row");
await env.smart_sources.run_clear_all();
const start = Date.now();
env.smart_sources.unload();
env.smart_blocks.unload();
await env.init_collections();
await env.load_collections();
await env.smart_sources.process_embed_queue();
const end = Date.now();
env.events?.emit("sources:reimported", { time_ms: end - start });
env.main.notices?.show("reload_sources", { time_ms: end - start });
confirm_row2.style.display = "none";
reimport_btn.style.display = "inline-block";
confirm_yes.textContent = "Yes";
confirm_yes.disabled = false;
});
confirm_cancel.addEventListener("click", (e) => {
confirm_row.style.display = "none";
reimport_btn.style.display = "inline-block";
}, { once: true });
}, "callback")
};

var import_obsidian50 = require("obsidian");
var ExcludedFilesFuzzy = class extends import_obsidian50.FuzzySuggestModal {
static {
__name(this, "ExcludedFilesFuzzy");
}
/**
* @param {App} app - The Obsidian app
* @param {Object} env - An environment-like object, must have .settings and .fs.file_paths
*/
constructor(app, env) {
super(app);
this.env = env;
this.setPlaceholder("Select a file to exclude...");
}
/**
* Open the modal with an optional callback invoked after an item is chosen.
* The current exclusion list is rendered at the top of the modal.
* @param {Function} [selection_callback]
*/
open(selection_callback) {
this.callback = selection_callback;
super.open();
this.render_excluded_list();
}
/**
* Return candidate file paths that are not already excluded.
* @returns {string[]}
*/
getItems() {
const smart_sources_settings = ensure_smart_sources_settings2(this.env);
const file_exclusions2 = parse_exclusions_csv2(smart_sources_settings.file_exclusions);
const candidates = (this.env.smart_sources?.fs?.file_paths || []).filter((path) => !file_exclusions2.includes(path));
return candidates;
}
getItemText(item) {
return item;
}
/**
* Handle selecting a file to exclude.
* @param {string} item
*/
onChooseItem(item) {
this.prevent_close = true;
if (!item) return;
const smart_sources_settings = ensure_smart_sources_settings2(this.env);
smart_sources_settings.file_exclusions = add_exclusion2(smart_sources_settings.file_exclusions, item);
this.render_excluded_list();
this.updateSuggestions();
this.callback?.();
}
/**
* Render the current list of excluded files at the top of the modal,
* with inline remove buttons.
*/
render_excluded_list() {
if (!this.modalEl) return;
const smart_sources_settings = ensure_smart_sources_settings2(this.env);
const excluded_files = parse_exclusions_csv2(smart_sources_settings.file_exclusions);
let header = this.modalEl.querySelector(".sc-excluded-files-header");
if (!header) {
header = this.modalEl.createEl("div", { cls: "sc-excluded-files-header" });
this.modalEl.prepend(header);
}
header.empty();
const title_el = header.createEl("h3");
title_el.setText("Excluded files");
if (!excluded_files.length) {
const empty_el = header.createEl("p");
empty_el.setText("No files excluded yet.");
return;
}
const list_el = header.createEl("ul");
excluded_files.forEach((file_path) => {
const li = list_el.createEl("li", { cls: "excluded-file-item" });
li.setText(file_path + "  ");
const remove_btn = li.createEl("button", {
text: "(x)",
cls: "remove-excluded-file-btn"
});
remove_btn.addEventListener("click", () => {
smart_sources_settings.file_exclusions = remove_exclusion2(
smart_sources_settings.file_exclusions,
file_path
);
this.env.update_exclusions?.();
this.render_excluded_list();
this.updateSuggestions();
});
});
}
close() {
setTimeout(() => {
if (!this.prevent_close) super.close();
this.prevent_close = false;
}, 10);
}
};

async function build_html27(env, opts = {}) {
return `
<div class="sources-pro-settings">
</div>
`;
}
__name(build_html27, "build_html");
async function render27(env, opts = {}) {
const html = await build_html27.call(this, env, opts);
const frag = this.create_doc_fragment(html);
const container = frag.firstElementChild;
post_process26.call(this, env, container, opts);
return container;
}
__name(render27, "render");
async function post_process26(env, container, opts = {}) {
const pro_settings_config = {
folder_exclusions: folder_exclusions2,
file_exclusions,
view_exclusions: view_exclusions2,
re_import_wait_time: {
type: "number",
name: "Re-import wait time",
description: "Time in seconds to wait before re-importing a file after modification.",
scope_class: "pro-setting"
},
"smart_blocks.embed_blocks": {
name: "Embed blocks",
type: "toggle",
description: "Blocks represent parts/sections of notes. Embedding allows more granular results in semantic lookups.",
scope_class: "pro-setting"
},
"smart_sources.min_chars": {
name: "Minimum length to embed (Sources)",
type: "number",
description: "Minimum number of characters a source must have to be embedded.",
scope_class: "pro-setting"
},
"smart_blocks.min_chars": {
name: "Minimum length to embed (Blocks)",
type: "number",
description: "Minimum number of characters a block must have to be embedded.",
scope_class: "pro-setting"
},
re_import_sources: re_import_sources2
};
render_settings_config2(pro_settings_config, env, container, {
default_group_name: "Sources",
heading_btn: {
btn_icon: "help-circle",
callback: /* @__PURE__ */ __name((event, setting) => {
window.open("https://smartconnections.app/smart-environment/settings/?utm_source=source-settings", "_external");
}, "callback")
}
});
const disposers = [];
disposers.push(env.events?.on("model:changed", highlight_reset_data2(env, container)));
this.attach_disposer(container, disposers);
return container;
}
__name(post_process26, "post_process");
var file_exclusions = {
type: "button",
name: "Manage excluded files",
description: "Manage the list of folders excluded from processing.",
btn_text: "Manage folders",
scope_class: "pro-setting",
callback: /* @__PURE__ */ __name(async function(value, setting) {
const env = this;
const fuzzy = new ExcludedFilesFuzzy(env.main.app, env);
const selection_callback = /* @__PURE__ */ __name(() => {
env.update_exclusions();
}, "selection_callback");
fuzzy.open(selection_callback);
}, "callback")
};

async function build_html28(env, opts = {}) {
return `
<div class="setting-component pro-setting">
<div class="setting-item">
<div class="info setting-item-info">
<div class="setting-item-name">Excluded files</div>
<div class="setting-item-description">Manage files to exclude from the environment.</div>
</div>
<div class="control setting-item-control">
<button class="sc-add-excluded-file-btn" type="button">Edit excluded files</button>
</div>
</div>
</div>
`;
}
__name(build_html28, "build_html");
async function render28(env, opts = {}) {
const html = await build_html28.call(this, env, opts);
const frag = this.create_doc_fragment(html);
const container = frag.firstElementChild;
post_process27.call(this, env, container, opts);
return container;
}
__name(render28, "render");
async function post_process27(env, container, opts = {}) {
const add_file_btn = container.querySelector(".sc-add-excluded-file-btn");
if (add_file_btn) {
add_file_btn.addEventListener("click", () => {
const fuzzy = new ExcludedFilesFuzzy(env.main.app, env);
fuzzy.open(() => {
env.update_exclusions();
});
});
}
return container;
}
__name(post_process27, "post_process");

var smart_env_config3 = {
collections: {
bases_caches: bases_caches_default,
chat_completion_models: chat_completion_models_default2,
ranking_models: ranking_models_default2,
smart_blocks: smart_blocks_default
},
item_types: {
ChatCompletionModel,
RankingModel
},
items: {
chat_completion_model: { class: ChatCompletionModel },
ranking_model: { class: RankingModel }
},
modules: {},
components: {
settings_env_sources: { render: render27 },
settings_sources_file_exclusions: { render: render28 }
},
actions: {}
};

var import_obsidian89 = require("obsidian");

var WILDCARD_KEY2 = "*";
var SmartEventsAdapter2 = class {
static {
__name(this, "SmartEventsAdapter");
}
constructor(instance) {
this.instance = instance;
this.handlers = /* @__PURE__ */ Object.create(null);
}
/**
* Register an event handler.
* When event_key is '*', the handler subscribes to all events.
* Handlers receive (event, event_key).
* @param {string} event_key
* @param {Function} event_callback
*/
on(event_key, event_callback) {
}
/**
* Register a one-time handler.
* When event_key is '*', the handler fires once on the next emitted event of any key.
* Handlers receive (event, event_key).
* @param {string} event_key
* @param {Function} event_callback
*/
once(event_key, event_callback) {
}
/**
* Remove an event handler.
* When event_key is '*', removes from the wildcard list only.
* @param {string} event_key
* @param {Function} event_callback
*/
off(event_key, event_callback) {
}
/**
* Emit an event.
* event_key must not be '*'.
* @param {string} event_key
* @param {Object} event
*/
emit(event_key, event) {
}
};

var DefaultEventsAdapter2 = class extends SmartEventsAdapter2 {
static {
__name(this, "DefaultEventsAdapter");
}
constructor(instance) {
super(instance);
this._next_id = 1;
}
on(event_key, event_callback = () => {
}) {
const key = event_key === WILDCARD_KEY2 ? WILDCARD_KEY2 : event_key;
const list = this.handlers[key] || (this.handlers[key] = []);
const entry = { id: this._next_id++, cb: event_callback };
list.push(entry);
return () => this.off_entry(key, entry.id);
}
once(event_key, event_callback = () => {
}) {
const key = event_key === WILDCARD_KEY2 ? WILDCARD_KEY2 : event_key;
const list = this.handlers[key] || (this.handlers[key] = []);
const entry = { id: this._next_id++, cb: null };
const wrapper = /* @__PURE__ */ __name((event, emitted_key) => {
this.off_entry(key, entry.id);
event_callback(event, emitted_key);
}, "wrapper");
entry.cb = wrapper;
list.push(entry);
return () => this.off_entry(key, entry.id);
}
/**
* Public removal by function reference.
* Removes a single matching registration for the given function.
* Preference is to remove the most-recent registration (LIFO) when duplicates exist.
*/
off(event_key, event_callback) {
const list = this.handlers[event_key];
if (!list || !event_callback) return;
for (let i = list.length - 1; i >= 0; i--) {
if (list[i].cb === event_callback) {
list.splice(i, 1);
break;
}
}
}
/**
* Internal precise removal by entry id.
* Used by unsubscribe closures returned from on/once.
*/
off_entry(event_key, entry_id) {
const list = this.handlers[event_key];
if (!list) return;
const idx = list.findIndex((e) => e.id === entry_id);
if (idx !== -1) list.splice(idx, 1);
}
emit(event_key, event = {}) {
if (event_key === WILDCARD_KEY2) {
throw new Error('emit("*") is not allowed; "*" is reserved for wildcard listeners.');
}
const specific_list = this.handlers[event_key];
const wildcard_list = this.handlers[WILDCARD_KEY2];
if (!specific_list && !wildcard_list) return;
const call_specific = specific_list ? [...specific_list] : [];
const call_wildcard = wildcard_list ? [...wildcard_list] : [];
for (let i = 0; i < call_specific.length; i++) {
call_specific[i].cb(event, event_key);
}
for (let i = 0; i < call_wildcard.length; i++) {
call_wildcard[i].cb(event, event_key);
}
}
};

var SmartEvents2 = class _SmartEvents {
static {
__name(this, "SmartEvents");
}
constructor(env, opts = {}) {
env.create_env_getter(this);
this.opts = opts;
}
static create(env, opts = {}) {
const smart_events = new _SmartEvents(env, opts);
if (!Object.getOwnPropertyDescriptor(env, "events")) {
Object.defineProperty(env, "events", { get: /* @__PURE__ */ __name(() => smart_events, "get") });
}
return smart_events;
}
get adapter() {
if (!this._adapter) {
this._adapter = this.opts.adapter_class ? new this.opts.adapter_class(this) : new DefaultEventsAdapter2(this);
}
return this._adapter;
}
on(event_key, event_callback = (event) => {
}) {
return this.adapter.on(event_key, event_callback);
}
once(event_key, event_callback = (event) => {
}) {
return this.adapter.once(event_key, event_callback);
}
off(event_key, event_callback = (event) => {
}) {
return this.adapter.off(event_key, event_callback);
}
/**
* Emit an event.
* @param {string} event_key
* @param {Record<string, unknown>} [event]
* @returns {void}
*/
emit(event_key, event = {}) {
const payload = { ...event };
if (payload.at === void 0) {
payload.at = Date.now();
}
Object.freeze(payload);
return this.adapter.emit(event_key, payload);
}
};

async function build_html29(env, opts = {}) {
const env_settings_html = Object.entries(env.settings_config).map(([setting_key, setting_config]) => {
if (!setting_config.setting) setting_config.setting = setting_key;
return this.render_setting_html(setting_config);
}).join("\n");
const env_collections_containers_html = Object.entries(env.collections).map(([collection_key, collection]) => {
return `<div data-smart-settings="${collection_key}"></div>`;
}).join("\n");
const html = `
<div class="">
${env_settings_html}
${env_collections_containers_html}
</div>
`;
return html;
}
__name(build_html29, "build_html");
async function render29(env, opts = {}) {
const html = await build_html29.call(this, env, opts);
const frag = this.create_doc_fragment(html);
return await post_process28.call(this, env, frag, opts);
}
__name(render29, "render");
async function post_process28(env, frag, opts = {}) {
await this.render_setting_components(frag, { scope: env });
const env_collections_containers = frag.querySelectorAll("[data-smart-settings]");
for (const env_collections_container of env_collections_containers) {
const collection_key = env_collections_container.dataset.smartSettings;
const collection = env[collection_key];
await collection.render_settings(env_collections_container);
}
return frag;
}
__name(post_process28, "post_process");

var SmartSettings2 = class {
static {
__name(this, "SmartSettings");
}
/**
* Creates an instance of SmartEnvSettings.
* @param {Object} main - The main object to contain the instance (smart_settings) and getter (settings)
* @param {Object} [opts={}] - Configuration options.
*/
constructor(main, opts = {}) {
this.main = main;
this.opts = opts;
this._fs = null;
this._settings = {};
this._saved = false;
this.save_timeout = null;
this.save_delay_ms = typeof opts.save_delay_ms === "number" ? opts.save_delay_ms : 1e3;
}
static async create(main, opts = {}) {
const smart_settings = new this(main, opts);
await smart_settings.load();
main.smart_settings = smart_settings;
Object.defineProperty(main, "settings", {
get() {
return smart_settings.settings;
},
set(settings) {
smart_settings.settings = settings;
}
});
return smart_settings;
}
static create_sync(main, opts = {}) {
const smart_settings = new this(main, opts);
smart_settings.load_sync();
main.smart_settings = smart_settings;
Object.defineProperty(main, "settings", {
get() {
return smart_settings.settings;
},
set(settings) {
smart_settings.settings = settings;
}
});
return smart_settings;
}
/**
* Gets the current settings, wrapped with an observer to handle changes.
* @returns {Proxy} A proxy object that observes changes to the settings.
*/
get settings() {
return observe_object2(this._settings, (change) => {
this.emit_settings_changed(change);
this.schedule_save();
});
}
/**
* Sets the current settings.
* @param {Object} settings - The new settings to apply.
*/
set settings(settings) {
this._settings = settings;
}
schedule_save() {
if (this.save_timeout) clearTimeout(this.save_timeout);
this.save_timeout = setTimeout(() => {
this.save(this._settings);
this.save_timeout = null;
}, this.save_delay_ms);
}
emit_settings_changed(change) {
const events_bus = this.resolve_events_bus();
if (!events_bus?.emit) return;
events_bus.emit("settings:changed", build_settings_changed_event2(change));
}
resolve_events_bus() {
if (this.opts.events) return this.opts.events;
if (typeof this.opts.emit === "function") {
return { emit: this.opts.emit };
}
if (this.main?.events) return this.main.events;
if (this.main?.env?.events) return this.main.env.events;
return null;
}
async save(settings = this._settings) {
if (typeof this.opts.save === "function") await this.opts.save(settings);
else await this.main.save_settings(settings);
}
async load() {
if (typeof this.opts.load === "function") this._settings = await this.opts.load();
else this._settings = await this.main.load_settings();
}
load_sync() {
if (typeof this.opts.load === "function") this._settings = this.opts.load();
else this._settings = this.main.load_settings();
}
};
function observe_object2(obj, on_change) {
const proxy_cache = /* @__PURE__ */ new WeakMap();
const proxy_targets = /* @__PURE__ */ new WeakMap();
const wrap_value = /* @__PURE__ */ __name((value, path) => {
if (!is_observable2(value)) return value;
if (proxy_targets.has(value)) return value;
if (proxy_cache.has(value)) return proxy_cache.get(value);
const proxy = create_proxy(value, path);
proxy_cache.set(value, proxy);
proxy_targets.set(proxy, value);
return proxy;
}, "wrap_value");
const create_proxy = /* @__PURE__ */ __name((target, path) => new Proxy(target, {
set(target2, property, value) {
const property_path = [...path, property];
const previous_snapshot = snapshot_value2(target2[property]);
const next_snapshot = snapshot_value2(value);
target2[property] = wrap_value(value, property_path);
if (has_changed2(previous_snapshot, next_snapshot)) {
on_change({
type: "set",
path: property_path,
value: next_snapshot,
previous_value: previous_snapshot
});
}
return true;
},
get(target2, property) {
const result = target2[property];
return wrap_value(result, [...path, property]);
},
deleteProperty(target2, property) {
if (!Object.prototype.hasOwnProperty.call(target2, property)) {
return true;
}
const property_path = [...path, property];
const previous_snapshot = snapshot_value2(target2[property]);
delete target2[property];
on_change({
type: "delete",
path: property_path,
previous_value: previous_snapshot
});
return true;
}
}), "create_proxy");
return wrap_value(obj, []);
}
__name(observe_object2, "observe_object");
function build_settings_changed_event2(change) {
const path = Array.isArray(change.path) ? change.path : [];
return {
type: change.type,
path,
path_string: path.join("."),
value: change.value,
previous_value: change.previous_value
};
}
__name(build_settings_changed_event2, "build_settings_changed_event");
function snapshot_value2(value) {
if (!is_observable2(value)) {
return value;
}
if (typeof structuredClone === "function") {
try {
return structuredClone(value);
} catch (error) {
}
}
try {
return JSON.parse(JSON.stringify(value));
} catch (error) {
return value;
}
}
__name(snapshot_value2, "snapshot_value");
function has_changed2(previous_snapshot, next_snapshot) {
return serialize_value2(previous_snapshot) !== serialize_value2(next_snapshot);
}
__name(has_changed2, "has_changed");
function serialize_value2(value) {
if (value === void 0) return "undefined";
if (Number.isNaN(value)) return "number:NaN";
if (value === Infinity) return "number:Infinity";
if (value === -Infinity) return "number:-Infinity";
if (!is_observable2(value)) {
return `${typeof value}:${String(value)}`;
}
try {
return `object:${JSON.stringify(value)}`;
} catch (error) {
return `object:${String(value)}`;
}
}
__name(serialize_value2, "serialize_value");
function is_observable2(value) {
return typeof value === "object" && value !== null;
}
__name(is_observable2, "is_observable");

function normalize_opts2(opts) {
if (!opts.collections) opts.collections = {};
if (!opts.modules) opts.modules = {};
if (!opts.items) opts.items = {};
Object.entries(opts.collections).forEach(([key, val]) => {
if (typeof val === "function") {
opts.collections[key] = { class: val };
}
const new_key = camel_case_to_snake_case3(key);
if (new_key !== key) {
opts.collections[new_key] = opts.collections[key];
delete opts.collections[key];
}
if (!opts.collections[new_key].collection_key) opts.collections[new_key].collection_key = new_key;
if (val.item_type) {
opts.items[val.item_type.key || camel_case_to_snake_case3(val.item_type.name)] = {
class: val.item_type
};
}
});
Object.entries(opts.modules).forEach(([key, val]) => {
if (typeof val === "function") {
opts.modules[key] = { class: val };
}
const new_key = camel_case_to_snake_case3(key);
if (new_key !== key) {
opts.modules[new_key] = opts.modules[key];
delete opts.modules[key];
}
});
if (!opts.item_types) opts.item_types = {};
if (!opts.items) opts.items = {};
Object.entries(opts.item_types).forEach(([key, val]) => {
if (typeof val === "function") {
const new_key = camel_case_to_snake_case3(key);
opts.items[new_key] = {
class: val,
actions: {},
...opts.items[new_key] || {}
};
}
});
return opts;
}
__name(normalize_opts2, "normalize_opts");

function is_plain_object6(value) {
if (!value || typeof value !== "object") return false;
const proto = Object.getPrototypeOf(value);
return proto === Object.prototype || proto === null;
}
__name(is_plain_object6, "is_plain_object");
function deep_clone_config2(input) {
if (Array.isArray(input)) {
return input.map((item) => deep_clone_config2(item));
}
if (is_plain_object6(input)) {
const output = {};
for (const [k, v] of Object.entries(input)) {
output[k] = deep_clone_config2(v);
}
return output;
}
return input;
}
__name(deep_clone_config2, "deep_clone_config");

function compare_versions2(new_value, cur_value) {
const a = normalize_version_value2(new_value);
const b = normalize_version_value2(cur_value);
const len = Math.max(a.parts.length, b.parts.length);
for (let i = 0; i < len; i++) {
const av = a.parts[i] !== void 0 ? a.parts[i] : 0;
const bv = b.parts[i] !== void 0 ? b.parts[i] : 0;
if (av > bv) return 1;
if (av < bv) return -1;
}
if (a.type === b.type) return 0;
if (a.type === "semver" && b.type !== "semver") return 1;
if (b.type === "semver" && a.type !== "semver") return -1;
if (a.type === "number" && b.type === "none") {
return a.parts[0] === 0 ? 0 : 1;
}
if (b.type === "number" && a.type === "none") {
return b.parts[0] === 0 ? 0 : -1;
}
return 0;
}
__name(compare_versions2, "compare_versions");
function normalize_version_value2(value) {
if (value === null || value === void 0) {
return { type: "none", parts: [0, 0, 0] };
}
if (typeof value === "number") {
if (!Number.isFinite(value)) {
return { type: "none", parts: [0, 0, 0] };
}
const major = Math.floor(value);
const minor = Math.floor((value - major) * 10);
return { type: "number", parts: [major, minor, 0] };
}
if (typeof value === "string") {
const trimmed = value.trim();
if (!trimmed) {
return { type: "none", parts: [0, 0, 0] };
}
const raw_parts = trimmed.split(".");
const parts = raw_parts.map((part) => {
const match = part.match(/^\d+/);
if (!match) return 0;
const num = Number.parseInt(match[0], 10);
return Number.isNaN(num) ? 0 : num;
});
while (parts.length < 3) {
parts.push(0);
}
return {
type: "semver",
parts
};
}
return { type: "none", parts: [0, 0, 0] };
}
__name(normalize_version_value2, "normalize_version_value");

function is_plain_object7(o) {
if (o === null) return false;
if (typeof o !== "object") return false;
if (Array.isArray(o)) return false;
if (o instanceof Function) return false;
if (o instanceof Date) return false;
return Object.getPrototypeOf(o) === Object.prototype;
}
__name(is_plain_object7, "is_plain_object");

function deep_merge_no_overwrite2(target, source, path = []) {
if (!is_plain_object7(target) || !is_plain_object7(source)) {
return target;
}
if (path.includes(source)) {
return target;
}
path.push(source);
for (const key of Object.keys(source)) {
if (!Object.prototype.hasOwnProperty.call(source, key)) {
continue;
}
const val = source[key];
if (Array.isArray(target[key]) && Array.isArray(val)) {
for (const item of val) {
if (typeof item === "function") {
const item_name = item.name;
const has_same_fn = target[key].some(
(el) => typeof el === "function" && el.name === item_name
);
if (!has_same_fn) {
target[key].push(item);
}
} else if (item === null || ["string", "number", "boolean", "undefined"].includes(typeof item)) {
if (!target[key].includes(item)) {
target[key].push(item);
}
} else {
target[key].push(item);
}
}
} else if (is_plain_object7(val)) {
if (!is_plain_object7(target[key])) {
target[key] = {};
}
deep_merge_no_overwrite2(target[key], val, [...path]);
} else if (!Object.prototype.hasOwnProperty.call(target, key)) {
target[key] = val;
}
}
return target;
}
__name(deep_merge_no_overwrite2, "deep_merge_no_overwrite");

function merge_env_config2(target, incoming) {
const CUR_VER = target.version;
const NEW_VER = incoming.version;
for (const [key, value] of Object.entries(incoming)) {
if (key === "collections" && value && typeof value === "object") {
if (!target.collections) target.collections = {};
for (const [col_key, col_def] of Object.entries(value)) {
const existing_def = target.collections[col_key];
if (!existing_def) {
target.collections[col_key] = { ...col_def };
continue;
}
const new_version_raw = col_def && col_def.version !== void 0 ? col_def.version : col_def?.class?.version;
const cur_version_raw = existing_def && existing_def.version !== void 0 ? existing_def.version : existing_def?.class?.version;
const cmp = compare_versions2(new_version_raw, cur_version_raw);
if (cmp > 0) {
const replaced = { ...col_def };
deep_merge_no_overwrite2(replaced, existing_def);
target.collections[col_key] = replaced;
} else {
deep_merge_no_overwrite2(existing_def, col_def);
}
}
continue;
}
if (["actions", "collections", "components", "item_types", "modules"].includes(key) && value && typeof value === "object") {
if (!target[key]) target[key] = {};
for (const [comp_key, comp_def] of Object.entries(value)) {
if (!target[key][comp_key]) {
target[key][comp_key] = { ...comp_def };
continue;
}
const target_comp = target[key][comp_key];
const incoming_ver = comp_def && comp_def.version;
const target_ver = target_comp && target_comp.version;
const cmp = compare_versions2(incoming_ver, target_ver);
if (cmp > 0) {
target[key][comp_key] = comp_def;
target[key][comp_key].version = incoming_ver || -1;
} else {
deep_merge_no_overwrite2(target_comp, comp_def);
}
}
continue;
}
if (Array.isArray(value)) {
if (Array.isArray(target[key])) {
if (value.length > 0 && (typeof value[0] === "string" || typeof value[0] === "number" || typeof value[0] === "boolean")) {
target[key] = Array.from(/* @__PURE__ */ new Set([...target[key], ...value]));
} else {
target[key] = [...target[key], ...value];
}
} else {
if (value.length > 0 && (typeof value[0] === "string" || typeof value[0] === "number" || typeof value[0] === "boolean")) {
target[key] = Array.from(new Set(value));
} else {
target[key] = [...value];
}
}
} else if (value && typeof value === "object") {
if (!target[key]) target[key] = {};
deep_merge_no_overwrite2(target[key], value);
} else {
target[key] = value;
}
}
return target;
}
__name(merge_env_config2, "merge_env_config");

function migrate_exclusion_settings_2025_08_222(settings = {}) {
const { file_exclusions: file_exclusions2, folder_exclusions: folder_exclusions3, excluded_headings } = settings;
if (file_exclusions2 !== void 0 || folder_exclusions3 !== void 0 || excluded_headings !== void 0) {
settings.smart_sources = settings.smart_sources || {};
if (file_exclusions2 !== void 0) {
if (file_exclusions2.length && file_exclusions2 !== "Untitled" && (!settings.smart_sources?.file_exclusions?.length || settings.smart_sources?.file_exclusions === "Untitled")) {
settings.smart_sources.file_exclusions = file_exclusions2;
}
}
if (folder_exclusions3 !== void 0) {
if (folder_exclusions3.length && !settings.smart_sources.folder_exclusions?.length) {
settings.smart_sources.folder_exclusions = folder_exclusions3;
}
}
if (excluded_headings !== void 0) {
if (excluded_headings.length && !settings.smart_sources.excluded_headings?.length) {
settings.smart_sources.excluded_headings = excluded_headings;
}
}
}
delete settings.file_exclusions;
delete settings.folder_exclusions;
delete settings.excluded_headings;
return settings;
}
__name(migrate_exclusion_settings_2025_08_222, "migrate_exclusion_settings_2025_08_22");

var ROOT_SCOPE2 = typeof globalThis !== "undefined" ? globalThis : Function("return this")();
var SmartEnv3 = class {
static {
__name(this, "SmartEnv");
}
static version = "2.2.8";
scope_name = "smart_env";
static global_ref = ROOT_SCOPE2;
global_ref = this.constructor.global_ref;
constructor(opts = {}) {
this.state = "init";
this._components = {};
this.collections = {};
this.load_timeout = null;
this._collections_version_signature = null;
this._events = SmartEvents2.create(this, build_events_opts2(this.config?.modules?.smart_events));
if (opts.primary_main_key) this.primary_main_key = opts.primary_main_key;
}
/**
* Builds or returns the cached configuration object.
* The cache is invalidated automatically whenever the “version signature”
* of any collection class changes (controlled by its static `version`).
*
* @returns {Object} the merged, up-to-date environment config
*/
get config() {
const signature = this.compute_collections_version_signature();
if (this._config && signature === this._collections_version_signature) {
return this._config;
}
this._collections_version_signature = signature;
this._config = {};
const sorted_configs = Object.entries(this.smart_env_configs).sort(([main_key]) => {
if (!this.primary_main_key) return 0;
return main_key === this.primary_main_key ? -1 : 0;
});
for (const [key, rec] of sorted_configs) {
if (!rec?.main) {
console.warn(`SmartEnv: '${key}' unloaded, skipping`);
delete this.smart_env_configs[key];
continue;
}
if (!rec?.opts) {
console.warn(`SmartEnv: '${key}' opts missing, skipping`);
continue;
}
merge_env_config2(
this._config,
deep_clone_config2(normalize_opts2(rec.opts))
);
}
return this._config;
}
/**
* Produces a deterministic string representing the current versions of every
* collection class across all mains.  When any collection ships a higher
* `static version`, the signature changes – automatically invalidating the
* cached `config`.
*
* @returns {string} pipe-delimited version signature
*/
compute_collections_version_signature() {
const list = [];
for (const rec of Object.values(this.smart_env_configs)) {
const { opts } = rec || {};
if (!opts) continue;
for (const [collection_key, def] of Object.entries(opts.collections || {})) {
const cls = def?.class;
const v = typeof cls?.version === "number" ? cls.version : 0;
list.push(`${collection_key}:${v}`);
}
}
return list.sort().join("|");
}
get env_start_wait_time() {
if (typeof this.config.env_start_wait_time === "number") return this.config.env_start_wait_time;
return 5e3;
}
static get global_env() {
return this.global_ref.smart_env;
}
static set global_env(env) {
this.global_ref.smart_env = env;
}
static get mains() {
return Object.keys(this.global_ref.smart_env_configs || {});
}
get mains() {
return Object.keys(this.global_ref.smart_env_configs || {});
}
static get should_reload() {
if (!this.global_env) return true;
if (this.global_env.state === "loaded") return true;
if (typeof this.global_env?.constructor?.version === "undefined") return true;
if (compare_versions2(this.version, this.global_env.constructor?.version) > 0) {
console.warn(
"SmartEnv: Reloading environment because of version mismatch",
`${this.version} > ${this.global_env.constructor.version}`
);
return true;
}
return false;
}
static get smart_env_configs() {
if (!this.global_ref.smart_env_configs) this.global_ref.smart_env_configs = {};
return this.global_ref.smart_env_configs;
}
get smart_env_configs() {
if (!this.global_ref.smart_env_configs) this.global_ref.smart_env_configs = {};
return this.global_ref.smart_env_configs;
}
/**
* Serializes all collection data in the environment into a plain object.
* @returns {object}
*/
to_json() {
return Object.fromEntries(
Object.entries(this).filter(([, val]) => typeof val?.collection_key !== "undefined").map(([key, collection]) => [key, collection_to_plain2(collection)])
);
}
/**
* Waits for either a specific main to be registered in the environment,
* or (if `opts.main` is not specified) waits for environment collections to load.
* @param {object} opts
* @param {object} [opts.main] - if set, the function waits until that main is found.
* @returns {Promise<SmartEnv>} Resolves with the environment instance
*/
static wait_for(opts = {}) {
return new Promise((resolve) => {
if (opts.main) {
const interval = setInterval(() => {
if (this.global_env && this.global_env[opts.main]) {
clearInterval(interval);
resolve(this.global_env);
}
}, 1e3);
} else {
const interval = setInterval(() => {
if (this.global_env && this.global_env.state === "loaded") {
clearInterval(interval);
resolve(this.global_env);
}
}, 100);
}
});
}
/**
* Creates or updates a SmartEnv instance.
* - If a global environment exists and is an older version or lacks 'init_main', it is replaced.
* @param {Object} main - The main object to be added to the SmartEnv instance.
* @param {Object} [env_config] - Options for configuring the SmartEnv instance.
* @returns {SmartEnv} The SmartEnv instance.
* @throws {TypeError} If an invalid main object is provided.
* @throws {Error} If there's an error creating or updating the SmartEnv instance.
*/
static async create(main, env_config) {
if (!main || typeof main !== "object") {
throw new TypeError("SmartEnv: Invalid main object provided");
}
if (!env_config) throw new Error("SmartEnv.create: 'env_config' parameter is required.");
env_config.version = this.version;
this.add_main(main, env_config);
if (this.should_reload) {
const opts = {};
if (this.global_env && compare_versions2(this.version, this.global_env.constructor?.version || 0) > 0) {
opts.primary_main_key = camel_case_to_snake_case3(main.constructor.name);
}
if (this.global_env?.load_timeout) clearTimeout(this.global_env.load_timeout);
this.global_env = new this(opts);
const g = this.global_ref;
if (!g.all_envs) g.all_envs = [];
g.all_envs.push(this.global_env);
}
clearTimeout(this.global_env.load_timeout);
this.global_env.load_timeout = setTimeout(async () => {
await this.global_env.load();
this.global_env.load_timeout = null;
}, this.global_env.env_start_wait_time);
return this.global_env;
}
static add_main(main, env_config = null) {
if (this.global_env) {
this.global_env._config = null;
this.global_env._collections_version_signature = null;
}
const main_key = camel_case_to_snake_case3(main.constructor.name);
this.smart_env_configs[main_key] = { main, opts: env_config };
this.create_env_getter(main);
}
/**
* Creates a dynamic environment getter on any instance object.
* The returned 'env' property will yield the global `smart_env`.
* @param {Object} instance_to_receive_getter
*/
static create_env_getter(instance_to_receive_getter) {
Object.defineProperty(instance_to_receive_getter, "env", {
configurable: true,
get: /* @__PURE__ */ __name(() => this.global_env, "get")
});
}
create_env_getter(instance_to_receive_getter) {
this.constructor.create_env_getter(instance_to_receive_getter);
}
async load() {
this.state = "loading";
await this.fs.load_files();
if (!this.settings) await SmartSettings2.create(this);
if (this.config.default_settings) {
deep_merge_no_overwrite2(this.settings, this.config.default_settings);
}
migrate_exclusion_settings_2025_08_222(this.settings);
this.smart_settings.save();
await this.init_collections();
for (const [main_key, { main, opts }] of Object.entries(this.smart_env_configs)) {
this[main_key] = main;
}
await this.ready_to_load_collections();
await this.load_collections();
this.state = "loaded";
}
/**
* Initializes collection classes if they have an 'init' function.
* @param {Object} [config=this.config]
*/
async init_collections(config = this.config) {
for (const key of Object.keys(config.collections || {})) {
const _class = config.collections[key]?.class;
if (!_class) continue;
if (_class.default_settings) {
deep_merge_no_overwrite2(
this.settings,
{
[key]: _class.default_settings
}
);
}
if (typeof _class.init !== "function") continue;
await _class.init(this, { ...config.collections[key] });
this.collections[key] = "init";
}
}
/**
* Hook/Override this method to wait for any conditions before loading collections.
* @param {Object} main
*/
async ready_to_load_collections() {
}
/**
* Loads any available collections, processing their load queues.
* @param {Object} [collections=this.collections] - Key-value map of collection instances.
*/
async load_collections(collections = this.collections) {
const collection_keys = Object.keys(collections || {}).sort((a, b) => {
const order_a = this.config.collections?.[a]?.load_order || 0;
const order_b = this.config.collections?.[b]?.load_order || 0;
return order_a - order_b;
});
for (const key of collection_keys) {
const time_start = Date.now();
if (typeof this[key]?.process_load_queue === "function") {
await this[key].process_load_queue();
this[key].load_time_ms = Date.now() - time_start;
this.collections[key] = "loaded";
console.log(`Loaded ${this[key].collection_key} in ${this[key].load_time_ms}ms`);
}
}
}
/**
* Removes a main from the global.smart_env_configs to exclude it on reload
* @param {Class} main
* @param {Object|null} [unload_config=null]
*/
static unload_main(main) {
const main_key = camel_case_to_snake_case3(main.constructor.name);
this.smart_env_configs[main_key] = null;
delete this.smart_env_configs[main_key];
}
unload_main(main) {
this.constructor.unload_main(main);
}
/**
* Triggers a save event in all known collections.
*/
save() {
for (const key of Object.keys(this.collections)) {
this[key].process_save_queue?.();
}
}
/**
* Initialize a module from the configured `this.opts.modules`.
* @param {string} module_key
* @param {object} opts
* @returns {object|null} instance of the requested module or null if not found
*/
init_module(module_key, opts = {}) {
const module_config = this.opts.modules[module_key];
if (!module_config) {
return console.warn(`SmartEnv: module ${module_key} not found`);
}
opts = {
...{ ...module_config, class: null },
...opts
};
return new module_config.class(opts);
}
get notices() {
if (!this._notices) {
const SmartNoticesClass = this.config.modules.smart_notices.class;
this._notices = new SmartNoticesClass(this, {
adapter: this.config.modules.smart_notices.adapter
});
}
return this._notices;
}
/**
* Exposes a settings template function from environment opts or defaults.
* @returns {Function}
*/
get settings_template() {
return this.opts.components?.smart_env?.settings || render29;
}
/**
* Renders settings UI into a container, using the environment's `settings_template`.
* @param {HTMLElement} [container=this.settings_container]
*/
async render_settings(container = this.settings_container) {
if (!this.settings_container || container !== this.settings_container) {
this.settings_container = container;
}
if (!container) {
throw new Error("Container is required");
}
const frag = await this.render_component("settings", this, {});
this.smart_view.empty(container);
container.appendChild(frag);
return frag;
}
/**
* Renders a named component using an optional scope and options.
* @deprecated use env.smart_components.render instead (2025-10-11)
* @param {string} component_key
* @param {Object} scope
* @param {Object} [opts]
* @returns {Promise<HTMLElement>}
*/
async render_component(component_key, scope, opts = {}) {
const component_renderer = this.get_component(component_key, scope);
if (!component_renderer) {
console.warn(`SmartEnv: component ${component_key} not found for scope ${scope.constructor.name}`);
return this.smart_view.create_doc_fragment(`<div class="smart-env-component-not-found">
<h1>Component Not Found</h1>
<p>The component ${component_key} was not found for scope ${scope.constructor.name}.</p>
</div>`);
}
const frag = await component_renderer(scope, opts);
return frag;
}
/**
* Retrieves or creates a memoized component renderer function.
* @deprecated use env.smart_components instead (2025-10-11)
* @param {string} component_key
* @param {Object} scope
* @returns {Function|undefined}
*/
get_component(component_key, scope) {
const scope_name = scope.collection_key ?? scope.scope_name;
const _cache_key = scope_name ? `${scope_name}-${component_key}` : component_key;
if (!this._components[_cache_key]) {
try {
if (this.opts.components[scope_name]?.[component_key]) {
const component_config = this.opts.components[scope_name][component_key];
const component = component_config.render || component_config;
this._components[_cache_key] = component.bind(
this.init_module("smart_view")
);
} else if (this.opts.components[component_key]) {
const component_config = this.opts.components[component_key];
const component = component_config.render || component_config;
this._components[_cache_key] = component.bind(
this.init_module("smart_view")
);
} else {
console.warn(
`SmartEnv: component ${component_key} not found for scope ${scope_name}`
);
}
} catch (e) {
console.error("Error getting component", e);
console.log(
`scope_name: ${scope_name}; component_key: ${component_key}; this.opts.components: ${Object.keys(
this.opts.components || {}
).join(", ")}; this.opts.components[scope_name]: ${Object.keys(
this.opts.components[scope_name] || {}
).join(", ")}`
);
}
}
return this._components[_cache_key];
}
/**
* A built-in settings schema for this environment.
* @abstract
* @returns {Object}
*/
get settings_config() {
return {};
}
get global_prop() {
return this.opts.global_prop ?? "smart_env";
}
get item_types() {
return this.config.item_types;
}
get fs_module_config() {
return this.opts.modules.smart_fs;
}
get fs() {
if (!this.smart_fs) {
this.smart_fs = new this.fs_module_config.class(this, {
adapter: this.fs_module_config.adapter,
fs_path: this.opts.env_path || ""
});
}
return this.smart_fs;
}
get env_data_dir() {
const env_settings_files = this.fs.file_paths?.filter((path) => path.endsWith("smart_env.json")) || [];
let env_data_dir = ".smart-env";
if (env_settings_files.length > 0) {
if (env_settings_files.length > 1) {
const env_data_dir_counts = env_settings_files.map((path) => {
const dir = path.split("/").slice(-2, -1)[0];
return {
dir,
count: this.fs.file_paths.filter((p) => p.includes(dir)).length
};
});
env_data_dir = env_data_dir_counts.reduce(
(max, dirObj) => dirObj.count > max.count ? dirObj : max,
env_data_dir_counts[0]
).dir;
} else {
env_data_dir = env_settings_files[0].split("/").slice(-2, -1)[0];
}
}
return env_data_dir;
}
get data_fs() {
if (!this._fs) {
this._fs = new this.fs_module_config.class(this, {
adapter: this.fs_module_config.adapter,
fs_path: this.data_fs_path
});
}
return this._fs;
}
get data_fs_path() {
if (!this._data_fs_path) {
this._data_fs_path = (this.opts.env_path + (this.opts.env_path ? this.opts.env_path.includes("\\") ? "\\" : "/" : "") + this.env_data_dir).replace(/\\\\/g, "\\").replace(/\/\//g, "/");
}
return this._data_fs_path;
}
/**
* Saves the current settings to the file system.
* @param {Object|null} [settings=null] - Optional settings to override the current settings before saving.
* @returns {Promise<void>}
*/
async save_settings(settings) {
this._saved = false;
if (!await this.data_fs.exists("")) {
await this.data_fs.mkdir("");
}
await this.data_fs.write("smart_env.json", JSON.stringify(settings, null, 2));
this._saved = true;
}
/**
* Loads settings from the file system, merging with any `default_settings`
* @returns {Promise<Object>} the loaded settings
*/
async load_settings() {
if (!await this.data_fs.exists("smart_env.json")) await this.save_settings({});
let settings = JSON.parse(JSON.stringify(this.config.default_settings || {}));
deep_merge3(settings, JSON.parse(await this.data_fs.read("smart_env.json")));
this._saved = true;
if (this.fs.auto_excluded_files) {
const existing_file_exclusions = settings.smart_sources.file_exclusions.split(",").map((s) => s.trim()).filter(Boolean);
settings.smart_sources.file_exclusions = [...existing_file_exclusions, ...this.fs.auto_excluded_files].filter((value, index, self) => self.indexOf(value) === index).join(",");
}
return settings;
}
/**
* Refreshes file-system state if exclusions changed,
* then re-renders relevant settings UI
*/
async update_exclusions() {
this.smart_sources._fs = null;
await this.smart_sources.init_fs();
}
/**
* Lazily instantiate the module 'smart_view'.
* @deprecated use env.smart_components instead (2025-09-30)
* @returns {object}
*/
get smart_view() {
if (!this._smart_view) {
this._smart_view = this.init_module("smart_view");
}
return this._smart_view;
}
/** @deprecated access `this.state` and `collection.state` directly instead */
get collections_loaded() {
return this.state === "loaded";
}
/** @deprecated Use this['main_class_name'] instead of this.main/this.plugin */
get main() {
return this.smart_env_configs[this.mains[0]]?.main;
}
/**
* @deprecated use component pattern instead
*/
get ejs() {
return this.opts.ejs;
}
/**
* @deprecated use component pattern instead
*/
get templates() {
return this.opts.templates;
}
/**
* @deprecated use component pattern instead
*/
get views() {
return this.opts.views;
}
/**
* @deprecated use this.config instead
*/
get opts() {
return this.config;
}
/**
* @deprecated Use this.main_class_name instead of this.plugin
*/
get plugin() {
return this.main;
}
};
function collection_to_plain2(collection) {
return {
items: Object.fromEntries(
Object.entries(collection.items || {}).map(([key, item]) => [key, item.data])
)
};
}
__name(collection_to_plain2, "collection_to_plain");
function build_events_opts2(module_config) {
if (!module_config) return {};
if (typeof module_config === "function") {
return { adapter_class: module_config };
}
const adapter_class = module_config.adapter_class || module_config.adapter;
return adapter_class ? { adapter_class } : {};
}
__name(build_events_opts2, "build_events_opts");

function create_regex2(pattern, { case_sensitive, extended_glob, windows_paths }) {
const regex_pattern = glob_to_regex_pattern2(pattern, extended_glob);
const adjusted_pattern = adjust_for_windows_paths2(regex_pattern, windows_paths);
const flags = case_sensitive ? "" : "i";
return new RegExp(`^${adjusted_pattern}$`, flags);
}
__name(create_regex2, "create_regex");
function adjust_for_windows_paths2(pattern, windows_paths) {
return windows_paths ? pattern.replace(/\\\//g, "[\\\\/]").replace(/\\\\\\/g, "[\\\\/]") : pattern;
}
__name(adjust_for_windows_paths2, "adjust_for_windows_paths");
function glob_to_regex_pattern2(pattern, extended_glob) {
let in_class = false;
let in_brace = 0;
let result = "";
for (let i = 0; i < pattern.length; i++) {
const char = pattern[i];
switch (char) {
case "\\":
if (i + 1 < pattern.length) {
result += `\\${pattern[i + 1]}`;
i++;
} else {
result += "\\\\";
}
break;
case "/":
result += "\\/";
break;
case "[":
if (!in_class) {
const closingIndex = pattern.indexOf("]", i + 1);
if (closingIndex === -1) {
result += "\\[";
} else {
in_class = true;
if (pattern[i + 1] === "!") {
result += "[^";
i++;
} else {
result += "[";
}
}
} else {
result += "\\[";
}
break;
case "]":
if (in_class) {
in_class = false;
result += "]";
} else {
result += "\\]";
}
break;
case "{":
if (!in_class) {
const closingIndex = pattern.indexOf("}", i + 1);
if (closingIndex === -1) {
result += "\\{";
} else {
in_brace++;
result += "(";
}
} else {
result += "\\{";
}
break;
case "}":
if (!in_class && in_brace > 0) {
in_brace--;
result += ")";
} else {
result += "\\}";
}
break;
case ",":
if (!in_class && in_brace > 0) {
result += "|";
} else {
result += ",";
}
break;
case "*":
if (!in_class) {
if (i + 1 < pattern.length && pattern[i + 1] === "*") {
result += ".*";
i++;
} else {
result += "[^/]*";
}
} else {
result += "\\*";
}
break;
case "?":
if (!in_class) {
result += "[^/]";
} else {
result += "\\?";
}
break;
case "(":
case ")":
case "+":
case "|":
case "^":
case "$":
case ".":
result += `\\${char}`;
break;
default:
result += char;
break;
}
}
if (in_class) {
result += "]";
in_class = false;
}
if (extended_glob) {
result = result.replace(/\\\+\\\((.*?)\\\)/g, "($1)+").replace(/\\\@\\\((.*?)\\\)/g, "($1)").replace(/\\\!\\\((.*?)\\\)/g, "(?!$1).*").replace(/\\\?\\\((.*?)\\\)/g, "($1)?").replace(/\\\*\\\((.*?)\\\)/g, "($1)*");
}
return result;
}
__name(glob_to_regex_pattern2, "glob_to_regex_pattern");
function glob_to_regex2(pattern, options = {}) {
const default_options = {
case_sensitive: true,
extended_glob: false,
windows_paths: false
};
const merged_options = { ...default_options, ...options };
if (pattern === "") {
return /^$/;
}
if (pattern === "*" && !merged_options.windows_paths) {
return /^[^/]+$/;
}
if (pattern === "**" && !merged_options.windows_paths) {
return /^.+$/;
}
return create_regex2(pattern, merged_options);
}
__name(glob_to_regex2, "glob_to_regex");

function fuzzy_search2(arr, search_term) {
let matches = [];
for (let i = 0; i < arr.length; i++) {
const search_chars = search_term.toLowerCase().split("");
let match = true;
let distance = 0;
const name = arr[i];
const label_name = name.toLowerCase();
for (let j = 0; j < search_chars.length; j++) {
const search_index = label_name.substring(distance).indexOf(search_chars[j]);
if (search_index >= 0) {
distance += search_index + 1;
} else {
match = false;
break;
}
}
if (match) matches.push({ name, distance });
}
matches.sort((a, b) => a.distance - b.distance);
return matches.map((match) => match.name);
}
__name(fuzzy_search2, "fuzzy_search");

var SmartFs2 = class {
static {
__name(this, "SmartFs");
}
/**
* Create a new SmartFs instance
*
* @param {Object} env - The Smart Environment instance
* @param {Object} [opts={}] - Optional configuration
* @param {string} [opts.fs_path] - Custom environment path
*/
constructor(env, opts = {}) {
this.env = env;
this.opts = opts;
this.fs_path = opts.fs_path || opts.env_path || "";
if (!opts.adapter) throw new Error("SmartFs requires an adapter");
this.adapter = new opts.adapter(this);
this.excluded_patterns = [];
if (Array.isArray(opts.exclude_patterns)) {
opts.exclude_patterns.forEach((pattern) => this.add_ignore_pattern(pattern));
}
this.folders = {};
this.files = {};
this.file_paths = [];
this.folder_paths = [];
this.auto_excluded_files = [];
}
async refresh() {
this.files = {};
this.file_paths = [];
this.folders = {};
this.folder_paths = [];
await this.init();
}
async init() {
await this.load_exclusions();
await this.load_files();
}
async load_files() {
const all = await this.list_recursive();
this.file_paths = [];
this.folder_paths = [];
all.forEach((file) => {
if (file.type === "file") {
this.files[file.path] = file;
this.file_paths.push(file.path);
} else if (file.type === "folder") {
this.folders[file.path] = file;
this.folder_paths.push(file.path);
}
});
}
include_file(file_path) {
const file = this.adapter.get_file(file_path);
this.files[file.path] = file;
this.file_paths.push(file.path);
return file;
}
/**
* Load .gitignore patterns
*
* @returns {Promise<RegExp[]>} Array of RegExp patterns
*/
async load_exclusions() {
const gitignore_path = ".gitignore";
const gitignore_exists = await this.adapter.exists(gitignore_path);
if (gitignore_exists && !this.env.settings.skip_excluding_gitignore) {
const gitignore_content = await this.adapter.read(gitignore_path, "utf-8");
gitignore_content.split("\n").filter((line) => !line.startsWith("#")).filter(Boolean).forEach((pattern) => this.add_ignore_pattern(pattern));
}
this.add_ignore_pattern(".**");
this.add_ignore_pattern("**/.**");
this.add_ignore_pattern("**/.*/**");
this.add_ignore_pattern("**/*.ajson");
}
/**
* Add a new ignore pattern
*
* @param {string} pattern - The pattern to add
*/
add_ignore_pattern(pattern, opts = {}) {
this.excluded_patterns.push(glob_to_regex2(pattern.trim(), opts));
}
/**
* Check if a path is ignored based on gitignore patterns
*
* @param {string} _path - The path to check
* @returns {boolean} True if the path is ignored, false otherwise
*/
is_excluded(_path) {
try {
if (_path.includes("#")) return true;
if (!this.excluded_patterns.length) return false;
return this.excluded_patterns.some((pattern) => pattern.test(_path));
} catch (e) {
console.error(`Error checking if path is excluded: ${e.message}`);
console.error(`Path: `, _path);
throw e;
}
}
/**
* Check if any path in an array of paths is excluded
*
* @param {string[]} paths - Array of paths to check
* @returns {boolean} True if any path is excluded, false otherwise
*/
has_excluded_patterns(paths) {
return paths.some((p) => this.is_excluded(p));
}
/**
* Pre-process an array of paths, throwing an error if any path is excluded
*
* @param {string[]} paths - Array of paths to pre-process
* @throws {Error} If any path in the array is excluded
* @returns {string[]} The array of paths
*/
pre_process(paths) {
if (this.has_excluded_patterns(paths)) {
throw new Error(`Path is excluded: ${paths.find((p) => this.is_excluded(p))}`);
}
return paths;
}
/**
* Post-process the result of an operation
*
* @param {any} returned_value - The value returned by the operation
* @returns {any} The post-processed value
*/
post_process(returned_value) {
if (this.adapter.post_process) return this.adapter.post_process(returned_value);
if (Array.isArray(returned_value)) {
returned_value = returned_value.filter((r) => {
if (typeof r === "string") return !this.is_excluded(r);
if (typeof r === "object" && r.path) return !this.is_excluded(r.path);
return true;
});
}
return returned_value;
}
/**
* Use the adapter for a method
* runs pre_process and post_process (checks exclusions)
* @param {string} method - The method to use
* @param {string[]} paths - The paths to use
* @param {...any} args - Additional arguments for the method
* @returns {Promise<any>} The result of the method
*/
async use_adapter(method, paths, ...args) {
if (!this.adapter[method]) throw new Error(`Method ${method} not found in adapter`);
paths = this.pre_process(paths ?? []);
let resp = await this.adapter[method](...paths, ...args);
return this.post_process(resp);
}
use_adapter_sync(method, paths, ...args) {
if (!this.adapter[method]) throw new Error(`Method ${method} not found in adapter`);
paths = this.pre_process(paths ?? []);
let resp = this.adapter[method](...paths, ...args);
return this.post_process(resp);
}
/**
* Append content to a file
*
* @param {string} rel_path - The relative path of the file to append to
* @param {string|Buffer} content - The content to append
* @returns {Promise<void>} A promise that resolves when the operation is complete
*/
async append(rel_path, content) {
return await this.use_adapter("append", [rel_path], content);
}
/**
* Create a new directory
*
* @param {string} rel_path - The relative path of the directory to create
* @returns {Promise<void>} A promise that resolves when the operation is complete
*/
async mkdir(rel_path, opts = { recursive: true }) {
return await this.use_adapter("mkdir", [rel_path], opts);
}
/**
* Check if a file or directory exists
*
* @param {string} rel_path - The relative path to check
* @returns {Promise<boolean>} True if the path exists, false otherwise
*/
async exists(rel_path) {
return await this.use_adapter("exists", [rel_path]);
}
exists_sync(rel_path) {
return this.use_adapter_sync("exists_sync", [rel_path]);
}
/**
* List files in a directory
*
* @param {string} rel_path - The relative path to list
* @returns {Promise<string[]>} Array of file paths
*/
async list(rel_path = "/") {
return await this.use_adapter("list", [rel_path]);
}
async list_recursive(rel_path = "/") {
return await this.use_adapter("list_recursive", [rel_path]);
}
async list_files(rel_path = "/") {
return await this.use_adapter("list_files", [rel_path]);
}
async list_files_recursive(rel_path = "/") {
return await this.use_adapter("list_files_recursive", [rel_path]);
}
async list_folders(rel_path = "/") {
return await this.use_adapter("list_folders", [rel_path]);
}
async list_folders_recursive(rel_path = "/") {
return await this.use_adapter("list_folders_recursive", [rel_path]);
}
/**
* Read the contents of a file
*
* @param {string} rel_path - The relative path of the file to read
* @returns {Promise<string|Buffer>} The contents of the file
*/
async read(rel_path, encoding = "utf-8") {
try {
const content = await this.adapter.read(rel_path, encoding);
return content;
} catch (error) {
console.warn("Error during read: " + error.message, rel_path);
if (error.code === "ENOENT") return null;
return { error: error.message };
}
}
/**
* Remove a file
*
* @param {string} rel_path - The relative path of the file to remove
* @returns {Promise<void>} A promise that resolves when the operation is complete
*/
async remove(rel_path) {
return await this.use_adapter("remove", [rel_path]);
}
/**
* Remove a directory
*
* @param {string} rel_path - The relative path of the directory to remove
* @returns {Promise<void>} A promise that resolves when the operation is complete
*/
async remove_dir(rel_path, recursive = false) {
return await this.use_adapter("remove_dir", [rel_path], recursive);
}
/**
* Rename a file or directory
*
* @param {string} rel_path - The current relative path
* @param {string} new_rel_path - The new relative path
* @returns {Promise<void>} A promise that resolves when the operation is complete
*/
async rename(rel_path, new_rel_path) {
await this.use_adapter("rename", [rel_path, new_rel_path]);
await this.refresh();
}
/**
* Get file or directory statistics
*
* @param {string} rel_path - The relative path to get statistics for
* @returns {Promise<Object>} An object containing file or directory statistics
*/
async stat(rel_path) {
return await this.use_adapter("stat", [rel_path]);
}
/**
* Write content to a file
* Should handle when target path is within a folder that doesn't exist
*
* @param {string} rel_path - The relative path of the file to write to
* @param {string|Buffer} content - The content to write
* @returns {Promise<void>} A promise that resolves when the operation is complete
*/
async write(rel_path, content) {
try {
await this.adapter.write(rel_path, content);
} catch (error) {
console.error("Error during write:", error);
throw error;
}
}
get_link_target_path(link_target, source_path) {
if (this.adapter.get_link_target_path) return this.adapter.get_link_target_path(link_target, source_path);
if (!this.file_paths) return console.warn("get_link_target_path: file_paths not found");
const matching_file_paths = this.file_paths.filter((path) => path.includes(link_target));
return fuzzy_search2(matching_file_paths, link_target)[0];
}
get sep() {
return this.adapter.sep || "/";
}
get_full_path(rel_path = "") {
return this.adapter.get_full_path(rel_path);
}
get base_path() {
return this.adapter.get_base_path();
}
};

var obsidian2 = __toESM(require("obsidian"), 1);
var ObsidianFsAdapter2 = class {
static {
__name(this, "ObsidianFsAdapter");
}
/**
* Create an ObsidianFsAdapter instance
*
* @param {Object} smart_fs - The SmartFs instance
*/
constructor(smart_fs) {
this.smart_fs = smart_fs;
this.obsidian = obsidian2;
this.obsidian_app = smart_fs.env.main.app;
this.obsidian_adapter = smart_fs.env.main.app.vault.adapter;
}
get fs_path() {
return this.smart_fs.fs_path;
}
get_file(file_path) {
const file = {};
file.path = file_path.replace(/\\/g, "/").replace(this.smart_fs.fs_path, "").replace(/^\//, "");
file.type = "file";
file.extension = file.path.split(".").pop().toLowerCase();
file.name = file.path.split("/").pop();
file.basename = file.name.split(".").shift();
Object.defineProperty(file, "stat", {
get: /* @__PURE__ */ __name(() => {
const tfile = this.obsidian_app.vault.getAbstractFileByPath(file_path);
if (tfile) {
return {
ctime: tfile.stat.ctime,
mtime: tfile.stat.mtime,
size: tfile.stat.size,
isDirectory: /* @__PURE__ */ __name(() => tfile instanceof this.obsidian.TFolder, "isDirectory"),
isFile: /* @__PURE__ */ __name(() => tfile instanceof this.obsidian.TFile, "isFile")
};
}
return null;
}, "get")
});
return file;
}
/**
* Append content to a file
*
* @param {string} rel_path - The relative path of the file to append to
* @param {string} data - The content to append
* @returns {Promise<void>} A promise that resolves when the operation is complete
*/
async append(rel_path, data) {
if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
return await this.obsidian_adapter.append(rel_path, data);
}
/**
* Create a new directory
*
* @param {string} rel_path - The relative path of the directory to create
* @returns {Promise<void>} A promise that resolves when the operation is complete
*/
async mkdir(rel_path) {
if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
return await this.obsidian_adapter.mkdir(rel_path);
}
/**
* Check if a file or directory exists
*
* @param {string} rel_path - The relative path to check
* @returns {Promise<boolean>} True if the path exists, false otherwise
*/
async exists(rel_path) {
if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
return await this.obsidian_adapter.exists(rel_path);
}
exists_sync(rel_path) {
return !!this.obsidian_app.vault.getAbstractFileByPath(rel_path);
}
/**
* List files in a directory (NOT up-to-date with list_recursive)
*
* @param {string} rel_path - The relative path to list
* @returns {Promise<string[]>} Array of file paths
*/
async list(rel_path, opts = {}) {
if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
if (rel_path.startsWith("/")) rel_path = rel_path.slice(1);
if (rel_path.endsWith("/")) rel_path = rel_path.slice(0, -1);
if (rel_path.includes(".")) {
const { files: file_paths } = await this.obsidian_adapter.list(rel_path);
const files2 = file_paths.map((file_path) => {
if (this.smart_fs.fs_path) file_path = file_path.replace(this.smart_fs.fs_path, "").slice(1);
const file_name = file_path.split("/").pop();
const file = {
basename: file_name.split(".")[0],
extension: file_name.split(".").pop().toLowerCase(),
name: file_name,
path: file_path
};
return file;
});
return files2;
}
const files = this.obsidian_app.vault.getAllLoadedFiles().filter((file) => {
const last_slash = file.path.lastIndexOf("/");
if (last_slash === -1 && rel_path !== "") return false;
const folder_path = file.path.slice(0, last_slash);
if (folder_path !== rel_path) return false;
return true;
});
return files;
}
async list_recursive(rel_path, opts = {}) {
if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
if (rel_path.startsWith("/")) rel_path = rel_path.slice(1);
if (rel_path.endsWith("/")) rel_path = rel_path.slice(0, -1);
const files = this.obsidian_app.vault.getAllLoadedFiles().filter((file) => {
if (file.path.length > 200) {
this.smart_fs.auto_excluded_files.push(file.path);
return false;
}
if (rel_path !== "" && !file.path.startsWith(rel_path)) return false;
if (file instanceof this.obsidian.TFile) {
if (opts.type === "folder") return false;
file.type = "file";
} else if (file instanceof this.obsidian.TFolder) {
if (opts.type === "file") return false;
delete file.basename;
delete file.extension;
file.type = "folder";
}
if (this.smart_fs.fs_path) file.path = file.path.replace(this.smart_fs.fs_path, "").slice(1);
return true;
});
return files;
}
async list_files(rel_path) {
return await this.list(rel_path, { type: "file" });
}
async list_files_recursive(rel_path) {
return await this.list_recursive(rel_path, { type: "file" });
}
async list_folders(rel_path) {
return await this.list(rel_path, { type: "folder" });
}
async list_folders_recursive(rel_path) {
return await this.list_recursive(rel_path, { type: "folder" });
}
/**
* Read the contents of a file
*
* @param {string} rel_path - The relative path of the file to read
* @returns {Promise<string>} The contents of the file
*/
async read(rel_path, encoding, opts = {}) {
if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
if (encoding === "utf-8") {
if (!opts.no_cache) {
const tfile = this.obsidian_app.vault.getFileByPath(rel_path);
if (tfile) return await this.obsidian_app.vault.cachedRead(tfile);
}
return await this.obsidian_adapter.read(rel_path);
}
if (encoding === "base64") {
const array_buffer2 = await this.obsidian_adapter.readBinary(rel_path, "base64");
const base644 = this.obsidian.arrayBufferToBase64(array_buffer2);
return base644;
}
const array_buffer = await this.obsidian_adapter.readBinary(rel_path);
return array_buffer;
}
/**
* Rename a file or directory
*
* @param {string} old_path - The current path of the file or directory
* @param {string} new_path - The new path for the file or directory
* @returns {Promise<void>} A promise that resolves when the operation is complete
*/
async rename(old_path, new_path) {
if (!old_path.startsWith(this.fs_path)) old_path = this.fs_path + "/" + old_path;
if (!new_path.startsWith(this.fs_path)) new_path = this.fs_path + "/" + new_path;
return await this.obsidian_adapter.rename(old_path, new_path);
}
/**
* Remove a file
*
* @param {string} rel_path - The relative path of the file to remove
* @returns {Promise<void>} A promise that resolves when the operation is complete
*/
async remove(rel_path) {
if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
try {
return await this.obsidian_adapter.remove(rel_path);
} catch (error) {
console.warn(`Error removing file: ${rel_path}`, error);
}
}
/**
* Remove a directory
*
* @param {string} rel_path - The relative path of the directory to remove
* @returns {Promise<void>} A promise that resolves when the operation is complete
*/
async remove_dir(rel_path, recursive = false) {
if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
return await this.obsidian_adapter.rmdir(rel_path, recursive);
}
/**
* Get file or directory information
*
* @param {string} rel_path - The relative path of the file or directory
* @returns {Promise<Object>} An object containing file or directory information
*/
async stat(rel_path) {
if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
return await this.obsidian_adapter.stat(rel_path);
}
/**
* Write content to a file
*
* @param {string} rel_path - The relative path of the file to write to
* @param {string} data - The content to write
* @returns {Promise<void>} A promise that resolves when the operation is complete
*/
async write(rel_path, data) {
if (!data) data = "";
if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
const folder_path = rel_path.split("/").slice(0, -1).join("/");
if (!await this.exists(folder_path)) {
await this.mkdir(folder_path);
console.log(`Created folder: ${folder_path}`);
}
return await this.obsidian_adapter.write(rel_path, data);
}
get_link_target_path(link_path, file_path) {
return this.obsidian_app.metadataCache.getFirstLinkpathDest(link_path, file_path)?.path;
}
get_base_path() {
return this.obsidian_adapter.basePath;
}
get_full_path(rel_path = "") {
const sep = rel_path.includes("/") ? "/" : "\\";
return this.get_base_path() + sep + rel_path;
}
/**
* Registers Obsidian vault/workspace listeners that emit Smart Environment events for Smart Sources.
* @param {import('smart-sources').SmartSources} sources_collection
* @returns {boolean}
*/
register_source_watchers(sources_collection) {
if (this._source_watchers_registered) return this._source_watchers_registered;
const plugin = this.smart_fs.env?.main;
if (!plugin?.registerEvent) {
console.warn("ObsidianFsAdapter: Unable to register source watchers without plugin context");
return false;
}
const { app } = plugin;
const emit_event = /* @__PURE__ */ __name((event_key, payload) => {
if (!payload?.path && !payload?.item_key) return;
this.smart_fs.env.events?.emit(event_key, {
collection_key: sources_collection.collection_key,
item_key: payload.item_key || payload.path,
...payload
});
}, "emit_event");
plugin.registerEvent(
app.vault.on("create", (file) => {
emit_event("sources:created", {
path: file.path,
event_source: "obsidian:vault.create"
});
})
);
plugin.registerEvent(
app.vault.on("modify", (file) => {
emit_event("sources:modified", {
path: file.path,
event_source: "obsidian:vault.modify"
});
})
);
plugin.registerEvent(
app.vault.on("rename", (file, old_path) => {
emit_event("sources:renamed", {
path: file.path,
old_path,
event_source: "obsidian:vault.rename"
});
})
);
plugin.registerEvent(
app.vault.on("delete", (file) => {
emit_event("sources:deleted", {
path: file.path,
event_source: "obsidian:vault.delete"
});
})
);
plugin.registerEvent(
app.workspace.on("editor-change", (_editor, info) => {
const file = info?.file;
if (!file) return;
emit_event("sources:modified", {
path: file.path,
event_source: "obsidian:workspace.editor-change"
});
})
);
this._source_watchers_registered = true;
return true;
}
};

function empty2(elm) {
const range = document.createRange();
range.selectNodeContents(elm);
range.deleteContents();
}
__name(empty2, "empty");

var replace_html2 = /* @__PURE__ */ (() => {
const cache = /* @__PURE__ */ new Map();
return (container, html_snippet) => {
const key = html_snippet.trim();
let tpl = cache.get(key);
if (!tpl) {
tpl = document.createElement("template");
tpl.innerHTML = key;
cache.set(key, tpl);
}
container.replaceChildren(tpl.content.cloneNode(true));
};
})();

var replace_with_fragment2 = /* @__PURE__ */ __name((container, html_snippet) => {
const range = document.createRange();
const frag = range.createContextualFragment(html_snippet.trim());
container.replaceChildren(frag);
}, "replace_with_fragment");

var restricted_re2 = /<(td|th|tr|thead|tbody|tfoot|caption|col|colgroup|option|optgroup|li|dt|dd|source|track)\b/i;
var safe_inner_html2 = /* @__PURE__ */ __name((container, html_snippet) => {
const trimmed = html_snippet.trim();
(restricted_re2.test(trimmed) ? replace_with_fragment2 : replace_html2)(container, trimmed);
}, "safe_inner_html");

var element_disposers2 = /* @__PURE__ */ new WeakMap();
var smart_setting_listeners2 = /* @__PURE__ */ new WeakMap();
var SmartView2 = class {
static {
__name(this, "SmartView");
}
static version = 0.1;
/**
* @constructor
* @param {object} opts - Additional options or overrides for rendering.
*/
constructor(opts = {}) {
this.opts = opts;
this._adapter = null;
}
/**
* Renders all setting components within a container.
* @async
* @param {HTMLElement|DocumentFragment} container - The container element.
* @param {Object} opts - Additional options for rendering.
* @returns {Promise<void>}
*/
async render_setting_components(container, opts = {}) {
const components = container.querySelectorAll(".setting-component");
const promises = [];
for (const component of components) {
promises.push(this.render_setting_component(component, opts));
}
await Promise.all(promises);
return container;
}
/**
* Creates a document fragment from HTML string.
* @param {string} html - The HTML string.
* @returns {DocumentFragment}
*/
create_doc_fragment(html) {
return document.createRange().createContextualFragment(html);
}
/**
* Gets the adapter instance used for rendering (e.g., Obsidian or Node, etc.).
* @returns {Object} The adapter instance.
*/
get adapter() {
if (!this._adapter) {
if (!this.opts.adapter) {
throw new Error("No adapter provided to SmartView. Provide a 'smart_view.adapter' in env config.");
}
const AdapterClass = this.opts.adapter;
this._adapter = new AdapterClass(this);
}
return this._adapter;
}
/**
* Gets an icon (implemented in the adapter).
* @param {string} icon_name - Name of the icon to get.
* @returns {string} The icon HTML string.
*/
get_icon_html(icon_name) {
return this.adapter.get_icon_html(icon_name);
}
/**
* Renders a single setting component (implemented in adapter).
* @async
* @param {HTMLElement} setting_elm - The DOM element for the setting.
* @param {Object} opts - Additional options for rendering.
* @returns {Promise<*>}
*/
async render_setting_component(setting_elm, opts = {}) {
return await this.adapter.render_setting_component(setting_elm, opts);
}
/**
* Renders markdown content (implemented in adapter).
* @param {string} markdown - The markdown content.
* @param {object|null} scope - The scope to pass for rendering.
* @returns {Promise<DocumentFragment>}
*/
async render_markdown(markdown, scope = null) {
return await this.adapter.render_markdown(markdown, scope);
}
/**
* Gets a value from an object by path.
* @param {Object} obj - The object to search in.
* @param {string} path - The path to the value.
* @returns {*}
*/
get_by_path(obj, path, settings_scope = null) {
return get_by_path2(obj, path, settings_scope);
}
/**
* Sets a value in an object by path.
* @param {Object} obj - The object to modify.
* @param {string} path - The path to set the value.
* @param {*} value - The value to set.
*/
set_by_path(obj, path, value, settings_scope = null) {
set_by_path2(obj, path, value, settings_scope);
}
/**
* Deletes a value from an object by path.
* @param {Object} obj - The object to modify.
* @param {string} path - The path to delete the value.
*/
delete_by_path(obj, path, settings_scope = null) {
delete_by_path2(obj, path, settings_scope);
}
/**
* Escapes HTML special characters in a string.
* @param {string} str - The string to escape.
* @returns {string} The escaped string.
*/
escape_html(str) {
return escape_html2(str);
}
/**
* A convenience method to build a setting HTML snippet from a config object.
* @param {Object} setting_config
* @returns {string}
*/
render_setting_html(setting_config) {
if (setting_config.type === "html") {
return setting_config.value;
}
const attributes = Object.entries(setting_config).map(([attr, value]) => {
if (attr.includes("class")) return "";
if (typeof value === "number") return `data-${attr.replace(/_/g, "-")}=${value}`;
return `data-${attr.replace(/_/g, "-")}="${value}"`;
}).join("\n");
return `<div class="setting-component${setting_config.scope_class ? " " + setting_config.scope_class : ""}"
data-setting="${setting_config.setting}"
${attributes}
></div>`;
}
/**
* Renders settings from a config, returning a fragment.
* @async
* @deprecated Use render_settings_config utility in Obsidian (obsidian-smart-env)
* @param {Object} settings_config
* @param {Object} opts
* @param {Object} [opts.scope={}] - The scope to use when rendering settings (should have settings property).
* @returns {Promise<DocumentFragment>}
*/
async render_settings(settings_config40, opts = {}) {
const is_fx = typeof settings_config40 === "function";
const html = Object.entries(is_fx ? await settings_config40(opts.scope) : settings_config40).map(([setting_key, setting_config]) => {
if (!setting_config.setting) {
setting_config.setting = setting_key;
}
return this.render_setting_html(setting_config);
}).join("\n");
const frag = this.create_doc_fragment(`<div>${html}</div>`);
return await this.render_setting_components(frag, opts);
}
/**
* Scans the given container for elements that have `data-smart-setting` and attaches
* a 'change' event listener that updates the corresponding path in `scope.settings`.
*
* Listener bookkeeping is done via WeakMap, not DOM attributes, to avoid
* clone/attribute-related bugs on re-render.
*
* @param {Object} scope - An object containing a `settings` property, where new values will be stored.
* @param {HTMLElement|Document} [container=document] - The DOM element to scan. Defaults to the entire document.
*/
add_settings_listeners(scope, container = document) {
if (!container || typeof container.querySelectorAll !== "function") return;
const elements = container.querySelectorAll("[data-smart-setting]");
elements.forEach((elm) => {
const path = elm.dataset.smartSetting;
if (!path) return;
if (smart_setting_listeners2.has(elm)) {
return;
}
const handler = /* @__PURE__ */ __name(() => {
let new_value;
if (elm instanceof HTMLInputElement) {
if (elm.type === "checkbox") {
new_value = elm.checked;
} else if (elm.type === "radio") {
if (elm.checked) {
new_value = elm.value;
} else {
return;
}
} else {
new_value = elm.value;
}
} else if (elm instanceof HTMLSelectElement || elm instanceof HTMLTextAreaElement) {
new_value = elm.value;
} else {
new_value = elm.value ?? elm.textContent;
}
this.set_by_path(scope.settings, path, new_value);
}, "handler");
smart_setting_listeners2.set(elm, handler);
elm.addEventListener("change", handler);
if (elm instanceof HTMLElement) {
this.attach_disposer(elm, () => {
const existing = smart_setting_listeners2.get(elm);
if (existing) {
elm.removeEventListener("change", existing);
smart_setting_listeners2.delete(elm);
}
});
}
});
}
apply_style_sheet(sheet) {
if (typeof sheet === "string") {
const css_hash = murmur_hash_32_alphanumeric3(sheet);
if (document.getElementById(`style-sheet-${css_hash}`)) {
return;
}
const styleEl = document.createElement("style");
styleEl.id = `style-sheet-${css_hash}`;
styleEl.textContent = sheet;
document.head.appendChild(styleEl);
return;
}
if ("adoptedStyleSheets" in Document.prototype) {
document.adoptedStyleSheets = [...document.adoptedStyleSheets, sheet];
} else {
const styleEl = document.createElement("style");
if (sheet.cssRules) {
styleEl.textContent = Array.from(sheet.cssRules).map((rule) => rule.cssText).join("\n");
}
document.head.appendChild(styleEl);
}
}
empty(elm) {
empty2(elm);
}
safe_inner_html(elm, html) {
safe_inner_html2(elm, html);
}
/**
* Attaches one or more disposer functions to an element that will be called
* when that element has been observed in the DOM and is later removed.
*
* - Multiple calls for the same element accumulate disposer functions.
* - Disposers are only invoked once, on the first removal after the
*   element has been in the DOM.
* - No DOM attributes or properties are used for bookkeeping; everything
*   is tracked via WeakMap.
*
* @param {HTMLElement} el - The element to monitor.
* @param {Function|Function[]} dispose - The disposer function or array of functions to call on removal.
*/
attach_disposer(el, dispose) {
if (!el) return;
const doc = el.ownerDocument;
const win = doc && doc.defaultView;
const MutationObserverCtor = win && win.MutationObserver;
if (!doc || !win || !MutationObserverCtor || !doc.body) return;
let dispose_fns;
if (typeof dispose === "function") {
dispose_fns = [dispose];
} else if (Array.isArray(dispose)) {
dispose_fns = dispose.filter((fn) => typeof fn === "function");
} else {
console.warn("[smart-view] attach_disposer called with invalid disposer");
return;
}
if (!dispose_fns.length) {
console.warn("[smart-view] attach_disposer called with no valid disposer functions");
return;
}
let entry = element_disposers2.get(el);
if (!entry) {
entry = {
dispose_fns: /* @__PURE__ */ new Set(),
observer: null,
has_been_in_dom: false,
disposed: false
};
element_disposers2.set(el, entry);
}
if (entry.disposed) {
entry.disposed = false;
entry.has_been_in_dom = false;
}
for (const fn of dispose_fns) {
entry.dispose_fns.add(fn);
}
if (!entry.observer) {
const observer = new MutationObserverCtor(() => {
const in_dom = doc.body.contains(el);
if (in_dom) {
entry.has_been_in_dom = true;
return;
}
if (!entry.has_been_in_dom || entry.disposed) {
return;
}
entry.disposed = true;
try {
for (const fn of entry.dispose_fns) {
try {
fn();
} catch (err) {
console.error("[smart-view] disposer error", err);
}
}
} finally {
try {
observer.disconnect();
} catch (e) {
}
if (element_disposers2.get(el) === entry) {
element_disposers2.delete(el);
}
}
});
entry.observer = observer;
observer.observe(doc.body, { childList: true, subtree: true });
}
}
};

var SmartViewAdapter2 = class {
static {
__name(this, "SmartViewAdapter");
}
constructor(main) {
this.main = main;
}
/**
* Retrieves the class used for settings.
* Must be overridden by subclasses to return the appropriate setting class.
* @abstract
* @returns {Function} The setting class constructor.
* @throws Will throw an error if not implemented in the subclass.
*/
get setting_class() {
throw new Error("setting_class() not implemented");
}
/**
* Generates the HTML for a specified icon.
* Must be overridden by subclasses to provide the correct icon HTML.
* @abstract
* @param {string} icon_name - The name of the icon to generate HTML for.
* @returns {string} The HTML string representing the icon.
* @throws Will throw an error if not implemented in the subclass.
*/
get_icon_html(icon_name) {
throw new Error("get_icon_html() not implemented");
}
/**
* Renders Markdown content within a specific scope.
* Must be overridden by subclasses to handle Markdown rendering appropriately.
* @abstract
* @param {string} markdown - The Markdown content to render.
* @param {object|null} [scope=null] - The scope within which to render the Markdown.
* @returns {Promise<void>} A promise that resolves when rendering is complete.
* @throws Will throw an error if not implemented in the subclass.
*/
async render_markdown(markdown, scope = null) {
throw new Error("render_markdown() not implemented");
}
/**
* Opens a specified URL.
* Should be overridden by subclasses to define how URLs are opened.
* @abstract
* @param {string} url - The URL to open.
*/
open_url(url) {
throw new Error("open_url() not implemented");
}
/**
* Handles the selection of a folder by invoking the folder selection dialog and updating the setting.
* @abstract
* @param {string} setting - The path of the setting being modified.
* @param {string} value - The current value of the setting.
* @param {HTMLElement} elm - The HTML element associated with the setting.
* @param {object} scope - The current scope containing settings and actions.
*/
handle_folder_select(path, value, elm, scope) {
throw new Error("handle_folder_select not implemented");
}
/**
* Handles the selection of a file by invoking the file selection dialog and updating the setting.
* @abstract
* @param {string} setting - The path of the setting being modified.
* @param {string} value - The current value of the setting.
* @param {HTMLElement} elm - The HTML element associated with the setting.
* @param {object} scope - The current scope containing settings and actions.
*/
handle_file_select(path, value, elm, scope) {
throw new Error("handle_file_select not implemented");
}
/**
* Performs actions before a setting is changed, such as clearing notices and updating the UI.
* @abstract
* @param {string} setting - The path of the setting being changed.
* @param {*} value - The new value for the setting.
* @param {HTMLElement} elm - The HTML element associated with the setting.
* @param {object} scope - The current scope containing settings and actions.
*/
pre_change(path, value, elm) {
}
/**
* Performs actions after a setting is changed, such as updating UI elements.
* @abstract
* @param {string} setting - The path of the setting that was changed.
* @param {*} value - The new value for the setting.
* @param {HTMLElement} elm - The HTML element associated with the setting.
* @param {object} changed - Additional information about the change.
*/
post_change(path, value, elm) {
}
/**
* Reverts a setting to its previous value in case of validation failure or error.
* @abstract
* @param {string} setting - The path of the setting to revert.
* @param {HTMLElement} elm - The HTML element associated with the setting.
* @param {object} scope - The current scope containing settings.
*/
revert_setting(path, elm, scope) {
console.warn("revert_setting() not implemented");
}
get setting_renderers() {
return {
text: this.render_text_component,
string: this.render_text_component,
password: this.render_password_component,
number: this.render_number_component,
dropdown: this.render_dropdown_component,
toggle: this.render_toggle_component,
textarea: this.render_textarea_component,
textarea_array: this.render_textarea_array_component,
button: this.render_button_component,
remove: this.render_remove_component,
folder: this.render_folder_select_component,
"text-file": this.render_file_select_component,
file: this.render_file_select_component,
slider: this.render_slider_component,
html: this.render_html_component,
button_with_confirm: this.render_button_with_confirm_component,
json: this.render_json_component,
array: this.render_array_component
};
}
async render_setting_component(elm, opts = {}) {
this.empty(elm);
const path = elm.dataset.setting;
const scope = opts.scope || this.main.main;
const settings_scope = opts.settings_scope || null;
try {
let value = elm.dataset.value ?? this.main.get_by_path(scope.settings, path, settings_scope);
if (typeof value === "undefined" && typeof elm.dataset.default !== "undefined") {
value = elm.dataset.default;
if (typeof value === "string") value = value.toLowerCase() === "true" ? true : value === "false" ? false : value;
this.main.set_by_path(scope.settings, path, value, settings_scope);
}
const renderer = this.setting_renderers[elm.dataset.type];
if (!renderer) {
console.warn(`Unsupported setting type: ${elm.dataset.type}`);
return elm;
}
const setting = renderer.call(this, elm, path, value, scope, settings_scope);
if (elm.dataset.name) setting.setName(elm.dataset.name);
if (elm.dataset.description) {
const frag = this.main.create_doc_fragment(`<span>${elm.dataset.description}</span>`);
setting.setDesc(frag);
}
if (elm.dataset.tooltip) setting.setTooltip(elm.dataset.tooltip);
this.add_button_if_needed(setting, elm, path, scope);
this.handle_disabled_and_hidden(elm);
return elm;
} catch (e) {
console.error(JSON.stringify({ path, elm }, null, 2));
console.error(JSON.stringify(e, null, 2));
}
}
render_dropdown_component(elm, path, value, scope, settings_scope) {
const smart_setting = new this.setting_class(elm);
let options;
smart_setting.addDropdown((dropdown) => {
if (elm.dataset.required) dropdown.selectEl.setAttribute("required", true);
const opts_callback = elm.dataset.optionsCallback ? this.main.get_by_path(scope, elm.dataset.optionsCallback) : null;
if (typeof opts_callback === "function") {
console.log(`getting options callback: ${elm.dataset.optionsCallback}`);
Promise.resolve(opts_callback()).then((opts) => {
opts.forEach((option) => {
const opt = dropdown.addOption(option.value, option.label ?? option.name ?? option.value);
opt.selected = option.value === value;
if (opts.length === 1 && opt.selected) dropdown.selectEl.classList.add("dropdown-no-options");
});
dropdown.setValue(value);
});
} else {
if (!options || !options.length) {
options = this.get_dropdown_options(elm);
}
options.forEach((option) => {
const opt = dropdown.addOption(option.value, option.label ?? option.name ?? option.value);
opt.selected = option.value === value;
if (options.length === 1 && opt.selected) dropdown.selectEl.classList.add("dropdown-no-options");
});
dropdown.setValue(value);
}
dropdown.onChange((value2) => {
this.handle_on_change(path, value2, elm, scope, settings_scope);
});
});
return smart_setting;
}
render_text_component(elm, path, value, scope, settings_scope) {
const smart_setting = new this.setting_class(elm);
smart_setting.addText((text) => {
text.setPlaceholder(elm.dataset.placeholder || "");
if (value) text.setValue(value);
let debounceTimer;
if (elm.dataset.button) {
smart_setting.addButton((button) => {
button.setButtonText(elm.dataset.button);
button.onClick(async () => this.handle_on_change(path, text.getValue(), elm, scope));
});
} else {
text.onChange(async (value2) => {
clearTimeout(debounceTimer);
debounceTimer = setTimeout(() => this.handle_on_change(path, value2.trim(), elm, scope, settings_scope), 2e3);
});
}
});
return smart_setting;
}
render_password_component(elm, path, value, scope, settings_scope) {
const smart_setting = new this.setting_class(elm);
smart_setting.addText((text) => {
text.inputEl.type = "password";
text.setPlaceholder(elm.dataset.placeholder || "");
if (value) text.setValue(value);
let debounceTimer;
text.onChange(async (value2) => {
clearTimeout(debounceTimer);
debounceTimer = setTimeout(() => this.handle_on_change(path, value2, elm, scope, settings_scope), 2e3);
});
});
return smart_setting;
}
render_number_component(elm, path, value, scope, settings_scope) {
const smart_setting = new this.setting_class(elm);
smart_setting.addText((number) => {
number.inputEl.type = "number";
number.setPlaceholder(elm.dataset.placeholder || "");
if (typeof value !== "undefined") number.inputEl.value = parseInt(value);
number.inputEl.min = elm.dataset.min || 0;
if (elm.dataset.max) number.inputEl.max = elm.dataset.max;
let debounceTimer;
number.onChange(async (value2) => {
clearTimeout(debounceTimer);
debounceTimer = setTimeout(() => this.handle_on_change(path, parseInt(value2), elm, scope, settings_scope), 2e3);
});
});
return smart_setting;
}
render_toggle_component(elm, path, value, scope, settings_scope) {
const smart_setting = new this.setting_class(elm);
smart_setting.addToggle((toggle) => {
let checkbox_val = value ?? false;
if (typeof checkbox_val === "string") {
checkbox_val = checkbox_val.toLowerCase() === "true";
}
toggle.setValue(checkbox_val);
toggle.onChange(async (value2) => this.handle_on_change(path, value2, elm, scope, settings_scope));
});
return smart_setting;
}
render_textarea_component(elm, path, value, scope, settings_scope) {
const smart_setting = new this.setting_class(elm);
smart_setting.addTextArea((textarea) => {
textarea.setPlaceholder(elm.dataset.placeholder || "");
textarea.setValue(value || "");
let debounceTimer;
textarea.onChange(async (value2) => {
clearTimeout(debounceTimer);
debounceTimer = setTimeout(() => this.handle_on_change(path, value2, elm, scope, settings_scope), 2e3);
});
});
return smart_setting;
}
render_textarea_array_component(elm, path, value, scope, settings_scope) {
const smart_setting = new this.setting_class(elm);
smart_setting.addTextArea((textarea) => {
textarea.setPlaceholder(elm.dataset.placeholder || "");
textarea.setValue(Array.isArray(value) ? value.join("\n") : value || "");
let debounceTimer;
textarea.onChange(async (value2) => {
value2 = value2.split("\n").map((v) => v.trim()).filter((v) => v);
clearTimeout(debounceTimer);
debounceTimer = setTimeout(() => this.handle_on_change(path, value2, elm, scope, settings_scope), 2e3);
});
});
return smart_setting;
}
render_button_component(elm, path, value, scope, settings_scope) {
const smart_setting = new this.setting_class(elm);
smart_setting.addButton((button) => {
button.setButtonText(elm.dataset.btnText || elm.dataset.name);
button.onClick(async () => {
if (elm.dataset.confirm && !confirm(elm.dataset.confirm)) return;
if (elm.dataset.href) this.open_url(elm.dataset.href);
if (elm.dataset.callback) {
const callback = this.main.get_by_path(scope, elm.dataset.callback);
if (callback) callback(path, value, elm, scope, settings_scope);
}
});
});
return smart_setting;
}
render_remove_component(elm, path, value, scope, settings_scope) {
const smart_setting = new this.setting_class(elm);
smart_setting.addButton((button) => {
button.setButtonText(elm.dataset.btnText || elm.dataset.name || "Remove");
button.onClick(async () => {
this.main.delete_by_path(scope.settings, path, settings_scope);
if (elm.dataset.callback) {
const callback = this.main.get_by_path(scope, elm.dataset.callback);
if (callback) callback(path, value, elm, scope, settings_scope);
}
});
});
return smart_setting;
}
render_folder_select_component(elm, path, value, scope, settings_scope) {
const smart_setting = new this.setting_class(elm);
smart_setting.addFolderSelect((folder_select) => {
folder_select.setPlaceholder(elm.dataset.placeholder || "");
if (value) folder_select.setValue(value);
folder_select.inputEl.closest("div").addEventListener("click", () => {
this.handle_folder_select(path, value, elm, scope);
});
folder_select.inputEl.querySelector("input").addEventListener("change", (e) => {
const folder = e.target.value;
this.handle_on_change(path, folder, elm, scope, settings_scope);
});
});
return smart_setting;
}
render_file_select_component(elm, path, value, scope, settings_scope) {
const smart_setting = new this.setting_class(elm);
smart_setting.addFileSelect((file_select) => {
file_select.setPlaceholder(elm.dataset.placeholder || "");
if (value) file_select.setValue(value);
file_select.inputEl.closest("div").addEventListener("click", () => {
this.handle_file_select(path, value, elm, scope, settings_scope);
});
});
return smart_setting;
}
render_slider_component(elm, path, value, scope, settings_scope) {
const smart_setting = new this.setting_class(elm);
smart_setting.addSlider((slider) => {
const min = parseFloat(elm.dataset.min) || 0;
const max = parseFloat(elm.dataset.max) || 100;
const step = parseFloat(elm.dataset.step) || 1;
const currentValue = typeof value !== "undefined" ? parseFloat(value) : min;
slider.setLimits(min, max, step);
slider.setValue(currentValue);
slider.onChange((newVal) => {
const numericVal = parseFloat(newVal);
this.handle_on_change(path, numericVal, elm, scope, settings_scope);
});
});
return smart_setting;
}
render_html_component(elm, path, value, scope) {
this.safe_inner_html(elm, value);
return elm;
}
/**
* Renders an array setting component for managing a list of strings.
* @param {HTMLElement} elm - Container element for the setting.
* @param {string} path - Dot-notation path to store the array.
* @param {Array<string>} value - Initial array value.
* @param {object} scope - Scope containing settings and actions.
* @param {object|null} settings_scope - Optional nested settings scope.
* @returns {object} smart_setting instance.
*/
render_array_component(elm, path, value, scope, settings_scope) {
const smart_setting = new this.setting_class(elm);
let arr = Array.isArray(value) ? [...value] : [];
const items_container = document.createElement("div");
items_container.className = "array-items-container";
const render_items = /* @__PURE__ */ __name(() => {
items_container.innerHTML = "";
arr.forEach((val, idx) => {
const row = document.createElement("div");
row.className = "array-item-row";
const input = document.createElement("input");
input.type = "text";
input.value = val;
input.placeholder = "Value";
const remove_btn = document.createElement("button");
remove_btn.textContent = "\u2715";
remove_btn.title = "Remove";
input.addEventListener("change", () => {
arr[idx] = input.value;
trigger_change();
});
remove_btn.addEventListener("click", () => {
arr.splice(idx, 1);
render_items();
trigger_change();
});
row.appendChild(input);
row.appendChild(remove_btn);
items_container.appendChild(row);
});
}, "render_items");
const add_row = document.createElement("div");
add_row.className = "array-add-row";
const new_input = document.createElement("input");
new_input.type = "text";
new_input.placeholder = "Value";
const add_btn = document.createElement("button");
add_btn.textContent = "+";
add_btn.title = "Add value";
add_btn.addEventListener("click", () => {
const v = new_input.value.trim();
if (!v) return;
arr.push(v);
new_input.value = "";
render_items();
trigger_change();
});
add_row.appendChild(new_input);
add_row.appendChild(add_btn);
smart_setting.controlEl.appendChild(items_container);
smart_setting.controlEl.appendChild(add_row);
const trigger_change = /* @__PURE__ */ __name(() => {
this.handle_on_change(path, [...arr], elm, scope, settings_scope);
}, "trigger_change");
render_items();
elm.appendChild(smart_setting.settingEl);
return smart_setting;
}
render_json_component(elm, path, value, scope, settings_scope) {
try {
const smart_setting = new this.setting_class(elm);
let obj = typeof value === "object" && value !== null ? { ...value } : {};
const pairs_container = document.createElement("div");
pairs_container.className = "json-pairs-container";
const renderPairs = /* @__PURE__ */ __name(() => {
pairs_container.innerHTML = "";
Object.entries(obj).forEach(([key, val], idx) => {
const pair_div = document.createElement("div");
pair_div.className = "json-pair-row";
const key_i = document.createElement("input");
key_i.type = "text";
key_i.value = key;
key_i.placeholder = "Property";
const value_i = document.createElement("input");
value_i.type = "text";
value_i.value = val;
value_i.placeholder = "Value";
const remove_btn = document.createElement("button");
remove_btn.textContent = "\u2715";
remove_btn.title = "Remove";
key_i.addEventListener("change", () => {
const newKey = key_i.value.trim();
if (!newKey) return;
if (newKey !== key) {
obj[newKey] = obj[key];
delete obj[key];
renderPairs();
triggerChange();
}
});
value_i.addEventListener("change", () => {
obj[key_i.value] = value_i.value;
triggerChange();
});
remove_btn.addEventListener("click", () => {
delete obj[key_i.value];
renderPairs();
triggerChange();
});
pair_div.appendChild(key_i);
pair_div.appendChild(value_i);
pair_div.appendChild(remove_btn);
pairs_container.appendChild(pair_div);
});
}, "renderPairs");
const add_div = document.createElement("div");
add_div.className = "json-add-row";
const new_key_i = document.createElement("input");
new_key_i.type = "text";
new_key_i.placeholder = "Property";
const new_val_i = document.createElement("input");
new_val_i.type = "text";
new_val_i.placeholder = "Value";
const add_btn = document.createElement("button");
add_btn.textContent = "+";
add_btn.title = "Add property";
add_btn.addEventListener("click", () => {
const k = new_key_i.value.trim();
if (!k || k in obj) return;
obj[k] = new_val_i.value;
new_key_i.value = "";
new_val_i.value = "";
renderPairs();
triggerChange();
});
add_div.appendChild(new_key_i);
add_div.appendChild(new_val_i);
add_div.appendChild(add_btn);
smart_setting.controlEl.appendChild(pairs_container);
smart_setting.controlEl.appendChild(add_div);
const triggerChange = /* @__PURE__ */ __name(() => {
this.handle_on_change(path, { ...obj }, elm, scope, settings_scope);
}, "triggerChange");
renderPairs();
elm.appendChild(smart_setting.settingEl);
return smart_setting;
} catch (e) {
console.error(e);
}
}
add_button_if_needed(smart_setting, elm, path, scope) {
if (elm.dataset.btn) {
smart_setting.addButton((button) => {
button.setButtonText(elm.dataset.btn);
if (elm.dataset.btnCallback || elm.dataset.btnHref || elm.dataset.callback || elm.dataset.href) {
button.inputEl.addEventListener("click", (e) => {
if (elm.dataset.btnCallback && typeof scope[elm.dataset.btnCallback] === "function") {
if (elm.dataset.btnCallbackArg) scope[elm.dataset.btnCallback](elm.dataset.btnCallbackArg);
else scope[elm.dataset.btnCallback](path, null, smart_setting, scope);
} else if (elm.dataset.btnHref) {
this.open_url(elm.dataset.btnHref);
} else if (elm.dataset.callback && typeof this.main.get_by_path(scope, elm.dataset.callback) === "function") {
this.main.get_by_path(scope, elm.dataset.callback)(path, null, smart_setting, scope);
} else if (elm.dataset.href) {
this.open_url(elm.dataset.href);
} else {
console.error("No callback or href found for button.");
}
});
}
if (elm.dataset.btnDisabled || elm.dataset.disabled && elm.dataset.btnDisabled !== "false") {
button.inputEl.disabled = true;
}
});
}
}
handle_disabled_and_hidden(elm) {
if (elm.dataset.disabled && elm.dataset.disabled !== "false") {
elm.classList.add("disabled");
elm.querySelector("input, select, textarea, button").disabled = true;
}
if (elm.dataset.hidden && elm.dataset.hidden !== "false") {
elm.style.display = "none";
}
}
get_dropdown_options(elm) {
return Object.entries(elm.dataset).reduce((acc, [k, v]) => {
if (!k.startsWith("option")) return acc;
const [value, name] = v.split("|");
acc.push({ value, name: name || value });
return acc;
}, []);
}
handle_on_change(path, value, elm, scope, settings_scope) {
this.pre_change(path, value, elm, scope);
if (elm.dataset.validate) {
const valid = this[elm.dataset.validate](path, value, elm, scope);
if (!valid) {
elm.querySelector(".setting-item").style.border = "2px solid red";
this.revert_setting(path, elm, scope);
return;
}
}
this.main.set_by_path(scope.settings, path, value, settings_scope);
if (elm.dataset.callback) {
const callback = this.main.get_by_path(scope, elm.dataset.callback);
if (callback) callback(path, value, elm, scope);
}
this.post_change(path, value, elm, scope);
}
render_button_with_confirm_component(elm, path, value, scope) {
const smart_setting = new this.setting_class(elm);
smart_setting.addButton((button) => {
button.setButtonText(elm.dataset.btnText || elm.dataset.name);
elm.appendChild(this.main.create_doc_fragment(`
<div class="sc-inline-confirm-row" style="
display: none;
">
<span style="margin-right: 10px;">
${elm.dataset.confirm || "Are you sure?"}
</span>
<span class="sc-inline-confirm-row-buttons">
<button class="sc-inline-confirm-yes">Yes</button>
<button class="sc-inline-confirm-cancel">Cancel</button>
</span>
</div>
`));
const confirm_row = elm.querySelector(".sc-inline-confirm-row");
const confirm_yes = confirm_row.querySelector(".sc-inline-confirm-yes");
const confirm_cancel = confirm_row.querySelector(".sc-inline-confirm-cancel");
button.onClick(async () => {
confirm_row.style.display = "block";
elm.querySelector(".setting-item").style.display = "none";
});
confirm_yes.addEventListener("click", async () => {
if (elm.dataset.href) this.open_url(elm.dataset.href);
if (elm.dataset.callback) {
const callback = this.main.get_by_path(scope, elm.dataset.callback);
if (callback) callback(path, value, elm, scope);
}
elm.querySelector(".setting-item").style.display = "block";
confirm_row.style.display = "none";
});
confirm_cancel.addEventListener("click", () => {
confirm_row.style.display = "none";
elm.querySelector(".setting-item").style.display = "block";
});
});
return smart_setting;
}
empty(elm) {
empty2(elm);
}
safe_inner_html(elm, html) {
safe_inner_html2(elm, html);
}
};

var import_obsidian51 = require("obsidian");
var SmartViewObsidianAdapter2 = class extends SmartViewAdapter2 {
static {
__name(this, "SmartViewObsidianAdapter");
}
get setting_class() {
return import_obsidian51.Setting;
}
open_url(url) {
window.open(url);
}
async render_file_select_component(elm, path, value) {
return super.render_text_component(elm, path, value);
}
async render_markdown(markdown, scope) {
const component = scope.env.smart_connections_plugin?.connections_view || new import_obsidian51.Component();
if (!scope) return console.warn("Scope required for rendering markdown in Obsidian adapter");
const frag = this.main.create_doc_fragment("<div><div class='inner'></div></div>");
const container = frag.querySelector(".inner");
try {
await import_obsidian51.MarkdownRenderer.render(
scope.env.plugin.app,
markdown,
container,
scope?.file_path || "",
component
);
} catch (e) {
console.warn("Error rendering markdown in Obsidian adapter", e);
}
return frag;
}
get_icon_html(name) {
return (0, import_obsidian51.getIcon)(name).outerHTML;
}
is_mod_event(event) {
return import_obsidian51.Keymap.isModEvent(event);
}
render_folder_select_component(elm, path, value, scope, settings_scope) {
const smart_setting = new this.setting_class(elm);
const folders = scope.env.plugin.app.vault.getAllFolders().sort((a, b) => a.path.localeCompare(b.path));
smart_setting.addDropdown((dropdown) => {
if (elm.dataset.required) dropdown.inputEl.setAttribute("required", true);
dropdown.addOption("", "No folder selected");
folders.forEach((folder) => {
dropdown.addOption(folder.path, folder.path);
});
dropdown.onChange((value2) => {
this.handle_on_change(path, value2, elm, scope, settings_scope);
});
dropdown.setValue(value);
});
return smart_setting;
}
};

function collection_instance_name_from3(class_name) {
if (class_name.endsWith("Item")) {
return class_name.replace(/Item$/, "").replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
}
return class_name.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase().replace(/y$/, "ie") + "s";
}
__name(collection_instance_name_from3, "collection_instance_name_from");

function create_uid3(data) {
const str = JSON.stringify(data);
let hash = 0;
if (str.length === 0) return hash;
for (let i = 0; i < str.length; i++) {
const char = str.charCodeAt(i);
hash = (hash << 5) - hash + char;
hash = hash & hash;
if (hash < 0) hash = hash * -1;
}
return hash.toString() + str.length;
}
__name(create_uid3, "create_uid");

function deep_equal3(obj1, obj2, visited = /* @__PURE__ */ new WeakMap()) {
if (obj1 === obj2) return true;
if (obj1 === null || obj2 === null || obj1 === void 0 || obj2 === void 0) return false;
if (typeof obj1 !== typeof obj2 || Array.isArray(obj1) !== Array.isArray(obj2)) return false;
if (Array.isArray(obj1)) {
if (obj1.length !== obj2.length) return false;
return obj1.every((item, index) => deep_equal3(item, obj2[index], visited));
}
if (typeof obj1 === "object") {
if (visited.has(obj1)) return visited.get(obj1) === obj2;
visited.set(obj1, obj2);
const keys1 = Object.keys(obj1);
const keys2 = Object.keys(obj2);
if (keys1.length !== keys2.length) return false;
return keys1.every((key) => deep_equal3(obj1[key], obj2[key], visited));
}
return obj1 === obj2;
}
__name(deep_equal3, "deep_equal");

function get_item_display_name3(key, show_full_path) {
if (show_full_path) {
return key.split("/").join(" > ").replace(".md", "");
}
return key.split("/").pop().replace(".md", "");
}
__name(get_item_display_name3, "get_item_display_name");

function create_actions_proxy3(ctx, actions_source) {
const input = actions_source || {};
const is_plain_object9 = /* @__PURE__ */ __name((val) => typeof val === "object" && val !== null && !Array.isArray(val), "is_plain_object");
const is_function = /* @__PURE__ */ __name((val) => typeof val === "function", "is_function");
const is_class_export = /* @__PURE__ */ __name((val) => is_function(val) && /^class\s/.test(Function.prototype.toString.call(val)), "is_class_export");
const is_action_object = /* @__PURE__ */ __name((val) => is_plain_object9(val) && is_function(val.action), "is_action_object");
const is_action_candidate = /* @__PURE__ */ __name((val) => is_function(val) || is_action_object(val) || is_class_export(val), "is_action_candidate");
const ignored_meta_keys = /* @__PURE__ */ new Set(["length", "name", "prototype"]);
const clone_with_descriptors = /* @__PURE__ */ __name((obj) => {
if (!is_plain_object9(obj)) return obj;
const out = Object.create(Object.getPrototypeOf(obj) || null);
for (const key of Reflect.ownKeys(obj)) {
const descriptor = Object.getOwnPropertyDescriptor(obj, key);
if (!descriptor) continue;
const next = { ...descriptor };
if ("value" in next && is_plain_object9(next.value)) {
next.value = clone_with_descriptors(next.value);
}
try {
Object.defineProperty(out, key, next);
} catch {
out[key] = next.value;
}
}
return out;
}, "clone_with_descriptors");
const should_bucket_actions = /* @__PURE__ */ __name((val) => {
if (!is_plain_object9(val)) return false;
if (is_action_object(val)) return false;
const keys = Reflect.ownKeys(val);
if (keys.length === 0) return false;
let found_candidate = false;
for (const key of keys) {
const descriptor = Object.getOwnPropertyDescriptor(val, key);
if (!descriptor) continue;
if ("value" in descriptor) {
const entry = descriptor.value;
if (is_action_candidate(entry)) {
found_candidate = true;
continue;
}
if (is_plain_object9(entry)) {
if (should_bucket_actions(entry)) {
found_candidate = true;
continue;
}
return false;
}
if (typeof entry === "undefined") continue;
return false;
}
return false;
}
return found_candidate;
}, "should_bucket_actions");
const clone_descriptor = /* @__PURE__ */ __name((descriptor) => {
if (!descriptor) return descriptor;
if (!("value" in descriptor)) return { ...descriptor };
const cloned = is_plain_object9(descriptor.value) ? clone_with_descriptors(descriptor.value) : descriptor.value;
return { ...descriptor, value: cloned };
}, "clone_descriptor");
const build_sources = /* @__PURE__ */ __name((src) => {
const global_source2 = /* @__PURE__ */ Object.create(null);
const scoped_sources2 = /* @__PURE__ */ new Map();
for (const key of Reflect.ownKeys(src)) {
const descriptor = Object.getOwnPropertyDescriptor(src, key);
if (!descriptor) continue;
if ("value" in descriptor && should_bucket_actions(descriptor.value)) {
scoped_sources2.set(key, clone_with_descriptors(descriptor.value));
continue;
}
try {
Object.defineProperty(global_source2, key, clone_descriptor(descriptor));
} catch {
global_source2[key] = descriptor.value;
}
}
return { global_source: global_source2, scoped_sources: scoped_sources2 };
}, "build_sources");
const { global_source, scoped_sources } = build_sources(input);
const has_own = /* @__PURE__ */ __name((obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop), "has_own");
const cache = /* @__PURE__ */ Object.create(null);
const copy_metadata = /* @__PURE__ */ __name((source, target, omit = []) => {
if (!source || !target) return;
const skips = /* @__PURE__ */ new Set([...ignored_meta_keys, ...omit]);
for (const key of Reflect.ownKeys(source)) {
if (skips.has(key)) continue;
const descriptor = Object.getOwnPropertyDescriptor(source, key);
if (!descriptor) continue;
try {
Object.defineProperty(target, key, descriptor);
} catch {
target[key] = descriptor.value;
}
}
}, "copy_metadata");
const instantiate_class = /* @__PURE__ */ __name((Ctor) => {
const instance = new Ctor(ctx);
const candidate = instance.action || instance.run || instance.execute || instance.call;
if (is_function(candidate)) {
const bound = candidate.bind(instance);
copy_metadata(Ctor, bound);
copy_metadata(instance, bound);
bound.instance = instance;
return bound;
}
copy_metadata(Ctor, instance);
return instance;
}, "instantiate_class");
const bind_or_clone = /* @__PURE__ */ __name((val) => {
if (is_class_export(val)) {
return instantiate_class(val);
}
if (is_action_object(val)) {
const bound = val.action.bind(ctx);
copy_metadata(val, bound, ["action"]);
return bound;
}
if (is_function(val)) {
const bound = val.bind(ctx);
copy_metadata(val, bound);
return bound;
}
if (is_plain_object9(val)) {
return clone_with_descriptors(val);
}
return val;
}, "bind_or_clone");
const scope_actions_for = /* @__PURE__ */ __name(() => {
const scope_key = ctx?.constructor?.key;
if (typeof scope_key === "undefined" || scope_key === null) return null;
const bucket = scoped_sources.get(scope_key);
return bucket && is_plain_object9(bucket) ? bucket : null;
}, "scope_actions_for");
const cache_result = /* @__PURE__ */ __name((target, prop, value) => {
target[prop] = value;
return value;
}, "cache_result");
const compute_and_cache = /* @__PURE__ */ __name((target, prop) => {
const scoped = scope_actions_for();
if (scoped && has_own(scoped, prop)) {
return cache_result(target, prop, bind_or_clone(scoped[prop]));
}
if (has_own(global_source, prop)) {
return cache_result(target, prop, bind_or_clone(global_source[prop]));
}
return cache_result(target, prop, void 0);
}, "compute_and_cache");
const union_keys = /* @__PURE__ */ __name(() => {
const scoped = scope_actions_for();
const keys = new Set(Reflect.ownKeys(cache));
for (const key of Reflect.ownKeys(global_source)) {
keys.add(key);
}
if (scoped) {
for (const key of Reflect.ownKeys(scoped)) {
keys.add(key);
}
}
return Array.from(keys);
}, "union_keys");
const descriptor_for = /* @__PURE__ */ __name((target, prop) => ({
configurable: true,
enumerable: true,
value: target[prop]
}), "descriptor_for");
return new Proxy(cache, {
get: /* @__PURE__ */ __name((target, prop) => {
if (prop === Symbol.toStringTag) return "ActionsProxy";
if (prop in target) return target[prop];
return compute_and_cache(target, prop);
}, "get"),
has: /* @__PURE__ */ __name((target, prop) => {
if (prop in target) return true;
const scoped = scope_actions_for();
if (scoped && has_own(scoped, prop)) return true;
return has_own(global_source, prop);
}, "has"),
ownKeys: /* @__PURE__ */ __name(() => union_keys(), "ownKeys"),
getOwnPropertyDescriptor: /* @__PURE__ */ __name((target, prop) => {
if (has_own(target, prop)) {
return descriptor_for(target, prop);
}
const scoped = scope_actions_for();
if (scoped && has_own(scoped, prop)) {
if (!has_own(target, prop)) {
compute_and_cache(target, prop);
}
return descriptor_for(target, prop);
}
if (has_own(global_source, prop)) {
if (!has_own(target, prop)) {
compute_and_cache(target, prop);
}
return descriptor_for(target, prop);
}
return void 0;
}, "getOwnPropertyDescriptor"),
defineProperty: /* @__PURE__ */ __name((target, prop, descriptor) => {
if ("value" in descriptor) {
target[prop] = descriptor.value;
return true;
}
return false;
}, "defineProperty"),
set: /* @__PURE__ */ __name((target, prop, value) => {
target[prop] = value;
return true;
}, "set"),
deleteProperty: /* @__PURE__ */ __name((target, prop) => {
if (has_own(target, prop)) {
delete target[prop];
}
return true;
}, "deleteProperty")
});
}
__name(create_actions_proxy3, "create_actions_proxy");

var CollectionItem3 = class _CollectionItem {
static {
__name(this, "CollectionItem");
}
static version = 2e-3;
/**
* Default properties for an instance of CollectionItem.
* Override in subclasses to define different defaults.
* @returns {Object}
*/
static get defaults() {
return {
data: {}
};
}
/**
* @param {Object} env - The environment/context.
* @param {Object|null} [data=null] - Initial data for the item.
*/
constructor(env, data = null) {
env.create_env_getter(this);
this.config = this.env?.config;
this.merge_defaults();
if (data) deep_merge3(this.data, data);
if (!this.data.class_name) this.data.class_name = this.collection.item_class_name;
}
/**
* Loads an item from data and initializes it.
* @param {Object} env
* @param {Object} data
* @returns {CollectionItem}
*/
static load(env, data) {
const item = new this(env, data);
item.init();
return item;
}
/**
* Merge default properties from the entire inheritance chain.
* @private
*/
merge_defaults() {
let current_class = this.constructor;
while (current_class) {
for (let key in current_class.defaults) {
const default_val = current_class.defaults[key];
if (typeof default_val === "object") {
this[key] = { ...default_val, ...this[key] };
} else {
this[key] = this[key] === void 0 ? default_val : this[key];
}
}
current_class = Object.getPrototypeOf(current_class);
}
}
/**
* Generates or retrieves a unique key for the item.
* Key syntax supports:
* - `[i]` for sequences
* - `/` for super-sources (groups, directories, clusters)
* - `#` for sub-sources (blocks)
* @returns {string} The unique key
*/
get_key() {
return create_uid3(this.data);
}
/**
* Updates the item data and returns true if changed.
* @param {Object} data
* @returns {boolean} True if data changed.
*/
update_data(data) {
const sanitized_data = this.sanitize_data(data);
const current_data = { ...this.data };
deep_merge3(current_data, sanitized_data);
const changed = !deep_equal3(this.data, current_data);
if (!changed) return false;
this.data = current_data;
return true;
}
/**
* Sanitizes data for saving. Ensures no circular references.
* @param {*} data
* @returns {*} Sanitized data.
*/
sanitize_data(data) {
if (data instanceof _CollectionItem) return data.ref;
if (Array.isArray(data)) return data.map((val) => this.sanitize_data(val));
if (typeof data === "object" && data !== null) {
return Object.keys(data).reduce((acc, key) => {
acc[key] = this.sanitize_data(data[key]);
return acc;
}, {});
}
return data;
}
/**
* Initializes the item. Override as needed.
* @param {Object} [input_data] - Additional data that might be provided on creation.
*/
init(input_data) {
}
/**
* Queues this item for saving.
*/
queue_save() {
this._queue_save = true;
}
/**
* Saves this item using its data adapter.
* @returns {Promise<void>}
*/
async save() {
try {
await this.data_adapter.save_item(this);
this.init();
} catch (err) {
this._queue_save = true;
console.error(err, err.stack);
}
}
/**
* Queues this item for loading.
*/
queue_load() {
this._queue_load = true;
}
/**
* Loads this item using its data adapter.
* @returns {Promise<void>}
*/
async load() {
try {
await this.data_adapter.load_item(this);
this.init();
} catch (err) {
this._load_error = err;
this.on_load_error(err);
}
}
/**
* Handles load errors by re-queuing for load.
* Override if needed.
* @param {Error} err
*/
on_load_error(err) {
this.queue_load();
}
/**
* Validates the item before saving. Checks for presence and validity of key.
* @deprecated should be better handled 2025-12-17 (wrong scope?)
* @returns {boolean}
*/
validate_save() {
if (!this.key) return false;
if (this.key.trim() === "") return false;
if (this.key === "undefined") return false;
return true;
}
/**
* Marks this item as deleted. This does not immediately remove it from memory,
* but queues a save that will result in the item being removed from persistent storage.
*/
delete() {
this.deleted = true;
this.queue_save();
}
/**
* Filters items in the collection based on provided options.
* functional filter (returns true or false) for filtering items in collection; called by collection class
* @param {Object} filter_opts - Filtering options.
* @param {string} [filter_opts.exclude_key] - A single key to exclude.
* @param {string[]} [filter_opts.exclude_keys] - An array of keys to exclude. If exclude_key is provided, it's added to this array.
* @param {string} [filter_opts.exclude_key_starts_with] - Exclude keys starting with this string.
* @param {string[]} [filter_opts.exclude_key_starts_with_any] - Exclude keys starting with any of these strings.
* @param {string} [filter_opts.exclude_key_includes] - Exclude keys that include this string.
* @param {string[]} [filter_opts.exclude_key_includes_any] - Exclude keys that include any of these strings.
* @param {string} [filter_opts.exclude_key_ends_with] - Exclude keys ending with this string.
* @param {string[]} [filter_opts.exclude_key_ends_with_any] - Exclude keys ending with any of these strings.
* @param {string} [filter_opts.key_ends_with] - Include only keys ending with this string.
* @param {string} [filter_opts.key_starts_with] - Include only keys starting with this string.
* @param {string[]} [filter_opts.key_starts_with_any] - Include only keys starting with any of these strings.
* @param {string} [filter_opts.key_includes] - Include only keys that include this string.
* @returns {boolean} True if the item passes the filter, false otherwise.
*/
filter(filter_opts = {}) {
const {
exclude_key,
exclude_keys = exclude_key ? [exclude_key] : [],
exclude_key_starts_with,
exclude_key_starts_with_any,
exclude_key_includes,
exclude_key_includes_any,
exclude_key_ends_with,
exclude_key_ends_with_any,
key_ends_with,
key_starts_with,
key_starts_with_any,
key_includes,
key_includes_any
} = filter_opts;
if (exclude_keys?.includes(this.key)) return false;
if (exclude_key_starts_with && this.key.startsWith(exclude_key_starts_with)) return false;
if (exclude_key_starts_with_any && exclude_key_starts_with_any.some((prefix) => this.key.startsWith(prefix))) return false;
if (exclude_key_includes && this.key.includes(exclude_key_includes)) return false;
if (exclude_key_includes_any && exclude_key_includes_any.some((include) => this.key.includes(include))) return false;
if (exclude_key_ends_with && this.key.endsWith(exclude_key_ends_with)) return false;
if (exclude_key_ends_with_any && exclude_key_ends_with_any.some((suffix) => this.key.endsWith(suffix))) return false;
if (key_ends_with && !this.key.endsWith(key_ends_with)) return false;
if (key_starts_with && !this.key.startsWith(key_starts_with)) return false;
if (key_starts_with_any && !key_starts_with_any.some((prefix) => this.key.startsWith(prefix))) return false;
if (key_includes && !this.key.includes(key_includes)) return false;
if (key_includes_any && !key_includes_any.some((include) => this.key.includes(include))) return false;
return true;
}
filter_and_score(params = {}) {
if (this.filter(params.filter) === false) return null;
return this.score(params);
}
score(params = {}) {
const score_action = this.actions[params.score_algo_key];
if (typeof score_action !== "function") throw new Error(`Missing score action: ${params.score_algo_key}`);
return {
...score_action(params) || {},
item: this
};
}
/**
* Parses item data for additional processing. Override as needed.
* @deprecated is this used anywhere?
*/
parse() {
}
get actions() {
if (!this._actions) {
this._actions = create_actions_proxy3(this, {
...this.env.config.actions || {},
...this.env.opts.items?.[this.item_type_key]?.actions || {}
});
}
return this._actions;
}
/**
* Derives the collection key from the class name.
* @returns {string}
*/
static get collection_key() {
let name = this.name;
if (name.match(/\d$/)) name = name.slice(0, -1);
return collection_instance_name_from3(name);
}
/**
* @returns {string} The collection key for this item.
*/
get collection_key() {
let name = this.constructor.name;
if (name.match(/\d$/)) name = name.slice(0, -1);
return collection_instance_name_from3(name);
}
/**
* Retrieves the parent collection from the environment.
* @returns {Collection}
*/
get collection() {
return this.env[this.collection_key];
}
/**
* @returns {string} The item's key.
*/
get key() {
return this.data?.key || this.get_key();
}
get item_type_key() {
let name = this.constructor.name;
if (name.match(/\d$/)) name = name.slice(0, -1);
return camel_case_to_snake_case3(name);
}
/**
* Emits an event with item metadata.
*
* @param {string} event_key
* @param {Object} [payload={}]
* @returns {void}
*/
emit_event(event_key, payload = {}) {
this.env.events?.emit(event_key, { collection_key: this.collection_key, item_key: this.key, ...payload });
}
on_event(event_key, callback) {
return this.env.events?.on(event_key, (payload) => {
if (payload?.item_key && payload.item_key !== this.key) return;
callback(payload);
});
}
once_event(event_key, callback) {
return this.env.events?.once(event_key, (payload) => {
if (payload?.item_key && payload.item_key !== this.key) return;
callback(payload);
});
}
/**
* @returns {Object} The data adapter for this item's collection.
*/
get data_adapter() {
return this.collection.data_adapter;
}
/**
* @returns {Object} The filesystem adapter.
*/
get data_fs() {
return this.collection.data_fs;
}
/**
* Access to collection-level settings.
* @returns {Object}
*/
get settings() {
if (!this.env.settings[this.collection_key]) this.env.settings[this.collection_key] = {};
return this.env.settings[this.collection_key];
}
set settings(settings) {
this.env.settings[this.collection_key] = settings;
this.env.smart_settings.save();
}
/**
* A simple reference object for this item.
* @deprecated 2025-11-11 lacks adoption
* @returns {{collection_key: string, key: string}}
*/
get ref() {
return { collection_key: this.collection_key, key: this.key };
}
/**
* @deprecated use env.smart_components~~env.smart_view~~ instead
*/
get smart_view() {
if (!this._smart_view) this._smart_view = this.env.init_module("smart_view");
return this._smart_view;
}
/**
* Retrieves the display name of the collection item.
* @readonly
* @deprecated Use `get_item_display_name(key, show_full_path)` instead (keep UI logic out of collections).
* @returns {string} The display name.
*/
get name() {
return get_item_display_name3(
this.key,
this.env.settings.smart_view_filter?.show_full_path
);
}
};

var AsyncFunction3 = Object.getPrototypeOf(async function() {
}).constructor;
var Collection3 = class {
static {
__name(this, "Collection");
}
static version = 1e-3;
/**
* Constructs a new Collection instance.
*
* @param {Object} env - The environment context containing configurations and adapters.
* @param {Object} [opts={}] - Optional configuration.
* @param {string} [opts.collection_key] - Custom key to override default collection name.
* @param {string} [opts.data_dir] - Custom data directory path.
*/
constructor(env, opts = {}) {
env.create_env_getter(this);
this.opts = opts;
if (opts.collection_key) this.collection_key = opts.collection_key;
this.env[this.collection_key] = this;
this.config = this.env.config;
this.items = {};
this.loaded = null;
this._loading = false;
this.load_time_ms = null;
this.settings_container = null;
}
/**
* Initializes a new collection in the environment. Override in subclass if needed.
*
* @param {Object} env
* @param {Object} [opts={}]
* @returns {Promise<void>}
*/
static async init(env, opts = {}) {
env[this.collection_key] = new this(env, opts);
await env[this.collection_key].init();
env.collections[this.collection_key] = "init";
}
/**
* The unique collection key derived from the class name.
* @returns {string}
*/
static get collection_key() {
let name = this.name;
if (name.match(/\d$/)) name = name.slice(0, -1);
return name.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
}
/**
* Instance-level init. Override in subclasses if necessary.
* @returns {Promise<void>}
*/
async init() {
}
/**
* Creates or updates an item in the collection.
* - If `data` includes a key that matches an existing item, that item is updated.
* - Otherwise, a new item is created.
* After updating or creating, the item is validated. If validation fails, the item is logged and returned without being saved.
* If validation succeeds for a new item, it is added to the collection and marked for saving.
*
* If the item’s `init()` method is async, a promise is returned that resolves once init completes.
*
* NOTE: wrapping in try/catch seems to fail to catch errors thrown in async init functions when awaiting create_or_update
*
* @param {Object} [data={}] - Data for creating/updating an item.
* @returns {Promise<Item>|Item} The created or updated item. May return a promise if `init()` is async.
*/
create_or_update(data = {}) {
const existing_item = this.find_by(data);
const item = existing_item ? existing_item : new this.item_type(this.env);
item._queue_save = !existing_item;
const data_changed = item.update_data(data);
if (!existing_item && !item.validate_save()) {
return item;
}
if (!existing_item) {
this.set(item);
}
if (existing_item && !data_changed) return existing_item;
if (item.init instanceof AsyncFunction3) {
return new Promise((resolve) => {
item.init(data).then(() => resolve(item));
});
}
item.init(data);
return item;
}
/**
* Finds an item by partial data match (first checks key). If `data.key` provided,
* returns the item with that key; otherwise attempts a match by merging data.
*
* @param {Object} data - Data to match against.
* @returns {Item|null}
*/
find_by(data) {
if (data.key) return this.get(data.key);
const temp = new this.item_type(this.env);
const temp_data = JSON.parse(JSON.stringify(data, temp.sanitize_data(data)));
deep_merge3(temp.data, temp_data);
return temp.key ? this.get(temp.key) : null;
}
/**
* Filters items based on provided filter options or a custom function.
*
* @param {Object|Function} [filter_opts={}] - Filter options or a predicate function.
* @returns {Item[]} Array of filtered items.
*/
filter(filter_opts = {}) {
if (typeof filter_opts === "function") {
return Object.values(this.items).filter(filter_opts);
}
const results = [];
const { first_n } = filter_opts;
for (const item of Object.values(this.items)) {
if (first_n && results.length >= first_n) break;
if (item.filter(filter_opts)) results.push(item);
}
return results;
}
/**
* Alias for `filter()`
* @param {Object|Function} filter_opts
* @returns {Item[]}
*/
list(filter_opts) {
return this.filter(filter_opts);
}
/**
* Retrieves an item by key.
* @param {string} key
* @returns {Item|undefined}
*/
get(key) {
return this.items[key];
}
/**
* Retrieves multiple items by an array of keys.
* @param {string[]} keys
* @returns {Item[]}
*/
get_many(keys = []) {
if (!Array.isArray(keys)) {
console.error("get_many called with non-array keys:", keys);
return [];
}
return keys.map((key) => this.get(key)).filter(Boolean);
}
/**
* Retrieves a random item from the collection, optionally filtered by options.
* @param {Object} [opts]
* @returns {Item|undefined}
*/
get_rand(opts = null) {
if (opts) {
const filtered = this.filter(opts);
return filtered[Math.floor(Math.random() * filtered.length)];
}
const keys = this.keys;
return this.items[keys[Math.floor(Math.random() * keys.length)]];
}
/**
* Adds or updates an item in the collection.
* @param {Item} item
*/
set(item) {
if (!item.key) throw new Error("Item must have a key property");
this.items[item.key] = item;
}
/**
* Updates multiple items by their keys.
* @param {string[]} keys
* @param {Object} data
*/
update_many(keys = [], data = {}) {
this.get_many(keys).forEach((item) => item.update_data(data));
}
/**
* Clears all items from the collection.
*/
clear() {
this.items = {};
}
/**
* @returns {string} The collection key, can be overridden by opts.collection_key
*/
get collection_key() {
return this._collection_key ? this._collection_key : this.constructor.collection_key;
}
set collection_key(key) {
this._collection_key = key;
}
/**
* Lazily initializes and returns the data adapter instance for this collection.
* @returns {Object} The data adapter instance.
*/
get data_adapter() {
if (!this._data_adapter) {
const AdapterClass = this.get_adapter_class("data");
this._data_adapter = new AdapterClass(this);
}
return this._data_adapter;
}
get_adapter_class(type) {
const config = this.env.opts.collections?.[this.collection_key];
const adapter_key = type + "_adapter";
const adapter_module = config?.[adapter_key] ?? this.env.opts.collections?.smart_collections?.[adapter_key];
if (typeof adapter_module === "function") return adapter_module;
if (typeof adapter_module?.collection === "function") return adapter_module.collection;
throw new Error(`No '${type}' adapter class found for ${this.collection_key} or smart_collections`);
}
/**
* Data directory strategy for this collection. Defaults to 'multi'.
* @deprecated should be handled in adapters (2025-12-09)
* @returns {string}
*/
get data_dir() {
return this.collection_key;
}
/**
* File system adapter from the environment.
* @returns {Object}
*/
get data_fs() {
return this.env.data_fs;
}
/**
* Derives the corresponding item class name based on this collection's class name.
* @returns {string}
*/
get item_class_name() {
let name = this.constructor.name;
if (name.match(/\d$/)) name = name.slice(0, -1);
if (name.endsWith("ies")) return name.slice(0, -3) + "y";
else if (name.endsWith("s")) return name.slice(0, -1);
return name + "Item";
}
/**
* Derives a readable item name from the item class name.
* @returns {string}
*/
get item_name() {
return this.item_class_name.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
}
/**
* Retrieves the item type (constructor) from the environment.
* @deprecated replace with item_class with strict adherence to conventions (2025-10-28)
* @returns {Function} Item constructor.
*/
get item_type() {
if (!this._item_type) this._item_type = this.resolve_item_type();
return this._item_type;
}
resolve_item_type() {
const available = [
this.env.config?.items?.[this.item_name],
this.opts.item_type,
this.env.item_types?.[this.item_class_name]
].filter(Boolean).sort((a, b) => {
const a_version = a?.class?.version || a.version || 0;
const b_version = b?.class?.version || b.version || 0;
return b_version - a_version;
});
if (available.length === 0) {
throw new Error(`No item_type found for collection '${this.collection_key}' with item_name '${this.item_name}' or class_name '${this.item_class_name}'`);
}
return available[0].class || available[0];
}
/**
* Returns an array of all keys in the collection.
* @returns {string[]}
*/
get keys() {
return Object.keys(this.items);
}
/**
* @deprecated use data_adapter instead (2024-09-14)
*/
get adapter() {
return this.data_adapter;
}
/**
* @method process_save_queue
* @description
* Saves items flagged for saving (_queue_save) back to AJSON or SQLite. This ensures persistent storage
* of any updates made since last load/import. This method also writes changes to disk (AJSON files or DB).
*/
async process_save_queue(opts = {}) {
if (opts.force) {
Object.values(this.items).forEach((item) => item._queue_save = true);
}
await this.data_adapter.process_save_queue(opts);
}
/**
* @alias process_save_queue
* @returns {Promise<void>}
*/
async save(opts = {}) {
await this.process_save_queue(opts);
}
/**
* @method process_load_queue
* @description
* Loads items that have been flagged for loading (_queue_load). This may involve
* reading from AJSON/SQLite or re-importing from markdown if needed.
* Called once initial environment is ready and collections are known.
*/
async process_load_queue() {
await this.data_adapter.process_load_queue();
}
/**
* Retrieves processed settings configuration.
* @returns {Object}
*/
get settings_config() {
return this.process_settings_config({});
}
/**
* Processes given settings config, adding prefixes and handling conditionals.
* @deprecated removing settings_config from collections (2025-11-24)
*
* @private
* @param {Object} _settings_config
* @param {string} [prefix='']
* @returns {Object}
*/
process_settings_config(_settings_config, prefix = "") {
const add_prefix = /* @__PURE__ */ __name((key) => prefix && !key.includes(`${prefix}.`) ? `${prefix}.${key}` : key, "add_prefix");
return Object.entries(_settings_config).reduce((acc, [key, val]) => {
let new_val = { ...val };
if (new_val.conditional) {
if (!new_val.conditional(this)) return acc;
delete new_val.conditional;
}
if (new_val.callback) new_val.callback = add_prefix(new_val.callback);
if (new_val.btn_callback) new_val.btn_callback = add_prefix(new_val.btn_callback);
if (new_val.options_callback) new_val.options_callback = add_prefix(new_val.options_callback);
const new_key = add_prefix(this.process_setting_key(key));
acc[new_key] = new_val;
return acc;
}, {});
}
/**
* Processes an individual setting key. Override if needed.
* @param {string} key
* @returns {string}
*/
process_setting_key(key) {
return key;
}
/**
* Default settings for this collection. Override in subclasses as needed.
* @returns {Object}
*/
get default_settings() {
return {};
}
/**
* Current settings for the collection.
* Initializes with default settings if none exist.
* @returns {Object}
*/
get settings() {
if (!this.env.settings[this.collection_key]) {
this.env.settings[this.collection_key] = this.default_settings;
}
return this.env.settings[this.collection_key];
}
/**
* Unloads collection data from memory.
*/
unload() {
this.clear();
this.unloaded = true;
this.env.collections[this.collection_key] = null;
}
/**
* Displays a process notice if the operation exceeds one second.
*
* @param {string} process - Identifier for the ongoing process.
* @param {Object} [opts={}] - Additional options passed to the notice.
*/
show_process_notice(process, opts = {}) {
if (!this.debounce_process_notice) this.debounce_process_notice = {};
this.debounce_process_notice[process] = setTimeout(() => {
this.debounce_process_notice[process] = null;
this.env.notices?.show(process, { collection_key: this.collection_key, ...opts });
}, 1e3);
}
/**
* Clears any pending process notice timers and removes active notices.
*
* @param {string} process - Identifier for the process notice to clear.
*/
clear_process_notice(process) {
if (this.debounce_process_notice?.[process]) {
clearTimeout(this.debounce_process_notice[process]);
this.debounce_process_notice[process] = null;
} else {
this.env.notices?.remove(process);
}
}
/**
* Emits an event with collection metadata.
*
* @param {string} event_key
* @param {Object} [payload={}]
* @returns {void}
*/
emit_event(event_key, payload = {}) {
this.env.events?.emit(event_key, { collection_key: this.collection_key, ...payload });
}
on_event(event_key, callback) {
return this.env.events?.on(event_key, (payload) => {
if (payload?.collection_key && payload.collection_key !== this.collection_key) return;
callback(payload);
});
}
/**
* Lazily binds action functions to the collection instance.
*
* @returns {Object} Bound action functions keyed by name.
*/
get actions() {
if (!this.constructor.key) this.constructor.key = this.collection_key;
if (!this._actions) {
const actions_modules = {
...this.env?.config?.actions || {},
...this.env?.config?.collections?.[this.collection_key]?.actions || {},
...this.env?.opts?.collections?.[this.collection_key]?.actions || {},
...this.opts?.actions || {}
};
this._actions = create_actions_proxy3(this, actions_modules);
}
return this._actions;
}
/**
* Clears cached actions proxy and rebuilds on next access.
* @returns {Object} Rebuilt proxy with latest source snapshot.
*/
refresh_actions() {
this._actions = null;
return this.actions;
}
queue_save() {
if (this._debounce_queue_save) clearTimeout(this._debounce_queue_save);
this._debounce_queue_save = setTimeout(() => {
this.process_save_queue();
}, 750);
}
/**
* @deprecated use env.smart_components~~env.smart_view~~ instead
* @returns {Object} smart_view instance
*/
get smart_view() {
if (!this._smart_view) this._smart_view = this.env.init_module("smart_view");
return this._smart_view;
}
/**
* Renders the settings for the collection into a given container.
* @deprecated use env.render_component('collection_settings', this) instead (2025-05-25: decouple UI from collections)
* @param {HTMLElement} [container=this.settings_container]
* @param {Object} opts
* @returns {Promise<HTMLElement>}
*/
async render_settings(container = this.settings_container, opts = {}) {
return await this.render_collection_settings(container, opts);
}
/**
* Helper function to render collection settings.
* @deprecated use env.render_component('collection_settings', this) instead (2025-05-25: decouple UI from collections)
* @param {HTMLElement} [container=this.settings_container]
* @param {Object} opts
* @returns {Promise<HTMLElement>}
*/
async render_collection_settings(container = this.settings_container, opts = {}) {
if (container && (!this.settings_container || this.settings_container !== container)) {
this.settings_container = container;
} else if (!container) {
container = this.env.smart_view.create_doc_fragment("<div></div>");
}
this.env.smart_view.safe_inner_html(container, `<div class="sc-loading">Loading ${this.collection_key} settings...</div>`);
const frag = await this.env.render_component("settings", this, opts);
this.env.smart_view.empty(container);
container.appendChild(frag);
return container;
}
};

var EntitiesVectorAdapter3 = class {
static {
__name(this, "EntitiesVectorAdapter");
}
/**
* @constructor
* @param {import('smart-entities').SmartEntities} collection - The collection (SmartEntities or derived class) instance.
*/
constructor(collection) {
this.collection = collection;
}
/**
* Find the nearest entities to the given vector.
* @async
* @param {number[]} vec - The reference vector.
* @param {Object} [filter={}] - Optional filters (limit, exclude, etc.)
* @returns {Promise<Array<{item: import('smart-entities').SmartEntity, score:number}>>} Array of results sorted by score descending.
* @abstract
* @throws {Error} Not implemented by default.
*/
async nearest(vec, filter = {}) {
throw new Error("EntitiesVectorAdapter.nearest() not implemented");
}
/**
* Find the furthest entities from the given vector.
* @async
* @param {number[]} vec - The reference vector.
* @param {Object} [filter={}] - Optional filters (limit, exclude, etc.)
* @returns {Promise<Array<{item: import('smart-entities').SmartEntity, score:number}>>} Array of results sorted by score ascending (furthest).
* @abstract
* @throws {Error} Not implemented by default.
*/
async furthest(vec, filter = {}) {
throw new Error("EntitiesVectorAdapter.furthest() not implemented");
}
/**
* Embed a batch of entities.
* @async
* @param {Object[]} entities - Array of entity instances to embed.
* @returns {Promise<void>}
* @abstract
* @throws {Error} Not implemented by default.
*/
async embed_batch(entities) {
throw new Error("EntitiesVectorAdapter.embed_batch() not implemented");
}
/**
* Process a queue of entities waiting to be embedded.
* Typically, this will call embed_batch in batches and update entities.
* @async
* @param {Object[]} embed_queue - Array of entities to embed.
* @returns {Promise<void>}
* @abstract
* @throws {Error} Not implemented by default.
*/
async process_embed_queue(embed_queue) {
throw new Error("EntitiesVectorAdapter.process_embed_queue() not implemented");
}
};
var EntityVectorAdapter3 = class {
static {
__name(this, "EntityVectorAdapter");
}
/**
* @constructor
* @param {import('smart-entities').SmartEntity} item - The SmartEntity instance that this adapter is associated with.
*/
constructor(item) {
this.item = item;
}
/**
* Retrieve the current vector embedding for this entity.
* @async
* @returns {Promise<number[]|undefined>} The entity's vector or undefined if not set.
* @abstract
* @throws {Error} Not implemented by default.
*/
async get_vec() {
throw new Error("EntityVectorAdapter.get_vec() not implemented");
}
/**
* Store/update the vector embedding for this entity.
* @async
* @param {number[]} vec - The vector to set.
* @returns {Promise<void>}
* @abstract
* @throws {Error} Not implemented by default.
*/
async set_vec(vec) {
throw new Error("EntityVectorAdapter.set_vec() not implemented");
}
/**
* Delete/remove the vector embedding for this entity.
* @async
* @returns {Promise<void>}
* @abstract
* @throws {Error} Not implemented by default.
*/
async delete_vec() {
throw new Error("EntityVectorAdapter.delete_vec() not implemented");
}
};

function results_acc3(_acc, result, ct = 10) {
if (_acc.results.size < ct) {
_acc.results.add(result);
if (_acc.results.size === ct && _acc.min === Number.POSITIVE_INFINITY) {
let { minScore, minObj } = find_min3(_acc.results);
_acc.min = minScore;
_acc.minResult = minObj;
}
} else if (result.score > _acc.min) {
_acc.results.add(result);
_acc.results.delete(_acc.minResult);
let { minScore, minObj } = find_min3(_acc.results);
_acc.min = minScore;
_acc.minResult = minObj;
}
}
__name(results_acc3, "results_acc");
function furthest_acc3(_acc, result, ct = 10) {
if (_acc.results.size < ct) {
_acc.results.add(result);
if (_acc.results.size === ct && _acc.max === Number.NEGATIVE_INFINITY) {
let { maxScore, maxObj } = find_max3(_acc.results);
_acc.max = maxScore;
_acc.maxResult = maxObj;
}
} else if (result.score < _acc.max) {
_acc.results.add(result);
_acc.results.delete(_acc.maxResult);
let { maxScore, maxObj } = find_max3(_acc.results);
_acc.max = maxScore;
_acc.maxResult = maxObj;
}
}
__name(furthest_acc3, "furthest_acc");
function find_min3(results) {
let minScore = Number.POSITIVE_INFINITY;
let minObj = null;
for (const obj of results) {
if (obj.score < minScore) {
minScore = obj.score;
minObj = obj;
}
}
return { minScore, minObj };
}
__name(find_min3, "find_min");
function find_max3(results) {
let maxScore = Number.NEGATIVE_INFINITY;
let maxObj = null;
for (const obj of results) {
if (obj.score > maxScore) {
maxScore = obj.score;
maxObj = obj;
}
}
return { maxScore, maxObj };
}
__name(find_max3, "find_max");

function sort_by_score3(a, b) {
const epsilon = 1e-9;
const score_diff = a.score - b.score;
if (Math.abs(score_diff) < epsilon) return 0;
return score_diff > 0 ? -1 : 1;
}
__name(sort_by_score3, "sort_by_score");
function sort_by_score_descending3(a, b) {
return sort_by_score3(a, b);
}
__name(sort_by_score_descending3, "sort_by_score_descending");
function sort_by_score_ascending3(a, b) {
return sort_by_score3(a, b) * -1;
}
__name(sort_by_score_ascending3, "sort_by_score_ascending");

var DefaultEntitiesVectorAdapter3 = class extends EntitiesVectorAdapter3 {
static {
__name(this, "DefaultEntitiesVectorAdapter");
}
constructor(collection) {
super(collection);
this._is_processing_embed_queue = false;
this._reset_embed_queue_stats();
}
/**
* Find the nearest entities to the given vector.
* @async
* @param {number[]} vec - The reference vector.
* @param {Object} [filter={}] - Optional filters (limit, exclude, etc.)
* @returns {Promise<Array<{item:Object, score:number}>>} Array of results sorted by score descending.
*/
async nearest(vec, filter = {}) {
if (!vec || !Array.isArray(vec)) {
throw new Error("Invalid vector input to nearest()");
}
const {
limit = 50
} = filter;
const nearest = this.collection.filter(filter).reduce((acc, item) => {
if (!item.vec) return acc;
const result = { item, score: cos_sim3(vec, item.vec) };
results_acc3(acc, result, limit);
return acc;
}, { min: 0, results: /* @__PURE__ */ new Set() });
return Array.from(nearest.results).sort(sort_by_score_descending3);
}
/**
* Find the furthest entities from the given vector.
* @async
* @param {number[]} vec - The reference vector.
* @param {Object} [filter={}] - Optional filters (limit, exclude, etc.)
* @returns {Promise<Array<{item:Object, score:number}>>} Array of results sorted by score ascending (furthest).
*/
async furthest(vec, filter = {}) {
if (!vec || !Array.isArray(vec)) {
throw new Error("Invalid vector input to furthest()");
}
const {
limit = 50
} = filter;
const furthest = this.collection.filter(filter).reduce((acc, item) => {
if (!item.vec) return acc;
const result = { item, score: cos_sim3(vec, item.vec) };
furthest_acc3(acc, result, limit);
return acc;
}, { max: 0, results: /* @__PURE__ */ new Set() });
return Array.from(furthest.results).sort(sort_by_score_ascending3);
}
/**
* Embed a batch of entities.
* @async
* @param {Object[]} entities - Array of entity instances to embed.
* @returns {Promise<void>}
*/
async embed_batch(entities) {
if (!this.collection.embed_model) {
throw new Error("No embed_model found in collection for embedding");
}
await Promise.all(entities.map((e) => e.get_embed_input()));
const embeddings = await this.collection.embed_model.embed_batch(entities);
embeddings.forEach((emb, i) => {
const entity = entities[i];
entity.vec = emb.vec;
entity.data.last_embed = entity.data.last_read;
if (emb.tokens !== void 0) entity.tokens = emb.tokens;
entity.emit_event("item:embedded");
});
}
/**
* Process a queue of entities waiting to be embedded.
* Prevents multiple concurrent runs by using `_is_processing_embed_queue`.
* @async
* @returns {Promise<void>}
*/
async process_embed_queue() {
if (this._is_processing_embed_queue) {
console.log("process_embed_queue is already running, skipping concurrent call.");
return;
}
this._is_processing_embed_queue = true;
try {
if (!this.collection.embed_model.is_loaded) {
await this.collection.embed_model.load();
}
} catch (e) {
this.collection.emit_event("embed_model:load_failed");
this.notices?.show("Failed to load embed_model");
return;
}
try {
const datetime_start = Date.now();
console.log(`Getting embed queue for ${this.collection.collection_key}...`);
await new Promise((resolve) => setTimeout(resolve, 1));
const embed_queue = this.collection.embed_queue;
this._reset_embed_queue_stats();
if (this.collection.embed_model_key === "None") {
console.log(`Smart Connections: No active embedding model for ${this.collection.collection_key}, skipping embedding`);
return;
}
if (!this.collection.embed_model) {
console.log(`Smart Connections: No active embedding model for ${this.collection.collection_key}, skipping embedding`);
return;
}
if (!embed_queue.length) {
console.log(`Smart Connections: No items in ${this.collection.collection_key} embed queue`);
return;
}
console.log(`Time spent getting embed queue: ${Date.now() - datetime_start}ms`);
console.log(`Processing ${this.collection.collection_key} embed queue: ${embed_queue.length} items`);
for (let i = 0; i < embed_queue.length; i += this.collection.embed_model.batch_size) {
if (this.is_queue_halted) {
this.is_queue_halted = false;
break;
}
this._show_embed_progress_notice(embed_queue.length);
const batch = embed_queue.slice(i, i + this.collection.embed_model.batch_size);
await Promise.all(batch.map((item) => item.get_embed_input()));
try {
const start_time = Date.now();
await this.embed_batch(batch);
this.total_time += Date.now() - start_time;
} catch (e) {
if (e && e.message && e.message.includes("API key not set")) {
this.halt_embed_queue_processing(`API key not set for ${this.collection.embed_model_key}
Please set the API key in the settings.`);
}
console.error(e);
console.error(`Error processing ${this.collection.collection_key} embed queue: ` + JSON.stringify(e || {}, null, 2));
}
batch.forEach((item) => {
item.embed_hash = item.read_hash;
item._queue_save = true;
});
this.embedded_total += batch.length;
this.total_tokens += batch.reduce((acc, item) => acc + (item.tokens || 0), 0);
if (this.embedded_total - this.last_save_total > 1e3) {
this.last_save_total = this.embedded_total;
await this.collection.process_save_queue();
if (this.collection.block_collection) {
console.log(`Saving ${this.collection.block_collection.collection_key} block collection`);
await this.collection.block_collection.process_save_queue();
}
}
}
this._show_embed_completion_notice(embed_queue.length);
await this.collection.process_save_queue();
if (this.collection.block_collection) {
await this.collection.block_collection.process_save_queue();
}
} finally {
this._is_processing_embed_queue = false;
}
}
get should_show_embed_progress_notice() {
if (Date.now() - (this.last_notice_time ?? 0) > 3e4) {
return true;
}
return this.embedded_total - this.last_notice_embedded_total >= 100;
}
/**
* Displays the embedding progress notice.
* @private
* @returns {void}
*/
_show_embed_progress_notice(embed_queue_length) {
if (embed_queue_length < 100) return;
if (!this.should_show_embed_progress_notice) return;
this.last_notice_time = Date.now();
this.last_notice_embedded_total = this.embedded_total;
this.collection.emit_event("embedding:progress_reported", {
progress: this.embedded_total,
total: embed_queue_length,
tokens_per_second: this._calculate_embed_tokens_per_second(),
model_name: this.collection.embed_model_key
});
this.notices?.show("embedding_progress", {
progress: this.embedded_total,
total: embed_queue_length,
tokens_per_second: this._calculate_embed_tokens_per_second(),
model_name: this.collection.embed_model_key
});
}
/**
* Displays the embedding completion notice.
* @private
* @returns {void}
*/
_show_embed_completion_notice() {
this.notices?.remove("embedding_progress");
if (this.embedded_total > 100) {
this.collection.emit_event("embedding:completed", {
total_embeddings: this.embedded_total,
tokens_per_second: this._calculate_embed_tokens_per_second(),
model_name: this.collection.embed_model_key
});
this.notices?.show("embedding_complete", {
total_embeddings: this.embedded_total,
tokens_per_second: this._calculate_embed_tokens_per_second(),
model_name: this.collection.embed_model_key
});
}
}
/**
* Halts the embed queue processing.
* @param {string|null} msg - Optional message.
*/
halt_embed_queue_processing(msg = null) {
this.is_queue_halted = true;
console.log("Embed queue processing halted");
this.notices?.remove("embedding_progress");
this.collection.emit_event("embedding:paused", {
progress: this.embedded_total,
total: this.collection._embed_queue.length,
tokens_per_second: this._calculate_embed_tokens_per_second(),
model_name: this.collection.embed_model_key
});
this.notices?.show("embedding_paused", {
progress: this.embedded_total,
total: this.collection._embed_queue.length,
tokens_per_second: this._calculate_embed_tokens_per_second(),
model_name: this.collection.embed_model_key
});
}
/**
* Resumes the embed queue processing after a delay.
* @param {number} [delay=0] - The delay in milliseconds before resuming.
* @returns {void}
*/
resume_embed_queue_processing(delay = 0) {
console.log("resume_embed_queue_processing");
this.notices?.remove("embedding_paused");
setTimeout(() => {
this.embedded_total = 0;
this.process_embed_queue();
}, delay);
}
/**
* Calculates the number of tokens processed per second.
* @private
* @returns {number} Tokens per second.
*/
_calculate_embed_tokens_per_second() {
const elapsed_time = this.total_time / 1e3;
return Math.round(this.total_tokens / (elapsed_time || 1));
}
/**
* Resets the statistics related to embed queue processing.
* @private
* @returns {void}
*/
_reset_embed_queue_stats() {
this.collection._embed_queue = [];
this.embedded_total = 0;
this.is_queue_halted = false;
this.last_save_total = 0;
this.last_notice_embedded_total = 0;
this.total_tokens = 0;
this.total_time = 0;
}
get notices() {
return this.collection.env.notices;
}
};
var DefaultEntityVectorAdapter3 = class extends EntityVectorAdapter3 {
static {
__name(this, "DefaultEntityVectorAdapter");
}
get data() {
return this.item.data;
}
/**
* Retrieve the current vector embedding for this entity.
* @async
* @returns {Promise<number[]|undefined>} The entity's vector or undefined if not set.
*/
async get_vec() {
return this.vec;
}
/**
* Store/update the vector embedding for this entity.
* @async
* @param {number[]} vec - The vector to set.
* @returns {Promise<void>}
*/
async set_vec(vec) {
this.vec = vec;
}
/**
* Delete/remove the vector embedding for this entity.
* @async
* @returns {Promise<void>}
*/
async delete_vec() {
if (this.item.data?.embeddings?.[this.item.embed_model_key]) {
delete this.item.data.embeddings[this.item.embed_model_key].vec;
}
}
get vec() {
return this.item.data?.embeddings?.[this.item.embed_model_key]?.vec;
}
set vec(vec) {
if (!this.item.data.embeddings) {
this.item.data.embeddings = {};
}
if (!this.item.data.embeddings[this.item.embed_model_key]) {
this.item.data.embeddings[this.item.embed_model_key] = {};
}
this.item.data.embeddings[this.item.embed_model_key].vec = vec;
}
};

var FRONTMATTER_SUFFIX3 = "---frontmatter---";
var to_array3 = /* @__PURE__ */ __name((value) => {
if (Array.isArray(value)) {
return value.map((entry) => typeof entry === "string" ? entry.trim() : "").filter((entry) => entry.length > 0);
}
if (typeof value === "string") {
const parts = value.includes(",") ? value.split(",") : [value];
return parts.map((part) => part.trim()).filter((part) => part.length > 0);
}
return [];
}, "to_array");
var merge_settings_with_params3 = /* @__PURE__ */ __name((entity, params = {}) => ({
...entity.env.settings.smart_view_filter || {},
...params,
entity
}), "merge_settings_with_params");
var remove_limit_fields3 = /* @__PURE__ */ __name((filter_opts) => {
const next = { ...filter_opts };
if (typeof next.limit !== "undefined") delete next.limit;
if (next.filter) {
next.filter = { ...next.filter };
if (typeof next.filter.limit !== "undefined") delete next.filter.limit;
}
return next;
}, "remove_limit_fields");
var apply_frontmatter_exclusion3 = /* @__PURE__ */ __name((filter_opts) => {
if (!filter_opts.exclude_frontmatter_blocks) return filter_opts;
const next = { ...filter_opts };
const suffixes = Array.isArray(next.exclude_key_ends_with_any) ? [...next.exclude_key_ends_with_any] : [];
suffixes.push(FRONTMATTER_SUFFIX3);
next.exclude_key_ends_with_any = suffixes;
return next;
}, "apply_frontmatter_exclusion");
var append_entity_filters3 = /* @__PURE__ */ __name((filter_opts, entity) => {
if (!entity) return filter_opts;
const next = { ...filter_opts };
let exclude_starts = Array.isArray(next.exclude_key_starts_with_any) ? [...next.exclude_key_starts_with_any] : [];
if (typeof next.exclude_key_starts_with === "string") {
exclude_starts.push(next.exclude_key_starts_with);
delete next.exclude_key_starts_with;
}
const entity_key = entity.source_key || entity.key;
if (entity_key) exclude_starts.push(entity_key);
if (next.exclude_inlinks && Array.isArray(entity.inlinks) && entity.inlinks.length) {
exclude_starts = [...exclude_starts, ...entity.inlinks];
}
if (next.exclude_outlinks && Array.isArray(entity.outlinks) && entity.outlinks.length) {
exclude_starts = [...exclude_starts, ...entity.outlinks.map((o) => o.key)];
}
if (exclude_starts.length) next.exclude_key_starts_with_any = exclude_starts;
if (next.exclude_filter) {
const exclude_values = to_array3(next.exclude_filter);
const current = Array.isArray(next.exclude_key_includes_any) ? [...next.exclude_key_includes_any] : [];
next.exclude_key_includes_any = [...current, ...exclude_values];
}
if (next.include_filter) {
const include_values = to_array3(next.include_filter);
const current = Array.isArray(next.key_includes_any) ? [...next.key_includes_any] : [];
next.key_includes_any = [...current, ...include_values];
}
return next;
}, "append_entity_filters");
var create_find_connections_filter_opts3 = /* @__PURE__ */ __name((entity, params = {}) => {
const merged = merge_settings_with_params3(entity, params);
const without_limits = remove_limit_fields3(merged);
const with_frontmatter = apply_frontmatter_exclusion3(without_limits);
return append_entity_filters3(with_frontmatter, entity);
}, "create_find_connections_filter_opts");
async function find_connections4(params = {}) {
const limit = params.filter?.limit || params.limit || this.env.settings.smart_view_filter?.results_limit || 10;
const filter_opts = create_find_connections_filter_opts3(this, params);
if (params.filter?.limit) delete params.filter.limit;
if (params.limit) delete params.limit;
const cache_key = this.key + murmur_hash_32_alphanumeric3(JSON.stringify({ ...filter_opts, entity: null }));
if (!this.env.connections_cache) this.env.connections_cache = {};
if (!this.env.connections_cache[cache_key]) {
const connections = (await this.nearest(filter_opts)).sort(sort_by_score3).slice(0, limit);
this.connections_to_cache(cache_key, connections);
}
return this.connections_from_cache(cache_key);
}
__name(find_connections4, "find_connections");
find_connections4.action_type = "connections";

var SmartEntity3 = class extends CollectionItem3 {
static {
__name(this, "SmartEntity");
}
/**
* Creates an instance of SmartEntity.
* @constructor
* @param {Object} env - The environment instance.
* @param {Object} [opts={}] - Configuration options.
*/
constructor(env, opts = {}) {
super(env, opts);
this.entity_adapter = new DefaultEntityVectorAdapter3(this);
}
/**
* Provides default values for a SmartEntity instance.
* @static
* @readonly
* @returns {Object} The default values.
*/
static get defaults() {
return {
data: {
path: null,
last_embed: {
hash: null
},
embeddings: {}
}
};
}
get vector_adapter() {
if (!this._vector_adapter) {
this._vector_adapter = new this.collection.opts.vector_adapter.item(this);
}
return this._vector_adapter;
}
/**
* Initializes the SmartEntity instance.
* Checks if the entity has a vector and if it matches the model dimensions.
* If not, it queues an embed.
* Removes embeddings for inactive models.
* @returns {void}
*/
init() {
super.init();
if (!this.vec || !this.vec.length) {
this.vec = null;
this.queue_embed();
}
Object.entries(this.data.embeddings || {}).forEach(([model, embedding]) => {
if (model !== this.embed_model_key) {
this.data.embeddings[model] = null;
delete this.data.embeddings[model];
}
});
}
/**
* Queues the entity for embedding.
* @returns {void}
*/
queue_embed() {
this._queue_embed = true;
}
/**
* Finds the nearest entities to this entity.
* @param {Object} [filter={}] - Optional filters to apply.
* @deprecated use actions (getter) instead
* @returns {Array<{item:Object, score:number}>} An array of result objects with score and item.
*/
async nearest(filter = {}) {
return await this.collection.nearest_to(this, filter);
}
/**
* Prepares the input for embedding.
* @async
* @param {string} [content=null] - Optional content to use instead of calling subsequent read()
* @returns {Promise<void>} Should be overridden in child classes.
*/
async get_embed_input(content = null) {
}
/**
* Retrieves the embed input, either from cache or by generating it.
* @readonly
* @returns {string|Promise<string>} The embed input string or a promise resolving to it.
*/
get embed_input() {
return this._embed_input ? this._embed_input : this.get_embed_input();
}
/**
* Finds connections relevant to this entity based on provided parameters.
* @async
* @param {Object} [params={}] - Parameters for finding connections.
* @deprecated should be in actions (getter) but also see ConnectionsLists (smart-lists)
* @returns {Array<{item:Object, score:number}>} An array of result objects with score and item.
*/
async find_connections(params = {}) {
return await this.actions.find_connections(params);
}
/**
* Retrieves connections from the cache based on the cache key.
* @param {string} cache_key - The cache key.
* @deprecated migrating to ConnectionsLists (smart-lists)
* @returns {Array<{item:Object, score:number}>} The cached connections.
*/
connections_from_cache(cache_key) {
return this.env.connections_cache[cache_key];
}
/**
* Stores connections in the cache with the provided cache key.
* @param {string} cache_key - The cache key.
* @deprecated migrating to ConnectionsLists (smart-lists)
* @param {Array<{item:Object, score:number}>} connections - The connections to cache.
* @returns {void}
*/
connections_to_cache(cache_key, connections) {
this.env.connections_cache[cache_key] = connections;
}
get read_hash() {
return this.data.last_read?.hash;
}
set read_hash(hash) {
if (!this.data.last_read) this.data.last_read = {};
this.data.last_read.hash = hash;
}
get embedding_data() {
if (!this.data.embeddings[this.embed_model_key]) {
this.data.embeddings[this.embed_model_key] = {};
}
return this.data.embeddings[this.embed_model_key];
}
get last_embed() {
if (!this.embedding_data.last_embed) {
this.embedding_data.last_embed = {};
if (this.data.last_embed) {
this.embedding_data.last_embed = this.data.last_embed;
delete this.data.last_embed;
this.queue_save();
}
}
return this.embedding_data.last_embed;
}
get embed_hash() {
return this.last_embed?.hash;
}
set embed_hash(hash) {
if (!this.embedding_data.last_embed) this.embedding_data.last_embed = {};
this.embedding_data.last_embed.hash = hash;
}
/**
* Gets the embed link for the entity.
* @readonly
* @returns {string} The embed link.
*/
get embed_link() {
return `![[${this.path}]]`;
}
/**
* Gets the key of the embedding model.
* @readonly
* @returns {string} The embedding model key.
*/
get embed_model_key() {
return this.collection.embed_model_key;
}
/**
* Gets the embedding model instance from the collection.
* @readonly
* @returns {Object} The embedding model instance.
*/
get embed_model() {
return this.collection.embed_model;
}
/**
* Determines if the entity should be embedded if unembedded. NOT the same as is_unembedded.
* @readonly
* @returns {boolean} True if no vector is set, false otherwise.
*/
get should_embed() {
return this.size > (this.settings?.min_chars || 300);
}
/**
* Sets the error for the embedding model.
* @param {string} error - The error message.
*/
set error(error) {
this.data.embeddings[this.embed_model_key].error = error;
}
/**
* Gets the number of tokens associated with the entity's embedding.
* @readonly
* @returns {number|undefined} The number of tokens, or undefined if not set.
*/
get tokens() {
return this.last_embed?.tokens;
}
/**
* Sets the number of tokens for the embedding.
* @param {number} tokens - The number of tokens.
*/
set tokens(tokens) {
this.last_embed.tokens = tokens;
}
/**
* Gets the vector representation from the entity adapter.
* @readonly
* @returns {Array<number>|undefined} The vector or undefined if not set.
*/
get vec() {
return this.entity_adapter.vec;
}
/**
* Sets the vector representation in the entity adapter.
* @param {Array<number>} vec - The vector to set.
*/
set vec(vec) {
this.entity_adapter.vec = vec;
this._queue_embed = false;
this._embed_input = null;
this.queue_save();
}
/**
* Removes all embeddings from the entity.
* @returns {void}
*/
remove_embeddings() {
this.data.embeddings = null;
this.queue_save();
}
/**
* Retrieves the key of the entity.
* @returns {string} The entity key.
*/
get_key() {
return this.data.key || this.data.path;
}
/**
* Retrieves the path of the entity.
* @readonly
* @returns {string|null} The entity path.
*/
get path() {
return this.data.path;
}
get is_unembedded() {
if (!this.vec) return true;
if (!this.embed_hash || this.embed_hash !== this.read_hash) return true;
return false;
}
};

var SmartEntities3 = class extends Collection3 {
static {
__name(this, "SmartEntities");
}
/**
* Creates an instance of SmartEntities.
* @constructor
* @param {Object} env - The environment instance.
* @param {Object} opts - Configuration options.
*/
constructor(env, opts) {
super(env, opts);
this.entities_vector_adapter = new DefaultEntitiesVectorAdapter3(this);
this.model_instance_id = null;
this._embed_queue = [];
}
/**
* Unloads the smart embedding model.
* @async
* @returns {Promise<void>}
*/
async unload() {
if (typeof this.embed_model?.unload === "function") {
this.embed_model.unload();
}
super.unload();
}
/**
* Gets the key of the embedding model.
* @readonly
* @returns {string} The embedding model key.
*/
get embed_model_key() {
return this.embed_model?.model_key;
}
/**
* Gets the embedding model instance.
* @readonly
* @returns {Object|null} The embedding model instance or null if none.
*/
get embed_model() {
if (this.env.embedding_models.default) {
return this.env.embedding_models.default.instance;
}
throw new Error("DEPRECATED SMART ENVIRONMENT LOADED: UPDATE SMART PLUGINS.");
}
set embed_model(embed_model) {
this.env._embed_model = embed_model;
}
reload_embed_model() {
console.log("reload_embed_model");
this.embed_model.unload();
this.env._embed_model = null;
}
/**
* Finds the nearest entities to a given entity.
* @async
* @param {Object} entity - The reference entity.
* @deprecated moved to action (type=score) and retrieve using filter_and_score()/get_results() patterns
* @param {Object} [filter={}] - Optional filters to apply.
* @returns {Promise<Array<{item:Object, score:number}>>} An array of result objects with score and item.
*/
async nearest_to(entity, filter = {}) {
return await this.nearest(entity.vec, filter);
}
/**
* Finds the nearest entities to a vector using the default adapter.
* @async
* @deprecated moved to action (type=score) and retrieve using filter_and_score()/get_results() patterns
* @param {Array<number>} vec - The vector to compare against.
* @param {Object} [filter={}] - Optional filters to apply.
* @returns {Promise<Array<{item:Object, score:number}>>} An array of result objects with score and item.
*/
async nearest(vec, filter = {}) {
if (!vec) {
console.warn("nearest: no vec");
return [];
}
return await this.entities_vector_adapter.nearest(vec, filter);
}
/**
* Finds the furthest entities from a vector using the default adapter.
* @async
* @deprecated moved to action (type=score) and retrieve using filter_and_score()/get_results() patterns
* @param {Array<number>} vec - The vector to compare against.
* @param {Object} [filter={}] - Optional filters to apply.
* @returns {Promise<Array<{item:Object, score:number}>>} An array of result objects with score and item.
*/
async furthest(vec, filter = {}) {
if (!vec) return console.warn("furthest: no vec");
return await this.entities_vector_adapter.furthest(vec, filter);
}
/**
* Gets the file name based on collection key and embedding model key.
* @readonly
* @deprecated likely unused (2025-09-29)
* @returns {string} The constructed file name.
*/
get file_name() {
return this.collection_key + "-" + this.embed_model_key.split("/").pop();
}
/**
* Looks up entities based on hypothetical content.
* @deprecated moved to action (type=score) and retrieve using get_results() (pre-process generates hypothetical vecs)
* @async
* @param {Object} [params={}] - The parameters for the lookup.
* @param {Array<string>} [params.hypotheticals=[]] - The hypothetical content to lookup.
* @param {Object} [params.filter] - The filter to use for the lookup.
* @param {number} [params.k] - Deprecated: Use `filter.limit` instead.
* @returns {Promise<Array<Result>|Object>} The lookup results or an error object.
*/
async lookup(params = {}) {
const { hypotheticals = [] } = params;
if (!hypotheticals?.length) return { error: "hypotheticals is required" };
if (!this.embed_model) return { error: "Embedding search is not enabled." };
const hyp_vecs = await this.embed_model.embed_batch(hypotheticals.map((h) => ({ embed_input: h })));
const limit = params.filter?.limit || params.k || this.env.settings.lookup_k || 10;
if (params.filter?.limit) delete params.filter.limit;
const filter = {
...this.env.chats?.current?.scope || {},
...params.filter || {}
};
const results = await hyp_vecs.reduce(async (acc_promise, embedding, i) => {
const acc = await acc_promise;
const results2 = await this.nearest(embedding.vec, filter);
results2.forEach((result) => {
if (!acc[result.item.path] || result.score > acc[result.item.path].score) {
acc[result.item.path] = {
key: result.item.key,
score: result.score,
item: result.item,
hypothetical_i: i
};
} else {
result.score = acc[result.item.path].score;
}
});
return acc;
}, Promise.resolve({}));
const top_k = Object.values(results).sort(sort_by_score3).slice(0, limit);
console.log(`Found and returned ${top_k.length} ${this.collection_key}.`);
return top_k;
}
/**
* Gets the configuration for settings.
* @readonly
* @returns {Object} The settings configuration.
*/
get settings_config() {
return settings_config18;
}
/**
* @deprecated use env.render_component('collection_settings', this) instead (2025-05-25: decouple UI from collections)
*/
async render_settings(container = this.settings_container, opts = {}) {
container = await this.render_collection_settings(container, opts);
const embed_model_settings_frag = await this.env.render_component("settings", this.embed_model, opts);
container.appendChild(embed_model_settings_frag);
return container;
}
/**
* Gets the notices from the environment.
* @readonly
* @returns {Object} The notices object.
*/
get notices() {
return this.env.smart_connections_plugin?.notices || this.env.main?.notices;
}
/**
* Gets the embed queue containing items to be embedded.
* @readonly
* @returns {Array<Object>} The embed queue.
*/
get embed_queue() {
if (!this._embed_queue?.length) {
console.time(`Building embed queue`);
this._embed_queue = Object.values(this.items).filter((item) => item._queue_embed || item.is_unembedded && item.should_embed);
console.timeEnd(`Building embed queue`);
}
return this._embed_queue;
}
/**
* Processes the embed queue by delegating to the default vector adapter.
* @async
* @returns {Promise<void>}
*/
async process_embed_queue() {
await this.entities_vector_adapter.process_embed_queue();
}
/**
* Handles changes to the embedding model by reinitializing and processing the load queue.
* @async
* @returns {Promise<void>}
*/
async embed_model_changed() {
await this.unload();
await this.init();
this.render_settings();
await this.process_load_queue();
}
/**
* @deprecated since v4 2025-11-28
*/
get connections_filter_config() {
return connections_filter_config3;
}
};
var settings_config18 = {
"min_chars": {
name: "Minimum length",
type: "number",
description: "Minimum length of entity to embed (in characters).",
placeholder: "Enter number ex. 300",
default: 300
}
};
var connections_filter_config3 = {
"smart_view_filter.show_full_path": {
"name": "Show full path",
"type": "toggle",
"description": "Turning on will include the folder path in the connections results."
},
"smart_view_filter.results_limit": {
"name": "Results limit",
"type": "number",
"description": "Adjust the number of connections displayed in the connections view (default 20).",
"default": 20
},
"smart_view_filter.exclude_inlinks": {
"name": "Exclude inlinks (backlinks)",
"type": "toggle",
"description": "Exclude notes that already link to the current note from the connections results."
},
"smart_view_filter.exclude_outlinks": {
"name": "Exclude outlinks",
"type": "toggle",
"description": "Exclude notes that are already linked from within the current note from appearing in the connections results."
},
"smart_view_filter.include_filter": {
"name": "Include filter",
"type": "text",
"description": "Notes must match this value in their file/folder path. Matching notes will be included in the connections results. Separate multiple values with commas."
},
"smart_view_filter.exclude_filter": {
"name": "Exclude filter",
"type": "text",
"description": "Notes must *not* match this value in their file/folder path. Matching notes will be *excluded* from the connections results. Separate multiple values with commas."
},
"smart_view_filter.exclude_blocks_from_source_connections": {
"name": "Hide blocks in results",
"type": "toggle",
"description": "Show only sources in the connections results (no blocks)."
}
};

async function find_connections5(params = {}) {
const filter_settings = this.env.settings.smart_view_filter;
const exclude_blocks_from_source_connections = params.exclude_blocks_from_source_connections ?? filter_settings?.exclude_blocks_from_source_connections ?? false;
const limit = params.filter?.limit || params.limit || this.env.settings.smart_view_filter?.results_limit || 20;
let connections;
if (this.block_collection.settings.embed_blocks && !exclude_blocks_from_source_connections) connections = [];
else connections = await find_connections4.call(this, params);
const filter_opts = create_find_connections_filter_opts3(this, params);
if (params.filter?.limit) delete params.filter.limit;
if (params.limit) delete params.limit;
if (!exclude_blocks_from_source_connections) {
const cache_key = this.key + murmur_hash_32_alphanumeric3(JSON.stringify({ ...filter_opts, entity: null })) + "_blocks";
if (!this.env.connections_cache) this.env.connections_cache = {};
if (!this.env.connections_cache[cache_key]) {
const nearest = (await this.env.smart_blocks.nearest(this.vec, filter_opts)).sort(sort_by_score3).slice(0, limit);
this.connections_to_cache(cache_key, nearest);
}
connections = [
...connections,
...this.connections_from_cache(cache_key)
].sort(sort_by_score3).slice(0, limit);
}
return connections;
}
__name(find_connections5, "find_connections");
find_connections5.action_type = "connections";

var SmartSource2 = class extends SmartEntity3 {
static {
__name(this, "SmartSource");
}
/**
* Provides default values for a SmartSource instance.
* @static
* @readonly
* @returns {Object} The default values.
*/
static get defaults() {
return {
data: {
last_read: {
hash: null,
mtime: 0
},
embeddings: {}
},
_embed_input: null,
_queue_load: true
};
}
/**
* Initializes the SmartSource instance by queuing an import if blocks are missing.
* @returns {void}
*/
init() {
super.init();
if (!this.data.blocks) this.queue_import();
}
/**
* Queues the SmartSource for import.
* @returns {void}
*/
queue_import() {
this._queue_import = true;
}
/**
* Imports the SmartSource by checking for updates and parsing content.
* @async
* @returns {Promise<void>}
*/
async import() {
this._queue_import = false;
try {
await this.source_adapter?.import();
this.emit_event("sources:imported");
} catch (err) {
if (err.code === "ENOENT") {
console.log(`Smart Connections: Deleting ${this.path} data because it no longer exists on disk`);
this.delete();
} else {
console.warn("Smart Connections: Error during import: re-queueing import", err);
this.queue_import();
}
}
}
/**
* @deprecated likely extraneous
*/
async parse_content(content = null) {
const parse_fns = this.env?.opts?.collections?.smart_sources?.content_parsers || [];
for (const fn of parse_fns) {
await fn(this, content);
}
if (this.data.last_import?.hash === this.data.last_read?.hash) {
if (this.data.blocks) return;
}
}
/**
* Finds connections relevant to this SmartSource based on provided parameters.
* @async
* @deprecated use ConnectionsLists
* @param {Object} [params={}] - Parameters for finding connections.
* @param {boolean} [params.exclude_blocks_from_source_connections=false] - Whether to exclude block connections from source connections.
* @param {Object} [params.exclude_frontmatter_blocks=true] - Whether to exclude frontmatter blocks from source connections.
* @returns {Array<SmartSource>} An array of relevant SmartSource entities.
*/
async find_connections(params = {}) {
return await this.actions.find_connections(params);
}
/**
* Prepares the embed input for the SmartSource by reading content and applying exclusions.
* @async
* @returns {Promise<string|false>} The embed input string or `false` if already embedded.
*/
async get_embed_input(content = null) {
if (typeof this._embed_input === "string" && this._embed_input.length) return this._embed_input;
if (!content) content = await this.read();
if (!content) {
console.warn("SmartSource.get_embed_input: No content available for embedding: " + this.path);
return "";
}
if (this.excluded_lines.length) {
const content_lines = content.split("\n");
this.excluded_lines.forEach((lines) => {
const { start, end } = lines;
for (let i = start; i <= end; i++) {
content_lines[i] = "";
}
});
content = content_lines.filter((line) => line.length).join("\n");
}
const breadcrumbs = this.path.split("/").join(" > ").replace(".md", "");
const max_tokens = this.collection.embed_model.model.data.max_tokens || 500;
const max_chars = Math.floor(max_tokens * 3.7);
this._embed_input = `${breadcrumbs}:
${content}`.substring(0, max_chars);
return this._embed_input;
}
/**
* Opens the SmartSource note in the SmartConnections plugin.
* @returns {void}
*/
open() {
this.env.smart_connections_plugin.open_note(this.path);
}
/**
* Retrieves the block associated with a specific line number.
* @param {number} line - The line number to search for.
* @returns {SmartBlock|null} The corresponding SmartBlock or `null` if not found.
*/
get_block_by_line(line) {
return Object.entries(this.data.blocks || {}).reduce((acc, [sub_key, range]) => {
if (acc) return acc;
if (range[0] <= line && range[1] >= line) {
const block = this.block_collection.get(this.key + sub_key);
if (block?.vec) return block;
}
return acc;
}, null);
}
/**
* Checks if the source file exists in the file system.
* @async
* @returns {Promise<boolean>} A promise that resolves to `true` if the file exists, `false` otherwise.
*/
async has_source_file() {
return await this.fs.exists(this.path);
}
/**
* FILTER/SEARCH METHODS
*/
/**
* Searches for keywords within the entity's data and content.
* @async
* @param {Object} search_filter - The search filter object.
* @param {string[]} search_filter.keywords - An array of keywords to search for.
* @param {string} [search_filter.type='any'] - The type of search to perform. 'any' counts all matching keywords, 'all' counts only if all keywords match.
* @returns {Promise<number>} A promise that resolves to the number of matching keywords.
*/
async search(search_filter = {}) {
const { keywords, type = "any", limit } = search_filter;
if (!keywords || !Array.isArray(keywords)) {
console.warn("Entity.search: keywords not set or is not an array");
return 0;
}
if (limit && this.collection.search_results_ct >= limit) return 0;
const lowercased_keywords = keywords.map((keyword) => keyword.toLowerCase());
const content = await this.read();
if (!content || typeof content !== "string" || !content.length) {
if (content.mime_type) {
console.warn(`Entity.search: No content available for searching: ${this.path}, mime_type: ${content.mime_type}`);
} else {
console.warn(`Entity.search: No content available for searching: ${this.path}, content: ${content ? JSON.stringify(content) : "empty"}`);
}
return 0;
}
const lowercased_content = content.toLowerCase();
const lowercased_path = this.path.toLowerCase();
const matching_keywords = lowercased_keywords.filter(
(keyword) => lowercased_path.includes(keyword) || lowercased_content.includes(keyword)
);
if (type === "all") {
return matching_keywords.length === lowercased_keywords.length ? matching_keywords.length : 0;
} else {
return matching_keywords.length;
}
}
/**
* ADAPTER METHODS
*/
use_source_adapter(method, ...args) {
if (!this.source_adapter) {
console.warn(`No source adapter available for ${this.key}. Cannot use method ${method}.`);
return;
}
if (typeof this.source_adapter[method] !== "function") {
console.warn(`Source adapter for ${this.key} does not implement method ${method}.`);
return;
}
return this.source_adapter[method](...args);
}
/**
* Appends content to the end of the source file.
* @async
* @param {string} content - The content to append to the file.
* @returns {Promise<void>} A promise that resolves when the operation is complete.
*/
async append(content) {
await this.use_source_adapter("append", content);
await this.import();
}
/**
* Updates the entire content of the source file.
* @async
* @param {string} full_content - The new content to write to the file.
* @param {Object} [opts={}] - Additional options for the update.
* @returns {Promise<void>} A promise that resolves when the operation is complete.
*/
async update(full_content, opts = {}) {
try {
await this.use_source_adapter("update", full_content, opts);
await this.import();
} catch (error) {
console.error(`Error during update for ${this.key}:`, error);
}
}
/**
* Reads the entire content of the source file.
* @async
* @param {Object} [opts={}] - Additional options for reading.
* @returns {Promise<string>} A promise that resolves with the content of the file.
*/
async read(opts = {}) {
try {
return await this.use_source_adapter("read", opts) || "";
} catch (error) {
console.error(`Error during reading ${this.key} (returning empty string)`, error);
return "";
}
}
/**
* Removes the source file from the file system and deletes the entity.
* This is different from `delete()` because it also removes the source file.
* @async
* @returns {Promise<void>} A promise that resolves when the operation is complete.
*/
async remove() {
try {
await this.use_source_adapter("remove");
} catch (error) {
console.error(`Error during remove for ${this.key}:`, error);
}
}
/**
* Moves the current source to a new location.
* Handles the destination as a string (new path) or entity (block or source).
*
* @async
* @param {string|SmartEntity} entity_ref - The destination path or entity to move to.
* @throws {Error} If the entity reference is invalid.
* @returns {Promise<void>} A promise that resolves when the move operation is complete.
*/
async move_to(entity_ref) {
try {
await this.use_source_adapter("move_to", entity_ref);
} catch (error) {
console.error(`Error during move for ${this.key}:`, error);
}
}
/**
* Merges the given content into the current source.
* Parses the content into blocks and either appends to existing blocks, replaces blocks, or replaces all content.
*
* @async
* @param {string} content - The content to merge into the current source.
* @param {Object} [opts={}] - Options object.
* @param {string} [opts.mode='append'] - The merge mode: 'append', 'replace_blocks', or 'replace_all'.
* @returns {Promise<void>}
*/
async merge(content, opts = {}) {
try {
await this.use_source_adapter("merge", content, opts);
await this.import();
} catch (error) {
console.error(`Error during merge for ${this.key}:`, error);
}
}
/**
* Handles errors during the load process.
* @param {Error} err - The error encountered during load.
* @returns {void}
*/
on_load_error(err) {
super.on_load_error(err);
if (err.code === "ENOENT") {
this._queue_load = false;
this.queue_import();
}
}
/**
* Retrieves the block collection associated with SmartSources.
* @readonly
* @returns {SmartBlocks} The block collection instance.
*/
get block_collection() {
return this.env.smart_blocks;
}
/**
* Retrieves the vector representations of all blocks within the SmartSource.
* @readonly
* @returns {Array<Array<number>>} An array of vectors.
*/
get block_vecs() {
return this.blocks.map((block) => block.vec).filter((vec) => vec);
}
/**
* Retrieves all blocks associated with the SmartSource.
* @readonly
* @returns {Array<SmartBlock>} An array of SmartBlock instances.
* @description
* Uses block refs (Fastest) to get blocks without iterating over all blocks
*/
get blocks() {
if (this.data.blocks) return this.block_collection.get_many(Object.keys(this.data.blocks).map((key) => this.key + key));
return [];
}
/**
* Determines if the SmartSource is excluded from processing.
* @readonly
* @returns {boolean} `true` if excluded, `false` otherwise.
*/
get excluded() {
return this.fs.is_excluded(this.path);
}
/**
* Retrieves the lines excluded from embedding.
* @readonly
* @returns {Array<Object>} An array of objects with `start` and `end` line numbers.
*/
get excluded_lines() {
return this.blocks.filter((block) => block.excluded).map((block) => block.lines);
}
/**
* Retrieves the file system instance from the SmartSource's collection.
* @readonly
* @returns {SmartFS} The file system instance.
*/
get fs() {
return this.collection.fs;
}
/**
* Retrieves the file object associated with the SmartSource.
* @deprecated should be replaced with adapter methods
* @readonly
* @returns {Object} The file object.
*/
get file() {
return this.fs.files[this.path];
}
/**
* Retrieves the file name of the SmartSource.
* @readonly
* @returns {string} The file name.
*/
get file_name() {
return this.path.split("/").pop();
}
/**
* Retrieves the file path of the SmartSource.
* @readonly
* @returns {string} The file path.
*/
get file_path() {
return this.path;
}
/**
* Retrieves the file type based on the file extension.
* @readonly
* @returns {string} The file type in lowercase.
*/
get file_type() {
if (!this._ext) {
this._ext = this.collection.get_extension_for_path(this.path) || "md";
}
return this._ext;
}
/**
* Retrieves the modification time of the SmartSource.
* @deprecated should be replaced with adapter methods (see get size)
* @readonly
* @returns {number} The modification time.
*/
get mtime() {
return this.file?.stat?.mtime || 0;
}
/**
* Retrieves the size of the SmartSource.
* @readonly
* @returns {number} The size.
*/
get size() {
return this.source_adapter?.size || 0;
}
/**
* Retrieves the last import stat of the SmartSource.
* @readonly
* @returns {Object} The last import stat.
*/
get last_import() {
return this.data?.last_import;
}
/**
* Retrieves the last import modification time of the SmartSource.
* @readonly
* @returns {number} The last import modification time.
*/
get last_import_mtime() {
return this.last_import?.mtime || 0;
}
/**
* Retrieves the last import size of the SmartSource.
* @readonly
* @returns {number} The last import size.
*/
get last_import_size() {
return this.last_import?.size || 0;
}
/**
* Retrieves the paths of inlinks to this SmartSource.
* @readonly
* @returns {Array<string>} An array of inlink paths.
*/
get inlinks() {
return Object.keys(this.collection.links?.[this.path] || {});
}
get is_media() {
return this.source_adapter.is_media || false;
}
/**
* Determines if the SmartSource is gone (i.e., the file no longer exists).
* @readonly
* @returns {boolean} `true` if gone, `false` otherwise.
*/
get is_gone() {
return !this.file;
}
/**
* Retrieves the last read hash of the SmartSource.
* @readonly
* @returns {string|undefined} The last read hash or `undefined` if not set.
*/
get last_read() {
return this.data.last_read;
}
get metadata() {
return this.data.metadata;
}
get outdated() {
return this.source_adapter.outdated;
}
/**
* Retrieves the outlink paths from the SmartSource.
* @readonly
* @returns {Array<string>} An array of outlink paths.
*/
get outlinks() {
return (this.data.outlinks || []).map((link) => {
const link_ref = link?.target || link;
if (typeof link_ref !== "string") return null;
if (link_ref.startsWith("http")) return null;
const link_path = this.fs.get_link_target_path(link_ref, this.file_path);
return {
key: link_path,
embedded: link.embedded || false
};
}).filter((link_path) => link_path);
}
/**
* @deprecated path should be derived from key (stable key principle)
*/
get path() {
return this.data.path || this.data.key;
}
get source_adapters() {
return this.collection.source_adapters;
}
get source_adapter() {
if (this._source_adapter) return this._source_adapter;
if (this.source_adapters[this.file_type]) this._source_adapter = new this.source_adapters[this.file_type](this);
else {
for (const Adapter of Object.values(this.source_adapters)) {
if (typeof Adapter.detect_type !== "function") continue;
if (Adapter.detect_type(this)) {
this._source_adapter = new Adapter(this);
break;
}
}
}
return this._source_adapter;
}
/**
* Calculates the mean vector of all blocks within the SmartSource.
* @readonly
* @returns {Array<number>|null} The mean vector or `null` if no vectors are present.
*/
get mean_block_vec() {
if (this._mean_block_vec) {
this._mean_block_vec = compute_centroid2(this.block_vecs);
}
return this._mean_block_vec;
}
/**
* Calculates the median vector of all blocks within the SmartSource.
* @readonly
* @returns {Array<number>|null} The median vector or `null` if no vectors are present.
*/
get median_block_vec() {
if (this._median_block_vec) {
this._median_block_vec = compute_medoid2(this.block_vecs);
}
return this._median_block_vec;
}
/**
* @async
* @deprecated Use `read` instead.
* @returns {Promise<string>} A promise that resolves with the content of the file.
*/
async _read() {
return await this.source_adapter._read();
}
/**
* @async
* @deprecated Use `remove` instead.
* @returns {Promise<void>} A promise that resolves when the entity is destroyed.
*/
async destroy() {
await this.remove();
}
/**
* @async
* @deprecated Use `update` instead.
* @param {string} content - The content to update.
* @returns {Promise<void>}
*/
async _update(content) {
await this.source_adapter.update(content);
}
/**
* @deprecated Use `source` instead.
* @readonly
* @returns {SmartSource} The associated SmartSource instance.
*/
get t_file() {
return this.fs.files[this.path];
}
};
var smart_source_default2 = {
class: SmartSource2,
actions: {
find_connections: find_connections5
}
};

var SmartSources2 = class extends SmartEntities3 {
static {
__name(this, "SmartSources");
}
/**
* Creates an instance of SmartSources.
* @constructor
* @param {Object} env - The environment instance.
* @param {Object} [opts={}] - Configuration options.
*/
constructor(env, opts = {}) {
super(env, opts);
this.search_results_ct = 0;
this._excluded_headings = null;
this.env_event_unsubscribers = [];
this.sources_re_import_queue = {};
this.sources_re_import_timeout = null;
this.sources_re_import_halted = false;
}
/**
* Initializes the SmartSources instance by performing an initial scan of sources.
* @async
* @returns {Promise<void>}
*/
async init() {
await super.init();
await this.init_items();
this.register_env_event_listeners();
this.register_source_watchers();
}
/**
* Registers env.events listeners for source lifecycle events emitted by filesystem adapters.
* @returns {void}
*/
register_env_event_listeners() {
this.unregister_env_event_listeners();
if (!this.env?.events) return;
const listeners = [
["sources:created", (event) => this.handle_source_created(event)],
["sources:modified", (event) => this.handle_source_modified(event)],
["sources:renamed", (event) => this.handle_source_renamed(event)],
["sources:deleted", (event) => this.handle_source_deleted(event)]
];
this.env_event_unsubscribers = listeners.map(([event_key, handler]) => this.env.events.on(event_key, handler)).filter(Boolean);
}
/**
* Unregisters env.events listeners that were previously attached by this collection.
* @returns {void}
*/
unregister_env_event_listeners() {
if (!Array.isArray(this.env_event_unsubscribers)) return;
while (this.env_event_unsubscribers.length) {
const unsub = this.env_event_unsubscribers.pop();
try {
unsub?.();
} catch (error) {
console.warn("SmartSources: Failed to unregister env event listener", error);
}
}
}
/**
* Determines whether the incoming event should be handled by this collection instance.
* @param {Object} event
* @returns {boolean}
*/
should_handle_event(event = {}) {
const { collection_key } = event;
if (collection_key && collection_key !== this.collection_key) return false;
return true;
}
/**
* Normalizes event payload keys into a canonical source path.
* @param {Object} event
* @returns {string|undefined}
*/
get_event_path(event = {}) {
return event.item_key || event.path || event.new_path;
}
/**
* Handles create events emitted by filesystem adapters.
* @param {Object} event
* @returns {void}
*/
handle_source_created(event = {}) {
if (!this.should_handle_event(event)) return;
const key = this.get_event_path(event);
if (!key) return;
const source = this.init_file_path(key) || this.get(key);
if (!source) {
console.warn("SmartSources: Unable to initialize source on create event", event);
return;
}
this.queue_source_re_import(source, { event_source: event.event_source });
}
/**
* Handles modify events emitted by filesystem adapters.
* @param {Object} event
* @returns {void}
*/
handle_source_modified(event = {}) {
if (!this.should_handle_event(event)) return;
const key = this.get_event_path(event);
if (!key) return;
if (this.fs.is_excluded(key)) return;
let source = this.get(key);
if (!source) source = this.init_file_path(key);
if (!source) {
console.warn("SmartSources: Unable to resolve source on modify event", { key, event });
return;
}
this.queue_source_re_import(source, { event_source: event.event_source });
}
/**
* Handles rename events emitted by filesystem adapters.
* @param {Object} event
* @returns {void}
*/
handle_source_renamed(event = {}) {
if (!this.should_handle_event(event)) return;
const new_key = this.get_event_path(event);
const old_key = event.old_path || event.from;
if (!new_key && !old_key) return;
if (old_key && this.items[old_key]) {
const old_source = this.items[old_key];
old_source?.delete?.();
delete this.items[old_key];
if (this.rename_debounce_timeout) clearTimeout(this.rename_debounce_timeout);
this.rename_debounce_timeout = setTimeout(() => {
this.process_save_queue();
this.rename_debounce_timeout = null;
}, 1e3);
}
if (!new_key) return;
let source = this.get(new_key);
if (!source) source = this.init_file_path(new_key);
if (!source) {
console.warn("SmartSources: Unable to initialize source on rename event", event);
return;
}
this.queue_source_re_import(source, { event_source: event.event_source });
}
/**
* Handles delete events emitted by filesystem adapters.
* @param {Object} event
* @returns {void}
*/
handle_source_deleted(event = {}) {
if (!this.should_handle_event(event)) return;
const key = this.get_event_path(event);
if (!key) return;
delete this.items[key];
if (this.sources_re_import_queue[key]) {
delete this.sources_re_import_queue[key];
}
}
/**
* Requests filesystem adapters to register source watchers for this collection.
* @returns {void}
*/
register_source_watchers() {
const adapter = this.fs?.adapter;
if (!adapter || typeof adapter.register_source_watchers !== "function") return;
if (this._source_watchers_registered) return;
this._source_watchers_registered = adapter.register_source_watchers(this);
}
/**
* Queues a SmartSource for re-import and schedules processing.
* @param {import('./smart_source.js').SmartSource} source
* @param {Object} [event_meta]
* @returns {void}
*/
queue_source_re_import(source, event_meta = {}) {
if (!source?.key) return;
if (this.sources_re_import_queue[source.key]) return;
source.data.last_import = { at: 0, hash: null, mtime: 0, size: 0 };
this.sources_re_import_queue[source.key] = { source, event_meta };
this.debounce_re_import_queue();
}
/**
* Debounces re-import processing to respect the configured wait time.
* @returns {void}
*/
debounce_re_import_queue() {
this.sources_re_import_halted = true;
if (this.sources_re_import_timeout) clearTimeout(this.sources_re_import_timeout);
const queue_keys = Object.keys(this.sources_re_import_queue || {});
if (!queue_keys.length) {
this.sources_re_import_timeout = null;
return;
}
const wait_seconds = typeof this.env?.settings?.re_import_wait_time === "number" ? this.env.settings.re_import_wait_time : 13;
this.sources_re_import_timeout = setTimeout(
() => this.run_re_import(),
wait_seconds * 1e3
);
}
/**
* Processes the queued re-import tasks.
* @returns {Promise<void>}
*/
async run_re_import() {
this.sources_re_import_halted = false;
const queue_entries = Object.entries(this.sources_re_import_queue || {});
if (!queue_entries.length) {
if (this.sources_re_import_timeout) clearTimeout(this.sources_re_import_timeout);
this.sources_re_import_timeout = null;
return;
}
for (const [key, { source }] of queue_entries) {
await source.import();
if (!this._embed_queue) this._embed_queue = [];
if (source.should_embed) this._embed_queue.push(source);
if (this.block_collection?.settings?.embed_blocks) {
for (const block of source.blocks || []) {
if (block._queue_embed || block.should_embed && block.is_unembedded) {
this._embed_queue.push(block);
block._queue_embed = true;
}
}
}
delete this.sources_re_import_queue[key];
if (this.sources_re_import_halted) {
this.debounce_re_import_queue();
break;
}
}
if (this._embed_queue?.length) {
const embed_start_at = Date.now();
await this.process_embed_queue();
console.log(`Processed embed queue in ${Date.now() - embed_start_at}ms`);
}
if (this.sources_re_import_timeout) clearTimeout(this.sources_re_import_timeout);
this.sources_re_import_timeout = null;
}
/**
* Initializes items by letting each adapter do any necessary file-based scanning.
* Adapters that do not rely on file scanning can skip or do nothing.
* @async
* @returns {Promise<void>}
*/
async init_items() {
this.emit_event("source:initial_scan_started");
this.show_process_notice("initial_scan");
for (const AdapterClass of Object.values(this.source_adapters)) {
if (typeof AdapterClass.init_items === "function") {
await AdapterClass.init_items(this);
}
}
this.clear_process_notice("initial_scan");
this.emit_event("source:initial_scan_completed");
this.notices?.show("done_initial_scan", { collection_key: this.collection_key });
}
/**
* Creates (or returns existing) a SmartSource for a given file path, if the extension is recognized.
* @param {string} file_path - The path to the file or pseudo-file
* @returns {SmartSource|undefined} The newly created or existing SmartSource, or undefined if no recognized extension
*/
init_file_path(file_path) {
const ext = this.get_extension_for_path(file_path);
if (!ext) {
return;
}
if (this.fs.is_excluded(file_path)) {
console.warn(`File ${file_path} is excluded from processing.`);
return;
}
if (!this.fs.files[file_path]) {
this.fs.include_file(file_path);
}
if (this.items[file_path]) return this.items[file_path];
const item = new this.item_type(this.env, { path: file_path });
this.items[file_path] = item;
item.queue_import();
item.queue_load();
return item;
}
/**
* Looks for an extension in descending order:
* e.g. split "my.file.name.github" -> ["my","file","name","github"]
* Try 'file.name.github', 'name.github', 'github'
* Return the first that is in 'source_adapters'
* @param {string} file_path
* @returns {string|undefined} recognized extension, or undefined if none
*/
get_extension_for_path(file_path) {
if (!file_path) return void 0;
const pcs = file_path.split(".");
if (pcs.length < 2) return void 0;
let last_ext;
pcs.shift();
while (pcs.length) {
const supported_ext = pcs.join(".").toLowerCase();
if (this.source_adapters[supported_ext]) {
return supported_ext;
}
last_ext = pcs.shift();
}
return last_ext;
}
/**
* Builds a map of links between sources.
* @returns {Object} An object mapping link paths to source keys.
*/
build_links_map() {
const start_time = Date.now();
this.links = {};
for (const source of Object.values(this.items)) {
for (const link of source.outlinks) {
if (!this.links[link.key]) this.links[link.key] = {};
this.links[link.key][source.key] = { ...link, key: void 0 };
}
}
const end_time = Date.now();
console.log(`Time spent building links: ${end_time - start_time}ms`);
return this.links;
}
/**
* Creates a new source with the given key and content.
* @async
* @param {string} key - The key (path) of the new source.
* @param {string} content - The content to write to the new source.
* @returns {Promise<SmartSource>} The created SmartSource instance.
*/
async create(key, content) {
await this.fs.write(key, content);
await this.fs.refresh();
const source = await this.create_or_update({ path: key });
await source.import();
return source;
}
/**
* Performs a lexical search for matching SmartSource content.
* @async
* @deprecated uses this.actions 2025-12-02
* @param {Object} search_filter - The filter criteria for the search.
* @param {string[]} search_filter.keywords - An array of keywords to search for.
* @param {number} [search_filter.limit] - The maximum number of results to return.
* @returns {Promise<Array<SmartSource>>} A promise that resolves to an array of matching SmartSource entities.
*/
async search(search_filter = {}) {
const {
keywords,
limit,
...filter_opts
} = search_filter;
if (!keywords) {
console.warn("search_filter.keywords not set");
return [];
}
this.search_results_ct = 0;
const initial_results = this.filter(filter_opts);
const search_results = [];
for (let i = 0; i < initial_results.length; i += 10) {
const batch = initial_results.slice(i, i + 10);
const batch_results = await Promise.all(
batch.map(async (item) => {
try {
const matches = await item.search(search_filter);
if (matches) {
this.search_results_ct++;
return { item, score: matches };
} else return null;
} catch (error) {
console.error(`Error searching item ${item.id || "unknown"}:`, error);
return null;
}
})
);
search_results.push(...batch_results.filter(Boolean));
}
return search_results.sort((a, b) => b.score - a.score).map((result) => result.item);
}
/**
* Looks up entities based on the provided parameters.
* @async
* @deprecated uses this.actions 2025-12-02
* @param {Object} [params={}] - Parameters for the lookup.
* @param {Object} [params.filter] - Filter options.
* @param {number} [params.k] - Deprecated. Use `params.filter.limit` instead.
* @returns {Promise<Array<SmartSource>>} A promise that resolves to an array of matching SmartSource entities.
*/
async lookup(params = {}) {
const limit = params.filter?.limit || params.k || this.env.settings.lookup_k || 10;
if (params.filter?.limit) delete params.filter.limit;
if (params.collection) {
const collection = this.env[params.collection];
if (collection && collection.lookup) {
delete params.collection;
params.skip_blocks = true;
const results2 = await collection.lookup(params);
if (results2.error) {
console.warn(results2.error);
return [];
}
return results2.slice(0, limit);
}
}
let results = await super.lookup(params);
if (results.error) {
console.warn(results.error);
return [];
}
if (this.block_collection?.settings?.embed_blocks && !params.skip_blocks) {
results = [
...results,
...await this.block_collection.lookup(params)
].sort(sort_by_score3);
}
return results.slice(0, limit);
}
/**
* Processes the load queue by loading items and optionally importing them.
* Called after a "re-load" from settings, or after environment init.
* @async
* @returns {Promise<void>}
*/
async process_load_queue() {
await super.process_load_queue();
if (this.collection_key === "smart_sources" && this.env.smart_blocks) {
Object.values(this.env.smart_blocks.items).forEach((item) => item.init());
}
if (this.block_collection) {
this.block_collection.loaded = Object.keys(this.block_collection.items).length;
}
if (!this.opts.prevent_import_on_load) {
await this.process_source_import_queue(this.opts);
}
this.build_links_map();
this.block_collection.cleanup_blocks();
}
/**
* @method process_source_import_queue
* @description
* Imports items (SmartSources or SmartBlocks) that have been flagged for import.
*/
async process_source_import_queue(opts = {}) {
const { process_embed_queue = true, force = false } = opts;
if (force) Object.values(this.items).forEach((item) => item._queue_import = true);
const import_queue = Object.values(this.items).filter((item) => item._queue_import);
console.log("import_queue " + import_queue.length);
if (import_queue.length) {
const time_start = Date.now();
for (let i = 0; i < import_queue.length; i += 100) {
this.notices?.show("import_progress", {
progress: i,
total: import_queue.length
});
await Promise.all(import_queue.slice(i, i + 100).map((item) => item.import()));
}
setTimeout(() => {
this.notices?.remove("import_progress");
}, 1e3);
this.notices?.show("done_import", {
count: import_queue.length,
time_in_seconds: (Date.now() - time_start) / 1e3
});
} else {
this.notices?.show("no_import_queue");
}
this.build_links_map();
if (process_embed_queue) await this.process_embed_queue();
else console.log("skipping process_embed_queue");
await this.process_save_queue();
await this.block_collection?.process_save_queue();
this.emit_event("sources:import_completed");
}
/**
* Retrieves the source adapters based on the collection configuration.
* @readonly
* @returns {Object} An object mapping file extensions to adapter constructors.
*/
get source_adapters() {
if (!this._source_adapters) {
const source_adapters = Object.entries(this.env.opts.collections?.[this.collection_key]?.source_adapters || {});
const _source_adapters = source_adapters.reduce((acc, [key, Adapter]) => {
if (Adapter.extensions) Adapter.extensions?.forEach((ext) => acc[ext] = Adapter);
else if (typeof Adapter.detect_type === "function") acc[key] = Adapter;
return acc;
}, {});
if (Object.keys(_source_adapters).length) {
this._source_adapters = _source_adapters;
}
}
return this._source_adapters;
}
/**
* Retrieves the notices system from the environment.
* @readonly
* @returns {Object} The notices object.
*/
get notices() {
return this.env.smart_connections_plugin?.notices || this.env.main?.notices;
}
/**
* Retrieves the currently active note.
* @readonly
* @returns {SmartSource|null} The current SmartSource instance or null if none.
*/
get current_note() {
return this.get(this.env.smart_connections_plugin.app.workspace.getActiveFile().path);
}
/**
* Retrieves the file system instance, initializing it if necessary.
* @readonly
* @returns {SmartFS} The file system instance.
*/
get fs() {
if (!this._fs) {
this._fs = new this.env.opts.modules.smart_fs.class(this.env, {
adapter: this.env.opts.modules.smart_fs.adapter,
fs_path: this.env.opts.env_path || "",
exclude_patterns: this.excluded_patterns || []
});
}
return this._fs;
}
/**
* Retrieves the settings configuration by combining superclass settings and adapter-specific settings.
* @readonly
* @returns {Object} The settings configuration object.
*/
get settings_config() {
const _settings_config = {
...super.settings_config,
...this.process_settings_config(settings_config19),
...Object.entries(this.source_adapters).reduce((acc, [file_extension, adapter_constructor]) => {
if (acc[adapter_constructor]) return acc;
const item = this.items[Object.keys(this.items).find((i) => i.endsWith(file_extension))];
const adapter_instance = new adapter_constructor(item || new this.item_type(this.env, {}));
if (adapter_instance.settings_config) {
acc[adapter_constructor.name] = {
type: "html",
value: `<h4>${adapter_constructor.name} adapter</h4>`
};
acc = { ...acc, ...adapter_instance.settings_config };
}
return acc;
}, {})
};
return _settings_config;
}
/**
* Retrieves the block collection associated with SmartSources.
* @readonly
* @returns {SmartBlocks} The block collection instance.
*/
get block_collection() {
return this.env.smart_blocks;
}
/**
* Retrieves the embed queue containing items and their blocks to be embedded.
* @readonly
* @returns {Array<Object>} The embed queue.
*/
get embed_queue() {
if (!this._embed_queue.length) {
try {
const embed_blocks = this.block_collection.settings.embed_blocks;
this._embed_queue = Object.values(this.items).reduce((acc, item) => {
if (item._queue_embed || item.should_embed && item.is_unembedded) acc.push(item);
if (embed_blocks) item.blocks.forEach((block) => {
if (block._queue_embed || block.should_embed && block.is_unembedded) acc.push(block);
});
return acc;
}, []);
} catch (e) {
console.error(`Error getting embed queue:`, e);
}
}
return this._embed_queue;
}
/**
* Clears all data by removing sources and blocks, reinitializing the file system, and reimporting items.
* @async
* @returns {Promise<void>}
*/
async run_clear_all() {
this.notices?.show("clearing_all");
await this.data_adapter.clear_all();
this.clear();
this.block_collection.clear();
this._fs = null;
await this.init_fs();
await this.init_items();
this._excluded_headings = null;
Object.values(this.items).forEach((item) => {
item.queue_import();
item.queue_embed();
item.loaded_at = Date.now() + 9999999999;
});
this.notices?.remove("clearing_all");
this.notices?.show("done_clearing_all");
await this.process_source_import_queue();
}
async init_fs(opts = {}) {
const { force_refresh = false } = opts;
if (force_refresh) await this.env.fs.refresh();
await this.fs.load_exclusions();
this.fs.file_paths = this.fs.post_process(this.env.fs.file_paths);
this.fs.files = this.fs.file_paths.reduce((acc, file_path) => {
acc[file_path] = this.env.fs.files[file_path];
return acc;
}, {});
this.fs.folder_paths = this.fs.post_process(this.env.fs.folder_paths);
this.fs.folders = this.fs.folder_paths.reduce((acc, folder_path) => {
acc[folder_path] = this.env.fs.folders[folder_path];
return acc;
}, {});
}
/**
* Retrieves patterns for excluding files/folders from processing.
* @readonly
* @returns {Array<string>}
*/
get excluded_patterns() {
return [
...this.file_exclusions?.map((file) => `${file}**`) || [],
...(this.folder_exclusions || []).map((folder) => `${folder}**`),
this.env.env_data_dir + "/**"
];
}
/**
* Retrieves the file exclusion patterns from settings.
* @readonly
* @returns {Array<string>} An array of file exclusion patterns.
*/
get file_exclusions() {
const csv = this.env.settings?.smart_sources?.file_exclusions;
return csv?.length ? csv.split(",").map((file) => file.trim()) : [];
}
/**
* Retrieves the folder exclusion patterns from settings.
* @readonly
* @returns {Array<string>} An array of folder exclusion patterns.
*/
get folder_exclusions() {
const csv = this.env.settings?.smart_sources?.folder_exclusions;
return csv?.length ? csv.split(",").map((folder) => {
folder = folder.trim();
if (folder === "") return false;
if (folder === "/") return false;
if (!folder.endsWith("/")) return folder + "/";
return folder;
}).filter(Boolean) : [];
}
/**
* Retrieves the excluded headings from settings.
* @readonly
* @returns {Array<string>} An array of excluded headings.
*/
get excluded_headings() {
if (!this._excluded_headings) {
const csv = this.env.settings?.smart_sources?.excluded_headings;
this._excluded_headings = csv?.length ? csv.split(",").map((heading) => heading.trim()) : [];
}
return this._excluded_headings;
}
/**
* Retrieves the count of included files that are not excluded.
* @readonly
* @returns {number} The number of included files.
*/
get included_files() {
const extensions = Object.keys(this.source_adapters);
return this.fs.file_paths.filter((file_path) => extensions.some((ext) => file_path.endsWith(ext)) && !this.fs.is_excluded(file_path)).length;
}
get excluded_file_paths() {
return this.env.fs.file_paths.filter((file_path) => this.fs.is_excluded(file_path));
}
/**
* Retrieves the total number of files, regardless of exclusion.
* @readonly
* @returns {number} The total number of files.
*/
get total_files() {
return this.fs.file_paths.filter((file) => file.endsWith(".md") || file.endsWith(".canvas")).length;
}
/**
* Unloads the collection and clears registered listeners and timers.
* @returns {void}
*/
unload() {
this.unregister_env_event_listeners();
if (this.sources_re_import_timeout) clearTimeout(this.sources_re_import_timeout);
this.sources_re_import_timeout = null;
this.sources_re_import_queue = {};
super.unload();
}
get data_dir() {
return "multi";
}
};
var settings_config19 = {
};

var CollectionDataAdapter3 = class {
static {
__name(this, "CollectionDataAdapter");
}
/**
* @constructor
* @param {Object} collection - The collection instance that this adapter manages.
*/
constructor(collection) {
this.collection = collection;
this.env = collection.env;
}
/**
* The class to use for item adapters.
* @type {typeof ItemDataAdapter}
*/
ItemDataAdapter = ItemDataAdapter3;
/**
* Optional factory method to create item adapters.
* If `this.item_adapter_class` is not null, it uses that; otherwise can be overridden by subclasses.
* @param {Object} item - The item to create an adapter for.
* @returns {ItemDataAdapter}
*/
create_item_adapter(item) {
if (!this.ItemDataAdapter) {
throw new Error("No item_adapter_class specified and create_item_adapter not overridden.");
}
return new this.ItemDataAdapter(item);
}
/**
* Load a single item by its key using an `ItemDataAdapter`.
* @async
* @abstract
* @param {string} key - The key of the item to load.
* @returns {Promise<void>} Resolves when the item is loaded.
*/
async load_item(key) {
throw new Error("Not implemented");
}
/**
* Save a single item by its key using its associated `ItemDataAdapter`.
* @async
* @abstract
* @param {string} key - The key of the item to save.
* @returns {Promise<void>} Resolves when the item is saved.
*/
async save_item(key) {
throw new Error("Not implemented");
}
/**
* Delete a single item by its key. This may involve updating or removing its file,
* as handled by the `ItemDataAdapter`.
* @async
* @abstract
* @param {string} key - The key of the item to delete.
* @returns {Promise<void>} Resolves when the item is deleted.
*/
async delete_item(key) {
throw new Error("Not implemented");
}
/**
* Process any queued load operations. Typically orchestrates calling `load_item()`
* on items that have been flagged for loading.
* @async
* @abstract
* @returns {Promise<void>}
*/
async process_load_queue() {
throw new Error("Not implemented");
}
/**
* Process any queued save operations. Typically orchestrates calling `save_item()`
* on items that have been flagged for saving.
* @async
* @abstract
* @returns {Promise<void>}
*/
async process_save_queue() {
throw new Error("Not implemented");
}
/**
* Load the item's data from storage if it has been updated externally.
* @async
* @param {string} key - The key of the item to load.
* @returns {Promise<void>} Resolves when the item is loaded.
*/
async load_item_if_updated(item) {
const adapter = this.create_item_adapter(item);
await adapter.load_if_updated();
}
/**
* Clear all data associated with this collection.
* @async
* @abstract
* @returns {Promise<void>}
*/
async clear_all() {
throw new Error("Not implemented");
}
};
var ItemDataAdapter3 = class {
static {
__name(this, "ItemDataAdapter");
}
/**
* @constructor
* @param {Object} item - The collection item instance that this adapter manages.
*/
constructor(item) {
this.item = item;
}
/**
* Load the item's data from storage. May involve reading a file and parsing
* its contents, then updating `item.data`.
* @async
* @abstract
* @returns {Promise<void>} Resolves when the item is fully loaded.
*/
async load() {
throw new Error("Not implemented");
}
/**
* Save the item's data to storage. May involve writing to a file or appending
* lines in an append-only format.
* @async
* @abstract
* @param {string|null} [ajson=null] - An optional serialized representation of the item’s data.
*                                     If not provided, the adapter should derive it from the item.
* @returns {Promise<void>} Resolves when the item is saved.
*/
async save(ajson = null) {
throw new Error("Not implemented");
}
/**
* Delete the item's data from storage. May involve removing a file or writing
* a `null` entry in an append-only file to signify deletion.
* @async
* @abstract
* @returns {Promise<void>} Resolves when the item’s data is deleted.
*/
async delete() {
throw new Error("Not implemented");
}
/**
* Returns the file path or unique identifier used by this adapter to locate and store
* the item's data. This may be a file name derived from the item's key.
* @abstract
* @returns {string} The path or identifier for the item's data.
*/
get data_path() {
throw new Error("Not implemented");
}
/**
* @returns {CollectionDataAdapter} The collection data adapter that this item data adapter belongs to.
*/
get collection_adapter() {
return this.item.collection.data_adapter;
}
get env() {
return this.item.env;
}
/**
* Load the item's data from storage if it has been updated externally.
* @async
* @abstract
* @returns {Promise<void>} Resolves when the item is loaded.
*/
async load_if_updated() {
throw new Error("Not implemented");
}
};

var FileCollectionDataAdapter3 = class extends CollectionDataAdapter3 {
static {
__name(this, "FileCollectionDataAdapter");
}
/**
* The class to use for item adapters.
* @type {typeof ItemDataAdapter}
*/
ItemDataAdapter = FileItemDataAdapter3;
/**
* @returns {Object} Filesystem interface derived from environment or collection settings.
*/
get fs() {
return this.collection.data_fs || this.collection.env.data_fs;
}
async clear_all() {
await this.fs.remove_dir(this.collection.data_dir, true);
}
};
var FileItemDataAdapter3 = class extends ItemDataAdapter3 {
static {
__name(this, "FileItemDataAdapter");
}
/**
* @returns {Object} Filesystem interface derived from environment or collection settings.
*/
get fs() {
return this.item.collection.data_fs || this.item.collection.env.data_fs;
}
/**
* Resolve the file path for the item's data.
* @abstract
* @returns {string} Path to the persisted item data.
*/
get data_path() {
throw new Error("Not implemented");
}
async load_if_updated() {
const data_path = this.data_path;
if (await this.fs.exists(data_path)) {
const loaded_at = this.item.loaded_at || 0;
const data_file_stat = await this.fs.stat(data_path);
if (data_file_stat.mtime > loaded_at + 1 * 60 * 1e3) {
console.log(`Smart Collections: Re-loading item ${this.item.key} because it has been updated on disk`);
await this.load();
}
}
}
};

var class_to_collection_key5 = {
"SmartSource": "smart_sources",
"SmartNote": "smart_sources",
"SmartBlock": "smart_blocks",
"SmartDirectory": "smart_directories"
};
var AjsonMultiFileCollectionDataAdapter3 = class extends FileCollectionDataAdapter3 {
static {
__name(this, "AjsonMultiFileCollectionDataAdapter");
}
/**
* The class to use for item adapters.
* @type {typeof ItemDataAdapter}
*/
ItemDataAdapter = AjsonMultiFileItemDataAdapter3;
/**
* Load a single item by its key.
* @async
* @param {string} key
* @returns {Promise<void>}
*/
async load_item(key) {
const item = this.collection.get(key);
if (!item) return;
const adapter = this.create_item_adapter(item);
await adapter.load();
}
/**
* Save a single item by its key.
* @async
* @param {string} key
* @returns {Promise<void>}
*/
async save_item(key) {
const item = this.collection.get(key);
if (!item) return;
const adapter = this.create_item_adapter(item);
await adapter.save();
}
/**
* Process any queued load operations.
* @async
* @returns {Promise<void>}
*/
async process_load_queue() {
this.collection.emit_event("collection:load_started");
this.collection.show_process_notice("loading_collection");
if (!await this.fs.exists(this.collection.data_dir)) {
await this.fs.mkdir(this.collection.data_dir);
}
const load_queue = Object.values(this.collection.items).filter((item) => item._queue_load);
if (!load_queue.length) {
this.collection.clear_process_notice("loading_collection");
return;
}
const now = Date.now();
console.log(`Loading ${this.collection.collection_key}: ${load_queue.length} items from disk`);
const batch_size = 100;
for (let i = 0; i < load_queue.length; i += batch_size) {
const batch = load_queue.slice(i, i + batch_size);
await Promise.all(batch.map((item) => {
const adapter = this.create_item_adapter(item);
return adapter.load().catch((err) => {
console.warn(`Error loading item ${item.key}`, err);
item.queue_load();
});
}));
}
console.log(`Loaded ${this.collection.collection_key} from disk in ${Date.now() - now}ms`);
this.collection.loaded = load_queue.length;
this.collection.clear_process_notice("loading_collection");
this.collection.emit_event("collection:load_completed");
}
/**
* Process any queued save operations.
* @async
* @returns {Promise<void>}
*/
async process_save_queue() {
this.collection.emit_event("collection:save_started");
this.collection.show_process_notice("saving_collection");
const save_queue = Object.values(this.collection.items).filter((item) => item._queue_save);
console.log(`Saving ${this.collection.collection_key}: ${save_queue.length} items`);
const time_start = Date.now();
const batch_size = 50;
for (let i = 0; i < save_queue.length; i += batch_size) {
const batch = save_queue.slice(i, i + batch_size);
await Promise.all(batch.map((item) => {
const adapter = this.create_item_adapter(item);
return adapter.save().catch((err) => {
console.warn(`Error saving item ${item.key}`, err);
item.queue_save();
});
}));
}
const deleted_items = Object.values(this.collection.items).filter((item) => item.deleted);
if (deleted_items.length) {
deleted_items.forEach((item) => {
delete this.collection.items[item.key];
});
}
console.log(`Saved ${this.collection.collection_key} in ${Date.now() - time_start}ms`);
this.collection.clear_process_notice("saving_collection");
this.collection.emit_event("collection:save_completed");
}
get_item_data_path(key) {
return [
this.collection.data_dir || "multi",
this.fs?.sep || "/",
this.get_data_file_name(key) + ".ajson"
].join("");
}
/**
* Transforms the item key into a safe filename.
* Replaces spaces, slashes, and dots with underscores.
* @returns {string} safe file name
*/
get_data_file_name(key) {
return key.split("#")[0].replace(/[\s\/\.]/g, "_").replace(".md", "");
}
/**
* Build a single AJSON line for the given item and data.
* @param {Object} item
* @returns {string}
*/
get_item_ajson(item) {
const collection_key = item.collection_key;
const key = item.key;
const data_value = item.deleted ? "null" : JSON.stringify(item.data);
return `${JSON.stringify(`${collection_key}:${key}`)}: ${data_value},`;
}
};
var AjsonMultiFileItemDataAdapter3 = class extends FileItemDataAdapter3 {
static {
__name(this, "AjsonMultiFileItemDataAdapter");
}
/**
* Derives the `.ajson` file path from the collection's data_dir and item key.
* @returns {string}
*/
get data_path() {
return this.collection_adapter.get_item_data_path(this.item.key);
}
/**
* Load the item from its `.ajson` file.
* @async
* @returns {Promise<void>}
*/
async load() {
try {
const raw_data = await this.fs.adapter.read(this.data_path, "utf-8", { no_cache: true });
if (!raw_data) {
this.item.queue_import();
return;
}
const { rewrite, file_data } = this._parse(raw_data);
if (rewrite) {
if (file_data.length) await this.fs.write(this.data_path, file_data);
else await this.fs.remove(this.data_path);
}
const last_import_mtime = this.item.data.last_import?.at || 0;
if (last_import_mtime && this.item.init_file_mtime > last_import_mtime) {
this.item.queue_import();
}
} catch (e) {
this.item.queue_import();
}
}
/**
* Parse the entire AJSON content as a JSON object, handle legacy keys, and extract final state.
* @private
* @param {string} ajson
* @returns {boolean}
*/
_parse(ajson) {
try {
let rewrite = false;
if (!ajson.length) return false;
ajson = ajson.trim();
const original_line_count = ajson.split("\n").length;
const json_str = "{" + ajson.slice(0, -1) + "}";
const data = JSON.parse(json_str);
const entries = Object.entries(data);
for (let i = 0; i < entries.length; i++) {
const [ajson_key, value] = entries[i];
if (!value) {
delete data[ajson_key];
rewrite = true;
continue;
}
const { collection_key, item_key, changed } = this._parse_ajson_key(ajson_key);
if (changed) {
rewrite = true;
data[collection_key + ":" + item_key] = value;
delete data[ajson_key];
}
const collection = this.env[collection_key];
if (!collection) continue;
const existing_item = collection.get(item_key);
if (!value.key) value.key = item_key;
if (existing_item) {
existing_item.data = value;
existing_item._queue_load = false;
existing_item.loaded_at = Date.now();
} else {
const ItemClass = collection.item_type;
const new_item = new ItemClass(this.env, value);
new_item._queue_load = false;
new_item.loaded_at = Date.now();
collection.set(new_item);
}
}
if (rewrite || original_line_count > entries.length) {
rewrite = true;
}
return {
rewrite,
file_data: rewrite ? Object.entries(data).map(([key, value]) => `${JSON.stringify(key)}: ${JSON.stringify(value)},`).join("\n") : null
};
} catch (e) {
if (ajson.split("\n").some((line) => !line.endsWith(","))) {
console.warn("fixing trailing comma error");
ajson = ajson.split("\n").map((line) => line.endsWith(",") ? line : line + ",").join("\n");
return this._parse(ajson);
}
console.warn("Error parsing JSON:", e);
return { rewrite: true, file_data: null };
}
}
_parse_ajson_key(ajson_key) {
let changed;
let [collection_key, ...item_key] = ajson_key.split(":");
if (class_to_collection_key5[collection_key]) {
collection_key = class_to_collection_key5[collection_key];
changed = true;
}
return {
collection_key,
item_key: item_key.join(":"),
changed
};
}
/**
* Save the current state of the item by appending a new line to its `.ajson` file.
* @async
* @returns {Promise<void>}
*/
async save(retries = 0) {
try {
const ajson_line = this.get_item_ajson();
await this.fs.append(this.data_path, "\n" + ajson_line);
this.item._queue_save = false;
} catch (e) {
if (e.code === "ENOENT" && retries < 1) {
const dir = this.collection_adapter.collection.data_dir;
if (!await this.fs.exists(dir)) {
await this.fs.mkdir(dir);
}
return await this.save(retries + 1);
}
console.warn("Error saving item", this.data_path, this.item.key, e);
}
}
/**
* Build a single AJSON line for the given item and data.
* @param {Object} item
* @returns {string}
*/
get_item_ajson() {
return this.collection_adapter.get_item_ajson(this.item);
}
};

var AjsonMultiFileSourcesDataAdapter2 = class extends AjsonMultiFileCollectionDataAdapter3 {
static {
__name(this, "AjsonMultiFileSourcesDataAdapter");
}
ItemDataAdapter = AjsonMultiFileSourceDataAdapter2;
};
var AjsonMultiFileSourceDataAdapter2 = class extends AjsonMultiFileItemDataAdapter3 {
static {
__name(this, "AjsonMultiFileSourceDataAdapter");
}
};

var SourceContentAdapter2 = class {
static {
__name(this, "SourceContentAdapter");
}
constructor(item) {
this.item = item;
}
async import() {
this.throw_not_implemented("import");
}
async create() {
this.throw_not_implemented("create");
}
async update() {
this.throw_not_implemented("update");
}
async read() {
this.throw_not_implemented("read");
}
async remove() {
this.throw_not_implemented("remove");
}
get data() {
return this.item.data;
}
create_hash(content) {
return murmur_hash_32_alphanumeric3(content);
}
get settings() {
return this.item.env.settings.smart_sources[this.adapter_key];
}
get adapter_key() {
return to_snake2(this.constructor.name);
}
static get adapter_key() {
return to_snake2(this.name);
}
get fs() {
return this.item.collection.fs;
}
get env() {
return this.item.env;
}
};
function to_snake2(str) {
return str[0].toLowerCase() + str.slice(1).replace(/([A-Z])/g, "_$1").toLowerCase();
}
__name(to_snake2, "to_snake");

function parse_markdown_blocks2(markdown, opts = {}) {
const { start_index = 1, line_keys = false } = opts;
const lines = markdown.split("\n");
const LIST_KEY_WORD_LEN = opts.list_key_word_len || 10;
const result = {};
const heading_stack = [];
const heading_lines = {};
const heading_counts = {};
const sub_block_counts = {};
const subheading_counts = {};
const task_lines = [];
const tasks = {};
let current_list_item = null;
let current_content_block = null;
let in_frontmatter = false;
let frontmatter_started = false;
const root_heading_key = "#";
let in_code_block = false;
const codeblock_ranges = [];
let codeblock_start = null;
sub_block_counts[root_heading_key] = 0;
for (let i = 0; i < lines.length; i++) {
const line_number = i + start_index;
const line = lines[i];
const trimmed_line = line.trim();
if (trimmed_line === "---") {
if (!frontmatter_started && line_number === 1) {
frontmatter_started = true;
in_frontmatter = true;
heading_lines["#---frontmatter---"] = [line_number, null];
continue;
} else if (in_frontmatter) {
in_frontmatter = false;
heading_lines["#---frontmatter---"][1] = line_number;
continue;
}
}
if (in_frontmatter) {
continue;
}
if (!in_code_block && /^[-*+]\s+\[(?: |x|X)\]/.test(trimmed_line)) {
task_lines.push(line_number);
if (/^[-*+]\s+\[ \]/.test(trimmed_line)) {
if (!tasks.incomplete) tasks.incomplete = { all: [], top: [] };
tasks.incomplete.all.push(line_number);
}
if (/^[-*+]\s+\[ \]/.test(line)) {
tasks.incomplete.top.push(line_number);
}
}
if (trimmed_line.startsWith("```")) {
in_code_block = !in_code_block;
if (in_code_block && !codeblock_start) codeblock_start = line_number;
else if (!in_code_block && codeblock_start) {
codeblock_ranges.push([codeblock_start, line_number]);
codeblock_start = null;
}
if (!current_content_block) {
const parent_key = heading_stack.length > 0 ? heading_stack[heading_stack.length - 1].key : root_heading_key;
if (parent_key === root_heading_key && !heading_lines[root_heading_key]) {
heading_lines[root_heading_key] = [line_number, null];
}
if (parent_key === root_heading_key) {
current_content_block = { key: root_heading_key, start_line: line_number };
if (heading_lines[root_heading_key][1] === null || heading_lines[root_heading_key][1] < line_number) {
heading_lines[root_heading_key][1] = null;
}
} else {
if (sub_block_counts[parent_key] === void 0) {
sub_block_counts[parent_key] = 0;
}
sub_block_counts[parent_key] += 1;
const n = sub_block_counts[parent_key];
const key = `${parent_key}#{${n}}`;
heading_lines[key] = [line_number, null];
current_content_block = { key, start_line: line_number };
}
}
continue;
}
const heading_match = trimmed_line.match(/^(#{1,6})\s*(.+)$/);
if (heading_match && !in_code_block) {
const level = heading_match[1].length;
let title = heading_match[2].trim();
while (heading_stack.length > 0 && heading_stack[heading_stack.length - 1].level >= level) {
const finished_heading = heading_stack.pop();
if (heading_lines[finished_heading.key][1] === null) {
heading_lines[finished_heading.key][1] = line_number - 1;
}
}
if (heading_stack.length === 0 && heading_lines[root_heading_key] && heading_lines[root_heading_key][1] === null) {
heading_lines[root_heading_key][1] = line_number - 1;
}
if (current_content_block) {
if (heading_lines[current_content_block.key][1] === null) {
heading_lines[current_content_block.key][1] = line_number - 1;
}
current_content_block = null;
}
if (current_list_item) {
if (heading_lines[current_list_item.key][1] === null) {
heading_lines[current_list_item.key][1] = line_number - 1;
}
current_list_item = null;
}
let parent_key = "";
let parent_level = 0;
if (heading_stack.length > 0) {
parent_key = heading_stack[heading_stack.length - 1].key;
parent_level = heading_stack[heading_stack.length - 1].level;
} else {
parent_key = "";
parent_level = 0;
}
if (heading_stack.length === 0) {
heading_counts[title] = (heading_counts[title] || 0) + 1;
if (heading_counts[title] > 1) {
title += `[${heading_counts[title]}]`;
}
} else {
if (!subheading_counts[parent_key]) {
subheading_counts[parent_key] = {};
}
subheading_counts[parent_key][title] = (subheading_counts[parent_key][title] || 0) + 1;
const count = subheading_counts[parent_key][title];
if (count > 1) {
title += `#{${count}}`;
}
}
const level_diff = level - parent_level;
const hashes = "#".repeat(level_diff);
const key = parent_key + hashes + title;
heading_lines[key] = [line_number, null];
sub_block_counts[key] = 0;
heading_stack.push({ level, title, key });
continue;
}
const list_match = line.match(/^(\s*)([-*]|\d+\.) (.+)$/);
if (list_match && !in_code_block) {
const indentation = list_match[1].length;
if (indentation === 0) {
if (current_list_item) {
if (heading_lines[current_list_item.key][1] === null) {
heading_lines[current_list_item.key][1] = line_number - 1;
}
current_list_item = null;
}
if (current_content_block && current_content_block.key !== root_heading_key) {
if (heading_lines[current_content_block.key][1] === null) {
heading_lines[current_content_block.key][1] = line_number - 1;
}
current_content_block = null;
}
let parent_key = heading_stack.length > 0 ? heading_stack[heading_stack.length - 1].key : root_heading_key;
if (parent_key === root_heading_key && !heading_lines[root_heading_key]) {
heading_lines[root_heading_key] = [line_number, null];
}
if (sub_block_counts[parent_key] === void 0) {
sub_block_counts[parent_key] = 0;
}
sub_block_counts[parent_key] += 1;
const n = sub_block_counts[parent_key];
let key;
if (line_keys) {
const content_without_task = list_match[3].replace(/^\[(?: |x|X)\]\s*/, "");
const words = get_longest_words_in_order2(content_without_task, LIST_KEY_WORD_LEN);
key = `${parent_key}#${words}`;
} else {
key = `${parent_key}#{${n}}`;
}
heading_lines[key] = [line_number, null];
current_list_item = { key, start_line: line_number };
continue;
}
if (current_list_item) {
continue;
}
}
if (trimmed_line === "") {
continue;
}
if (!current_content_block) {
if (current_list_item) {
if (heading_lines[current_list_item.key][1] === null) {
heading_lines[current_list_item.key][1] = line_number - 1;
}
current_list_item = null;
}
let parent_key = heading_stack.length > 0 ? heading_stack[heading_stack.length - 1].key : root_heading_key;
if (parent_key === root_heading_key) {
if (!heading_lines[root_heading_key]) {
heading_lines[root_heading_key] = [line_number, null];
}
if (heading_lines[root_heading_key][1] === null || heading_lines[root_heading_key][1] < line_number) {
heading_lines[root_heading_key][1] = null;
}
current_content_block = { key: root_heading_key, start_line: line_number };
} else {
if (sub_block_counts[parent_key] === void 0) {
sub_block_counts[parent_key] = 0;
}
sub_block_counts[parent_key] += 1;
const n = sub_block_counts[parent_key];
const key = `${parent_key}#{${n}}`;
heading_lines[key] = [line_number, null];
current_content_block = { key, start_line: line_number };
}
}
}
const total_lines = lines.length;
while (heading_stack.length > 0) {
const finished_heading = heading_stack.pop();
if (heading_lines[finished_heading.key][1] === null) {
heading_lines[finished_heading.key][1] = total_lines + start_index - 1;
}
}
if (current_list_item) {
if (heading_lines[current_list_item.key][1] === null) {
heading_lines[current_list_item.key][1] = total_lines + start_index - 1;
}
current_list_item = null;
}
if (current_content_block) {
if (heading_lines[current_content_block.key][1] === null) {
heading_lines[current_content_block.key][1] = total_lines + start_index - 1;
}
current_content_block = null;
}
if (heading_lines[root_heading_key] && heading_lines[root_heading_key][1] === null) {
heading_lines[root_heading_key][1] = total_lines + start_index - 1;
}
for (const key in heading_lines) {
result[key] = heading_lines[key];
}
return { blocks: result, task_lines, tasks, codeblock_ranges };
}
__name(parse_markdown_blocks2, "parse_markdown_blocks");
function get_longest_words_in_order2(line, n = 3) {
const words = line.split(/\s+/).sort((a, b) => b.length - a.length).slice(0, n);
return words.sort((a, b) => line.indexOf(a) - line.indexOf(b)).join(" ");
}
__name(get_longest_words_in_order2, "get_longest_words_in_order");

var FileSourceContentAdapter2 = class extends SourceContentAdapter2 {
static {
__name(this, "FileSourceContentAdapter");
}
static async init_items(collection) {
if (collection.fs_items_initialized) return;
collection._fs = null;
await collection.fs.init();
await collection.init_fs();
for (const file of Object.values(collection.fs.files)) {
const item = collection.init_file_path(file.path);
if (item) item.init_file_mtime = file.stat.mtime;
}
collection.fs_items_initialized = Date.now();
}
/**
* @name fs
* @type {Object}
* @readonly
* @description
* Access the file system interface used by this adapter. Typically derived
* from `this.item.collection.fs`.
*/
get fs() {
return this.item.collection.fs;
}
/**
* @name file_path
* @type {string}
* @readonly
* @description
* The file path on disk corresponding to the source. Used for read/write operations.
*/
get file_path() {
return this.item.file_path;
}
/**
* @async
* @method create
* @param {string|null} [content=null] Initial content for the new file.
* @description
* Create a new file on disk. If content is not provided, attempts to use
* `this.item.data.content` as fallback.
*/
async create(content = null) {
if (!content) content = this.item.data.content || "";
await this.fs.write(this.file_path, content);
}
/**
* @async
* @method update
* @param {string} content The full new content to write to the file.
* @description
* Overwrite the entire file content on disk.
*/
async update(content) {
await this.fs.write(this.file_path, content);
}
/**
* @async
* @method read
* @returns {Promise<string>} The content of the file.
* @description
* Read the file content from disk. Updates `last_read` hash and timestamp on the entity’s data.
* If file is large or special handling is needed, override this method.
*/
async read() {
const content = await this.fs.read(this.file_path);
this.data.last_read = {
hash: this.create_hash(content || ""),
at: Date.now()
};
return content;
}
/**
* @async
* @method remove
* @returns {Promise<void>}
* @description
* Delete the file from disk. After removal, the source item should also be deleted or updated accordingly.
*/
async remove() {
await this.fs.remove(this.file_path);
}
async move_to(move_to_ref) {
if (!move_to_ref) {
throw new Error("Invalid entity reference for move_to operation");
}
const move_content = await this.read();
let has_existing = false;
if (typeof move_to_ref === "string") {
const existing = this.item.collection.get(move_to_ref);
if (existing) {
move_to_ref = existing;
has_existing = true;
}
} else {
has_existing = true;
}
if (has_existing) {
await move_to_ref.append(move_content);
} else {
move_to_ref = await this.item.collection.create(move_to_ref, move_content);
}
if (this.item.key !== move_to_ref.key) {
await this.remove();
this.item.delete();
} else {
console.log(`did not delete ${this.item.key} because it was moved to ${move_to_ref.key}`);
}
return move_to_ref;
}
/**
* Merge content into the source
* @param {string} content - The content to merge into the source
* @param {Object} opts - Options for the merge operation
* @param {string} opts.mode - The mode to use for the merge operation. Defaults to 'append_blocks' (may also be 'replace_blocks')
*/
async merge(content, opts = {}) {
const { mode = "append_blocks" } = opts;
const { blocks: blocks_obj, task_lines } = parse_markdown_blocks2(content);
if (typeof blocks_obj !== "object" || Array.isArray(blocks_obj)) {
console.warn("merge error: Expected an object from parse_markdown_blocks, but received:", blocks_obj);
throw new Error("merge error: parse_markdown_blocks did not return an object as expected.");
}
const { new_blocks, new_with_parent_blocks, changed_blocks, same_blocks } = await this.get_changes(blocks_obj, content);
for (const block of new_blocks) {
await this.append(block.content);
}
for (const block of new_with_parent_blocks) {
const parent_block = this.item.block_collection.get(block.parent_key);
await parent_block.append(block.content);
}
for (const block of changed_blocks) {
const changed_block = this.item.block_collection.get(block.key);
if (mode === "replace_blocks") {
await changed_block.update(block.content);
} else {
await changed_block.append(block.content);
}
}
}
async get_changes(blocks_obj, content) {
const new_blocks = [];
const new_with_parent_blocks = [];
const changed_blocks = [];
const same_blocks = [];
const existing_blocks = this.source.data.blocks || {};
for (const [sub_key, line_range] of Object.entries(blocks_obj)) {
const has_existing = !!existing_blocks[sub_key];
const block_key = `${this.source.key}${sub_key}`;
const block_content = get_line_range(content, line_range[0], line_range[1]);
if (!has_existing) {
new_blocks.push({
key: block_key,
state: "new",
content: block_content
});
continue;
}
let has_parent;
let headings = sub_key.split("#");
let parent_key;
while (!has_parent && headings.length > 0) {
headings.pop();
parent_key = headings.join("#");
has_parent = !!existing_blocks[parent_key];
}
if (has_parent) {
new_with_parent_blocks.push({
key: block_key,
parent_key: `${this.source.key}${parent_key}`,
state: "new",
content: block_content
});
continue;
}
const block = this.item.block_collection.get(block_key);
const content_hash = await this.create_hash(block_content);
if (content_hash !== block.last_read?.hash) {
changed_blocks.push({
key: block_key,
state: "changed",
content: block_content
});
continue;
}
same_blocks.push({
key: block_key,
state: "same",
content: block_content
});
}
return {
new_blocks,
new_with_parent_blocks,
changed_blocks,
same_blocks
};
}
/**
* Append new content to the source file, placing it at the end of the file.
* @async
* @param {string} content - The content to append.
* @returns {Promise<void>}
*/
async append(content) {
const current_content = await this.read();
const new_content = [
current_content,
"",
content
].join("\n").trim();
await this.update(new_content);
}
get size() {
return this.item.file?.stat?.size || 0;
}
};

function get_markdown_links2(content) {
const result = [];
const markdown_link_re = /\[([^\]]+?)\]\(([^)]+?)\)/g;
const wikilink_re = /\[\[([^\|\]]+?)(?:\|([^\]]+?))?\]\]/g;
const normalise_target = /* @__PURE__ */ __name((raw) => {
const trimmed = raw.trim();
if (/^[a-zA-Z][\w+\-.]*:\/\//.test(trimmed)) return trimmed;
try {
return decodeURIComponent(trimmed);
} catch (_) {
return trimmed.replace(/%20/gi, " ");
}
}, "normalise_target");
const is_embedded = /* @__PURE__ */ __name((index) => {
if (index <= 0) return false;
return content[index - 1] === "!";
}, "is_embedded");
let m;
while ((m = markdown_link_re.exec(content)) !== null) {
const title = m[1];
const target = normalise_target(m[2]);
const line_no = content.slice(0, m.index).split("\n").length;
const embedded = is_embedded(m.index);
const record = { title, target, line: line_no };
if (embedded) record.embedded = true;
result.push(record);
}
while ((m = wikilink_re.exec(content)) !== null) {
const target_raw = m[1];
const title = m[2] || target_raw;
const target = normalise_target(target_raw);
const line_no = content.slice(0, m.index).split("\n").length;
const embedded = is_embedded(m.index);
const record = { title, target, line: line_no };
if (embedded) record.embedded = true;
result.push(record);
}
return result.sort(
(a, b) => a.line - b.line || a.target.localeCompare(b.target)
);
}
__name(get_markdown_links2, "get_markdown_links");

function get_bases_cache_links2({ source, links = [], cache } = {}) {
if (!source || !Array.isArray(links) || !links.length) return [];
const cache_items = cache || source?.env?.bases_caches?.items;
if (!cache_items) return [];
const source_key = source?.key || source?.path;
if (!source_key) return [];
return links.flatMap((link) => {
if (!link?.embedded) return [];
if (typeof link.target !== "string" || !link.target.includes(".base")) return [];
const cache_key = `${source_key}#${link.target}`;
const markdown_table = cache_items?.[cache_key]?.markdown_table;
if (!markdown_table) return [];
const table_links = get_markdown_links2(markdown_table);
if (!table_links.length) return [];
return table_links.map((table_link) => ({
...table_link,
line: link.line,
bases_row: table_link.line - 2
}));
});
}
__name(get_bases_cache_links2, "get_bases_cache_links");

function parse_value2(raw_value) {
const trimmed = raw_value.trim();
if (trimmed.startsWith('"') && trimmed.endsWith('"') || trimmed.startsWith("'") && trimmed.endsWith("'")) {
return trimmed.slice(1, -1);
}
const lower = trimmed.toLowerCase();
if (lower === "true") return true;
if (lower === "false") return false;
if (!isNaN(trimmed) && trimmed !== "") {
return Number(trimmed);
}
return trimmed;
}
__name(parse_value2, "parse_value");
function parse_yaml_block2(yaml_block) {
const lines = yaml_block.split(/\r?\n/);
const data = {};
let i = 0;
while (i < lines.length) {
const line = lines[i];
i++;
if (!line.trim() || line.trim().startsWith("#")) {
continue;
}
const match = line.match(/^([^:]+)\s*:\s*(.*)$/);
if (!match) {
continue;
}
const key = match[1].trim();
let value = match[2].trim();
if (value === ">" || value === "|") {
const multiline_lines = [];
while (i < lines.length) {
const next_line = lines[i];
if (!/^\s+/.test(next_line) || next_line.trim().startsWith("#")) {
break;
}
multiline_lines.push(next_line.replace(/^\s+/, ""));
i++;
}
const joined = multiline_lines.join("\n");
data[key] = parse_value2(joined);
} else if (value === "") {
const arr = [];
let array_consumed = false;
while (i < lines.length) {
const next_line = lines[i];
if (!next_line.trim().startsWith("- ")) {
break;
}
const item_value = next_line.trim().slice(2);
arr.push(parse_value2(item_value));
i++;
array_consumed = true;
}
if (array_consumed) {
data[key] = arr;
} else {
data[key] = "";
}
} else {
data[key] = parse_value2(value);
}
}
return data;
}
__name(parse_yaml_block2, "parse_yaml_block");
function parse_frontmatter2(content) {
if (!content.startsWith("---")) {
return { frontmatter: {}, body: content };
}
const lines = content.split(/\r?\n/);
let end_index = -1;
for (let i = 1; i < lines.length; i++) {
if (lines[i].trim() === "---") {
end_index = i;
break;
}
}
if (end_index === -1) {
return { frontmatter: {}, body: content };
}
const frontmatter_lines = lines.slice(1, end_index);
const frontmatter_block = frontmatter_lines.join("\n");
const frontmatter = parse_yaml_block2(frontmatter_block);
const body_lines = lines.slice(end_index + 1);
const body = body_lines.join("\n");
return { frontmatter, body };
}
__name(parse_frontmatter2, "parse_frontmatter");

var get_markdown_tags2 = /* @__PURE__ */ __name((content = "") => {
const tag_re = /(?<!\w)#([\w/-]+)/g;
const tags = /* @__PURE__ */ new Set();
let match;
while ((match = tag_re.exec(content)) !== null) {
tags.add(`#${match[1]}`);
}
return [...tags];
}, "get_markdown_tags");

var MarkdownSourceContentAdapter2 = class extends FileSourceContentAdapter2 {
static {
__name(this, "MarkdownSourceContentAdapter");
}
static extensions = ["md", "txt"];
/**
* Import the source file content, parse blocks and links, and update `item.data`.
* @async
* @returns {Promise<void>}
*/
async import() {
if (!this.can_import) return;
if (!this.outdated) {
this.item.blocks.forEach((block) => {
if (!block.vec) block.queue_embed();
});
return;
}
const content = await this.read();
if (!content) {
return;
}
if (!this.item.vec) {
this.item.data.last_import = null;
}
if (this.data.last_import?.hash === this.data.last_read?.hash) {
if (this.data.blocks) return;
}
this.data.blocks = null;
await this.parse_content(content);
await this.item.parse_content(content);
const { mtime, size } = this.item.file.stat;
this.data.last_import = {
mtime,
size,
at: Date.now(),
hash: this.data.last_read.hash
};
this.item.loaded_at = Date.now();
this.item.queue_save();
if (this.item.should_embed) this.item.queue_embed();
}
async parse_content(content) {
const outlinks = await this.get_links(content);
this.data.outlinks = outlinks;
const metadata = await this.get_metadata(content);
this.data.metadata = metadata;
}
async get_links(content = null) {
if (!content) content = await this.read();
if (!content) return;
const markdown_links = get_markdown_links2(content);
const bases_links = get_bases_cache_links2({
source: this.item,
links: markdown_links
});
return [
...markdown_links,
...bases_links
];
}
async get_metadata(content = null) {
if (!content) content = await this.read();
if (!content) return;
const { frontmatter, body } = parse_frontmatter2(content);
const tag_set = /* @__PURE__ */ new Set();
let fm_tags = frontmatter.tags;
if (typeof fm_tags === "string") {
fm_tags = fm_tags.replace(/[\[\]]/g, "").split(",").map((t) => t.trim()).filter(Boolean);
}
if (Array.isArray(fm_tags)) {
fm_tags.forEach((tag) => tag_set.add(tag.startsWith("#") ? tag : `#${tag}`));
}
get_markdown_tags2(body).forEach((tag) => tag_set.add(tag));
if (tag_set.size) frontmatter.tags = [...tag_set];
return frontmatter;
}
get can_import() {
if (!this.item.file) {
console.warn(`MarkdownSourceContentAdapter: Skipping missing-file: ${this.file_path}`);
return false;
}
if (this.item.size > (this.settings?.max_import_size || 3e5)) {
console.warn(`MarkdownSourceContentAdapter: Skipping large file: ${this.file_path}`);
return false;
}
return true;
}
/**
* @deprecated use outdated instead
*/
get should_import() {
return this.outdated;
}
get outdated() {
try {
if (!this.data.last_import) {
if (this.data.mtime && this.data.size && this.data.hash) {
this.data.last_import = {
mtime: this.data.mtime,
size: this.data.size,
at: Date.now(),
hash: this.data.hash
};
delete this.data.mtime;
delete this.data.size;
delete this.data.hash;
} else {
return true;
}
}
if (this.data.last_read.at > this.data.last_import.at) {
if (this.data.last_import?.hash !== this.data.last_read?.hash) return true;
}
if (this.data.last_import.mtime < this.item.mtime) {
if (!this.data.last_import.size) return true;
const size_diff = Math.abs(this.data.last_import.size - this.item.size);
const size_diff_ratio = size_diff / (this.data.last_import.size || 1);
if (size_diff_ratio > 0.01) return true;
}
return false;
} catch (e) {
console.warn(`MarkdownSourceContentAdapter: error getting should_import for ${this.file_path}: ${e}`);
return true;
}
}
};

var import_obsidian52 = require("obsidian");
function merge_tags2(fm_tags, cache_tags = []) {
const tag_set = /* @__PURE__ */ new Set();
if (typeof fm_tags === "string") {
fm_tags = fm_tags.replace(/[\[\]]/g, "").split(",").map((t) => t.trim()).filter(Boolean);
}
if (Array.isArray(fm_tags)) {
fm_tags.forEach((tag) => tag_set.add(tag.startsWith("#") ? tag : `#${tag}`));
}
cache_tags.forEach(({ tag }) => tag_set.add(tag));
return [...tag_set];
}
__name(merge_tags2, "merge_tags");
var ObsidianMarkdownSourceContentAdapter2 = class extends MarkdownSourceContentAdapter2 {
static {
__name(this, "ObsidianMarkdownSourceContentAdapter");
}
/**
* Returns metadata using Obsidian's metadataCache, merging frontmatter and tags.
* @async
* @returns {Promise<Object|undefined>}
*/
async get_metadata() {
const app = this.item.env.main.app;
const cache = app.metadataCache.getFileCache(this.item.file) || {};
const tags = merge_tags2(cache.frontmatter?.tags, cache.tags);
if (cache.frontmatter) {
if (tags.length) cache.frontmatter.tags = tags;
return cache.frontmatter;
}
return tags.length ? { tags } : void 0;
}
/**
* Reads the file content. If opts.render_output is true, attempts to use
* Obsidian's MarkdownRenderer to render the file to HTML, then convert it
* back to markdown via htmlToMarkdown.
* @async
* @param {Object} [opts={}] - Options for reading.
* @param {boolean} [opts.render_output=false] - If true, render MD -> HTML -> MD.
* @returns {Promise<string>} The file content (possibly rendered).
*/
async read(opts = {}) {
const content = await super.read(opts);
if (!opts.render_output) {
return content;
}
const app = this.item.env.main.app;
if (!app || !import_obsidian52.MarkdownRenderer || !import_obsidian52.htmlToMarkdown) {
console.warn("Obsidian environment not found; cannot render markdown.");
return content;
}
const container = document.createElement("div");
await import_obsidian52.MarkdownRenderer.render(app, content, container, this.item.path, new import_obsidian52.Component());
let last_html = container.innerHTML;
const max_wait = 1e4;
let wait_time = 0;
let conseq_same = 0;
let changed = true;
while (conseq_same < 7) {
await new Promise((resolve) => setTimeout(resolve, 100));
changed = last_html !== container.innerHTML;
last_html = container.innerHTML;
if (!changed) conseq_same++;
else conseq_same = 0;
wait_time += 100;
if (wait_time > max_wait) {
console.warn("ObsidianMarkdownSourceContentAdapter: Timeout waiting for markdown to render.");
break;
}
}
const newMd = (0, import_obsidian52.htmlToMarkdown)(container);
return newMd;
}
};

var BasesSourceContentAdapter2 = class extends FileSourceContentAdapter2 {
static {
__name(this, "BasesSourceContentAdapter");
}
static extensions = ["base"];
async import() {
}
};

var RenderedSourceContentAdapter2 = class extends FileSourceContentAdapter2 {
static {
__name(this, "RenderedSourceContentAdapter");
}
static extensions = ["rendered"];
async import() {
}
};

function parse_canvas_json2({ content } = {}) {
if (!content) return null;
try {
return JSON.parse(content);
} catch (error) {
console.warn("CanvasSourceContentAdapter: invalid JSON content.", error);
return null;
}
}
__name(parse_canvas_json2, "parse_canvas_json");
function build_link_record2({ target, title } = {}) {
if (!target) return null;
return {
title: title || target,
target,
line: 1
};
}
__name(build_link_record2, "build_link_record");
function get_canvas_node_links2({ node } = {}) {
if (!node || typeof node !== "object") return [];
if (node.type === "text" && typeof node.text === "string") {
return get_markdown_links2(node.text);
}
if (node.type === "file" && typeof node.file === "string") {
const subpath = typeof node.subpath === "string" ? node.subpath : "";
const target = `${node.file}${subpath}`;
const record = build_link_record2({ target, title: node.file });
return record ? [record] : [];
}
if (node.type === "link" && typeof node.url === "string") {
const record = build_link_record2({ target: node.url, title: node.url });
return record ? [record] : [];
}
return [];
}
__name(get_canvas_node_links2, "get_canvas_node_links");
function get_canvas_links_from_nodes2({ nodes = [] } = {}) {
if (!Array.isArray(nodes)) return [];
return nodes.reduce((links, node) => {
links.push(...get_canvas_node_links2({ node }));
return links;
}, []);
}
__name(get_canvas_links_from_nodes2, "get_canvas_links_from_nodes");
function get_canvas_links2({ content } = {}) {
const canvas_data = parse_canvas_json2({ content });
if (!canvas_data?.nodes) return [];
return get_canvas_links_from_nodes2({ nodes: canvas_data.nodes });
}
__name(get_canvas_links2, "get_canvas_links");
var CanvasSourceContentAdapter2 = class extends FileSourceContentAdapter2 {
static {
__name(this, "CanvasSourceContentAdapter");
}
static extensions = ["canvas"];
async import() {
if (!this.item.file) {
console.warn(`CanvasSourceContentAdapter: Skipping missing-file: ${this.file_path}`);
return;
}
const content = await this.read();
if (!content) return;
if (this.data.last_import?.hash === this.data.last_read?.hash && Array.isArray(this.data.outlinks)) {
return;
}
this.data.outlinks = get_canvas_links2({ content });
const file_stat = this.item.file?.stat;
const size = file_stat?.size ?? content.length;
const mtime = file_stat?.mtime ?? 0;
this.data.last_import = {
mtime,
size,
at: Date.now(),
hash: this.data.last_read?.hash
};
this.item.loaded_at = Date.now();
this.item.queue_save();
}
};

var ExcalidrawSourceContentAdapter2 = class extends ObsidianMarkdownSourceContentAdapter2 {
static {
__name(this, "ExcalidrawSourceContentAdapter");
}
static extensions = ["excalidraw.md"];
is_media = true;
async read(opts = {}) {
const full_content = await super.read(opts);
const BEGIN_LINE_MATCHER = "# Text Elements";
const END_LINE_MATCHER = "# Drawing";
const text_elements_start = full_content.indexOf(BEGIN_LINE_MATCHER);
const drawing_lines_start = full_content.indexOf(END_LINE_MATCHER);
if (text_elements_start === -1 || drawing_lines_start === -1) {
console.warn("Excalidraw file does not contain expected sections. File: " + this.item.key);
this.item.data.last_read.size = 0;
return "";
}
const text_content = full_content.slice(text_elements_start + BEGIN_LINE_MATCHER.length, drawing_lines_start).trim();
const stripped_refs = text_content.split("\n").map((line) => {
if (line.trim() === "%%") return "";
if (line.trim() === "#") return "";
return line.replace(/\^[a-z0-9]+$/i, "").trim();
}).filter(Boolean).join("\n");
this.item.data.last_read.size = stripped_refs.length;
return stripped_refs;
}
get size() {
if (this.item.data?.last_read?.size) {
return this.item.data.last_read.size;
}
return this.file?.stat?.size || 0;
}
};

function get_block_display_name4(key, show_full_path) {
const [source_key, ...path_parts] = key.split("#").filter(Boolean);
const source_name = get_item_display_name3(source_key, show_full_path);
if (show_full_path) return [source_name, ...path_parts].join(" > ");
const last_heading = path_parts.findLast((part) => part && part[0] !== "{");
return [source_name, last_heading].join(" > ");
}
__name(get_block_display_name4, "get_block_display_name");

var SmartBlock3 = class extends SmartEntity3 {
static {
__name(this, "SmartBlock");
}
/**
* Provides default values for a SmartBlock instance.
* @static
* @readonly
* @returns {Object} The default values.
*/
static get defaults() {
return {
data: {
text: null,
length: 0,
last_read: {
hash: null,
at: 0
}
},
_embed_input: ""
};
}
get block_adapter() {
if (!this._block_adapter) {
this._block_adapter = new this.collection.opts.block_adapters.md(this);
}
return this._block_adapter;
}
/**
* Initializes the SmartBlock instance by queuing an embed if embedding is enabled.
* @returns {void}
*/
init() {
if (this.settings.embed_blocks) super.init();
}
/**
* Queues the entity for embedding.
* @returns {void}
*/
queue_embed() {
this._queue_embed = this.should_embed;
this.source?.queue_embed();
}
/**
* Queues the block for import via the source.
* @returns {void}
*/
queue_import() {
this.source?.queue_import();
}
/**
* Prepares the embed input for the SmartBlock by reading content and generating a hash.
* @async
* @returns {Promise<string|false>} The embed input string or `false` if already embedded.
*/
async get_embed_input(content = null) {
if (typeof this._embed_input !== "string" || !this._embed_input.length) {
if (!content) content = await this.read();
this._embed_input = this.breadcrumbs + "\n" + content;
}
return this._embed_input;
}
/**
* @method read
* @description Reads the block content by delegating to the block adapter.
* @async
* @returns {Promise<string>} The block content.
*/
async read() {
try {
return await this.block_adapter.read();
} catch (e) {
if (e.message.includes("BLOCK NOT FOUND")) {
return 'BLOCK NOT FOUND (run "Prune" to remove)';
} else {
throw e;
}
}
}
/**
* @method append
* @description Appends content to this block by delegating to the block adapter.
* @async
* @param {string} content
* @returns {Promise<void>}
*/
async append(content) {
await this.block_adapter.append(content);
this.queue_save();
}
/**
* @method update
* @description Updates the block content by delegating to the block adapter.
* @async
* @param {string} new_block_content
* @param {Object} [opts={}]
* @returns {Promise<void>}
*/
async update(new_block_content, opts = {}) {
await this.block_adapter.update(new_block_content, opts);
this.queue_save();
}
/**
* @method remove
* @description Removes the block by delegating to the block adapter.
* @async
* @returns {Promise<void>}
*/
async remove() {
await this.block_adapter.remove();
this.queue_save();
}
/**
* @method move_to
* @description Moves the block to another location by delegating to the block adapter.
* @async
* @param {string} to_key
* @returns {Promise<void>}
*/
async move_to(to_key) {
await this.block_adapter.move_to(to_key);
this.queue_save();
}
get_display_name(params = {}) {
return this.block_adapter?.get_display_name(params);
}
/**
* Retrieves the breadcrumbs representing the block's path within the source.
* @readonly
* @returns {string} The breadcrumbs string.
*/
get breadcrumbs() {
return this.key.split("/").join(" > ").split("#").slice(0, -1).join(" > ").replace(".md", "");
}
/**
* Determines if the block is excluded from embedding based on headings.
* @readonly
* @returns {boolean} `true` if excluded, `false` otherwise.
*/
get excluded() {
const block_headings = this.path.split("#").slice(1);
if (this.source_collection.excluded_headings.some((heading) => block_headings.includes(heading))) return true;
return this.source?.excluded;
}
/**
* Retrieves the file path of the SmartSource associated with the block.
* @readonly
* @returns {string} The file path.
*/
get file_path() {
return this.source?.file_path;
}
/**
* Retrieves the file type of the SmartSource associated with the block.
* @readonly
* @returns {string} The file type.
*/
get file_type() {
return this.source.file_type;
}
/**
* Retrieves the folder path of the block.
* @readonly
* @returns {string} The folder path.
*/
get folder() {
return this.path.split("/").slice(0, -1).join("/");
}
/**
* Retrieves the embed link for the block.
* @readonly
* @returns {string} The embed link.
*/
get embed_link() {
return `![[${this.link}]]`;
}
/**
* Determines if the block has valid line range information.
* @readonly
* @returns {boolean} `true` if the block has both start and end lines, `false` otherwise.
*/
get has_lines() {
return this.lines && this.lines.length === 2;
}
/**
* Determines if the entity is a block based on its key.
* @readonly
* @returns {boolean} `true` if it's a block, `false` otherwise.
*/
get is_block() {
return this.key.includes("#");
}
/**
* Determines if the block is gone (i.e., the source file or block data no longer exists).
* @readonly
* @returns {boolean} `true` if gone, `false` otherwise.
*/
get is_gone() {
if (!this.source?.file) return true;
if (!this.source?.data?.blocks?.[this.sub_key]) return true;
return false;
}
get last_read() {
return this.data.last_read;
}
/**
* Retrieves the sub-key of the block.
* @readonly
* @returns {string} The sub-key.
*/
get sub_key() {
return "#" + this.key.split("#").slice(1).join("#");
}
/**
* Retrieves the lines range of the block.
* @readonly
* @returns {Array<number>|undefined} An array containing the start and end lines or `undefined` if not set.
*/
get lines() {
return this.data.lines;
}
/**
* Retrieves the starting line number of the block.
* @readonly
* @returns {number|undefined} The starting line number or `undefined` if not set.
*/
get line_start() {
return this.lines?.[0];
}
/**
* Retrieves the ending line number of the block.
* @readonly
* @returns {number|undefined} The ending line number or `undefined` if not set.
*/
get line_end() {
return this.lines?.[1];
}
/**
* Retrieves the link associated with the block, handling page numbers if present.
* @readonly
* @deprecated was specific to PDFs and removed this sort of PDF handling
* @returns {string} The block link.
*/
get link() {
if (/^.*page\s*(\d+).*$/i.test(this.sub_key)) {
const number = this.sub_key.match(/^.*page\s*(\d+).*$/i)[1];
return `${this.source.path}#page=${number}`;
} else {
return this.source?.path || "MISSING SOURCE";
}
}
get next_block() {
if (!this.data.lines) return null;
const next_line = this.data.lines[1] + 1;
return this.source.blocks?.find((block) => next_line === block.data?.lines?.[0]);
}
/**
* Retrieves the paths of outlinks from the block.
* @readonly
* @returns {Array<string>} An array of outlink paths.
*/
get outlinks() {
return this.source.outlinks;
}
/**
* Retrieves the path of the SmartBlock.
* @readonly
* @returns {string} The path of the SmartBlock.
*/
get path() {
return this.key;
}
/**
* Determines if the block should be embedded based on its coverage and size.
* @readonly
* @returns {boolean} `true` if it should be embedded, `false` otherwise.
*/
get should_embed() {
try {
if (this.settings?.min_chars && this.size < this.settings.min_chars) return false;
const match_line_start = this.line_start + 1;
const match_line_end = this.line_end;
const { has_line_start, has_line_end } = Object.entries(this.source?.data?.blocks || {}).reduce((acc, [key, range]) => {
if (!key.startsWith(this.sub_key + "#")) return acc;
if (range[0] === match_line_start) acc.has_line_start = key;
if (range[1] === match_line_end) acc.has_line_end = key;
return acc;
}, { has_line_start: null, has_line_end: null });
if (has_line_start && has_line_end) {
const start_block = this.collection.get(this.source_key + has_line_start);
if (start_block?.should_embed) {
const end_block = this.collection.get(this.source_key + has_line_end);
if (end_block?.should_embed) return false;
}
}
return true;
} catch (e) {
console.error(e, e.stack);
console.error(`Error getting should_embed for ${this.key}: ` + JSON.stringify(e || {}, null, 2));
}
}
/**
* Retrieves the size of the SmartBlock.
* @readonly
* @returns {number} The size of the SmartBlock.
*/
get size() {
return this.data.size;
}
/**
* Retrieves the SmartSource associated with the block.
* @readonly
* @returns {import("smart-sources").SmartSource} The associated SmartSource instance.
*/
get source() {
return this.source_collection.get(this.source_key);
}
/**
* Retrieves the SmartSources collection instance.
* @readonly
* @returns {import("smart-sources").SmartSources} The SmartSources collection.
*/
get source_collection() {
return this.env.smart_sources;
}
get source_key() {
return this.key.split("#")[0];
}
get sub_blocks() {
return this.source?.blocks?.filter((block) => block.key.startsWith(this.key + "#") && block.line_start > this.line_start && block.line_end <= this.line_end) || [];
}
get excluded_lines() {
return this.source.excluded_lines;
}
get file() {
return this.source.file;
}
get is_media() {
return this.source.is_media;
}
get mtime() {
return this.source.mtime;
}
/**
* Retrieves the display name of the block.
* @readonly
* @returns {string} The display name.
*/
get name() {
return get_block_display_name4(
this.key,
this.env.settings.smart_view_filter?.show_full_path
);
}
/**
* @deprecated Use `source` instead. Removing after 2025-09-01.
* @readonly
* @returns {SmartSource} The associated SmartSource instance.
*/
get note() {
return this.source;
}
/**
* @deprecated Use `source.key` instead. Removing after 2025-09-01.
* @readonly
* @returns {string} The source key.
*/
get note_key() {
return this.key.split("#")[0];
}
};
var smart_block_default2 = {
class: SmartBlock3,
actions: {
find_connections: find_connections4
}
};

var SmartBlocks3 = class extends SmartEntities3 {
static {
__name(this, "SmartBlocks");
}
/**
* Initializes the SmartBlocks instance. Currently muted as processing is handled by SmartSources.
* @returns {void}
*/
init() {
}
get fs() {
return this.env.smart_sources.fs;
}
/**
* Retrieves the embedding model associated with the SmartSources collection.
* @readonly
* @returns {Object|undefined} The embedding model instance or `undefined` if not set.
*/
get embed_model() {
return this.source_collection?.embed_model;
}
/**
* Retrieves the embedding model key from the SmartSources collection.
* @readonly
* @returns {string|undefined} The embedding model key or `undefined` if not set.
*/
get embed_model_key() {
return this.source_collection?.embed_model_key;
}
/**
* Calculates the expected number of blocks based on the SmartSources collection.
* @readonly
* @returns {number} The expected count of blocks.
*/
get expected_blocks_ct() {
return Object.values(this.source_collection.items).reduce((acc, item) => acc += Object.keys(item.data.blocks || {}).length, 0);
}
/**
* Retrieves the notices system from the environment.
* @readonly
* @returns {Object} The notices object.
*/
get notices() {
return this.env.smart_connections_plugin?.notices || this.env.main?.notices;
}
/**
* Retrieves the settings configuration for SmartBlocks.
* @readonly
* @returns {Object} The settings configuration object.
*/
get settings_config() {
return this.process_settings_config({
"embed_blocks": {
name: "Embed blocks",
type: "toggle",
description: "Blocks represent parts/sections of notes. Get more granular results.",
default: true
},
...super.settings_config
});
}
render_settings(container, opts = {}) {
return this.render_collection_settings(container, opts);
}
get data_dir() {
return "multi";
}
/**
* Retrieves the SmartSources collection instance.
* @readonly
* @returns {SmartSources} The SmartSources collection.
*/
get source_collection() {
return this.env.smart_sources;
}
/**
* Processes the embed queue. Currently handled by SmartSources, so this method is muted.
* @async
* @returns {Promise<void>}
*/
async process_embed_queue() {
}
/**
* Processes the load queue. Currently muted as processing is handled by SmartSources.
* @async
* @returns {Promise<void>}
*/
async process_load_queue() {
}
/**
* @async
* @abstract
* @throws {Error} Throws an error indicating the method is not implemented.
* @returns {Promise<void>}
*/
async prune() {
throw "Not implemented: prune";
}
/**
* @throws {Error} Throws an error indicating the method is not implemented.
* @abstract
* @returns {void}
*/
build_links_map() {
throw "Not implemented: build_links_map";
}
/**
* @async
* @abstract
* @throws {Error} Throws an error indicating the method is not implemented.
* @returns {Promise<void>}
*/
async refresh() {
throw "Not implemented: refresh";
}
/**
* @async
* @abstract
* @throws {Error} Throws an error indicating the method is not implemented.
* @returns {Promise<void>}
*/
async search() {
throw "Not implemented: search";
}
/**
* @async
* @abstract
* @throws {Error} Throws an error indicating the method is not implemented.
* @returns {Promise<void>}
*/
async run_refresh() {
throw "Not implemented: run_refresh";
}
/**
* @async
* @abstract
* @throws {Error} Throws an error indicating the method is not implemented.
* @returns {Promise<void>}
*/
async run_force_refresh() {
throw "Not implemented: run_force_refresh";
}
async cleanup_blocks() {
const expired_blocks = Object.values(this.items).filter((i) => i.is_gone);
console.log(`Removing ${expired_blocks.length} expired blocks`);
expired_blocks.forEach((i) => i.delete());
await this.process_save_queue();
expired_blocks.forEach((i) => {
delete this.items[i.key];
});
this.emit_event("blocks:cleaned", { expired_blocks_ct: expired_blocks.length });
}
};

var AjsonMultiFileBlocksDataAdapter2 = class extends AjsonMultiFileCollectionDataAdapter3 {
static {
__name(this, "AjsonMultiFileBlocksDataAdapter");
}
ItemDataAdapter = AjsonMultiFileBlockDataAdapter2;
/**
* Transforms the item key into a safe filename.
* Replaces spaces, slashes, and dots with underscores.
* @returns {string} safe file name
*/
get_data_file_name(key) {
return key.split("#")[0].replace(/[\s\/\.]/g, "_").replace(".md", "");
}
/**
* Process any queued save operations.
* @async
* @returns {Promise<void>}
*/
async process_save_queue() {
this.collection.emit_event("collection:save_started");
this.collection.show_process_notice("saving_collection");
const save_queue = Object.values(this.collection.items).filter((item) => item._queue_save);
console.log(`Saving ${this.collection.collection_key}: ${save_queue.length} items`);
const time_start = Date.now();
const save_files = Object.entries(save_queue.reduce((acc, item) => {
const file_name = this.get_item_data_path(item.key);
acc[file_name] = acc[file_name] || [];
acc[file_name].push(item);
return acc;
}, {}));
for (let i = 0; i < save_files.length; i++) {
const [file_name, items] = save_files[i];
await this.fs.append(
file_name,
items.map((item) => this.get_item_ajson(item)).join("\n") + "\n"
);
items.forEach((item) => item._queue_save = false);
}
console.log(`Saved ${this.collection.collection_key} in ${Date.now() - time_start}ms`);
this.collection.clear_process_notice("saving_collection");
this.collection.emit_event("collection:save_completed");
}
process_load_queue() {
console.log(`Skipping loading ${this.collection.collection_key}...`);
}
};
var AjsonMultiFileBlockDataAdapter2 = class extends AjsonMultiFileItemDataAdapter3 {
static {
__name(this, "AjsonMultiFileBlockDataAdapter");
}
};

var BlockContentAdapter2 = class {
static {
__name(this, "BlockContentAdapter");
}
/**
* @constructor
* @param {import('smart-blocks').SmartBlock} item - The SmartBlock instance this adapter operates on.
* The `item` should at least provide `data` and references to its parent source.
*/
constructor(item) {
this.item = item;
}
/**
* @async
* @method read
* @abstract
* @returns {Promise<string>} The content of the block.
* @throws {Error} If not implemented by subclass.
*/
async read() {
throw new Error("Not implemented");
}
/**
* @async
* @method append
* @abstract
* @param {string} content Content to append to the block.
* @returns {Promise<void>}
* @throws {Error} If not implemented by subclass.
*/
async append(content) {
throw new Error("Not implemented");
}
/**
* @async
* @method update
* @abstract
* @param {string} new_content The new content for the block.
* @param {Object} [opts={}] Additional update options.
* @returns {Promise<void>}
* @throws {Error} If not implemented by subclass.
*/
async update(new_content, opts = {}) {
throw new Error("Not implemented");
}
/**
* @async
* @method remove
* @abstract
* @returns {Promise<void>}
* @throws {Error} If not implemented by subclass.
*/
async remove() {
throw new Error("Not implemented");
}
/**
* @async
* @method move_to
* @abstract
* @param {string} to_key The destination key (source or block reference).
* @returns {Promise<void>}
* @throws {Error} If not implemented by subclass.
*/
async move_to(to_key) {
throw new Error("Not implemented");
}
/**
* @method get_display_name
* @abstract
* @param {Object} params Parameters for display name generation.
* @returns {string} The display name of the block.
* @throws {Error} If not implemented by subclass.
*/
get_display_name(params) {
throw new Error("Not implemented");
}
/**
* @name data
* @type {Object}
* @readonly
* @description Access the block’s data object. Useful for updating metadata like line references or hashes.
*/
get data() {
return this.item.data;
}
/**
* @async
* @method update_last_read
* @param {string} content The current content of the block.
* @returns {Promise<void>}
* @description Update the block’s `last_read` hash and timestamp based on the given content.
*/
async update_last_read(content) {
this.data.last_read = {
hash: this.create_hash(content),
at: Date.now()
};
}
/**
* @method create_hash
* @param {string} content The content to hash.
* @returns {Promise<string>} The computed hash of the content.
* @description Hash the block content to detect changes and prevent unnecessary re-embeddings.
*/
create_hash(content) {
return murmur_hash_32_alphanumeric3(content);
}
};

function get_line_range3(content, start_line, end_line) {
const lines = content.split("\n");
return lines.slice(start_line - 1, end_line).join("\n");
}
__name(get_line_range3, "get_line_range");

var MarkdownBlockContentAdapter2 = class extends BlockContentAdapter2 {
static {
__name(this, "MarkdownBlockContentAdapter");
}
/**
* Read the content of the block.
* @async
* @returns {Promise<string>} The block content as a string.
* @throws {Error} If the block cannot be found.
*/
async read() {
const source_content = await this.item.source?.read();
if (!source_content) {
console.warn(`BLOCK NOT FOUND: ${this.item.key} has no source content.`);
return "";
}
const content = this._extract_block(source_content);
this.update_last_read(content);
return content;
}
/**
* Append content to the existing block.
* This method inserts additional lines after the block's end, then re-parses the file to update line references.
* @async
* @param {string} content Content to append to the block.
* @returns {Promise<void>}
* @throws {Error} If the block cannot be found.
*/
async append(content) {
let full_content = await this.item.source.read();
const { line_start, line_end } = this.item;
if (!line_start || !line_end) {
throw new Error(`Cannot append to block ${this.item.key}: invalid line references.`);
}
const lines = full_content.split("\n");
lines.splice(line_end, 0, "", content);
const updated_content = lines.join("\n");
await this.item.source._update(updated_content);
await this._reparse_source();
}
/**
* Update the block with new content, replacing its current lines.
* @async
* @param {string} new_content New content for the block.
* @param {Object} [opts={}] Additional options.
* @returns {Promise<void>}
* @throws {Error} If the block cannot be found.
*/
async update(new_content, opts = {}) {
let full_content = await this.item.source.read();
const { line_start, line_end } = this.item;
if (!line_start || !line_end) {
throw new Error(`Cannot update block ${this.item.key}: invalid line references.`);
}
const lines = full_content.split("\n");
const updated_lines = [
...lines.slice(0, line_start - 1),
...new_content.split("\n"),
...lines.slice(line_end)
];
const updated_content = updated_lines.join("\n");
await this.item.source._update(updated_content);
await this._reparse_source();
}
/**
* Remove the block entirely from the source.
* @async
* @returns {Promise<void>}
* @throws {Error} If the block cannot be found.
*/
async remove() {
let full_content = await this.item.source.read();
const { line_start, line_end } = this.item;
if (!line_start || !line_end) {
throw new Error(`Cannot remove block ${this.item.key}: invalid line references.`);
}
const lines = full_content.split("\n");
const updated_lines = [
...lines.slice(0, line_start - 1),
...lines.slice(line_end)
];
const updated_content = updated_lines.join("\n");
await this.item.source._update(updated_content);
await this._reparse_source();
}
/**
* Move the block to a new location (another source or heading).
* This involves reading the block content, removing it from the current source, and appending it to the target.
* @async
* @param {string} to_key The destination path or entity reference.
* @returns {Promise<void>}
* @throws {Error} If the block or target is invalid.
*/
async move_to(to_key) {
const content = await this.read();
await this.remove();
const is_block_ref = to_key.includes("#");
let target_source_key = is_block_ref ? to_key.split("#")[0] : to_key;
const target_source = this.item.env.smart_sources.get(target_source_key);
if (!target_source) {
await this.item.env.smart_sources.create(target_source_key, content);
return;
}
if (is_block_ref) {
const target_block = this.item.env.smart_blocks.get(to_key);
if (target_block) {
await target_block.append(content);
} else {
await target_source.append(content);
}
} else {
await target_source.append(content);
}
}
/**
* Extract the block content using current line references from a full source content.
* @private
* @param {string} source_content Full source file content.
* @returns {string} Extracted block content.
* @throws {Error} If the block cannot be found.
*/
_extract_block(source_content) {
if (!source_content) {
console.warn(`BLOCK NOT FOUND: ${this.item.key} has no source content.`);
return "";
}
const { line_start, line_end } = this.item;
if (!line_start || !line_end) {
throw new Error(`BLOCK NOT FOUND: ${this.item.key} has invalid line references.`);
}
return get_line_range3(source_content, line_start, line_end);
}
/**
* Re-parse the source file after a CRUD operation to update line references for all blocks.
* @private
* @async
* @returns {Promise<void>}
*/
async _reparse_source() {
await this.item.source.import();
}
get_display_name(params = {}) {
if (!this.item?.key) return "";
const show_full_path = params.show_full_path ?? true;
if (show_full_path) {
return this.item.key.replace(/#/g, " > ").replace(/\//g, " > ");
}
const pcs = [];
const [source_key, ...block_parts] = this.item.key.split("#");
const filename = source_key.split("/").pop();
pcs.push(filename);
if (block_parts.length) {
const last = block_parts[block_parts.length - 1];
if (last.startsWith("{") && last.endsWith("}")) {
block_parts.pop();
pcs.push(block_parts.pop());
if (this.item.lines) pcs.push(`Lines: ${this.item.lines.join("-")}`);
} else {
pcs.push(block_parts.pop());
}
}
return pcs.filter(Boolean).join(" > ");
}
};

var SmartModel2 = class {
static {
__name(this, "SmartModel");
}
scope_name = "smart_model";
static defaults = {
};
/**
* Create a SmartModel instance.
* @param {Object} opts - Configuration options
* @param {Object} opts.adapters - Map of adapter names to adapter classes
* @param {Object} opts.settings - Model settings configuration
* @param {string} [opts.model_key] - Optional model identifier to override settings
* @throws {Error} If required options are missing
*/
constructor(opts = {}) {
this.opts = opts;
this.validate_opts(opts);
this.state = "unloaded";
this._adapter = null;
this.data = opts;
}
/**
* Initialize the model by loading the configured adapter.
* @async
* @returns {Promise<void>}
*/
async initialize() {
this.load_adapter(this.adapter_name);
await this.load();
}
/**
* Validate required options.
* @param {Object} opts - Configuration options
*/
validate_opts(opts) {
if (!opts.adapters) throw new Error("opts.adapters is required");
if (!opts.settings) throw new Error("opts.settings is required");
}
/**
* Get the current settings
* @returns {Object} Current settings
*/
get settings() {
if (!this.opts.settings) this.opts.settings = {
...this.constructor.defaults
};
return this.opts.settings;
}
/**
* Get the current adapter name
* @returns {string} Current adapter name
*/
get adapter_name() {
let adapter_key = this.opts.adapter || this.settings.adapter || Object.keys(this.adapters)[0];
if (!adapter_key || !this.adapters[adapter_key]) {
console.warn(`Platform "${adapter_key}" not supported`);
adapter_key = Object.keys(this.adapters)[0];
}
return adapter_key;
}
/**
* Get available models.
* @returns {Object} Map of model objects
*/
get models() {
return this.adapter.models;
}
/**
* Get default model key.
* @returns {string} Default model key
*/
get default_model_key() {
return this.adapter.constructor.defaults.default_model;
}
/**
* Get the current model key
* @returns {string} Current model key
*/
get model_key() {
return this.opts.model_key || this.settings.model_key || this.default_model_key;
}
/**
* Load the current adapter and transition to loaded state.
* @async
* @returns {Promise<void>}
*/
async load() {
this.set_state("loading");
try {
if (!this.adapter?.is_loaded) {
await this.invoke_adapter_method("load");
}
} catch (err) {
this.set_state("unloaded");
if (!this.reload_model_timeout) {
this.reload_model_timeout = setTimeout(async () => {
this.reload_model_timeout = null;
await this.load();
this.set_state("loaded");
this.env?.events?.emit("model:loaded", { model_key: this.model_key });
this.notices?.show("Loaded model: " + this.model_key);
}, 6e4);
}
throw new Error(`Failed to load model: ${err.message}`);
}
this.set_state("loaded");
}
/**
* Unload the current adapter and transition to unloaded state.
* @async
* @returns {Promise<void>}
*/
async unload() {
if (this.adapter?.is_loaded) {
this.set_state("unloading");
await this.invoke_adapter_method("unload");
this.set_state("unloaded");
}
}
/**
* Set the model's state.
* @param {('unloaded'|'loading'|'loaded'|'unloading')} new_state - The new state
* @throws {Error} If the state is invalid
*/
set_state(new_state) {
const valid_states = ["unloaded", "loading", "loaded", "unloading"];
if (!valid_states.includes(new_state)) {
throw new Error(`Invalid state: ${new_state}`);
}
this.state = new_state;
}
get is_loading() {
return this.state === "loading";
}
get is_loaded() {
return this.state === "loaded";
}
get is_unloading() {
return this.state === "unloading";
}
get is_unloaded() {
return this.state === "unloaded";
}
/**
* Get the map of available adapters
* @returns {Object} Map of adapter names to adapter classes
*/
get adapters() {
return this.opts.adapters || {};
}
/**
* Load a specific adapter by name.
* @async
* @param {string} adapter_name - Name of the adapter to load
* @throws {Error} If adapter not found or loading fails
* @returns {Promise<void>}
*/
async load_adapter(adapter_name) {
this.set_adapter(adapter_name);
if (!this._adapter.loaded) {
this.set_state("loading");
try {
await this.invoke_adapter_method("load");
this.set_state("loaded");
} catch (err) {
this.set_state("unloaded");
throw new Error(`Failed to load adapter: ${err.message}`);
}
}
}
/**
* Set an adapter instance by name without loading it.
* @param {string} adapter_name - Name of the adapter to set
* @throws {Error} If adapter not found
*/
set_adapter(adapter_name) {
const AdapterClass = this.adapters[adapter_name];
if (!AdapterClass) {
throw new Error(`Adapter "${adapter_name}" not found.`);
}
if (this._adapter?.constructor.name.toLowerCase() === adapter_name.toLowerCase()) {
return;
}
this._adapter = new AdapterClass(this);
}
/**
* Get the current active adapter instance
* @returns {Object} The active adapter instance
* @throws {Error} If adapter not found
*/
get adapter() {
const adapter_name = this.adapter_name;
if (!adapter_name) {
throw new Error(`Adapter not set for model.`);
}
if (!this._adapter) {
this.load_adapter(adapter_name);
}
return this._adapter;
}
/**
* Ensure the adapter is ready to execute a method.
* @param {string} method - Name of the method to check
* @throws {Error} If adapter not loaded or method not implemented
*/
ensure_adapter_ready(method) {
if (!this.adapter) {
throw new Error("No adapter loaded.");
}
if (typeof this.adapter[method] !== "function") {
throw new Error(`Adapter does not implement method: ${method}`);
}
}
/**
* Invoke a method on the current adapter.
* @async
* @param {string} method - Name of the method to call
* @param {...any} args - Arguments to pass to the method
* @returns {Promise<any>} Result from the adapter method
* @throws {Error} If adapter not ready or method fails
*/
async invoke_adapter_method(method, ...args) {
this.ensure_adapter_ready(method);
return await this.adapter[method](...args);
}
/**
* Get platforms as dropdown options.
* @returns {Array<Object>} Array of {value, name} option objects
*/
get_platforms_as_options() {
return Object.entries(this.adapters).map(([key, AdapterClass]) => ({ value: key, name: AdapterClass.defaults.description || key }));
}
/**
* Get the settings configuration schema
* @returns {Object} Settings configuration object
*/
get settings_config() {
return this.process_settings_config({
adapter: {
name: "Model Platform",
type: "dropdown",
description: "Select a model platform to use with Smart Model.",
options_callback: "get_platforms_as_options",
is_scope: true,
callback: "adapter_changed",
default: "default"
}
});
}
/**
* Process settings configuration with conditionals and prefixes.
* @param {Object} _settings_config - Raw settings configuration
* @param {string} [prefix] - Optional prefix for setting keys
* @returns {Object} Processed settings configuration
*/
process_settings_config(_settings_config, prefix = null) {
return Object.entries(_settings_config).reduce((acc, [key, val]) => {
const new_key = (prefix ? prefix + "." : "") + this.process_setting_key(key);
acc[new_key] = val;
return acc;
}, {});
}
/**
* Process an individual setting key.
* Example: replace placeholders with actual adapter names.
* @param {string} key - The setting key with placeholders.
* @returns {string} Processed setting key.
*/
process_setting_key(key) {
return key.replace(/\[ADAPTER\]/g, this.adapter_name);
}
re_render_settings() {
if (typeof this.opts.re_render_settings === "function") this.opts.re_render_settings();
else console.warn("re_render_settings is not a function (must be passed in model opts)");
}
/**
* Reload model.
*/
reload_model() {
if (typeof this.opts.reload_model === "function") this.opts.reload_model();
else console.warn("reload_model is not a function (must be passed in model opts)");
}
adapter_changed() {
this.reload_model();
this.re_render_settings();
}
model_changed() {
this.reload_model();
this.re_render_settings();
}
};

var SmartEmbedModel2 = class extends SmartModel2 {
static {
__name(this, "SmartEmbedModel");
}
scope_name = "smart_embed_model";
static defaults = {
adapter: "transformers"
};
/**
* Create a SmartEmbedModel instance
* @param {Object} opts - Configuration options
* @param {Object} [opts.adapters] - Map of available adapter implementations
* @param {number} [opts.batch_size] - Default batch size for processing
* @param {Object} [opts.settings] - User settings
* @param {string} [opts.settings.api_key] - API key for remote models
* @param {number} [opts.settings.min_chars] - Minimum text length to embed
*/
constructor(opts = {}) {
super(opts);
}
/**
* Count tokens in an input string
* @param {string} input - Text to tokenize
* @returns {Promise<Object>} Token count result
* @property {number} tokens - Number of tokens in input
*
* @example
* ```javascript
* const result = await model.count_tokens("Hello world");
* console.log(result.tokens); // 2
* ```
*/
async count_tokens(input) {
return await this.invoke_adapter_method("count_tokens", input);
}
/**
* Generate embeddings for a single input
* @param {string|Object} input - Text or object with embed_input property
* @returns {Promise<Object>} Embedding result
* @property {number[]} vec - Embedding vector
* @property {number} tokens - Token count
*
* @example
* ```javascript
* const result = await model.embed("Hello world");
* console.log(result.vec); // [0.1, 0.2, ...]
* ```
*/
async embed(input) {
if (typeof input === "string") input = { embed_input: input };
return (await this.embed_batch([input]))[0];
}
/**
* Generate embeddings for multiple inputs in batch
* @param {Array<string|Object>} inputs - Array of texts or objects with embed_input
* @returns {Promise<Array<Object>>} Array of embedding results
* @property {number[]} vec - Embedding vector for each input
* @property {number} tokens - Token count for each input
*
* @example
* ```javascript
* const results = await model.embed_batch([
*   { embed_input: "First text" },
*   { embed_input: "Second text" }
* ]);
* ```
*/
async embed_batch(inputs) {
return await this.invoke_adapter_method("embed_batch", inputs);
}
/**
* Get the current batch size based on GPU settings
* @returns {number} Current batch size for processing
*/
get batch_size() {
return this.adapter.batch_size || 1;
}
/**
* Get settings configuration schema
* @returns {Object} Settings configuration object
*/
get settings_config() {
const _settings_config = {
adapter: {
name: "Embedding model platform",
type: "dropdown",
description: "Select an embedding model platform. The default 'transformers' utilizes built-in local models.",
options_callback: "get_platforms_as_options",
callback: "adapter_changed",
default: this.constructor.defaults.adapter
},
...this.adapter.settings_config || {}
};
return this.process_settings_config(_settings_config);
}
process_setting_key(key) {
return key.replace(/\[ADAPTER\]/g, this.adapter_name);
}
/**
* Get available embedding model options
* @returns {Array<Object>} Array of model options with value and name
*/
get_embedding_model_options() {
return Object.entries(this.models).map(([key, model]) => ({ value: key, name: key }));
}
};

var SmartModelAdapter3 = class {
static {
__name(this, "SmartModelAdapter");
}
/**
* Create a SmartModelAdapter instance.
* @param {SmartModel} model - The parent SmartModel instance
*/
constructor(model) {
this.model = model;
this.state = "unloaded";
}
/**
* Load the adapter.
* @async
* @returns {Promise<void>}
*/
async load() {
this.set_state("loaded");
}
/**
* Unload the adapter.
* @returns {void}
*/
unload() {
this.set_state("unloaded");
}
/**
* Get all settings.
* @returns {Object} All settings
*/
get settings() {
return this.model.settings;
}
/**
* Get the current model key.
* @returns {string} Current model identifier
*/
get model_key() {
return this.model.model_key;
}
/**
* Get the models.
* @returns {Object} Map of model objects
*/
get models() {
const models = this.model.data.provider_models;
if (typeof models === "object" && Object.keys(models || {}).length > 0) return models;
else {
return {};
}
}
/**
* Get available models from the API.
* @abstract
* @param {boolean} [refresh=false] - Whether to refresh cached models
* @returns {Promise<Object>} Map of model objects
*/
async get_models(refresh = false) {
throw new Error("get_models not implemented");
}
/**
* Get available models as dropdown options synchronously.
* @returns {Array<Object>} Array of model options.
*/
get_models_as_options() {
const models = this.models;
if (!Object.keys(models || {}).length) {
this.get_models(true);
return [{ value: "", name: "No models currently available" }];
}
return Object.entries(models).map(([id, model]) => ({ value: id, name: model.name || id })).sort((a, b) => a.name.localeCompare(b.name));
}
/**
* Set the adapter's state.
* @deprecated should be handled in SmartModel (only handle once)
* @param {('unloaded'|'loading'|'loaded'|'unloading')} new_state - The new state
* @throws {Error} If the state is invalid
*/
set_state(new_state) {
const valid_states = ["unloaded", "loading", "loaded", "unloading"];
if (!valid_states.includes(new_state)) {
throw new Error(`Invalid state: ${new_state}`);
}
this.state = new_state;
}
get is_loading() {
return this.state === "loading";
}
get is_loaded() {
return this.state === "loaded";
}
get is_unloading() {
return this.state === "unloading";
}
get is_unloaded() {
return this.state === "unloaded";
}
};

var SmartEmbedAdapter2 = class extends SmartModelAdapter3 {
static {
__name(this, "SmartEmbedAdapter");
}
/**
* @override in sub-class with adapter-specific default configurations
* @property {string} id - The adapter identifier
* @property {string} description - Human-readable description
* @property {string} type - Adapter type ("API")
* @property {string} endpoint - API endpoint
* @property {string} adapter - Adapter identifier
* @property {string} default_model - Default model to use
*/
static defaults = {};
/**
* Count tokens in input text
* @abstract
* @param {string} input - Text to tokenize
* @returns {Promise<Object>} Token count result
* @property {number} tokens - Number of tokens in input
* @throws {Error} If not implemented by subclass
*/
async count_tokens(input) {
throw new Error("count_tokens method not implemented");
}
/**
* Generate embeddings for single input
* @abstract
* @param {string|Object} input - Text to embed
* @returns {Promise<Object>} Embedding result
* @property {number[]} vec - Embedding vector
* @property {number} tokens - Number of tokens in input
* @throws {Error} If not implemented by subclass
*/
async embed(input) {
if (typeof input === "string") input = { embed_input: input };
return (await this.embed_batch([input]))[0];
}
/**
* Generate embeddings for multiple inputs
* @abstract
* @param {Array<string|Object>} inputs - Texts to embed
* @returns {Promise<Array<Object>>} Array of embedding results
* @property {number[]} vec - Embedding vector for each input
* @property {number} tokens - Number of tokens in each input
* @throws {Error} If not implemented by subclass
*/
async embed_batch(inputs) {
throw new Error("embed_batch method not implemented");
}
get settings_config() {
return {
"[ADAPTER].model_key": {
name: "Embedding model",
type: "dropdown",
description: "Select an embedding model.",
options_callback: "adapter.get_models_as_options",
callback: "model_changed",
default: this.constructor.defaults.default_model
}
};
}
get dims() {
return this.model.data.dims;
}
get max_tokens() {
return this.model.data.max_tokens;
}
get batch_size() {
return this.model.data.batch_size || 1;
}
};

var SmartHttpRequest3 = class {
static {
__name(this, "SmartHttpRequest");
}
/**
* @param {object} opts - Options for the SmartHttpRequest class
* @param {SmartHttpRequestAdapter} opts.adapter - The adapter constructor to use for making HTTP requests
* @param {Obsidian.requestUrl} opts.obsidian_request_adapter - For use with Obsidian adapter
*/
constructor(opts = {}) {
this.opts = opts;
if (!opts.adapter) throw new Error("HttpRequestAdapter is required");
this.adapter = new opts.adapter(this);
}
/**
* Returns a well-formed response object
* @param {object} request_params - Parameters for the HTTP request
* @param {string} request_params.url - The URL to make the request to
* @param {string} [request_params.method='GET'] - The HTTP method to use
* @param {object} [request_params.headers] - Headers to include in the request
* @param {*} [request_params.body] - The body of the request (for POST, PUT, etc.)
* @returns {SmartHttpResponseAdapter} instance of the SmartHttpResponseAdapter class
* @example
* const response = await smart_http_request.request({
*   url: 'https://api.example.com/data',
*   method: 'GET',
*   headers: { 'Content-Type': 'application/json' }
* });
* console.log(await response.json());
*/
async request(request_params, throw_on_error = false) {
return await this.adapter.request(request_params, throw_on_error);
}
};

var SmartHttpRequestAdapter3 = class {
static {
__name(this, "SmartHttpRequestAdapter");
}
constructor(main) {
this.main = main;
}
/**
* Execute an HTTP request using adapter-specific transport.
* @abstract
* @param {Object} request_params - Parameters for the outbound request.
* @returns {Promise<SmartHttpResponseAdapter>} Adapter-specific response wrapper.
*/
async request(request_params) {
throw new Error("request not implemented");
}
};
var SmartHttpResponseAdapter3 = class {
static {
__name(this, "SmartHttpResponseAdapter");
}
constructor(response) {
this.response = response;
}
/**
* Retrieve response headers.
* @abstract
* @returns {Promise<Object>} Headers object for the response.
*/
async headers() {
throw new Error("headers not implemented");
}
/**
* Parse the response body as JSON.
* @abstract
* @returns {Promise<*>} Parsed JSON payload.
*/
async json() {
throw new Error("json not implemented");
}
/**
* Get the HTTP status code.
* @abstract
* @returns {Promise<number>} Response status code.
*/
async status() {
throw new Error("status not implemented");
}
/**
* Read the raw text body.
* @abstract
* @returns {Promise<string>} Response body as text.
*/
async text() {
throw new Error("text not implemented");
}
};

var SmartHttpObsidianRequestAdapter3 = class extends SmartHttpRequestAdapter3 {
static {
__name(this, "SmartHttpObsidianRequestAdapter");
}
async request(request_params, throw_on_error = false) {
let response;
try {
if (!this.main.opts.obsidian_request_url) {
throw new Error("obsidian_request_url is required in SmartHttp constructor opts");
}
response = await this.main.opts.obsidian_request_url({ ...request_params, throw: throw_on_error });
if (throw_on_error && response.status === 400) throw new Error("Obsidian request failed");
return new SmartHttpObsidianResponseAdapter2(response);
} catch (error) {
console.error("Error in SmartHttpObsidianRequestAdapter.request():");
console.error(JSON.stringify(request_params, null, 2));
console.error(response);
console.error(error);
return null;
}
}
};
var SmartHttpObsidianResponseAdapter2 = class extends SmartHttpResponseAdapter3 {
static {
__name(this, "SmartHttpObsidianResponseAdapter");
}
async status() {
return this.response.status;
}
async json() {
return await this.response.json;
}
async text() {
return await this.response.text;
}
async headers() {
return this.response.headers;
}
};

var SmartHttpRequestFetchAdapter3 = class extends SmartHttpRequestAdapter3 {
static {
__name(this, "SmartHttpRequestFetchAdapter");
}
async request(request_params) {
const { url, ...opts } = request_params;
const resp = await fetch(url, opts);
return new SmartHttpResponseFetchAdapter3(resp);
}
};
var SmartHttpResponseFetchAdapter3 = class extends SmartHttpResponseAdapter3 {
static {
__name(this, "SmartHttpResponseFetchAdapter");
}
async headers() {
return this.response.headers;
}
async json() {
if (!this._json) {
this._json = await this.response.json();
}
return this._json;
}
async status() {
return this.response.status;
}
async text() {
if (!this._text) {
this._text = await this.response.text();
}
return this._text;
}
};

var import_base64_js2 = __toESM(require_base64_js2(), 1);
var __defProp3 = Object.defineProperty;
var __defNormalProp2 = /* @__PURE__ */ __name((obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value, "__defNormalProp");
var __publicField2 = /* @__PURE__ */ __name((obj, key, value) => {
__defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
return value;
}, "__publicField");
function bytePairMerge2(piece, ranks) {
let parts = Array.from(
{ length: piece.length },
(_, i) => ({ start: i, end: i + 1 })
);
while (parts.length > 1) {
let minRank = null;
for (let i = 0; i < parts.length - 1; i++) {
const slice = piece.slice(parts[i].start, parts[i + 1].end);
const rank = ranks.get(slice.join(","));
if (rank == null)
continue;
if (minRank == null || rank < minRank[0]) {
minRank = [rank, i];
}
}
if (minRank != null) {
const i = minRank[1];
parts[i] = { start: parts[i].start, end: parts[i + 1].end };
parts.splice(i + 1, 1);
} else {
break;
}
}
return parts;
}
__name(bytePairMerge2, "bytePairMerge");
function bytePairEncode2(piece, ranks) {
if (piece.length === 1)
return [ranks.get(piece.join(","))];
return bytePairMerge2(piece, ranks).map((p) => ranks.get(piece.slice(p.start, p.end).join(","))).filter((x) => x != null);
}
__name(bytePairEncode2, "bytePairEncode");
function escapeRegex2(str) {
return str.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
}
__name(escapeRegex2, "escapeRegex");
var _Tiktoken2 = class {
static {
__name(this, "_Tiktoken");
}
/** @internal */
specialTokens;
/** @internal */
inverseSpecialTokens;
/** @internal */
patStr;
/** @internal */
textEncoder = new TextEncoder();
/** @internal */
textDecoder = new TextDecoder("utf-8");
/** @internal */
rankMap = /* @__PURE__ */ new Map();
/** @internal */
textMap = /* @__PURE__ */ new Map();
constructor(ranks, extendedSpecialTokens) {
this.patStr = ranks.pat_str;
const uncompressed = ranks.bpe_ranks.split("\n").filter(Boolean).reduce((memo, x) => {
const [_, offsetStr, ...tokens] = x.split(" ");
const offset = Number.parseInt(offsetStr, 10);
tokens.forEach((token, i) => memo[token] = offset + i);
return memo;
}, {});
for (const [token, rank] of Object.entries(uncompressed)) {
const bytes = import_base64_js2.default.toByteArray(token);
this.rankMap.set(bytes.join(","), rank);
this.textMap.set(rank, bytes);
}
this.specialTokens = { ...ranks.special_tokens, ...extendedSpecialTokens };
this.inverseSpecialTokens = Object.entries(this.specialTokens).reduce((memo, [text, rank]) => {
memo[rank] = this.textEncoder.encode(text);
return memo;
}, {});
}
encode(text, allowedSpecial = [], disallowedSpecial = "all") {
const regexes = new RegExp(this.patStr, "ug");
const specialRegex = _Tiktoken2.specialTokenRegex(
Object.keys(this.specialTokens)
);
const ret = [];
const allowedSpecialSet = new Set(
allowedSpecial === "all" ? Object.keys(this.specialTokens) : allowedSpecial
);
const disallowedSpecialSet = new Set(
disallowedSpecial === "all" ? Object.keys(this.specialTokens).filter(
(x) => !allowedSpecialSet.has(x)
) : disallowedSpecial
);
if (disallowedSpecialSet.size > 0) {
const disallowedSpecialRegex = _Tiktoken2.specialTokenRegex([
...disallowedSpecialSet
]);
const specialMatch = text.match(disallowedSpecialRegex);
if (specialMatch != null) {
throw new Error(
`The text contains a special token that is not allowed: ${specialMatch[0]}`
);
}
}
let start = 0;
while (true) {
let nextSpecial = null;
let startFind = start;
while (true) {
specialRegex.lastIndex = startFind;
nextSpecial = specialRegex.exec(text);
if (nextSpecial == null || allowedSpecialSet.has(nextSpecial[0]))
break;
startFind = nextSpecial.index + 1;
}
const end = nextSpecial?.index ?? text.length;
for (const match of text.substring(start, end).matchAll(regexes)) {
const piece = this.textEncoder.encode(match[0]);
const token2 = this.rankMap.get(piece.join(","));
if (token2 != null) {
ret.push(token2);
continue;
}
ret.push(...bytePairEncode2(piece, this.rankMap));
}
if (nextSpecial == null)
break;
let token = this.specialTokens[nextSpecial[0]];
ret.push(token);
start = nextSpecial.index + nextSpecial[0].length;
}
return ret;
}
decode(tokens) {
const res = [];
let length = 0;
for (let i2 = 0; i2 < tokens.length; ++i2) {
const token = tokens[i2];
const bytes = this.textMap.get(token) ?? this.inverseSpecialTokens[token];
if (bytes != null) {
res.push(bytes);
length += bytes.length;
}
}
const mergedArray = new Uint8Array(length);
let i = 0;
for (const bytes of res) {
mergedArray.set(bytes, i);
i += bytes.length;
}
return this.textDecoder.decode(mergedArray);
}
};
var Tiktoken2 = _Tiktoken2;
__publicField2(Tiktoken2, "specialTokenRegex", (tokens) => {
return new RegExp(tokens.map((i) => escapeRegex2(i)).join("|"), "g");
});

async function fetch_json_cached2(url, cache_key = url) {
const is_browser = typeof window !== "undefined" && typeof window.document !== "undefined";
if (is_browser) {
const cached_text = window.localStorage.getItem(cache_key);
if (cached_text) return JSON.parse(cached_text);
const remote2 = await do_fetch2(url);
window.localStorage.setItem(cache_key, JSON.stringify(remote2));
return remote2;
}
const fs = await import("node:fs/promises");
const path = await import("node:path");
const os = await import("node:os");
const cache_dir = path.join(os.homedir(), ".cache", "smart-embed-model");
const cache_file = path.join(cache_dir, cache_key);
try {
const txt = await fs.readFile(cache_file, "utf8");
return JSON.parse(txt);
} catch {
}
const remote = await do_fetch2(url);
await fs.mkdir(cache_dir, { recursive: true });
await fs.writeFile(cache_file, JSON.stringify(remote), "utf8");
return remote;
}
__name(fetch_json_cached2, "fetch_json_cached");
async function do_fetch2(url) {
const resp = await fetch(url);
if (!resp.ok) throw new Error(`failed to download ${url} \u2013 ${resp.status}`);
return await resp.json();
}
__name(do_fetch2, "do_fetch");

function is_json_compatible3(value) {
if (value === null) {
return true;
}
const type = typeof value;
if (type === "string" || type === "number" || type === "boolean") {
return true;
}
if (Array.isArray(value)) {
return value.every(is_json_compatible3);
}
if (type === "object") {
const obj = (
/** @type {Record<string, unknown>} */
value
);
return Object.values(obj).every(is_json_compatible3);
}
return false;
}
__name(is_json_compatible3, "is_json_compatible");
function extract_json_details3(source, exclude_keys) {
const details = {};
for (const [key, value] of Object.entries(source)) {
if (exclude_keys.includes(key)) {
continue;
}
if (!is_json_compatible3(value)) {
continue;
}
details[key] = value;
}
return details;
}
__name(extract_json_details3, "extract_json_details");
function is_empty_object3(obj) {
return Object.keys(obj).length === 0;
}
__name(is_empty_object3, "is_empty_object");
function merge_details3(first, second) {
if (is_empty_object3(first)) {
return second;
}
if (is_empty_object3(second)) {
return first;
}
return { ...first, ...second };
}
__name(merge_details3, "merge_details");
function get_message_from_object3(value) {
const raw = value.message;
if (typeof raw === "string") {
const trimmed = raw.trim();
if (trimmed.length > 0) {
return trimmed;
}
}
return null;
}
__name(get_message_from_object3, "get_message_from_object");
function normalize_error3(error, http_status = null) {
if (Array.isArray(error) && error.length > 0) {
return normalize_error3(error[0], http_status);
}
if (error == null) {
return { message: "Unknown error", details: null, http_status };
}
if (typeof error === "string") {
return { message: error, details: null, http_status };
}
if (error instanceof Error) {
const message = (error.message || "").trim() || "Unknown error";
const extra_details = extract_json_details3(
/** @type {Record<string, unknown>} */
error,
["message"]
);
return {
message,
details: is_empty_object3(extra_details) ? null : extra_details,
http_status
};
}
if (typeof error === "object") {
const obj = (
/** @type {Record<string, unknown>} */
error
);
if ("error" in obj && obj.error != null) {
const nested_error = obj.error;
if (typeof nested_error === "object") {
const nested_obj = (
/** @type {Record<string, unknown>} */
nested_error
);
const nested_message = get_message_from_object3(nested_obj);
const nested_details = extract_json_details3(nested_obj, ["message"]);
const outer_details = extract_json_details3(obj, ["message", "error"]);
const combined_details = merge_details3(outer_details, nested_details);
const message = nested_message || get_message_from_object3(obj) || "Unknown error";
return {
message,
details: is_empty_object3(combined_details) ? null : combined_details,
http_status
};
}
return normalize_error3(nested_error);
}
const object_message = get_message_from_object3(obj);
if (object_message) {
const details = extract_json_details3(obj, ["message"]);
return {
message: object_message,
details: is_empty_object3(details) ? null : details,
http_status
};
}
}
return { message: "Unknown error", details: null, http_status };
}
__name(normalize_error3, "normalize_error");

var CL100K_URL2 = "https://raw.githubusercontent.com/brianpetro/jsbrains/refs/heads/main/smart-embed-model/cl100k_base.json";
var SmartEmbedModelApiAdapter2 = class extends SmartEmbedAdapter2 {
static {
__name(this, "SmartEmbedModelApiAdapter");
}
/**
* Get the request adapter class.
* @returns {SmartEmbedModelRequestAdapter} The request adapter class
*/
get req_adapter() {
return SmartEmbedModelRequestAdapter2;
}
/**
* Get the response adapter class.
* @returns {SmartEmbedModelResponseAdapter} The response adapter class
*/
get res_adapter() {
return SmartEmbedModelResponseAdapter2;
}
/** @returns {string} API endpoint URL */
get endpoint() {
return this.model.data.endpoint;
}
/**
* Get HTTP request adapter instance
* @returns {SmartHttpRequest} HTTP request handler
*/
get http_adapter() {
if (!this._http_adapter) {
if (this.model.opts.http_adapter)
this._http_adapter = this.model.opts.http_adapter;
else
this._http_adapter = new SmartHttpRequest3({
adapter: SmartHttpRequestFetchAdapter3
});
}
return this._http_adapter;
}
/**
* Get API key for authentication
* @returns {string} API key
*/
get api_key() {
return this.model.data.api_key;
}
/**
* Count tokens in input text
* @abstract
* @param {string} input - Text to tokenize
* @returns {Promise<Object>} Token count result
* @throws {Error} If not implemented by subclass
*/
async count_tokens(input) {
throw new Error("count_tokens not implemented");
}
/**
* Estimate token count for input text
* Uses character-based estimation (3.7 chars per token)
* @param {string|Object} input - Input to estimate tokens for
* @returns {number} Estimated token count
*/
estimate_tokens(input) {
if (typeof input === "object") input = JSON.stringify(input);
return Math.ceil(input.length / 3.7);
}
/**
* Process a batch of inputs for embedding
* @param {Array<Object>} inputs - Array of input objects
* @returns {Promise<Array<Object>>} Processed inputs with embeddings
* @throws {Error} If API key is not set
*/
async embed_batch(inputs) {
if (!this.api_key) throw new Error("API key not set");
inputs = inputs.filter((item) => item.embed_input?.length > 0);
if (inputs.length === 0) {
console.log("Empty batch (or all items have empty embed_input)");
return [];
}
const embed_inputs = await Promise.all(
inputs.map((item) => this.prepare_embed_input(item.embed_input))
);
const _req = new this.req_adapter(this, embed_inputs);
const request_params = _req.to_platform();
const resp = await this.request(request_params);
if (!resp) {
console.error("No response received for embedding request.");
return [];
}
if (resp.error) return [resp];
const _res = new this.res_adapter(this, resp);
const embeddings = _res.to_openai();
if (!embeddings) {
console.error("Failed to parse embeddings.");
return [];
}
return inputs.map((item, i) => {
item.vec = embeddings[i].vec;
item.tokens = embeddings[i].tokens;
return item;
});
}
/**
* Prepare input text for embedding
* @abstract
* @param {string} embed_input - Raw input text
* @returns {Promise<string>} Processed input text
* @throws {Error} If not implemented by subclass
*/
async prepare_embed_input(embed_input) {
throw new Error("prepare_embed_input not implemented");
}
/**
* Prepare request headers
* @returns {Object} Headers object with authorization
*/
prepare_request_headers() {
let headers = {
"Content-Type": "application/json"
};
if (this.api_key) {
headers["Authorization"] = `Bearer ${this.api_key}`;
}
return headers;
}
/**
* Make API request with retry logic
* @param {Object} req - Request configuration
* @param {number} [retries=0] - Number of retries attempted
* @returns {Promise<Object>} API response
*/
async request(req, retries = 0) {
try {
req.throw = false;
const resp = await this.http_adapter.request({
url: this.endpoint,
...req
});
const resp_json = await this.get_resp_json(resp);
if (resp_json.error) {
return { error: normalize_error3(resp_json, resp.status()) };
}
return resp_json;
} catch (error) {
console.warn("Request error:", error);
return await this.handle_request_err(error, req, retries);
}
}
/**
* Handle API request errors with retry logic
* @param {Error|Object} error - Error object
* @param {Object} req - Original request
* @param {number} retries - Number of retries attempted
* @returns {Promise<Object|null>} Retry response or null
*/
async handle_request_err(error, req, retries) {
if (error.status === 429 && retries < 3) {
const backoff = Math.pow(retries + 1, 2);
console.log(`Retrying request (429) in ${backoff} seconds...`);
await new Promise((r) => setTimeout(r, 1e3 * backoff));
return await this.request(req, retries + 1);
}
console.error(error);
return null;
}
/**
* Parse response body as JSON
* @param {Response} resp - Response object
* @returns {Promise<Object>} Parsed JSON
*/
async get_resp_json(resp) {
return typeof resp.json === "function" ? await resp.json() : await resp.json;
}
/**
* Validate API key by making test request
* @returns {Promise<boolean>} True if API key is valid
*/
async validate_api_key() {
const resp = await this.embed_batch([{ embed_input: "test" }]);
return Array.isArray(resp) && resp.length > 0 && resp[0].vec !== null;
}
/**
* Trim input text to satisfy `max_tokens`.
* @param {string} embed_input - Input text
* @param {number} tokens_ct - Existing token count
* @returns {Promise<string|null>} Trimmed text
*/
async trim_input_to_max_tokens(embed_input, tokens_ct) {
const reduce_ratio = (tokens_ct - this.max_tokens) / tokens_ct;
const new_length = Math.floor(embed_input.length * (1 - reduce_ratio));
let trimmed_input = embed_input.slice(0, new_length);
const last_space_index = trimmed_input.lastIndexOf(" ");
if (last_space_index > 0) trimmed_input = trimmed_input.slice(0, last_space_index);
const prepared = await this.prepare_embed_input(trimmed_input);
if (prepared === null) return null;
return prepared;
}
async load_tiktoken() {
const cl100k_base = await fetch_json_cached2(CL100K_URL2, "cl100k_base.json");
this.tiktoken = new Tiktoken2(cl100k_base);
}
};
var SmartEmbedModelRequestAdapter2 = class {
static {
__name(this, "SmartEmbedModelRequestAdapter");
}
/**
* @constructor
* @param {SmartEmbedModelApiAdapter} adapter - The SmartEmbedModelApiAdapter instance
* @param {Array<string>} embed_inputs - The array of input texts
*/
constructor(adapter, embed_inputs) {
this.adapter = adapter;
this.embed_inputs = embed_inputs;
}
get model_id() {
return this.adapter.model.data.model_key;
}
get model_dims() {
return this.adapter.model.data.dims;
}
/**
* Get request headers
* @returns {Object} Headers object
*/
get_headers() {
return this.adapter.prepare_request_headers();
}
/**
* Convert request to platform-specific format
* @returns {Object} Platform-specific request parameters
*/
to_platform() {
return {
method: "POST",
headers: this.get_headers(),
body: JSON.stringify(this.prepare_request_body())
};
}
/**
* Prepare request body for API call
* @abstract
* @returns {Object} Request body object
* @throws {Error} If not implemented by subclass
*/
prepare_request_body() {
throw new Error("prepare_request_body not implemented");
}
};
var SmartEmbedModelResponseAdapter2 = class {
static {
__name(this, "SmartEmbedModelResponseAdapter");
}
/**
* @constructor
* @param {SmartEmbedModelApiAdapter} adapter - The SmartEmbedModelApiAdapter instance
* @param {Object} response - The response object
*/
constructor(adapter, response) {
this.adapter = adapter;
this.response = response;
}
/**
* Convert response to standard format
* @returns {Array<Object>} Array of embedding results
*/
to_openai() {
return this.parse_response();
}
/**
* Parse API response
* @abstract
* @returns {Array<Object>} Parsed embedding results
* @throws {Error} If not implemented by subclass
*/
parse_response() {
throw new Error("parse_response not implemented");
}
};

var SmartEmbedOpenAIAdapter2 = class extends SmartEmbedModelApiAdapter2 {
static {
__name(this, "SmartEmbedOpenAIAdapter");
}
static defaults = {
adapter: "openai",
description: "OpenAI (API)",
default_model: "text-embedding-3-small",
endpoint: "https://api.openai.com/v1/embeddings"
};
/**
* Count tokens in input text using OpenAI's tokenizer
* @param {string} input - Text to tokenize
* @returns {Promise<Object>} Token count result
*/
async count_tokens(input) {
if (!this.tiktoken) await this.load_tiktoken();
return { tokens: this.tiktoken.encode(input).length };
}
/**
* Prepare input text for embedding
* Handles token limit truncation
* @param {string} embed_input - Raw input text
* @returns {Promise<string|null>} Processed input text
*/
async prepare_embed_input(embed_input) {
if (typeof embed_input !== "string") {
throw new TypeError("embed_input must be a string");
}
if (embed_input.length === 0) {
console.log("Warning: prepare_embed_input received an empty string");
return null;
}
const { tokens } = await this.count_tokens(embed_input);
if (tokens <= this.max_tokens) {
return embed_input;
}
return await this.trim_input_to_max_tokens(embed_input, tokens);
}
/**
* Trim input text to fit token limit
* @private
* @param {string} embed_input - Input text to trim
* @param {number} tokens_ct - Current token count
* @returns {Promise<string|null>} Trimmed input text
*/
async trim_input_to_max_tokens(embed_input, tokens_ct) {
const reduce_ratio = (tokens_ct - this.max_tokens) / tokens_ct;
const new_length = Math.floor(embed_input.length * (1 - reduce_ratio));
let trimmed_input = embed_input.slice(0, new_length);
const last_space_index = trimmed_input.lastIndexOf(" ");
if (last_space_index > 0) {
trimmed_input = trimmed_input.slice(0, last_space_index);
}
const prepared_input = await this.prepare_embed_input(trimmed_input);
if (prepared_input === null) {
console.log(
"Warning: prepare_embed_input resulted in an empty string after trimming"
);
return null;
}
return prepared_input;
}
/**
* Get the request adapter class.
* @returns {SmartEmbedOpenAIRequestAdapter} The request adapter class
*/
get req_adapter() {
return SmartEmbedOpenAIRequestAdapter2;
}
/**
* Get the response adapter class.
* @returns {SmartEmbedOpenAIResponseAdapter} The response adapter class
*/
get res_adapter() {
return SmartEmbedOpenAIResponseAdapter2;
}
/** @returns {number} Maximum tokens per input */
get max_tokens() {
return this.model.data.max_tokens || 8191;
}
/** @returns {Object} Settings configuration for OpenAI adapter */
get settings_config() {
return {
...super.settings_config,
"[ADAPTER].api_key": {
name: "OpenAI API key for embeddings",
type: "password",
description: "Required for OpenAI embedding models.",
placeholder: "Enter OpenAI API key"
}
};
}
/**
* Get available models (hardcoded list)
* @returns {Promise<Object>} Map of model objects
*/
get_models() {
return Promise.resolve(this.models);
}
get models() {
return {
"text-embedding-3-small": {
"id": "text-embedding-3-small",
"batch_size": 50,
"dims": 1536,
"max_tokens": 8191,
"name": "OpenAI Text-3 Small",
"description": "API, 8,191 tokens, 1,536 dim",
"endpoint": "https://api.openai.com/v1/embeddings",
"adapter": "openai"
},
"text-embedding-3-large": {
"id": "text-embedding-3-large",
"batch_size": 50,
"dims": 3072,
"max_tokens": 8191,
"name": "OpenAI Text-3 Large",
"description": "API, 8,191 tokens, 3,072 dim",
"endpoint": "https://api.openai.com/v1/embeddings",
"adapter": "openai"
},
"text-embedding-ada-002": {
"id": "text-embedding-ada-002",
"batch_size": 50,
"dims": 1536,
"max_tokens": 8191,
"name": "OpenAI Ada",
"description": "API, 8,191 tokens, 1,536 dim",
"endpoint": "https://api.openai.com/v1/embeddings",
"adapter": "openai"
}
};
}
};
var SmartEmbedOpenAIRequestAdapter2 = class extends SmartEmbedModelRequestAdapter2 {
static {
__name(this, "SmartEmbedOpenAIRequestAdapter");
}
/**
* Prepare request body for OpenAI API
* @returns {Object} Request body for API
*/
prepare_request_body() {
const body = {
model: this.model_id,
input: this.embed_inputs
};
if (this.model_id.startsWith("text-embedding-3")) {
body.dimensions = this.model_dims;
}
return body;
}
};
var SmartEmbedOpenAIResponseAdapter2 = class extends SmartEmbedModelResponseAdapter2 {
static {
__name(this, "SmartEmbedOpenAIResponseAdapter");
}
/**
* Parse OpenAI API response
* @returns {Array<Object>} Parsed embedding results
*/
parse_response() {
const resp = this.response;
if (!resp || !resp.data || !resp.usage) {
console.error("Invalid response format", resp);
return [];
}
const avg_tokens = resp.usage.total_tokens / resp.data.length;
return resp.data.map((item) => ({
vec: item.embedding,
tokens: avg_tokens
}));
}
};

var SmartEmbedMessageAdapter2 = class extends SmartEmbedAdapter2 {
static {
__name(this, "SmartEmbedMessageAdapter");
}
/**
* Create message adapter instance
*/
constructor(model) {
super(model);
this.message_queue = {};
this.message_id = 0;
this.connector = null;
this.message_prefix = `msg_${Math.random().toString(36).substr(2, 9)}_`;
}
/**
* Send message and wait for response
* @protected
* @param {string} method - Method name to call
* @param {Object} params - Method parameters
* @returns {Promise<any>} Response data
*/
async _send_message(method, params) {
return new Promise((resolve, reject) => {
const id = `${this.message_prefix}${this.message_id++}`;
this.message_queue[id] = { resolve, reject };
this._post_message({ method, params, id });
});
}
/**
* Handle response message from worker/iframe
* @protected
* @param {string} id - Message ID
* @param {*} result - Response result
* @param {Error} [error] - Response error
*/
_handle_message_result(id, result, error) {
if (!id.startsWith(this.message_prefix)) return;
if (result?.model_loaded) {
console.log("model loaded");
this.state = "loaded";
this.model.model_loaded = true;
this.model.load_result = result;
}
if (this.message_queue[id]) {
if (error) {
this.message_queue[id].reject(new Error(error));
} else {
this.message_queue[id].resolve(result);
}
delete this.message_queue[id];
}
}
/**
* Count tokens in input text
* @param {string} input - Text to tokenize
* @returns {Promise<Object>} Token count result
*/
async count_tokens(input) {
return this._send_message("count_tokens", { input });
}
/**
* Generate embeddings for multiple inputs
* @param {Array<Object>} inputs - Array of input objects
* @returns {Promise<Array<Object>>} Processed inputs with embeddings
*/
async embed_batch(inputs) {
inputs = inputs.filter((item) => item.embed_input?.length > 0);
if (!inputs.length) return [];
const embed_inputs = inputs.map((item) => ({ embed_input: item.embed_input }));
const result = await this._send_message("embed_batch", { inputs: embed_inputs });
return inputs.map((item, i) => {
item.vec = result[i].vec;
item.tokens = result[i].tokens;
return item;
});
}
/**
* Post message to worker/iframe
* @abstract
* @protected
* @param {Object} message_data - Message to send
* @throws {Error} If not implemented by subclass
*/
_post_message(message_data) {
throw new Error("_post_message must be implemented by subclass");
}
};

var SmartEmbedIframeAdapter2 = class extends SmartEmbedMessageAdapter2 {
static {
__name(this, "SmartEmbedIframeAdapter");
}
/**
* Create iframe adapter instance
*/
constructor(model) {
super(model);
this.iframe = null;
this.origin = window.location.origin;
this.iframe_id = `smart_embed_iframe`;
}
/**
* Initialize iframe and load model
* @returns {Promise<void>}
*/
async load() {
const existing_iframe = document.getElementById(this.iframe_id);
if (existing_iframe) {
existing_iframe.remove();
}
this.iframe = document.createElement("iframe");
this.iframe.style.display = "none";
this.iframe.id = this.iframe_id;
document.body.appendChild(this.iframe);
window.addEventListener("message", this._handle_message.bind(this));
this.iframe.srcdoc = `
<html>
<body>
<script type="module">
${this.connector}
window.addEventListener('message', async (event) => {
if (event.origin !== '${this.origin}' || event.data.iframe_id !== '${this.iframe_id}') return console.log('message ignored (listener)', event);
const response = await process_message(event.data);
window.parent.postMessage({ ...response, iframe_id: '${this.iframe_id}' }, '${this.origin}');
});
</script>
</body>
</html>
`;
await new Promise((resolve) => this.iframe.onload = resolve);
const load_opts = {
model_key: this.model.model_key,
adapters: null,
settings: null,
batch_size: this.batch_size,
use_gpu: this.use_gpu
};
await this._send_message("load", load_opts);
return new Promise((resolve) => {
const check_model_loaded = /* @__PURE__ */ __name(() => {
if (this.model.model_loaded) {
resolve();
} else {
setTimeout(check_model_loaded, 100);
}
}, "check_model_loaded");
check_model_loaded();
});
}
/**
* Post message to iframe
* @protected
* @param {Object} message_data - Message to send
*/
_post_message(message_data) {
this.iframe.contentWindow.postMessage({ ...message_data, iframe_id: this.iframe_id }, this.origin);
}
/**
* Handle message from iframe
* @private
* @param {MessageEvent} event - Message event
*/
_handle_message(event) {
if (event.origin !== this.origin || event.data.iframe_id !== this.iframe_id) return;
const { id, result, error } = event.data;
this._handle_message_result(id, result, error);
}
};

var transformers_connector2 = 'var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);\n\n// ../smart-model/adapters/_adapter.js\nvar SmartModelAdapter = class {\n  /**\n   * Create a SmartModelAdapter instance.\n   * @param {SmartModel} model - The parent SmartModel instance\n   */\n  constructor(model2) {\n    this.model = model2;\n    this.state = "unloaded";\n  }\n  /**\n   * Load the adapter.\n   * @async\n   * @returns {Promise<void>}\n   */\n  async load() {\n    this.set_state("loaded");\n  }\n  /**\n   * Unload the adapter.\n   * @returns {void}\n   */\n  unload() {\n    this.set_state("unloaded");\n  }\n  /**\n   * Get all settings.\n   * @returns {Object} All settings\n   */\n  get settings() {\n    return this.model.settings;\n  }\n  /**\n   * Get the current model key.\n   * @returns {string} Current model identifier\n   */\n  get model_key() {\n    return this.model.model_key;\n  }\n  /**\n   * Get the models.\n   * @returns {Object} Map of model objects\n   */\n  get models() {\n    const models = this.model.data.provider_models;\n    if (typeof models === "object" && Object.keys(models || {}).length > 0) return models;\n    else {\n      return {};\n    }\n  }\n  /**\n   * Get available models from the API.\n   * @abstract\n   * @param {boolean} [refresh=false] - Whether to refresh cached models\n   * @returns {Promise<Object>} Map of model objects\n   */\n  async get_models(refresh = false) {\n    throw new Error("get_models not implemented");\n  }\n  /**\n   * Get available models as dropdown options synchronously.\n   * @returns {Array<Object>} Array of model options.\n   */\n  get_models_as_options() {\n    const models = this.models;\n    if (!Object.keys(models || {}).length) {\n      this.get_models(true);\n      return [{ value: "", name: "No models currently available" }];\n    }\n    return Object.entries(models).map(([id, model2]) => ({ value: id, name: model2.name || id })).sort((a, b) => a.name.localeCompare(b.name));\n  }\n  /**\n   * Set the adapter\'s state.\n   * @deprecated should be handled in SmartModel (only handle once)\n   * @param {(\'unloaded\'|\'loading\'|\'loaded\'|\'unloading\')} new_state - The new state\n   * @throws {Error} If the state is invalid\n   */\n  set_state(new_state) {\n    const valid_states = ["unloaded", "loading", "loaded", "unloading"];\n    if (!valid_states.includes(new_state)) {\n      throw new Error(`Invalid state: ${new_state}`);\n    }\n    this.state = new_state;\n  }\n  // Replace individual state getters/setters with a unified state management\n  get is_loading() {\n    return this.state === "loading";\n  }\n  get is_loaded() {\n    return this.state === "loaded";\n  }\n  get is_unloading() {\n    return this.state === "unloading";\n  }\n  get is_unloaded() {\n    return this.state === "unloaded";\n  }\n};\n\n// adapters/_adapter.js\nvar SmartEmbedAdapter = class extends SmartModelAdapter {\n  /**\n   * Count tokens in input text\n   * @abstract\n   * @param {string} input - Text to tokenize\n   * @returns {Promise<Object>} Token count result\n   * @property {number} tokens - Number of tokens in input\n   * @throws {Error} If not implemented by subclass\n   */\n  async count_tokens(input) {\n    throw new Error("count_tokens method not implemented");\n  }\n  /**\n   * Generate embeddings for single input\n   * @abstract\n   * @param {string|Object} input - Text to embed\n   * @returns {Promise<Object>} Embedding result\n   * @property {number[]} vec - Embedding vector\n   * @property {number} tokens - Number of tokens in input\n   * @throws {Error} If not implemented by subclass\n   */\n  async embed(input) {\n    if (typeof input === "string") input = { embed_input: input };\n    return (await this.embed_batch([input]))[0];\n  }\n  /**\n   * Generate embeddings for multiple inputs\n   * @abstract\n   * @param {Array<string|Object>} inputs - Texts to embed\n   * @returns {Promise<Array<Object>>} Array of embedding results\n   * @property {number[]} vec - Embedding vector for each input\n   * @property {number} tokens - Number of tokens in each input\n   * @throws {Error} If not implemented by subclass\n   */\n  async embed_batch(inputs) {\n    throw new Error("embed_batch method not implemented");\n  }\n  get settings_config() {\n    return {\n      "[ADAPTER].model_key": {\n        name: "Embedding model",\n        type: "dropdown",\n        description: "Select an embedding model.",\n        options_callback: "adapter.get_models_as_options",\n        callback: "model_changed",\n        default: this.constructor.defaults.default_model\n      }\n    };\n  }\n  get dims() {\n    return this.model.data.dims;\n  }\n  get max_tokens() {\n    return this.model.data.max_tokens;\n  }\n  get batch_size() {\n    return this.model.data.batch_size || 1;\n  }\n};\n/**\n * @override in sub-class with adapter-specific default configurations\n * @property {string} id - The adapter identifier\n * @property {string} description - Human-readable description\n * @property {string} type - Adapter type ("API")\n * @property {string} endpoint - API endpoint\n * @property {string} adapter - Adapter identifier\n * @property {string} default_model - Default model to use\n */\n__publicField(SmartEmbedAdapter, "defaults", {});\n\n// adapters/transformers.js\nvar transformers_defaults = {\n  adapter: "transformers",\n  description: "Transformers (Local, built-in)",\n  default_model: "TaylorAI/bge-micro-v2",\n  models: transformers_models\n};\nvar DEVICE_CONFIGS = {\n  // // WebGPU: high quality first\n  webgpu_fp16: {\n    device: "webgpu",\n    dtype: "fp16",\n    quantized: false\n  },\n  webgpu_fp32: {\n    device: "webgpu",\n    dtype: "fp32",\n    quantized: false\n  },\n  // WebGPU: quantized tiers\n  webgpu_q8: {\n    device: "webgpu",\n    dtype: "q8",\n    quantized: true\n  },\n  webgpu_q4: {\n    device: "webgpu",\n    dtype: "q4",\n    quantized: true\n  },\n  // Optional, if you use it\n  webgpu_q4f16: {\n    device: "webgpu",\n    dtype: "q4f16",\n    quantized: true\n  },\n  webgpu_bnb4: {\n    device: "webgpu",\n    dtype: "bnb4",\n    quantized: true\n  },\n  // WASM: quantized CPU\n  wasm_q8: {\n    dtype: "q8",\n    quantized: true\n  },\n  wasm_q4: {\n    dtype: "q4",\n    quantized: true\n  },\n  // Final universal fallback: WASM CPU, dtype = auto\n  wasm_auto: {\n    // NOTE: leaving out device to avoid Linux issues with \'wasm\'\n    // transformers.js will pick CPU/WASM backend itself\n    quantized: false\n  }\n};\nvar is_webgpu_available = async () => {\n  if (!("gpu" in navigator)) return false;\n  const adapter = await navigator.gpu.requestAdapter();\n  if (!adapter) return false;\n  return true;\n};\nvar SmartEmbedTransformersAdapter = class extends SmartEmbedAdapter {\n  /**\n   * @param {import("../smart_embed_model.js").SmartEmbedModel} model\n   */\n  constructor(model2) {\n    super(model2);\n    this.pipeline = null;\n    this.tokenizer = null;\n    this.active_config_key = null;\n    this.has_gpu = false;\n  }\n  /**\n   * Load the underlying transformers pipeline with WebGPU \u2192 WASM fallback.\n   * @returns {Promise<void>}\n   */\n  async load() {\n    this.has_gpu = await is_webgpu_available();\n    try {\n      if (this.loading) {\n        console.warn("[Transformers v2] load already in progress, waiting...");\n        while (this.loading) {\n          await new Promise((resolve) => setTimeout(resolve, 100));\n        }\n      } else {\n        this.loading = true;\n        if (this.pipeline) {\n          this.loaded = true;\n          this.loading = false;\n          return;\n        }\n        await this.load_transformers_with_fallback();\n        this.loading = false;\n        this.loaded = true;\n        console.log(`[Transformers v2] model loaded using ${this.active_config_key}`, this);\n      }\n    } catch (e) {\n      this.loading = false;\n      this.loaded = false;\n      console.error("[Transformers v2] load failed", e);\n      throw e;\n    }\n  }\n  /**\n   * Unload the pipeline and free resources.\n   * @returns {Promise<void>}\n   */\n  async unload() {\n    try {\n      if (this.pipeline) {\n        if (typeof this.pipeline.destroy === "function") {\n          this.pipeline.destroy();\n        } else if (typeof this.pipeline.dispose === "function") {\n          this.pipeline.dispose();\n        }\n      }\n    } catch (err) {\n      console.warn("[Transformers v2] error while disposing pipeline", err);\n    }\n    this.pipeline = null;\n    this.tokenizer = null;\n    this.active_config_key = null;\n    this.loaded = false;\n  }\n  /**\n   * Available models \u2013 reuses the v1 transformers model catalog.\n   * @returns {Object}\n   */\n  get models() {\n    return transformers_models;\n  }\n  /**\n   * Maximum tokens per input.\n   * @returns {number}\n   */\n  get max_tokens() {\n    return this.model.data.max_tokens || 512;\n  }\n  /**\n   * Effective batch size.\n   * Prefers small deterministic batches when not explicitly configured.\n   * @returns {number}\n   */\n  get batch_size() {\n    const configured = this.model.data.batch_size;\n    if (configured && configured > 0) return configured;\n    return this.gpu_enabled ? 16 : 8;\n  }\n  get gpu_enabled() {\n    if (this.has_gpu) {\n      const explicit = typeof this.model.data.use_gpu === "boolean" ? this.model.data.use_gpu : null;\n      if (explicit === false) return false;\n      return true;\n    } else {\n      return false;\n    }\n  }\n  /**\n   * Initialize transformers pipeline with WebGPU \u2192 WASM fallback.\n   * @private\n   * @returns {Promise<void>}\n   */\n  async load_transformers_with_fallback() {\n    const { pipeline, env, AutoTokenizer } = await import("@huggingface/transformers");\n    env.allowLocalModels = false;\n    if (typeof env.useBrowserCache !== "undefined") {\n      env.useBrowserCache = true;\n    }\n    let last_error = null;\n    const CONFIG_LIST_ORDER = Object.keys(DEVICE_CONFIGS);\n    const try_create = async (config_key) => {\n      const pipe = await pipeline("feature-extraction", this.model_key, DEVICE_CONFIGS[config_key]);\n      return pipe;\n    };\n    for (const config of CONFIG_LIST_ORDER) {\n      if (this.pipeline) break;\n      if (config.includes("gpu") && !this.gpu_enabled) {\n        console.warn(`[Transformers v2: ${config}] skipping ${config} as GPU is disabled`);\n        continue;\n      }\n      try {\n        console.log(`[Transformers v2] trying to load pipeline on ${config}`);\n        this.pipeline = await try_create(config);\n        this.active_config_key = config;\n        break;\n      } catch (err) {\n        console.warn(`[Transformers v2: ${config}] failed to load pipeline on ${config}`, err);\n        last_error = err;\n      }\n    }\n    if (this.pipeline) {\n      console.log(`[Transformers v2: ${this.active_config_key}] pipeline initialized using ${this.active_config_key}`);\n    } else {\n      throw last_error || new Error("Failed to initialize transformers pipeline");\n    }\n    this.tokenizer = await AutoTokenizer.from_pretrained(this.model_key);\n  }\n  /**\n   * Count tokens in input text.\n   * @param {string} input\n   * @returns {Promise<{tokens:number}>}\n   */\n  async count_tokens(input) {\n    if (!this.tokenizer) {\n      await this.load();\n    }\n    const { input_ids } = await this.tokenizer(input);\n    return { tokens: input_ids.data.length };\n  }\n  /**\n   * Generate embeddings for multiple inputs.\n   * @param {Array<Object>} inputs\n   * @returns {Promise<Array<Object>>}\n   */\n  async embed_batch(inputs) {\n    if (!this.pipeline) {\n      await this.load();\n    }\n    const filtered_inputs = inputs.filter((item) => item.embed_input && item.embed_input.length > 0);\n    if (!filtered_inputs.length) return [];\n    const results = [];\n    for (let i = 0; i < filtered_inputs.length; i += this.batch_size) {\n      const batch = filtered_inputs.slice(i, i + this.batch_size);\n      const batch_results = await this._process_batch(batch);\n      results.push(...batch_results);\n    }\n    return results;\n  }\n  /**\n   * Process a single batch \u2013 with per-item retry on failure.\n   * @private\n   * @param {Array<Object>} batch_inputs\n   * @returns {Promise<Array<Object>>}\n   */\n  async _process_batch(batch_inputs) {\n    const prepared = await Promise.all(\n      batch_inputs.map((item) => this._prepare_input(item.embed_input))\n    );\n    const embed_inputs = prepared.map((p) => p.text);\n    const tokens = prepared.map((p) => p.tokens);\n    try {\n      const resp = await this.pipeline(embed_inputs, { pooling: "mean", normalize: true });\n      return batch_inputs.map((item, i) => {\n        const vec = Array.from(resp[i].data).map((val) => Math.round(val * 1e8) / 1e8);\n        item.vec = vec;\n        item.tokens = tokens[i];\n        return item;\n      });\n    } catch (err) {\n      console.error("[Transformers v2] batch embed failed \\u2013 retrying items individually", err);\n      return await this._retry_items_individually(batch_inputs);\n    }\n  }\n  /**\n   * Prepare a single input by truncating to max_tokens if necessary.\n   * @private\n   * @param {string} embed_input\n   * @returns {Promise<{text:string,tokens:number}>}\n   */\n  async _prepare_input(embed_input) {\n    let { tokens } = await this.count_tokens(embed_input);\n    if (tokens <= this.max_tokens) {\n      return { text: embed_input, tokens };\n    }\n    let truncated = embed_input;\n    while (tokens > this.max_tokens && truncated.length > 0) {\n      const pct = this.max_tokens / tokens;\n      const max_chars = Math.floor(truncated.length * pct * 0.9);\n      truncated = truncated.slice(0, max_chars);\n      const last_space = truncated.lastIndexOf(" ");\n      if (last_space > 0) {\n        truncated = truncated.slice(0, last_space);\n      }\n      tokens = (await this.count_tokens(truncated)).tokens;\n    }\n    return { text: truncated, tokens };\n  }\n  /**\n   * Retry each item individually after a batch failure.\n   * @private\n   * @param {Array<Object>} batch_inputs\n   * @returns {Promise<Array<Object>>}\n   */\n  async _retry_items_individually(batch_inputs) {\n    await this._reset_pipeline_after_error();\n    const results = [];\n    for (const item of batch_inputs) {\n      try {\n        const prepared = await this._prepare_input(item.embed_input);\n        const resp = await this.pipeline(prepared.text, { pooling: "mean", normalize: true });\n        const vec = Array.from(resp[0].data).map((val) => Math.round(val * 1e8) / 1e8);\n        results.push({\n          ...item,\n          vec,\n          tokens: prepared.tokens\n        });\n      } catch (single_err) {\n        console.error("[Transformers v2] single item embed failed \\u2013 skipping", single_err);\n        results.push({\n          ...item,\n          vec: [],\n          tokens: 0,\n          error: single_err.message\n        });\n      }\n    }\n    return results;\n  }\n  /**\n   * Reset pipeline after a failure \u2013 falling back to WASM if needed.\n   * @private\n   * @returns {Promise<void>}\n   */\n  async _reset_pipeline_after_error() {\n    try {\n      if (this.pipeline) {\n        if (typeof this.pipeline.destroy === "function") {\n          this.pipeline.destroy();\n        } else if (typeof this.pipeline.dispose === "function") {\n          this.pipeline.dispose();\n        }\n      }\n    } catch (err) {\n      console.warn("[Transformers v2] error while resetting pipeline", err);\n    }\n    this.pipeline = null;\n    await this.load_transformers_with_fallback();\n  }\n  /**\n   * V2 intentionally exposes only model selection in the settings UI.\n   * @returns {Object}\n   */\n  get settings_config() {\n    return super.settings_config;\n  }\n};\n__publicField(SmartEmbedTransformersAdapter, "defaults", transformers_defaults);\nvar transformers_models = {\n  "TaylorAI/bge-micro-v2": {\n    "id": "TaylorAI/bge-micro-v2",\n    "batch_size": 1,\n    "dims": 384,\n    "max_tokens": 512,\n    "name": "BGE-micro-v2",\n    "description": "Local, 512 tokens, 384 dim (recommended)",\n    "adapter": "transformers"\n  },\n  "Snowflake/snowflake-arctic-embed-xs": {\n    "id": "Snowflake/snowflake-arctic-embed-xs",\n    "batch_size": 1,\n    "dims": 384,\n    "max_tokens": 512,\n    "name": "Snowflake Arctic Embed XS",\n    "description": "Local, 512 tokens, 384 dim",\n    "adapter": "transformers"\n  },\n  "Snowflake/snowflake-arctic-embed-s": {\n    "id": "Snowflake/snowflake-arctic-embed-s",\n    "batch_size": 1,\n    "dims": 384,\n    "max_tokens": 512,\n    "name": "Snowflake Arctic Embed Small",\n    "description": "Local, 512 tokens, 384 dim",\n    "adapter": "transformers"\n  },\n  "Snowflake/snowflake-arctic-embed-m": {\n    "id": "Snowflake/snowflake-arctic-embed-m",\n    "batch_size": 1,\n    "dims": 768,\n    "max_tokens": 512,\n    "name": "Snowflake Arctic Embed Medium",\n    "description": "Local, 512 tokens, 768 dim",\n    "adapter": "transformers"\n  },\n  "TaylorAI/gte-tiny": {\n    "id": "TaylorAI/gte-tiny",\n    "batch_size": 1,\n    "dims": 384,\n    "max_tokens": 512,\n    "name": "GTE-tiny",\n    "description": "Local, 512 tokens, 384 dim",\n    "adapter": "transformers"\n  },\n  "onnx-community/embeddinggemma-300m-ONNX": {\n    "id": "onnx-community/embeddinggemma-300m-ONNX",\n    "batch_size": 1,\n    "dims": 768,\n    "max_tokens": 2048,\n    "name": "EmbeddingGemma-300M",\n    "description": "Local, 2,048 tokens, 768 dim",\n    "adapter": "transformers"\n  },\n  "Mihaiii/Ivysaur": {\n    "id": "Mihaiii/Ivysaur",\n    "batch_size": 1,\n    "dims": 384,\n    "max_tokens": 512,\n    "name": "Ivysaur",\n    "description": "Local, 512 tokens, 384 dim",\n    "adapter": "transformers"\n  },\n  "andersonbcdefg/bge-small-4096": {\n    "id": "andersonbcdefg/bge-small-4096",\n    "batch_size": 1,\n    "dims": 384,\n    "max_tokens": 4096,\n    "name": "BGE-small-4K",\n    "description": "Local, 4,096 tokens, 384 dim",\n    "adapter": "transformers"\n  },\n  // Too slow and persistent crashes\n  // "jinaai/jina-embeddings-v2-base-de": {\n  //   "id": "jinaai/jina-embeddings-v2-base-de",\n  //   "batch_size": 1,\n  //   "dims": 768,\n  //   "max_tokens": 4096,\n  //   "name": "jina-embeddings-v2-base-de",\n  //   "description": "Local, 4,096 tokens, 768 dim, German",\n  //   "adapter": "transformers"\n  // },\n  "Xenova/jina-embeddings-v2-base-zh": {\n    "id": "Xenova/jina-embeddings-v2-base-zh",\n    "batch_size": 1,\n    "dims": 768,\n    "max_tokens": 8192,\n    "name": "Jina-v2-base-zh-8K",\n    "description": "Local, 8,192 tokens, 768 dim, Chinese/English bilingual",\n    "adapter": "transformers"\n  },\n  "Xenova/jina-embeddings-v2-small-en": {\n    "id": "Xenova/jina-embeddings-v2-small-en",\n    "batch_size": 1,\n    "dims": 512,\n    "max_tokens": 8192,\n    "name": "Jina-v2-small-en",\n    "description": "Local, 8,192 tokens, 512 dim",\n    "adapter": "transformers"\n  },\n  "nomic-ai/nomic-embed-text-v1.5": {\n    "id": "nomic-ai/nomic-embed-text-v1.5",\n    "batch_size": 1,\n    "dims": 768,\n    "max_tokens": 2048,\n    "name": "Nomic-embed-text-v1.5",\n    "description": "Local, 8,192 tokens, 768 dim",\n    "adapter": "transformers"\n  },\n  "Xenova/bge-small-en-v1.5": {\n    "id": "Xenova/bge-small-en-v1.5",\n    "batch_size": 1,\n    "dims": 384,\n    "max_tokens": 512,\n    "name": "BGE-small",\n    "description": "Local, 512 tokens, 384 dim",\n    "adapter": "transformers"\n  },\n  "nomic-ai/nomic-embed-text-v1": {\n    "id": "nomic-ai/nomic-embed-text-v1",\n    "batch_size": 1,\n    "dims": 768,\n    "max_tokens": 2048,\n    "name": "Nomic-embed-text",\n    "description": "Local, 2,048 tokens, 768 dim",\n    "adapter": "transformers"\n  }\n};\n\n// build/transformers_iframe_script.js\nvar model = null;\nasync function process_message(data) {\n  const { method, params, id, iframe_id } = data;\n  try {\n    let result;\n    switch (method) {\n      case "init":\n        console.log("init");\n        break;\n      case "load":\n        const model_params = { data: params, ...params };\n        console.log("load", { model_params });\n        model = new SmartEmbedTransformersAdapter(model_params);\n        await model.load();\n        result = { model_loaded: true, model_config_key: model.active_config_key };\n        break;\n      case "embed_batch":\n        if (!model) throw new Error("Model not loaded");\n        result = await model.embed_batch(params.inputs);\n        break;\n      case "count_tokens":\n        if (!model) throw new Error("Model not loaded");\n        result = await model.count_tokens(params);\n        break;\n      default:\n        throw new Error(`Unknown method: ${method}`);\n    }\n    return { id, result, iframe_id };\n  } catch (error) {\n    console.error("Error processing message:", error);\n    return { id, error: error.message, iframe_id };\n  }\n}\nprocess_message({ method: "init" });\n';

var transformers_defaults2 = {
adapter: "transformers",
description: "Transformers (Local, built-in)",
default_model: "TaylorAI/bge-micro-v2",
models: transformers_models2
};
var transformers_models2 = {
"TaylorAI/bge-micro-v2": {
"id": "TaylorAI/bge-micro-v2",
"batch_size": 1,
"dims": 384,
"max_tokens": 512,
"name": "BGE-micro-v2",
"description": "Local, 512 tokens, 384 dim (recommended)",
"adapter": "transformers"
},
"Snowflake/snowflake-arctic-embed-xs": {
"id": "Snowflake/snowflake-arctic-embed-xs",
"batch_size": 1,
"dims": 384,
"max_tokens": 512,
"name": "Snowflake Arctic Embed XS",
"description": "Local, 512 tokens, 384 dim",
"adapter": "transformers"
},
"Snowflake/snowflake-arctic-embed-s": {
"id": "Snowflake/snowflake-arctic-embed-s",
"batch_size": 1,
"dims": 384,
"max_tokens": 512,
"name": "Snowflake Arctic Embed Small",
"description": "Local, 512 tokens, 384 dim",
"adapter": "transformers"
},
"Snowflake/snowflake-arctic-embed-m": {
"id": "Snowflake/snowflake-arctic-embed-m",
"batch_size": 1,
"dims": 768,
"max_tokens": 512,
"name": "Snowflake Arctic Embed Medium",
"description": "Local, 512 tokens, 768 dim",
"adapter": "transformers"
},
"TaylorAI/gte-tiny": {
"id": "TaylorAI/gte-tiny",
"batch_size": 1,
"dims": 384,
"max_tokens": 512,
"name": "GTE-tiny",
"description": "Local, 512 tokens, 384 dim",
"adapter": "transformers"
},
"onnx-community/embeddinggemma-300m-ONNX": {
"id": "onnx-community/embeddinggemma-300m-ONNX",
"batch_size": 1,
"dims": 768,
"max_tokens": 2048,
"name": "EmbeddingGemma-300M",
"description": "Local, 2,048 tokens, 768 dim",
"adapter": "transformers"
},
"Mihaiii/Ivysaur": {
"id": "Mihaiii/Ivysaur",
"batch_size": 1,
"dims": 384,
"max_tokens": 512,
"name": "Ivysaur",
"description": "Local, 512 tokens, 384 dim",
"adapter": "transformers"
},
"andersonbcdefg/bge-small-4096": {
"id": "andersonbcdefg/bge-small-4096",
"batch_size": 1,
"dims": 384,
"max_tokens": 4096,
"name": "BGE-small-4K",
"description": "Local, 4,096 tokens, 384 dim",
"adapter": "transformers"
},
"Xenova/jina-embeddings-v2-base-zh": {
"id": "Xenova/jina-embeddings-v2-base-zh",
"batch_size": 1,
"dims": 768,
"max_tokens": 8192,
"name": "Jina-v2-base-zh-8K",
"description": "Local, 8,192 tokens, 768 dim, Chinese/English bilingual",
"adapter": "transformers"
},
"Xenova/jina-embeddings-v2-small-en": {
"id": "Xenova/jina-embeddings-v2-small-en",
"batch_size": 1,
"dims": 512,
"max_tokens": 8192,
"name": "Jina-v2-small-en",
"description": "Local, 8,192 tokens, 512 dim",
"adapter": "transformers"
},
"nomic-ai/nomic-embed-text-v1.5": {
"id": "nomic-ai/nomic-embed-text-v1.5",
"batch_size": 1,
"dims": 768,
"max_tokens": 2048,
"name": "Nomic-embed-text-v1.5",
"description": "Local, 8,192 tokens, 768 dim",
"adapter": "transformers"
},
"Xenova/bge-small-en-v1.5": {
"id": "Xenova/bge-small-en-v1.5",
"batch_size": 1,
"dims": 384,
"max_tokens": 512,
"name": "BGE-small",
"description": "Local, 512 tokens, 384 dim",
"adapter": "transformers"
},
"nomic-ai/nomic-embed-text-v1": {
"id": "nomic-ai/nomic-embed-text-v1",
"batch_size": 1,
"dims": 768,
"max_tokens": 2048,
"name": "Nomic-embed-text",
"description": "Local, 2,048 tokens, 768 dim",
"adapter": "transformers"
}
};
var transformers_settings_config2 = {
};
var settings_config21 = {
};

var SmartEmbedTransformersIframeAdapter2 = class extends SmartEmbedIframeAdapter2 {
static {
__name(this, "SmartEmbedTransformersIframeAdapter");
}
static defaults = transformers_defaults2;
/**
* Create transformers iframe adapter instance
*/
constructor(model) {
super(model);
this.connector = transformers_connector2.replace("@huggingface/transformers", "https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.8.0");
console.log("transformers iframe connector", this.model);
}
/** @returns {Object} Settings configuration for transformers adapter */
get settings_config() {
return {
...super.settings_config,
...transformers_settings_config2
};
}
/**
* Get available models (hardcoded list)
* @returns {Promise<Object>} Map of model objects
*/
get_models() {
return Promise.resolve(this.models);
}
get models() {
return transformers_models2;
}
};

var SmartEmbedOllamaAdapter2 = class extends SmartEmbedModelApiAdapter2 {
static {
__name(this, "SmartEmbedOllamaAdapter");
}
static defaults = {
description: "Ollama (Local)",
type: "API",
host: "http://localhost:11434",
endpoint: "/api/embed",
models_endpoint: "/api/tags",
api_key: "na",
streaming: false,
max_tokens: 512,
signup_url: null,
batch_size: 30,
models: {}
};
get host() {
return this.model.data.host || this.constructor.defaults.host;
}
get endpoint() {
return `${this.host}${this.constructor.defaults.endpoint}`;
}
get models_endpoint() {
return `${this.host}${this.constructor.defaults.models_endpoint}`;
}
get model_show_endpoint() {
return `${this.host}/api/show`;
}
async load() {
await this.get_models();
await super.load();
}
/**
* Estimate token count for input text.
* Ollama does not expose a tokenizer so we use a character based heuristic.
* @param {string} input - Text to tokenize
* @returns {Promise<Object>} Token count result
*/
async count_tokens(input) {
return { tokens: this.estimate_tokens(input) };
}
/**
* Prepare input text and ensure it fits within `max_tokens`.
* @param {string} embed_input - Raw input text
* @returns {Promise<string|null>} Processed input text
*/
async prepare_embed_input(embed_input) {
if (typeof embed_input !== "string") throw new TypeError("embed_input must be a string");
if (embed_input.length === 0) return null;
const { tokens } = await this.count_tokens(embed_input);
if (tokens <= this.max_tokens) return embed_input;
return await this.trim_input_to_max_tokens(embed_input, tokens);
}
/**
* Trim input text to satisfy `max_tokens`.
* @private
* @param {string} embed_input - Input text
* @param {number} tokens_ct - Existing token count
* @returns {Promise<string|null>} Trimmed text
*/
async trim_input_to_max_tokens(embed_input, tokens_ct) {
const reduce_ratio = (tokens_ct - this.max_tokens) / tokens_ct;
const new_length = Math.floor(embed_input.length * (1 - reduce_ratio));
let trimmed_input = embed_input.slice(0, new_length);
const last_space_index = trimmed_input.lastIndexOf(" ");
if (last_space_index > 0) trimmed_input = trimmed_input.slice(0, last_space_index);
const prepared = await this.prepare_embed_input(trimmed_input);
if (prepared === null) return null;
return prepared;
}
/** @returns {number} Maximum tokens for an input */
get max_tokens() {
return this.model.data.max_tokens || this.constructor.defaults.max_tokens;
}
/**
* Get the request adapter class.
* @returns {SmartEmbedModelOllamaRequestAdapter} The request adapter class
*/
get req_adapter() {
return SmartEmbedModelOllamaRequestAdapter2;
}
/**
* Get the response adapter class.
* @returns {SmartEmbedModelOllamaResponseAdapter} The response adapter class
*/
get res_adapter() {
return SmartEmbedModelOllamaResponseAdapter2;
}
/**
* Get available models from local Ollama instance.
* @param {boolean} [refresh=false] - Whether to refresh cached models
* @returns {Promise<Object>} Map of model objects
*/
async get_models(refresh = false) {
if (!this.model_data || refresh) {
const list_resp = await this.http_adapter.request({
url: this.models_endpoint,
method: "GET"
});
if (list_resp.ok === false) {
throw new Error(`Failed to fetch models list: ${list_resp.statusText}`);
}
const list_data = await list_resp.json();
const models_raw = [];
for (const m of filter_embedding_models2(list_data.models || [])) {
const detail_resp = await this.http_adapter.request({
url: this.model_show_endpoint,
method: "POST",
body: JSON.stringify({ model: m.name })
});
models_raw.push({ ...await detail_resp.json(), name: m.name });
}
const model_data = this.parse_model_data(models_raw);
this.model_data = model_data;
if (typeof this.model.re_render_settings === "function") {
this.model.re_render_settings();
}
return model_data;
}
return this.model_data;
}
/**
* Get available models as dropdown options synchronously.
* @returns {Array<Object>} Array of model options.
*/
get_models_as_options() {
const models = this.model_data;
if (!Object.keys(models || {}).length) {
this.get_models(true);
return [{ value: "", name: "No models currently available" }];
}
return Object.values(models).map((model) => ({ value: model.id, name: model.name || model.id })).sort((a, b) => a.name.localeCompare(b.name));
}
/**
* Parse model data from Ollama API response.
* @param {Object} model_data - Raw model data from Ollama
* @returns {Object} Map of model objects with capabilities and limits
*/
parse_model_data(model_data) {
if (!Array.isArray(model_data)) {
this.model_data = {};
console.error("Invalid model data format from Ollama:", model_data);
return {};
}
if (model_data.length === 0) {
this.model_data = { "no_models_available": {
id: "no_models_available",
name: "No models currently available"
} };
return this.model_data;
}
this.model_data = model_data.reduce((acc, model) => {
const info = model.model_info || {};
const ctx = Object.entries(info).find(([k]) => k.includes("context_length"))?.[1];
const dims = Object.entries(info).find(([k]) => k.includes("embedding_length"))?.[1];
acc[model.name] = {
model_name: model.name,
id: model.name,
multimodal: false,
max_tokens: ctx || this.max_tokens,
dims,
description: model.description || `Model: ${model.name}`
};
return acc;
}, {});
this._models = this.model_data;
return this.model_data;
}
/**
* Get the models.
* @returns {Object} Map of model objects
*/
get models() {
if (typeof this._models === "object" && Object.keys(this._models || {}).length > 0) return this._models;
else {
return {};
}
}
/**
* Override settings config to remove API key setting since not needed for local instance.
* @returns {Object} Settings configuration object
*/
get settings_config() {
const config = super.settings_config;
delete config["[ADAPTER].api_key"];
config["[ADAPTER].host"] = {
name: "Ollama host",
type: "text",
description: "Enter the host for your Ollama instance",
default: this.constructor.defaults.host
};
return config;
}
};
var SmartEmbedModelOllamaRequestAdapter2 = class extends SmartEmbedModelRequestAdapter2 {
static {
__name(this, "SmartEmbedModelOllamaRequestAdapter");
}
/**
* Convert request to Ollama's embed API format.
* @returns {Object} Request parameters in Ollama's format
*/
to_platform() {
const ollama_body = {
model: this.model_id,
input: this.embed_inputs
};
return {
url: this.adapter.endpoint,
method: "POST",
headers: this.get_headers(),
body: JSON.stringify(ollama_body)
};
}
/**
* Prepare request headers for Ollama API.
* @returns {Object} Headers object
*/
get_headers() {
return {
"Content-Type": "application/json"
};
}
};
var SmartEmbedModelOllamaResponseAdapter2 = class extends SmartEmbedModelResponseAdapter2 {
static {
__name(this, "SmartEmbedModelOllamaResponseAdapter");
}
/**
* Convert Ollama's response to a standardized OpenAI-like format.
* @returns {Array<Object>} Array of embedding results
*/
to_openai() {
const resp = this.response;
if (!resp || !resp.embeddings) {
console.error("Invalid response format from Ollama:", resp);
return [];
}
const tokens = Math.ceil(resp.prompt_eval_count / this.adapter.batch_size);
const embeddings = resp.embeddings.map((vec) => ({
vec,
tokens
}));
return embeddings;
}
/**
* Parse the response object.
* @returns {Array<Object>} Parsed embedding results
*/
parse_response() {
return this.to_openai();
}
};
var is_embedding_model2 = /* @__PURE__ */ __name((mod) => {
return ["embed", "embedding", "bge"].some((keyword) => mod.name.toLowerCase().includes(keyword));
}, "is_embedding_model");
var filter_embedding_models2 = /* @__PURE__ */ __name((models) => {
if (!Array.isArray(models)) {
throw new TypeError("models must be an array");
}
return models.filter(is_embedding_model2);
}, "filter_embedding_models");

var GeminiEmbedModelAdapter2 = class extends SmartEmbedModelApiAdapter2 {
static {
__name(this, "GeminiEmbedModelAdapter");
}
static defaults = {
adapter: "gemini",
description: "Google Gemini (API)",
default_model: "gemini-embedding-001",
endpoint: "https://generativelanguage.googleapis.com/v1beta/models/gemini-embedding-001:batchEmbedContents",
dims: 768,
max_tokens: 2048,
batch_size: 50
};
/**
* Count tokens in input text using tokenizer
* @param {string} input - Text to tokenize
* @returns {Promise<Object>} Token count result
*/
async count_tokens(input) {
if (!this.tiktoken) await this.load_tiktoken();
return { tokens: this.tiktoken.encode(input).length };
}
/**
* Prepare input text for embedding
* Handles token limit truncation
* @param {string} embed_input - Raw input text
* @returns {Promise<string|null>} Processed input text
*/
async prepare_embed_input(embed_input) {
if (typeof embed_input !== "string") {
throw new TypeError("embed_input must be a string");
}
if (embed_input.length === 0) {
console.log("Warning: prepare_embed_input received an empty string");
return null;
}
const { tokens } = await this.count_tokens(embed_input);
if (tokens <= this.max_tokens) {
return embed_input;
}
return await this.trim_input_to_max_tokens(embed_input, tokens);
}
/**
* Trim input text to fit token limit
* @private
* @param {string} embed_input - Input text to trim
* @param {number} tokens_ct - Current token count
* @returns {Promise<string|null>} Trimmed input text
*/
async trim_input_to_max_tokens(embed_input, tokens_ct) {
const reduce_ratio = (tokens_ct - this.max_tokens) / tokens_ct;
const new_length = Math.floor(embed_input.length * (1 - reduce_ratio));
let trimmed_input = embed_input.slice(0, new_length);
const last_space_index = trimmed_input.lastIndexOf(" ");
if (last_space_index > 0) {
trimmed_input = trimmed_input.slice(0, last_space_index);
}
const prepared_input = await this.prepare_embed_input(trimmed_input);
if (prepared_input === null) {
console.log(
"Warning: prepare_embed_input resulted in an empty string after trimming"
);
return null;
}
return prepared_input;
}
/**
* Get the request adapter class.
* @returns {SmartEmbedGeminiRequestAdapter} The request adapter class
*/
get req_adapter() {
return SmartEmbedGeminiRequestAdapter2;
}
/**
* Get the response adapter class.
* @returns {SmartEmbedGeminiResponseAdapter} The response adapter class
*/
get res_adapter() {
return SmartEmbedGeminiResponseAdapter2;
}
/** @returns {Object} Settings configuration for Gemini adapter */
get settings_config() {
return {
...super.settings_config,
"[ADAPTER].api_key": {
name: "Google API Key for Gemini embeddings",
type: "password",
description: "Required for Gemini embedding models",
placeholder: "Enter Google API Key"
}
};
}
/**
* Get available models (hardcoded list)
* @returns {Promise<Object>} Map of model objects
*/
get_models() {
return Promise.resolve(this.models);
}
get models() {
return {
"gemini-embedding-001": {
"id": "gemini-embedding-001",
"batch_size": 50,
"dims": 768,
"max_tokens": 2048,
"name": "Gemini Embedding",
"description": "API, 2,048 tokens, 768 dim",
"endpoint": "https://generativelanguage.googleapis.com/v1beta/models/gemini-embedding-001:batchEmbedContents",
"adapter": "gemini"
}
};
}
prepare_request_headers() {
return {
"Content-Type": "application/json",
"x-goog-api-key": this.api_key
};
}
backoff_wait_time = 5e3;
backoff_factor = 1;
async embed_batch(inputs, retries = 0) {
if (smart_env.smart_sources.entities_vector_adapter.is_queue_halted) {
throw new Error("Embedding queue halted during backoff wait due to rate limit errors.");
}
const token_cts = inputs.map((item) => this.estimate_tokens(item.embed_input));
const resp = await super.embed_batch(inputs);
if (resp[0].error && resp[0].error.details && resp[0].error.details.code === 429) {
console.warn("Rate limit error detected in Gemini embed_batch response.", resp);
if (retries > 3) {
console.error("Max retries reached for rate limit errors.");
throw new Error("Max retries reached for rate limit errors.");
}
console.warn(resp[0].error.message);
const retry_detail = resp[0].error.details?.details?.find((d) => d.retryDelay);
if (retry_detail.retryDelay) {
const wait_time_ms = parseInt(retry_detail.retryDelay) * 1e3 * 2;
console.warn(`Using server-specified retry delay of ${wait_time_ms} ms`);
await new Promise((resolve) => setTimeout(resolve, wait_time_ms));
return await this.embed_batch(inputs, retries + 1);
} else {
this.backoff_factor += 1;
console.warn(`Rate limit exceeded, backing off for ${this.backoff_wait_time * this.backoff_factor} ms`);
await new Promise((resolve) => setTimeout(resolve, this.backoff_wait_time * this.backoff_factor));
return await this.embed_batch(inputs, retries + 1);
}
} else if (resp[0].error) {
console.error("Error in Gemini embed_batch response:", resp[0].error);
throw new Error(`Gemini embed_batch error: ${resp[0].error.message}`);
}
resp.forEach((item, idx) => {
item.tokens = token_cts[idx];
});
console.log("Gemini embed_batch response:", resp);
return resp;
}
};
var SmartEmbedGeminiRequestAdapter2 = class extends SmartEmbedModelRequestAdapter2 {
static {
__name(this, "SmartEmbedGeminiRequestAdapter");
}
get model_id() {
let model_id = this.adapter.model.data.model_key;
return `models/${model_id}`;
}
/**
* Prepare request body for Gemini API
* @returns {Object} Request body for API
*/
prepare_request_body() {
const requests = this.embed_inputs.map((input) => {
const [title, ...content] = input.split("\n");
const doc_content = content.join("\n").trim() || "";
if (doc_content.length) {
return {
model: this.model_id,
content: {
parts: [{ text: doc_content }]
},
outputDimensionality: this.model_dims,
taskType: "RETRIEVAL_DOCUMENT",
title
};
} else {
return {
model: this.model_id,
content: {
parts: [{ text: title }]
},
outputDimensionality: this.model_dims,
taskType: "RETRIEVAL_DOCUMENT"
};
}
});
return {
requests
};
}
};
var SmartEmbedGeminiResponseAdapter2 = class extends SmartEmbedModelResponseAdapter2 {
static {
__name(this, "SmartEmbedGeminiResponseAdapter");
}
/**
* Parse Gemini API response
* @returns {Array<Object>} Parsed embedding results
*/
parse_response() {
const resp = this.response;
console.log("Gemini response:", resp);
if (!resp || !resp.embeddings || !resp.embeddings[0].values) {
console.error("Invalid Gemini embedding response format", resp);
return [];
}
return resp.embeddings.map((embedding, i) => {
if (!embedding.values || embedding.values.length === 0) {
console.warn(`No values for embedding at index ${i}`);
return { vec: [], tokens: 0 };
}
return {
vec: embedding.values,
tokens: null
};
});
}
};

function parse_lm_studio_models2(list, adapter_key = "lm_studio") {
if (list.object !== "list" || !Array.isArray(list.data)) {
return { _: { id: "No models found." } };
}
console.log("LM Studio models", list);
return list.data.filter((m) => m.id && m.type === "embeddings").reduce((acc, m) => {
acc[m.id] = {
id: m.id,
model_name: m.id,
max_tokens: m.loaded_context_length || 512,
description: `LM Studio model: ${m.id}`,
adapter: adapter_key
};
return acc;
}, {});
}
__name(parse_lm_studio_models2, "parse_lm_studio_models");
var LmStudioEmbedModelAdapter2 = class extends SmartEmbedModelApiAdapter2 {
static {
__name(this, "LmStudioEmbedModelAdapter");
}
static key = "lm_studio";
static defaults = {
description: "LM Studio",
type: "API",
host: "http://localhost:1234",
endpoint: "/api/v0/embeddings",
models_endpoint: "/api/v0/models",
default_model: "",
streaming: false,
api_key: "na",
batch_size: 10,
max_tokens: 512
};
get req_adapter() {
return LmStudioEmbedModelRequestAdapter2;
}
get res_adapter() {
return LmStudioEmbedModelResponseAdapter2;
}
get host() {
return this.model.data.host || this.constructor.defaults.host;
}
get endpoint() {
return `${this.host}${this.constructor.defaults.endpoint}`;
}
get models_endpoint() {
return `${this.host}${this.constructor.defaults.models_endpoint}`;
}
get settings_config() {
const cfg = { ...super.settings_config };
delete cfg["[ADAPTER].api_key"];
cfg["[ADAPTER].refresh_models"] = {
name: "Refresh Models",
type: "button",
description: "Refresh the list of available models.",
callback: "adapter.refresh_models"
};
cfg["[ADAPTER].current_model"] = {
type: "html",
value: `<p>Embedding Model Max Tokens: ${this.max_tokens} (may be configured in LM Studio)</p>`
};
cfg["[ADAPTER].batch_size"] = {
name: "Embedding Batch Size",
type: "number",
description: "Number of embeddings to process in parallel. Adjusting this may improve performance.",
value: this.batch_size,
default: this.constructor.defaults.batch_size
};
cfg["[ADAPTER].cors_note"] = {
name: "CORS required",
type: "html",
value: `<p>Before you can use LM Studio you must <strong>Enable CORS</strong> inside LM Studio \u2192 Developer \u2192 Settings</p>`
};
return cfg;
}
async get_models(refresh = false) {
if (!refresh && this.model.data.provider_models) return this.model.data.provider_models;
const resp = await this.http_adapter.request({
url: this.models_endpoint,
method: "GET"
});
const raw = await resp.json();
const parsed = this.parse_model_data(raw);
this.model.data.provider_models = parsed;
this.model.re_render_settings();
return parsed;
}
parse_model_data(list) {
return parse_lm_studio_models2(list, this.constructor.key);
}
async count_tokens(input) {
return { tokens: this.estimate_tokens(input) };
}
/**
* Prepare input text and ensure it fits within `max_tokens`.
* @param {string} embed_input - Raw input text
* @returns {Promise<string|null>} Processed input text
*/
async prepare_embed_input(embed_input) {
if (typeof embed_input !== "string") throw new TypeError("embed_input must be a string");
if (embed_input.length === 0) return null;
const { tokens } = await this.count_tokens(embed_input);
if (tokens <= this.max_tokens) return embed_input;
return await this.trim_input_to_max_tokens(embed_input, tokens);
}
/**
* Refresh available models.
*/
refresh_models() {
console.log("refresh_models");
this.get_models(true);
}
async embed_batch(inputs) {
const token_cts = inputs.map((item) => this.estimate_tokens(item.embed_input));
const resp = await super.embed_batch(inputs);
resp.forEach((item, idx) => {
item.tokens = token_cts[idx];
});
return resp;
}
};
var LmStudioEmbedModelRequestAdapter2 = class extends SmartEmbedModelRequestAdapter2 {
static {
__name(this, "LmStudioEmbedModelRequestAdapter");
}
/**
* Prepare request body for LM Studio API
* @returns {Object} Request body for API
*/
prepare_request_body() {
const body = {
model: this.model_id,
input: this.embed_inputs
};
return body;
}
};
var LmStudioEmbedModelResponseAdapter2 = class extends SmartEmbedModelResponseAdapter2 {
static {
__name(this, "LmStudioEmbedModelResponseAdapter");
}
/**
* Parse LM Studio API response
* @returns {Array<Object>} Parsed embedding results
*/
parse_response() {
const resp = this.response;
if (!resp || !resp.data) {
console.error("Invalid response format", resp);
return [];
}
return resp.data.map((item) => ({
vec: item.embedding,
tokens: null
}));
}
};

var SmartChatModel2 = class extends SmartModel2 {
static {
__name(this, "SmartChatModel");
}
scope_name = "smart_chat_model";
static defaults = {
adapter: "openai"
};
/**
* Create a SmartChatModel instance.
* @param {Object} opts - Configuration options
* @param {string} opts.adapter - Adapter to use
* @param {Object} opts.adapters - Map of adapter names to adapter classes
* @param {Object} opts.settings - Model settings configuration
*/
constructor(opts = {}) {
super(opts);
}
/**
* Get available models.
* @returns {Object} Map of model objects
*/
get models() {
return this.adapter.models;
}
get can_stream() {
return this.adapter.constructor.defaults.streaming;
}
/**
* Complete a chat request.
* @param {Object} req - Request parameters
* @returns {Promise<Object>} Completion result
*/
async complete(req) {
const resp = await this.invoke_adapter_method("complete", req);
if (resp.error) {
throw normalize_error3(resp.error);
}
return resp;
}
/**
* Stream chat responses.
* @param {Object} req - Request parameters
* @param {Object} handlers - Event handlers for streaming
* @param {Function} handlers.chunk - Handler for chunks: receives response object
* @param {Function} handlers.error - Handler for errors: receives error object
* @param {Function} handlers.done - Handler for completion: receives final response object
* @returns {Promise<string>} Complete response text
*/
async stream(req, handlers = {}) {
return await this.invoke_adapter_method("stream", req, handlers);
}
/**
* Stop active stream.
*/
stop_stream() {
this.invoke_adapter_method("stop_stream");
}
/**
* Count tokens in input text.
* @param {string|Object} input - Text to count tokens for
* @returns {Promise<number>} Token count
*/
async count_tokens(input) {
return await this.invoke_adapter_method("count_tokens", input);
}
/**
* Test if API key is valid.
* @returns {Promise<boolean>} True if API key is valid
*/
async test_api_key() {
await this.invoke_adapter_method("test_api_key");
this.re_render_settings();
}
/**
* Get default model key.
* @returns {string} Default model key
*/
get default_model_key() {
return this.adapter.constructor.defaults.default_model;
}
/**
* Get current settings.
* @returns {Object} Settings object
*/
get settings() {
return this.opts.settings;
}
/**
* Get settings configuration.
* @returns {Object} Settings configuration object
*/
get settings_config() {
const _settings_config = {
adapter: {
name: "Chat Model Platform",
type: "dropdown",
description: "Select a platform/provider for chat models.",
options_callback: "get_platforms_as_options",
is_scope: true,
callback: "adapter_changed"
},
...this.adapter.settings_config || {}
};
return this.process_settings_config(_settings_config);
}
/**
* Process setting key.
* @param {string} key - Setting key
* @returns {string} Processed key
*/
process_setting_key(key) {
return key.replace(/\[CHAT_ADAPTER\]/g, this.adapter_name);
}
};

var SmartStreamer3 = class {
static {
__name(this, "SmartStreamer");
}
constructor(url, options = {}) {
const {
method = "GET",
headers = {},
body = null,
withCredentials = false
} = options;
this.url = url;
this.method = method;
this.headers = headers;
this.body = body;
this.withCredentials = withCredentials;
this.listeners = {};
this.readyState = this.CONNECTING;
this.progress = 0;
this.chunk = "";
this.last_event_id = "";
this.xhr = null;
this.FIELD_SEPARATOR = ":";
this.INITIALIZING = -1;
this.CONNECTING = 0;
this.OPEN = 1;
this.CLOSED = 2;
this.chunk_accumulator = "";
this.chunk_splitting_regex = options.chunk_splitting_regex || /(\r\n|\n|\r)/g;
}
/**
* Adds an event listener for the specified event type.
*
* @param {string} type - The type of the event.
* @param {Function} listener - The listener function to be called when the event is triggered.
*/
addEventListener(type, listener) {
if (!this.listeners[type]) this.listeners[type] = [];
if (!this.listeners[type].includes(listener)) this.listeners[type].push(listener);
}
/**
* Removes an event listener from the SmartStreamer instance.
*
* @param {string} type - The type of event to remove the listener from.
* @param {Function} listener - The listener function to remove.
*/
removeEventListener(type, listener) {
if (!this.listeners[type]) return;
this.listeners[type] = this.listeners[type].filter((callback) => callback !== listener);
if (this.listeners[type].length === 0) delete this.listeners[type];
}
/**
* Dispatches an event to the appropriate event handlers.
*
* @param {Event} event - The event to be dispatched.
* @returns {boolean} - Returns true if the event was successfully dispatched, false otherwise.
*/
dispatchEvent(event) {
if (!event) return true;
event.source = this;
const onHandler = "on" + event.type;
if (Object.prototype.hasOwnProperty.call(this, onHandler)) {
this[onHandler].call(this, event);
if (event.defaultPrevented) return false;
}
if (this.listeners[event.type]) {
this.listeners[event.type].forEach((callback) => {
callback(event);
return !event.defaultPrevented;
});
}
return true;
}
/**
* Initiates the streaming process.
*/
stream() {
this.#setReadyState(this.CONNECTING);
this.xhr = new XMLHttpRequest();
this.xhr.addEventListener("progress", this.#onStreamProgress.bind(this));
this.xhr.addEventListener("load", this.#onStreamLoaded.bind(this));
this.xhr.addEventListener("readystatechange", this.#checkStreamClosed.bind(this));
this.xhr.addEventListener("error", this.#onStreamFailure.bind(this));
this.xhr.addEventListener("abort", this.#onStreamAbort.bind(this));
this.xhr.open(this.method, this.url);
for (const header in this.headers) {
this.xhr.setRequestHeader(header, this.headers[header]);
}
if (this.last_event_id) this.xhr.setRequestHeader("Last-Event-ID", this.last_event_id);
this.xhr.withCredentials = this.withCredentials;
this.xhr.send(this.body);
}
/**
* Ends the streamer connection.
* Aborts the current XHR request and sets the ready state to CLOSED.
*/
end() {
if (this.readyState === this.CLOSED) return;
this.xhr.abort();
this.xhr = null;
this.#setReadyState(this.CLOSED);
}
#setReadyState(state) {
const event = new CustomEvent("readyStateChange");
event.readyState = state;
this.readyState = state;
this.dispatchEvent(event);
}
#onStreamFailure(e) {
const event = new CustomEvent("error");
try {
const parsed = JSON.parse(e.currentTarget.response);
if (typeof parsed === "object") {
event.data = parsed;
} else {
event.data = e.currentTarget.response;
}
} catch {
event.data = e.currentTarget.response;
}
this.dispatchEvent(event);
this.end();
}
#onStreamAbort(e) {
const event = new CustomEvent("abort");
this.end();
}
#onStreamProgress(e) {
if (!this.xhr) return;
if (this.xhr.status !== 200) {
this.#onStreamFailure(e);
return;
}
if (this.readyState === this.CONNECTING) {
this.dispatchEvent(new CustomEvent("open"));
this.#setReadyState(this.OPEN);
}
const data = this.xhr.responseText.substring(this.progress);
this.progress += data.length;
const parts = data.split(this.chunk_splitting_regex);
parts.forEach((part, index) => {
if (part.trim().length === 0) {
if (this.chunk) {
this.dispatchEvent(this.#parseEventChunk(this.chunk.trim()));
this.chunk = "";
}
} else {
this.chunk += part;
if (index === parts.length - 1 && this.xhr.readyState === XMLHttpRequest.DONE) {
this.dispatchEvent(this.#parseEventChunk(this.chunk.trim()));
this.chunk = "";
}
}
});
}
#onStreamLoaded(e) {
this.#onStreamProgress(e);
this.dispatchEvent(this.#parseEventChunk(this.chunk));
this.chunk = "";
}
#parseEventChunk(chunk) {
if (!chunk) return console.log("no chunk");
const event = new CustomEvent("message");
event.data = chunk;
event.last_event_id = this.last_event_id;
return event;
}
#checkStreamClosed() {
if (!this.xhr) return;
if (this.xhr.readyState === XMLHttpRequest.DONE) this.#setReadyState(this.CLOSED);
}
};

var SmartChatModelAdapter3 = class extends SmartModelAdapter3 {
static {
__name(this, "SmartChatModelAdapter");
}
/**
* @override in sub-class with adapter-specific default configurations
* @property {string} id - The adapter identifier
* @property {string} description - Human-readable description
* @property {string} type - Adapter type ("API")
* @property {string} endpoint - API endpoint
* @property {boolean} streaming - Whether streaming is supported
* @property {string} adapter - Adapter identifier
* @property {string} models_endpoint - Endpoint for retrieving models
* @property {string} default_model - Default model to use
* @property {string} signup_url - URL for API key signup
*/
static defaults = {};
/**
* Create a SmartChatModelAdapter instance.
* @param {SmartChatModel} model - The parent SmartChatModel instance
*/
constructor(model) {
super(model);
this.smart_chat = model;
this.main = model;
}
/**
* Complete a chat request.
* @abstract
* @param {Object} req - Request parameters
* @returns {Promise<Object>} Completion result
*/
async complete(req) {
throw new Error("complete not implemented");
}
/**
* Count tokens in input text.
* @abstract
* @param {string|Object} input - Text to count tokens for
* @returns {Promise<number>} Token count
*/
async count_tokens(input) {
throw new Error("count_tokens not implemented");
}
/**
* Stream chat responses.
* @abstract
* @param {Object} req - Request parameters
* @param {Object} handlers - Event handlers for streaming
* @returns {Promise<string>} Complete response text
*/
async stream(req, handlers = {}) {
throw new Error("stream not implemented");
}
/**
* Test if API key is valid.
* @abstract
* @returns {Promise<boolean>} True if API key is valid
*/
async test_api_key() {
throw new Error("test_api_key not implemented");
}
/**
* Refresh available models.
*/
refresh_models() {
console.log("refresh_models");
this.get_models(true);
}
/**
* Get settings configuration.
* @returns {Object} Settings configuration object
*/
get settings_config() {
return {
"[CHAT_ADAPTER].model_key": {
name: "Chat Model",
type: "dropdown",
description: "Select a chat model.",
options_callback: "adapter.get_models_as_options",
callback: "reload_model",
default: this.constructor.defaults.default_model
},
"[CHAT_ADAPTER].refresh_models": {
name: "Refresh Models",
type: "button",
description: "Refresh the list of available models.",
callback: "adapter.refresh_models"
}
};
}
};

var MODEL_ADAPTER_CACHE3 = {};
var MODELS_DEV_CACHE3 = { data: null, fetched_at: 0 };
var SmartChatModelApiAdapter3 = class extends SmartChatModelAdapter3 {
static {
__name(this, "SmartChatModelApiAdapter");
}
constructor(model) {
super(model);
this.model_data_loaded_at = 0;
}
/**
* Get the request adapter class.
* @returns {SmartChatModelRequestAdapter} The request adapter class
*/
get req_adapter() {
return SmartChatModelRequestAdapter3;
}
/**
* Get the response adapter class.
* @returns {SmartChatModelResponseAdapter} The response adapter class
*/
get res_adapter() {
return SmartChatModelResponseAdapter3;
}
/**
* Get or initialize the HTTP adapter.
* @returns {SmartHttpRequest} The HTTP adapter instance
*/
get http_adapter() {
if (!this._http_adapter) {
if (this.model.http_adapter) this._http_adapter = this.model.http_adapter;
else if (this.model.opts.http_adapter) this._http_adapter = this.model.opts.http_adapter;
else this._http_adapter = new SmartHttpRequest3({ adapter: SmartHttpRequestFetchAdapter3 });
}
return this._http_adapter;
}
/**
* Get the settings configuration for the API adapter.
* @deprecated migrating to module export
* @returns {Object} Settings configuration object with API key and other settings
*/
get settings_config() {
return {
...super.settings_config,
"[CHAT_ADAPTER].api_key": {
name: "API Key",
type: "password",
description: "Enter your API key for the chat model platform.",
callback: "test_api_key",
is_scope: true
}
};
}
/**
* Count tokens in the input text.
* @abstract
* @param {string|Object} input - Text or message object to count tokens for
* @returns {Promise<number>} Number of tokens in the input
*/
async count_tokens(input) {
throw new Error("count_tokens not implemented");
}
/**
* Get the parameters for requesting available models.
* @returns {Object} Request parameters for models endpoint
*/
get models_request_params() {
return {
url: this.models_endpoint,
method: this.models_endpoint_method,
headers: {
"Authorization": `Bearer ${this.api_key}`
}
};
}
async get_enriched_model_data() {
const provider_key = this.constructor.models_dev_key || this.constructor.key;
await this.get_models_dev_index();
const provider_data = MODELS_DEV_CACHE3.data[provider_key] || {};
const get_limit_i = /* @__PURE__ */ __name((model) => model.limit?.context || 1e4, "get_limit_i");
const get_limit_o = /* @__PURE__ */ __name((model) => model.limit?.output || 1e4, "get_limit_o");
const get_multimodal = /* @__PURE__ */ __name((model) => model.modalities?.input?.includes("image") || false, "get_multimodal");
if (Object.keys(this.model_data || {}).length > 0) {
for (const [key, model] of Object.entries(this.model_data)) {
const enriched = provider_data?.models?.[model.id];
if (!enriched) continue;
this.model_data[key].models_dev = enriched;
this.model_data[key].name = enriched.name || model.name;
this.model_data[key].max_input_tokens = get_limit_i(enriched);
this.model_data[key].max_output_tokens = get_limit_o(enriched);
this.model_data[key].multimodal = get_multimodal(enriched);
this.model_data[key].cost = enriched.cost;
}
} else {
for (const [key, model] of Object.entries(provider_data?.models || {})) {
this.model_data[key] = {
...model,
model_name: model.name,
description: model.name,
max_input_tokens: get_limit_i(model),
max_output_tokens: get_limit_o(model),
multimodal: get_multimodal(model)
};
}
}
return this.model_data;
}
valid_model_data() {
return typeof this.model_data === "object" && Object.keys(this.model_data || {}).length > 0 && this.model_data_loaded_at && Date.now() - this.model_data_loaded_at < 1 * 60 * 60 * 1e3;
}
/**
* Get available models from the API.
* @param {boolean} [refresh=false] - Whether to refresh cached models
* @returns {Promise<Object>} Map of model objects
*/
async get_models(refresh = false) {
if (!refresh && this.valid_model_data()) return this.model_data;
if (this.api_key) {
let response;
try {
response = await this.http_adapter.request(this.models_request_params);
this.model_data = this.parse_model_data(await response.json());
} catch (error) {
console.error("Failed to fetch model data:", { error, response });
}
}
this.model_data = await this.get_enriched_model_data();
this.model_data_loaded_at = Date.now();
if (this.model.data) {
this.model.data.provider_models = this.model_data;
}
if (this.valid_model_data() && typeof this.model.re_render_settings === "function") setTimeout(() => {
this.model.re_render_settings();
}, 100);
else console.warn("Invalid model data, not re-rendering settings");
return this.model_data;
}
/**
* Parses the raw model data from OpenAI API and transforms it into a more usable format.
* @param {Object} model_data - The raw model data received from OpenAI API.
* @abstract
* @returns {Array<Object>} An array of parsed model objects with the following properties:
*   @property {string} model_name - The name/ID of the model as returned by the API.
*   @property {string} id - The id used to identify the model (usually same as model_name).
*   @property {boolean} multimodal - Indicates if the model supports multimodal inputs.
*   @property {number} [max_input_tokens] - The maximum number of input tokens the model can process.
*   @property {string} [description] - A description of the model's context and output capabilities.
*/
parse_model_data(model_data) {
throw new Error("parse_model_data not implemented");
}
/**
* Complete a chat request.
* @param {Object} req - Request parameters
* @returns {Promise<Object>} Completion response in OpenAI format
*/
async complete(req) {
const _req = new this.req_adapter(this, {
...req,
stream: false
});
const request_params = _req.to_platform();
const http_resp = await this.http_adapter.request(request_params);
if (!http_resp) return null;
const _res = new this.res_adapter(this, await http_resp.json());
try {
const resp = _res.to_openai();
return resp;
} catch (error) {
const normalized_error = normalize_error3(error?.data || error);
console.error("Error in SmartChatModelApiAdapter.complete():", { normalized_error, error });
console.error(http_resp);
return normalized_error;
}
}
/**
* Stream chat responses.
* @param {Object} req - Request parameters
* @param {Object} handlers - Event handlers for streaming
* @param {Function} handlers.chunk - Handler for response objects
* @param {Function} handlers.error - Handler for errors
* @param {Function} handlers.done - Handler for completion
* @returns {Promise<Object>} Complete response object
*/
async stream(req, handlers = {}) {
const _req = new this.req_adapter(this, req);
const request_params = _req.to_platform(true);
if (this.streaming_chunk_splitting_regex) request_params.chunk_splitting_regex = this.streaming_chunk_splitting_regex;
return await new Promise((resolve, reject) => {
try {
this.active_stream = new SmartStreamer3(this.endpoint_streaming, request_params);
const resp_adapter = new this.res_adapter(this);
this.active_stream.addEventListener("message", async (e) => {
if (this.is_end_of_stream(e)) {
await resp_adapter.handle_chunk(e.data);
this.stop_stream();
const final_resp = resp_adapter.to_openai();
handlers.done && await handlers.done(final_resp);
resolve(final_resp);
return;
}
try {
const raw = resp_adapter.handle_chunk(e.data);
handlers.chunk && await handlers.chunk({ ...resp_adapter.to_openai(), raw });
} catch (error) {
const normalized_error = normalize_error3({ ...e.data, ...error });
console.error("Error processing stream chunk:", { e, error, normalized_error });
handlers.error && handlers.error(normalized_error);
this.stop_stream();
reject(normalized_error);
}
});
this.active_stream.addEventListener("error", (e) => {
console.error("Stream error:", e);
const normalized_error = normalize_error3(e?.data || e);
handlers.error && handlers.error(normalized_error);
this.stop_stream();
reject(normalized_error);
});
this.active_stream.stream();
} catch (err) {
console.error("Failed to start stream:", err);
const normalized_error = normalize_error3(err?.data || err);
handlers.error && handlers.error(normalized_error);
this.stop_stream();
reject(normalized_error);
}
});
}
/**
* Check if a stream event indicates end of stream.
* @param {Event} event - Stream event
* @returns {boolean} True if end of stream
*/
is_end_of_stream(event) {
return event.data === "data: [DONE]";
}
/**
* Stop active stream.
*/
stop_stream() {
if (this.active_stream) {
this.active_stream.end();
this.active_stream = null;
}
}
/**
* Get the API key.
* @returns {string} The API key.
*/
get api_key() {
return this.model.api_key || this.main.opts.api_key;
}
get models_endpoint() {
return this.constructor.defaults.models_endpoint;
}
get models_endpoint_method() {
return "POST";
}
/**
* Get the endpoint URL.
* @returns {string} The endpoint URL.
*/
get endpoint() {
return this.constructor.defaults.endpoint;
}
/**
* Get the streaming endpoint URL.
* @returns {string} The streaming endpoint URL.
*/
get endpoint_streaming() {
return this.constructor.defaults.endpoint_streaming || this.endpoint;
}
/**
* Get the maximum output tokens.
* @returns {number} The maximum output tokens.
*/
get max_output_tokens() {
return this.model.data.max_output_tokens || 3e3;
}
async get_models_dev_index(ttl_ms = 60 * 60 * 1e3) {
const now = Date.now();
if (MODELS_DEV_CACHE3?.data && now - MODELS_DEV_CACHE3?.fetched_at < ttl_ms) {
return MODELS_DEV_CACHE3.data;
}
try {
const req = {
url: "https://models.dev/api.json",
method: "GET",
headers: { "Content-Type": "application/json" }
};
const resp = await this.http_adapter.request(req);
const data = await resp.json();
MODELS_DEV_CACHE3.data = data;
MODELS_DEV_CACHE3.fetched_at = now;
console.log({ MODELS_DEV_CACHE: MODELS_DEV_CACHE3 });
return data;
} catch (err) {
console.warn("models.dev fetch failed; continuing without enrichment", err);
return MODELS_DEV_CACHE3.data || [];
}
}
/**
* Get available models as dropdown options synchronously.
* @returns {Array<Object>} Array of model options.
*/
get_models_as_options() {
if (Object.keys(this.model_data || {}).length) {
return Object.entries(this.model_data).map(([id, model]) => ({ value: id, name: model.name || id })).sort((a, b) => a.name.localeCompare(b.name));
}
this.get_models(true);
return [{ value: "", name: "No models currently available" }];
}
get model_data() {
if (!MODEL_ADAPTER_CACHE3[this.constructor.key]) MODEL_ADAPTER_CACHE3[this.constructor.key] = {};
return MODEL_ADAPTER_CACHE3[this.constructor.key];
}
set model_data(data) {
if (!MODEL_ADAPTER_CACHE3[this.constructor.key]) MODEL_ADAPTER_CACHE3[this.constructor.key] = {};
MODEL_ADAPTER_CACHE3[this.constructor.key] = data;
}
};
var SmartChatModelRequestAdapter3 = class {
static {
__name(this, "SmartChatModelRequestAdapter");
}
/**
* @constructor
* @param {SmartChatModelAdapter} adapter - The SmartChatModelAdapter instance
* @param {Object} req - The incoming request object
*/
constructor(adapter, req = {}) {
this.adapter = adapter;
this._req = req;
}
/**
* Get the messages array from the request
* @returns {Array<Object>} Array of message objects
*/
get messages() {
return this._req.messages || [];
}
/**
* Get the model identifier
* @returns {string} Model ID
*/
get model_id() {
return this._req.model || this.adapter.model.model_key || this.adapter.model.data.id;
}
/**
* Get the temperature setting
* @returns {number} Temperature value
*/
get temperature() {
return this._req.temperature;
}
/**
* Get the maximum tokens setting
* @returns {number} Max tokens value
*/
get max_tokens() {
return this._req.max_tokens || this.adapter.max_output_tokens;
}
/**
* Get the streaming flag
* @returns {boolean} Whether to stream responses
*/
get stream() {
return this._req.stream;
}
/**
* Get the tools array
* @returns {Array<Object>|null} Array of tool objects or null
*/
get tools() {
return this._req.tools || null;
}
/**
* Get the tool choice setting
* @returns {string|Object|null} Tool choice configuration
*/
get tool_choice() {
return this._req.tool_choice || null;
}
get frequency_penalty() {
return this._req.frequency_penalty;
}
get presence_penalty() {
return this._req.presence_penalty;
}
get top_p() {
return this._req.top_p;
}
/**
* Get request headers
* @returns {Object} Headers object
*/
get_headers() {
const headers = {
"Content-Type": "application/json",
...this.adapter.constructor.defaults.headers || {}
};
const api_key_header = this.adapter.constructor.defaults.api_key_header;
if (api_key_header !== "none") {
if (api_key_header) {
headers[api_key_header] = this.adapter.api_key;
} else if (this.adapter.api_key) {
headers["Authorization"] = `Bearer ${this.adapter.api_key}`;
}
}
return headers;
}
/**
* Convert request to platform-specific format
* @returns {Object} Platform-specific request parameters
*/
to_platform(streaming = false) {
return this.to_openai(streaming);
}
/**
* Convert request to OpenAI format
* @returns {Object} Request parameters in OpenAI format
*/
to_openai(streaming = false) {
const body = {
messages: this._transform_messages_to_openai(),
model: this.model_id,
temperature: this.temperature,
stream: streaming,
...this.tools && { tools: this._transform_tools_to_openai() }
};
if (body.tools?.length > 0 && this.tool_choice && this.tool_choice !== "none") {
body.tool_choice = this.tool_choice;
}
if (this.model_id?.startsWith("o1-")) {
body.messages = body.messages.filter((m) => m.role !== "system");
delete body.temperature;
}
if (typeof this._req.top_p === "number") body.top_p = this._req.top_p;
if (typeof this._req.presence_penalty === "number") body.presence_penalty = this._req.presence_penalty;
if (typeof this._req.frequency_penalty === "number") body.frequency_penalty = this._req.frequency_penalty;
return {
url: this.adapter.endpoint,
method: "POST",
headers: this.get_headers(),
body: JSON.stringify(body)
};
}
/**
* Transform messages to OpenAI format
* @returns {Array<Object>} Transformed messages array
* @private
*/
_transform_messages_to_openai() {
return this.messages.map((message) => this._transform_single_message_to_openai(message));
}
/**
* Transform a single message to OpenAI format
* @param {Object} message - Message object to transform
* @returns {Object} Transformed message object
* @private
*/
_transform_single_message_to_openai(message) {
const transformed = {
role: this._get_openai_role(message.role),
content: this._get_openai_content(message)
};
if (message.name) transformed.name = message.name;
if (message.tool_calls) transformed.tool_calls = this._transform_tool_calls_to_openai(message.tool_calls);
if (message.image_url) transformed.image_url = message.image_url;
if (message.tool_call_id) transformed.tool_call_id = message.tool_call_id;
return transformed;
}
/**
* Get the OpenAI role for a given role.
* @param {string} role - The role to transform.
* @returns {string} The transformed role.
* @private
*/
_get_openai_role(role) {
return role;
}
/**
* Get the OpenAI content for a given content.
* @param {string} content - The content to transform.
* @returns {string} The transformed content.
* @private
*/
_get_openai_content(message) {
return message.content;
}
/**
* Transform tool calls to OpenAI format.
* @param {Array} tool_calls - Array of tool call objects.
* @returns {Array} Transformed tool calls array.
* @private
*/
_transform_tool_calls_to_openai(tool_calls) {
return tool_calls.map((tool_call) => ({
id: tool_call.id,
type: tool_call.type,
function: {
name: tool_call.function.name,
arguments: tool_call.function.arguments
}
}));
}
/**
* Transform tools to OpenAI format.
* @returns {Array} Transformed tools array.
* @private
*/
_transform_tools_to_openai() {
return this.tools.map((tool2) => ({
type: tool2.type,
function: {
name: tool2.function.name,
description: tool2.function.description,
parameters: tool2.function.parameters
}
}));
}
};
var SmartChatModelResponseAdapter3 = class {
static {
__name(this, "SmartChatModelResponseAdapter");
}
static get platform_res() {
return {
id: "",
object: "chat.completion",
created: 0,
model: "",
choices: [],
usage: {}
};
}
/**
* @constructor
* @param {SmartChatModelAdapter} adapter - The SmartChatModelAdapter instance
* @param {Object} res - The response object
*/
constructor(adapter, res, status = null) {
this.adapter = adapter;
this._res = res || this.constructor.platform_res;
this.status = status;
}
/**
* Get response ID
* @returns {string|null} Response ID
*/
get id() {
return this._res.id || null;
}
/**
* Get response object type
* @returns {string|null} Object type
*/
get object() {
return this._res.object || null;
}
/**
* Get creation timestamp
* @returns {number|null} Creation timestamp
*/
get created() {
return this._res.created || null;
}
/**
* Get response choices
* @returns {Array<Object>} Array of choice objects
*/
get choices() {
return this._res.choices || [];
}
/**
* Get first tool call if present
* @returns {Object|null} Tool call object
*/
get tool_call() {
return this.message.tool_calls?.[0] || null;
}
/**
* Get tool name from first tool call
* @returns {string|null} Tool name
*/
get tool_name() {
return this.tool_call?.tool_name || null;
}
/**
* Get tool call parameters
* @returns {Object|null} Tool parameters
*/
get tool_call_content() {
return this.tool_call?.parameters || null;
}
/**
* Get token usage statistics
* @returns {Object|null} Usage statistics
*/
get usage() {
return this._res.usage || null;
}
get error() {
return this._res.error || null;
}
/**
* Convert response to OpenAI format
* @returns {Object} Response in OpenAI format
*/
to_openai() {
if (this.error) return { error: normalize_error3(this.error, this.status) };
const res = {
id: this.id,
object: this.object,
created: this.created,
choices: this._transform_choices_to_openai(),
usage: this._transform_usage_to_openai(),
raw: this._res
};
return res;
}
/**
* Parse chunk adds delta to content as expected output format
*/
handle_chunk(chunk) {
if (chunk === "data: [DONE]") return;
chunk = JSON.parse(chunk.split("data: ")[1] || "{}");
if (Object.keys(chunk).length === 0) return;
if (!this._res.choices[0]) {
this._res.choices.push({
message: {
index: 0,
role: "assistant",
content: ""
}
});
}
if (!this._res.id) {
this._res.id = chunk.id;
}
let raw;
if (chunk.choices?.[0]?.delta?.content) {
const content = chunk.choices[0].delta.content;
raw = content;
this._res.choices[0].message.content += content;
}
if (chunk.choices?.[0]?.delta?.tool_calls) {
if (!this._res.choices[0].message.tool_calls) {
this._res.choices[0].message.tool_calls = [{
id: "",
type: "function",
function: {
name: "",
arguments: ""
}
}];
}
if (chunk.choices[0].delta.tool_calls[0].id) {
this._res.choices[0].message.tool_calls[0].id += chunk.choices[0].delta.tool_calls[0].id;
}
if (chunk.choices[0].delta.tool_calls[0].function.name) {
this._res.choices[0].message.tool_calls[0].function.name += chunk.choices[0].delta.tool_calls[0].function.name;
}
if (chunk.choices[0].delta.tool_calls[0].function.arguments) {
this._res.choices[0].message.tool_calls[0].function.arguments += chunk.choices[0].delta.tool_calls[0].function.arguments;
}
}
return raw;
}
/**
* Transform choices to OpenAI format.
* @returns {Array} Transformed choices array.
* @private
*/
_transform_choices_to_openai() {
return this.choices.map((choice) => ({
index: choice.index,
message: this._transform_message_to_openai(choice.message),
finish_reason: this._get_openai_finish_reason(choice.finish_reason)
}));
}
/**
* Transform a single message to OpenAI format.
* @param {Object} message - The message object to transform.
* @returns {Object} Transformed message object.
* @private
*/
_transform_message_to_openai(message = {}) {
const transformed = {
role: this._get_openai_role(message.role),
content: this._get_openai_content(message)
};
if (message.name) transformed.name = message.name;
if (message.tool_calls) transformed.tool_calls = this._transform_tool_calls_to_openai(message.tool_calls);
if (message.image_url) transformed.image_url = message.image_url;
return transformed;
}
/**
* Get the OpenAI role for a given role.
* @param {string} role - The role to transform.
* @returns {string} The transformed role.
* @private
*/
_get_openai_role(role) {
return role;
}
/**
* Get the OpenAI content for a given content.
* @param {string} content - The content to transform.
* @returns {string} The transformed content.
* @private
*/
_get_openai_content(message) {
return message.content;
}
/**
* Get the OpenAI finish reason for a given finish reason.
* @param {string} finish_reason - The finish reason to transform.
* @returns {string} The transformed finish reason.
* @private
*/
_get_openai_finish_reason(finish_reason) {
return finish_reason;
}
/**
* Transform usage to OpenAI format.
* @returns {Object} Transformed usage object.
* @private
*/
_transform_usage_to_openai() {
return this.usage;
}
/**
* Transform tool calls to OpenAI format.
* @param {Array} tool_calls - Array of tool call objects.
* @returns {Array} Transformed tool calls array.
* @private
*/
_transform_tool_calls_to_openai(tool_calls) {
return tool_calls.map((tool_call) => ({
id: tool_call.id,
type: tool_call.type,
function: {
name: tool_call.function.name,
arguments: tool_call.function.arguments
}
}));
}
};

var SmartChatModelAnthropicAdapter2 = class extends SmartChatModelApiAdapter3 {
static {
__name(this, "SmartChatModelAnthropicAdapter");
}
static key = "anthropic";
static defaults = {
description: "Anthropic Claude",
type: "API",
endpoint: "https://api.anthropic.com/v1/messages",
streaming: true,
api_key_header: "x-api-key",
headers: {
"anthropic-version": "2023-06-01",
"anthropic-beta": "tools-2024-04-04",
"anthropic-dangerous-direct-browser-access": true
},
adapter: "Anthropic",
models_endpoint: false,
default_model: "claude-opus-4-1-20250805",
signup_url: "https://console.anthropic.com/login?returnTo=%2Fsettings%2Fkeys"
};
/**
* Get request adapter class
* @returns {typeof SmartChatModelAnthropicRequestAdapter} Request adapter class
*/
get req_adapter() {
return SmartChatModelAnthropicRequestAdapter2;
}
/**
* Get response adapter class
* @returns {typeof SmartChatModelAnthropicResponseAdapter} Response adapter class
*/
res_adapter = SmartChatModelAnthropicResponseAdapter2;
/**
* Get available models (hardcoded list) and enrich via models.dev
* @returns {Promise<Object>} Map of model objects
*/
async get_models() {
try {
this.model_data = await this.get_enriched_model_data();
this.model_data_loaded_at = Date.now();
this.model.data.provider_models = this.model_data;
setTimeout(() => {
this.model.re_render_settings();
}, 100);
return this.model_data;
} catch {
return this.anthropic_models;
}
}
is_end_of_stream(event) {
return event.data.includes("message_stop");
}
/**
* Get hardcoded list of available models
* @deprecated use get_enriched_model_data() instead (remove after no-incidents)
* @returns {Object} Map of model objects with capabilities and limits
*/
get anthropic_models() {
return {
"claude-opus-4-1-20250805": {
name: "Claude Opus 4.1 (2025-08-05)",
id: "claude-opus-4-1-20250805",
model_name: "claude-opus-4-1-20250805",
description: "Anthropic Claude Opus 4.1 snapshot (2025-08-05)",
max_input_tokens: 2e5,
max_output_tokens: 32e3,
multimodal: true
},
"claude-opus-4-20250514": {
name: "Claude Opus 4 (2025-05-14)",
id: "claude-opus-4-20250514",
model_name: "claude-opus-4-20250514",
description: "Anthropic Claude Opus 4 snapshot (2025-05-14)",
max_input_tokens: 2e5,
max_output_tokens: 32e3,
multimodal: true
},
"claude-sonnet-4-20250514": {
name: "Claude Sonnet 4 (2025-05-14)",
id: "claude-sonnet-4-20250514",
model_name: "claude-sonnet-4-20250514",
description: "Anthropic Claude Sonnet 4 snapshot (2025-05-14)",
max_input_tokens: 2e5,
max_output_tokens: 64e3,
multimodal: true
},
"claude-3-7-sonnet-latest": {
name: "Claude 3.7 Sonnet (latest)",
id: "claude-3-7-sonnet-latest",
model_name: "claude-3-7-sonnet-latest",
description: "Anthropic Claude 3.7 Sonnet (rolling-latest)",
max_input_tokens: 2e5,
max_output_tokens: 64e3,
multimodal: true
},
"claude-3-7-sonnet-20250219": {
name: "Claude 3.7 Sonnet (2025-02-19)",
id: "claude-3-7-sonnet-20250219",
model_name: "claude-3-7-sonnet-20250219",
description: "Anthropic Claude 3.7 Sonnet snapshot (2025-02-19)",
max_input_tokens: 2e5,
max_output_tokens: 64e3,
multimodal: true
},
"claude-3-5-sonnet-latest": {
name: "Claude 3.5 Sonnet (latest)",
id: "claude-3-5-sonnet-latest",
model_name: "claude-3-5-sonnet-latest",
description: "Anthropic Claude 3.5 Sonnet (rolling-latest)",
max_input_tokens: 2e5,
max_output_tokens: 8192,
multimodal: true
},
"claude-3-5-sonnet-20241022": {
name: "Claude 3.5 Sonnet (2024-10-22)",
id: "claude-3-5-sonnet-20241022",
model_name: "claude-3-5-sonnet-20241022",
description: "Anthropic Claude 3.5 Sonnet snapshot (2024-10-22)",
max_input_tokens: 2e5,
max_output_tokens: 8192,
multimodal: true
},
"claude-3-5-haiku-latest": {
name: "Claude 3.5 Haiku (latest)",
id: "claude-3-5-haiku-latest",
model_name: "claude-3-5-haiku-latest",
description: "Anthropic Claude 3.5 Haiku (rolling-latest)",
max_input_tokens: 2e5,
max_output_tokens: 8192
},
"claude-3-5-haiku-20241022": {
name: "Claude 3.5 Haiku (2024-10-22)",
id: "claude-3-5-haiku-20241022",
model_name: "claude-3-5-haiku-20241022",
description: "Anthropic Claude 3.5 Haiku snapshot (2024-10-22)",
max_input_tokens: 2e5,
max_output_tokens: 8192
},
"claude-3-opus-latest": {
name: "Claude 3 Opus (latest)",
id: "claude-3-opus-latest",
model_name: "claude-3-opus-latest",
description: "Anthropic Claude 3 Opus (rolling-latest)",
max_input_tokens: 2e5,
max_output_tokens: 4096,
multimodal: true
},
"claude-3-opus-20240229": {
name: "Claude 3 Opus (2024-02-29)",
id: "claude-3-opus-20240229",
model_name: "claude-3-opus-20240229",
description: "Anthropic Claude 3 Opus snapshot (2024-02-29)",
max_input_tokens: 2e5,
max_output_tokens: 4096,
multimodal: true
},
"claude-3-sonnet-20240229": {
name: "Claude 3 Sonnet (2024-02-29)",
id: "claude-3-sonnet-20240229",
model_name: "claude-3-sonnet-20240229",
description: "Anthropic Claude 3 Sonnet snapshot (2024-02-29)",
max_input_tokens: 2e5,
max_output_tokens: 4096,
multimodal: true
},
"claude-3-haiku-20240307": {
name: "Claude 3 Haiku (2024-03-07)",
id: "claude-3-haiku-20240307",
model_name: "claude-3-haiku-20240307",
description: "Anthropic Claude 3 Haiku snapshot (2024-03-07)",
max_input_tokens: 2e5,
max_output_tokens: 4096,
multimodal: true
}
};
}
};
var SmartChatModelAnthropicRequestAdapter2 = class extends SmartChatModelRequestAdapter3 {
static {
__name(this, "SmartChatModelAnthropicRequestAdapter");
}
/**
* Convert request to Anthropic format
* @returns {Object} Request parameters in Anthropic format
*/
to_platform(streaming = false) {
return this.to_anthropic(streaming);
}
/**
* Convert request to Anthropic format
* @returns {Object} Request parameters in Anthropic format
*/
to_anthropic(streaming = false) {
this.anthropic_body = {
model: this.model_id,
max_tokens: this.max_tokens,
temperature: this.temperature,
stream: streaming
};
this.anthropic_body.messages = this._transform_messages_to_anthropic();
if (this.tools) {
this.anthropic_body.tools = this._transform_tools_to_anthropic();
}
if (this.tool_choice) {
this.anthropic_body.tool_choice = this.tool_choice === "auto" ? { type: "auto" } : { type: "tool", name: this.tool_choice.function.name };
}
return {
url: this.adapter.endpoint,
method: "POST",
headers: this.get_headers(),
body: JSON.stringify(this.anthropic_body)
};
}
/**
* Transform messages to Anthropic format
* @returns {Array<Object>} Messages in Anthropic format
* @private
*/
_transform_messages_to_anthropic() {
let anthropic_messages = [];
for (const message of this.messages) {
if (message.role === "system") {
if (!this.anthropic_body.system) this.anthropic_body.system = "";
else this.anthropic_body.system += "\n\n";
this.anthropic_body.system += Array.isArray(message.content) ? message.content.map((part) => part.text).join("\n") : message.content;
} else if (message.role === "tool") {
const msg = {
role: "user",
content: [
{
type: "tool_result",
tool_use_id: message.tool_call_id,
content: message.content
}
]
};
anthropic_messages.push(msg);
} else {
const msg = {
role: this._get_anthropic_role(message.role),
content: this._get_anthropic_content(message.content)
};
if (message.tool_calls?.length > 0) msg.content = this._transform_tool_calls_to_content(message.tool_calls);
anthropic_messages.push(msg);
}
}
return anthropic_messages;
}
/**
* Transform tool calls to Anthropic format
* @param {Array<Object>} tool_calls - Tool calls
* @returns {Array<Object>} Tool calls in Anthropic format
* @private
*/
_transform_tool_calls_to_content(tool_calls) {
return tool_calls.map((tool_call) => ({
type: "tool_use",
id: tool_call.id,
name: tool_call.function.name,
input: JSON.parse(tool_call.function.arguments)
}));
}
/**
* Transform role to Anthropic format
* @param {string} role - Original role
* @returns {string} Role in Anthropic format
* @private
*/
_get_anthropic_role(role) {
const role_map = {
function: "assistant",
tool: "user"
};
return role_map[role] || role;
}
/**
* Transform content to Anthropic format
* @param {string|Array} content - Original content
* @returns {string|Array} Content in Anthropic format
* @private
*/
_get_anthropic_content(content) {
if (Array.isArray(content)) {
return content.map((item) => {
if (item.type === "text") return { type: "text", text: item.text };
if (item.type === "image_url") {
return {
type: "image",
source: {
type: "base64",
media_type: item.image_url.url.split(";")[0].split(":")[1],
data: item.image_url.url.split(",")[1]
}
};
}
if (item.type === "file" && item.file?.filename?.toLowerCase().endsWith(".pdf")) {
if (item.file?.file_data) {
return {
type: "document",
source: {
type: "base64",
media_type: "application/pdf",
data: item.file.file_data.split(",")[1]
}
};
}
}
return item;
});
}
return content;
}
/**
* Transform tools to Anthropic format
* @returns {Array<Object>} Tools in Anthropic format
* @private
*/
_transform_tools_to_anthropic() {
if (!this.tools) return void 0;
return this.tools.map((tool2) => ({
name: tool2.function.name,
description: tool2.function.description,
input_schema: tool2.function.parameters
}));
}
};
var SmartChatModelAnthropicResponseAdapter2 = class extends SmartChatModelResponseAdapter3 {
static {
__name(this, "SmartChatModelAnthropicResponseAdapter");
}
static get platform_res() {
return {
content: [],
id: "",
model: "",
role: "assistant",
stop_reason: null,
stop_sequence: null,
type: "message",
usage: {
input_tokens: 0,
output_tokens: 0
}
};
}
/**
* Convert response to OpenAI format
* @returns {Object} Response in OpenAI format
*/
to_openai() {
if (this.error) return { error: normalize_error3(this.error, this.status) };
return {
id: this._res.id,
object: "chat.completion",
created: Date.now(),
choices: [
{
index: 0,
message: this._transform_message_to_openai(),
finish_reason: this._get_openai_finish_reason(this._res.stop_reason)
}
],
usage: this._transform_usage_to_openai()
};
}
/**
* Transform message to OpenAI format
* @returns {Object} Message in OpenAI format
* @private
*/
_transform_message_to_openai() {
const message = {
role: "assistant",
content: "",
tool_calls: []
};
if (Array.isArray(this._res.content)) {
for (const content of this._res.content) {
if (content.type === "text") {
message.content += (message.content ? "\n\n" : "") + content.text;
} else if (content.type === "tool_use") {
message.tool_calls.push({
id: content.id,
type: "function",
function: {
name: content.name,
arguments: JSON.stringify(content.input)
}
});
}
}
} else {
message.content = this._res.content;
}
if (message.tool_calls.length === 0) {
delete message.tool_calls;
}
return message;
}
/**
* Transform finish reason to OpenAI format
* @param {string} stop_reason - Original finish reason
* @returns {string} Finish reason in OpenAI format
* @private
*/
_get_openai_finish_reason(stop_reason) {
const reason_map = {
"end_turn": "stop",
"max_tokens": "length",
"tool_use": "function_call"
};
return reason_map[stop_reason] || stop_reason;
}
/**
* Transform usage statistics to OpenAI format
* @returns {Object} Usage statistics in OpenAI format
* @private
*/
_transform_usage_to_openai() {
if (!this._res.usage) {
return {
prompt_tokens: 0,
completion_tokens: 0,
total_tokens: 0
};
}
return {
prompt_tokens: this._res.usage.input_tokens || 0,
completion_tokens: this._res.usage.output_tokens || 0,
total_tokens: (this._res.usage.input_tokens || 0) + (this._res.usage.output_tokens || 0)
};
}
handle_chunk(chunk) {
if (!chunk.startsWith("data: ")) return;
chunk = JSON.parse(chunk.slice(6));
if (!this._res.content.length) {
this._res.content = [
{
type: "text",
text: ""
}
];
}
if (chunk.message?.id) {
this._res.id = chunk.message.id;
}
if (chunk.message?.model) {
this._res.model = chunk.message.model;
}
if (chunk.message?.role) {
this._res.role = chunk.message.role;
}
let raw;
if (chunk.delta?.type === "text_delta") {
const content = chunk.delta?.text;
raw = content;
this._res.content[0].text += content;
}
if (chunk.delta?.stop_reason) {
this._res.stop_reason = chunk.delta.stop_reason;
}
if (chunk.usage) {
this._res.usage = {
...this._res.usage,
...chunk.usage
};
}
return raw;
}
};

var EXCLUDED_PREFIXES2 = [
"text-",
"davinci",
"babbage",
"ada",
"curie",
"dall-e",
"whisper",
"omni",
"tts",
"gpt-4o-mini-tts",
"computer-use",
"codex",
"gpt-4o-transcribe",
"gpt-4o-mini-transcribe",
"gpt-4o-mini-realtime",
"gpt-4o-realtime",
"o4-mini-deep-research",
"o3-deep-research",
"gpt-image"
];
var SmartChatModelOpenaiAdapter2 = class extends SmartChatModelApiAdapter3 {
static {
__name(this, "SmartChatModelOpenaiAdapter");
}
static key = "openai";
static defaults = {
description: "OpenAI",
type: "API",
endpoint: "https://api.openai.com/v1/chat/completions",
streaming: true,
models_endpoint: "https://api.openai.com/v1/models",
default_model: "gpt-5-nano",
signup_url: "https://platform.openai.com/api-keys"
};
res_adapter = SmartChatModelOpenaiResponseAdapter2;
/**
* Parse model data from OpenAI API response.
* Filters for GPT models and adds context window information.
* @param {Object} model_data - Raw model data from OpenAI
* @returns {Object} Map of model objects with capabilities and limits
*/
parse_model_data(model_data) {
return model_data.data.filter((model) => !EXCLUDED_PREFIXES2.some((m) => model.id.startsWith(m)) && !model.id.includes("-instruct")).reduce((acc, model) => {
const out = {
model_name: model.id,
id: model.id,
multimodal: true,
max_input_tokens: get_max_input_tokens2(model.id)
};
acc[model.id] = out;
return acc;
}, {});
}
/**
* Override the HTTP method for fetching models.
*/
models_endpoint_method = "GET";
/**
* Test the API key by attempting to fetch models.
* @returns {Promise<boolean>} True if API key is valid
*/
async test_api_key() {
const models = await this.get_models();
return models.length > 0;
}
/**
* Get settings configuration for OpenAI adapter.
* Adds image resolution setting for multimodal models.
* @returns {Object} Settings configuration object
*/
get settings_config() {
const config = super.settings_config;
config["[CHAT_ADAPTER].open_ai_note"] = {
name: "Note about using OpenAI",
type: "html",
value: "<b>OpenAI models:</b> Some models require extra verification steps in your OpenAI account for them to appear in the model list."
};
return config;
}
};
function get_max_input_tokens2(model_id) {
if (model_id.startsWith("gpt-4.1")) {
return 1e6;
}
if (model_id.startsWith("o")) {
return 2e5;
}
if (model_id.startsWith("gpt-5")) {
return 4e5;
}
if (model_id.startsWith("gpt-4o") || model_id.startsWith("gpt-4.5") || model_id.startsWith("gpt-4-turbo")) {
return 128e3;
}
if (model_id.startsWith("gpt-4")) {
return 8192;
}
if (model_id.startsWith("gpt-3")) {
return 16385;
}
return 8e3;
}
__name(get_max_input_tokens2, "get_max_input_tokens");
var SmartChatModelOpenaiResponseAdapter2 = class extends SmartChatModelResponseAdapter3 {
static {
__name(this, "SmartChatModelOpenaiResponseAdapter");
}
};

var SmartChatModelAzureAdapter2 = class extends SmartChatModelOpenaiAdapter2 {
static {
__name(this, "SmartChatModelAzureAdapter");
}
static key = "azure";
static defaults = {
description: "Azure OpenAI",
type: "API",
adapter: "AzureOpenAI",
streaming: true,
api_key_header: "api-key",
azure_resource_name: "",
azure_deployment_name: "",
azure_api_version: "2024-10-01-preview",
default_model: "gpt-35-turbo",
signup_url: "https://learn.microsoft.com/azure/cognitive-services/openai/quickstart?tabs=command-line",
models_endpoint: "https://{azure_resource_name}.openai.azure.com/openai/deployments?api-version={azure_api_version}"
};
/**
* Override the settings configuration to include Azure-specific fields.
*/
get settings_config() {
return {
...super.settings_config,
"[CHAT_ADAPTER].azure_resource_name": {
name: "Azure Resource Name",
type: "text",
description: "The name of your Azure OpenAI resource (e.g. 'my-azure-openai').",
default: ""
},
"[CHAT_ADAPTER].azure_deployment_name": {
name: "Azure Deployment Name",
type: "text",
description: "The name of your specific model deployment (e.g. 'gpt35-deployment').",
default: ""
},
"[CHAT_ADAPTER].azure_api_version": {
name: "Azure API Version",
type: "text",
description: "The API version for Azure OpenAI (e.g. '2024-10-01-preview').",
default: "2024-10-01-preview"
}
};
}
/**
* Build the endpoint dynamically based on Azure settings.
* Example:
*  https://<RESOURCE>.openai.azure.com/openai/deployments/<DEPLOYMENT>/chat/completions?api-version=2023-05-15
*/
get endpoint() {
const { azure_resource_name, azure_deployment_name, azure_api_version } = this.model.data;
return `https://${azure_resource_name}.openai.azure.com/openai/deployments/${azure_deployment_name}/chat/completions?api-version=${azure_api_version}`;
}
/**
* For streaming, we can reuse the same endpoint.
* The request body includes `stream: true` which the base class uses.
*/
get endpoint_streaming() {
return this.endpoint;
}
/**
* The models endpoint for retrieving a list of your deployments.
* E.g.:
*   https://<RESOURCE>.openai.azure.com/openai/deployments?api-version=2023-05-15
*/
get models_endpoint() {
const { azure_resource_name, azure_api_version } = this.model.data;
return `https://${azure_resource_name}.openai.azure.com/openai/deployments?api-version=${azure_api_version}`;
}
/**
* Azure returns a list of deployments in the shape:
* {
*   "object": "list",
*   "data": [
*     {
*       "id": "mydeployment",
*       "model": "gpt-35-turbo",
*       "status": "succeeded",
*       "createdAt": ...
*       "updatedAt": ...
*       ...
*     },
*     ...
*   ]
* }
* We'll parse them into a dictionary keyed by deployment ID.
*/
parse_model_data(model_data) {
if (model_data.object !== "list" || !Array.isArray(model_data.data)) {
return { "_": { id: "No deployments found." } };
}
const parsed = {};
for (const d of model_data.data) {
parsed[d.id] = {
model_name: d.id,
id: d.id,
raw: d,
description: `Model: ${d.model}, Status: ${d.status}`,
max_input_tokens: 4e3
};
}
return parsed;
}
};

var SmartChatModelGoogleAdapter2 = class extends SmartChatModelApiAdapter3 {
static {
__name(this, "SmartChatModelGoogleAdapter");
}
static key = "google";
static defaults = {
description: "Google (Gemini)",
type: "API",
api_key_header: "none",
endpoint: "https://generativelanguage.googleapis.com/v1beta/models/MODEL_NAME:generateContent",
endpoint_streaming: "https://generativelanguage.googleapis.com/v1beta/models/MODEL_NAME:streamGenerateContent",
streaming: true,
adapter: "Gemini",
models_endpoint: "https://generativelanguage.googleapis.com/v1beta/models",
default_model: "gemini-1.5-pro",
signup_url: "https://ai.google.dev/"
};
streaming_chunk_splitting_regex = /(\r\n|\n|\r){2}/g;
/**
* Get request adapter class
*/
req_adapter = SmartChatModelGeminiRequestAdapter2;
/**
* Get response adapter class
*/
res_adapter = SmartChatModelGeminiResponseAdapter2;
/**
* Uses Gemini's dedicated token counting endpoint
*/
async count_tokens(input) {
const req = {
url: `https://generativelanguage.googleapis.com/v1beta/models/${this.model_key}:countTokens?key=${this.api_key}`,
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify(this.prepare_token_count_body(input))
};
const resp = await this.http_adapter.request(req);
return resp.json.totalTokens;
}
/**
* Formats input for token counting based on type
* @private
*/
prepare_token_count_body(input) {
if (typeof input === "string") {
return { contents: [{ parts: [{ text: input }] }] };
} else if (Array.isArray(input)) {
return { contents: input.map((msg) => this.transform_message_for_token_count(msg)) };
} else if (typeof input === "object") {
return { contents: [this.transform_message_for_token_count(input)] };
}
throw new Error("Invalid input for count_tokens");
}
/**
* Transforms message for token counting, handling text and images
* @private
*/
transform_message_for_token_count(message) {
return {
role: message.role === "assistant" ? "model" : message.role,
parts: Array.isArray(message.content) ? message.content.map((part) => {
if (part.type === "text") return { text: part.text };
if (part.type === "image_url") return {
inline_data: {
mime_type: part.image_url.url.split(";")[0].split(":")[1],
data: part.image_url.url.split(",")[1]
}
};
return part;
}) : [{ text: message.content }]
};
}
/**
* Builds endpoint URLs with model and API key
*/
get endpoint() {
return `https://generativelanguage.googleapis.com/v1beta/models/${this.model_key}:generateContent?key=${this.api_key}`;
}
get endpoint_streaming() {
return `https://generativelanguage.googleapis.com/v1beta/models/${this.model_key}:streamGenerateContent?key=${this.api_key}`;
}
/**
* Get models endpoint URL with API key
* @returns {string} Complete models endpoint URL
*/
get models_endpoint() {
return `${this.constructor.defaults.models_endpoint}?key=${this.api_key}`;
}
/**
* Get HTTP method for models endpoint
* @returns {string} HTTP method ("GET")
*/
get models_endpoint_method() {
return "GET";
}
get models_request_params() {
return {
url: this.models_endpoint,
method: this.models_endpoint_method
};
}
/**
* Parse model data from Gemini API response
* @param {Object} model_data - Raw model data from API
* @returns {Object} Map of model objects with capabilities and limits
*/
parse_model_data(model_data) {
return model_data.models.filter((model) => model.name.startsWith("models/gemini")).reduce((acc, model) => {
const out = {
model_name: model.name.split("/").pop(),
id: model.name.split("/").pop(),
max_input_tokens: model.inputTokenLimit,
max_output_tokens: model.maxOutputTokens,
description: model.description,
multimodal: model.name.includes("vision") || model.description.includes("multimodal"),
raw: model
};
acc[model.name.split("/").pop()] = out;
return acc;
}, {});
}
is_end_of_stream(event) {
return event.data.includes('"finishReason"');
return false;
}
};
var SmartChatModelGeminiRequestAdapter2 = class extends SmartChatModelRequestAdapter3 {
static {
__name(this, "SmartChatModelGeminiRequestAdapter");
}
to_platform(streaming = false) {
return this.to_gemini(streaming);
}
to_gemini(streaming = false) {
const gemini_body = {
contents: this._transform_messages_to_gemini(),
generationConfig: {
temperature: this.temperature,
maxOutputTokens: this.max_tokens,
topK: this._req.topK || 1,
topP: this._req.topP || 1,
stopSequences: this._req.stop || []
},
safetySettings: [
{
category: "HARM_CATEGORY_HARASSMENT",
threshold: "BLOCK_NONE"
},
{
category: "HARM_CATEGORY_HATE_SPEECH",
threshold: "BLOCK_NONE"
},
{
category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
threshold: "BLOCK_NONE"
},
{
category: "HARM_CATEGORY_DANGEROUS_CONTENT",
threshold: "BLOCK_NONE"
}
]
};
if (this.tools) gemini_body.tools = this._transform_tools_to_gemini();
if (gemini_body.tools && this.tool_choice !== "none") gemini_body.tool_config = this._transform_tool_choice_to_gemini();
return {
url: streaming ? this.adapter.endpoint_streaming : this.adapter.endpoint,
method: "POST",
headers: this.get_headers(),
body: JSON.stringify(gemini_body)
};
}
_transform_messages_to_gemini() {
let gemini_messages = [];
let system_message = "";
for (const message of this.messages) {
if (message.role === "system") {
system_message += message.content + "\n";
} else {
gemini_messages.push({
role: this._get_gemini_role(message.role),
parts: this._transform_content_to_gemini(message.content)
});
}
}
if (system_message) {
gemini_messages.unshift({
role: "user",
parts: [{ text: system_message.trim() }]
});
}
return gemini_messages;
}
_get_gemini_role(role) {
const role_map = {
user: "user",
assistant: "model",
function: "model"
};
return role_map[role] || role;
}
_transform_content_to_gemini(content) {
if (Array.isArray(content)) {
return content.map((part) => {
if (part.type === "text") return { text: part.text };
if (part.type === "image_url") {
let mime_type = part.image_url.url.split(";")[0].split(":")[1];
if (mime_type === "image/jpg") mime_type = "image/jpeg";
return {
inline_data: {
mime_type,
data: part.image_url.url.split(",")[1]
}
};
}
if (part.type === "file" && part.file?.filename?.toLowerCase().endsWith(".pdf")) {
if (part.file?.file_data) {
return {
inline_data: {
mime_type: "application/pdf",
data: part.file.file_data.split(",")[1]
}
};
}
}
return part;
});
}
return [{ text: content }];
}
_transform_tools_to_gemini() {
return [{
function_declarations: this.tools.map((tool2) => ({
name: tool2.function.name,
description: tool2.function.description,
parameters: tool2.function.parameters
}))
}];
}
_transform_tool_choice_to_gemini() {
return {
function_calling_config: {
mode: "ANY",
allowed_function_names: this.tools.map((tool2) => tool2.function.name)
}
};
}
};
var SmartChatModelGeminiResponseAdapter2 = class extends SmartChatModelResponseAdapter3 {
static {
__name(this, "SmartChatModelGeminiResponseAdapter");
}
static get platform_res() {
return {
candidates: [{
content: {
parts: [
{
text: ""
}
],
role: ""
},
finishReason: ""
}],
promptFeedback: {},
usageMetadata: {}
};
}
to_openai() {
if (this.error) return { error: normalize_error3(this.error, this.status) };
const first_candidate = this._res.candidates[0];
if (!this._res.id) this._res.id = "gemini-" + Date.now().toString();
return {
id: this._res.id,
object: "chat.completion",
created: Date.now(),
model: this.adapter.model_key,
choices: [{
index: 0,
message: first_candidate?.content ? this._transform_message_to_openai(first_candidate.content) : "",
finish_reason: this._get_openai_finish_reason(first_candidate.finishReason)
}],
usage: this._transform_usage_to_openai()
};
}
_transform_message_to_openai(content) {
const message = {
role: "assistant",
content: content.parts.filter((part) => part.text).map((part) => part.text).join("")
};
const function_call = content.parts.find((part) => part.functionCall);
if (function_call) {
message.tool_calls = [{
type: "function",
function: {
name: function_call.functionCall.name,
arguments: JSON.stringify(function_call.functionCall.args)
}
}];
}
return message;
}
_get_openai_finish_reason(finish_reason) {
const reason_map = {
"STOP": "stop",
"MAX_TOKENS": "length",
"SAFETY": "content_filter",
"RECITATION": "content_filter",
"OTHER": "null"
};
return reason_map[finish_reason] || finish_reason.toLowerCase();
}
_transform_usage_to_openai() {
if (!this._res.usageMetadata) {
return {
prompt_tokens: null,
completion_tokens: null,
total_tokens: null
};
}
return {
prompt_tokens: this._res.usageMetadata.promptTokenCount || null,
completion_tokens: this._res.usageMetadata.candidatesTokenCount || null,
total_tokens: this._res.usageMetadata.totalTokenCount || null
};
}
handle_chunk(chunk) {
let chunk_trimmed = chunk.trim();
if (["[", ","].includes(chunk_trimmed[0])) chunk_trimmed = chunk_trimmed.slice(1);
if (["]", ","].includes(chunk_trimmed[chunk_trimmed.length - 1])) chunk_trimmed = chunk_trimmed.slice(0, -1);
const data = JSON.parse(chunk_trimmed);
let raw;
if (data.candidates?.[0]?.content?.parts?.[0]?.text?.length) {
const content = data.candidates[0].content.parts[0].text;
raw = content;
this._res.candidates[0].content.parts[0].text += content;
}
if (data.candidates?.[0]?.content?.role?.length) {
this._res.candidates[0].content.role = data.candidates[0].content.role;
}
if (data.candidates?.[0]?.finishReason?.length) {
this._res.candidates[0].finishReason += data.candidates[0].finishReason;
}
if (data.promptFeedback) {
this._res.promptFeedback = {
...this._res.promptFeedback || {},
...data.promptFeedback
};
}
if (data.usageMetadata) {
this._res.usageMetadata = {
...this._res.usageMetadata || {},
...data.usageMetadata
};
}
if (data.candidates?.[0]?.content?.parts?.[0]?.functionCall) {
if (!this._res.candidates[0].content.parts[0].functionCall) {
this._res.candidates[0].content.parts[0].functionCall = {
name: "",
args: {}
};
}
this._res.candidates[0].content.parts[0].functionCall.name += data.candidates[0].content.parts[0].functionCall.name;
if (data.candidates[0].content.parts[0].functionCall.args) {
Object.entries(data.candidates[0].content.parts[0].functionCall.args).forEach(([key, value]) => {
if (!this._res.candidates[0].content.parts[0].functionCall.args[key]) {
this._res.candidates[0].content.parts[0].functionCall.args[key] = "";
}
this._res.candidates[0].content.parts[0].functionCall.args[key] += value;
});
}
}
return raw;
}
};
var SmartChatModelGeminiAdapter2 = class extends SmartChatModelGoogleAdapter2 {
static {
__name(this, "SmartChatModelGeminiAdapter");
}
static key = "gemini";
static defaults = {
description: "Gemini (SWITCH TO **GOOGLE** ADAPTER)",
type: "API",
api_key_header: "none",
endpoint: "https://generativelanguage.googleapis.com/v1beta/models/MODEL_NAME:generateContent",
endpoint_streaming: "https://generativelanguage.googleapis.com/v1beta/models/MODEL_NAME:streamGenerateContent",
streaming: true,
adapter: "Gemini",
models_endpoint: "https://generativelanguage.googleapis.com/v1beta/models",
default_model: "gemini-1.5-pro",
signup_url: "https://ai.google.dev/"
};
};

var SmartChatModelOpenRouterAdapter3 = class extends SmartChatModelApiAdapter3 {
static {
__name(this, "SmartChatModelOpenRouterAdapter");
}
static key = "open_router";
static models_dev_key = "openrouter";
static defaults = {
description: "Open Router",
type: "API",
endpoint: "https://openrouter.ai/api/v1/chat/completions",
streaming: true,
adapter: "OpenRouter",
models_endpoint: "https://openrouter.ai/api/v1/models",
default_model: "mistralai/mistral-7b-instruct:free",
signup_url: "https://accounts.openrouter.ai/sign-up?redirect_url=https%3A%2F%2Fopenrouter.ai%2Fkeys"
};
/**
* Get request adapter class
* @returns {typeof SmartChatModelOpenRouterRequestAdapter} Request adapter class
*/
get req_adapter() {
return SmartChatModelOpenRouterRequestAdapter3;
}
/**
* Get response adapter class
* @returns {typeof SmartChatModelOpenRouterResponseAdapter} Response adapter class
*/
get res_adapter() {
return SmartChatModelOpenRouterResponseAdapter3;
}
/**
* Count tokens in input text (rough estimate)
* @param {string|Object} input - Text to count tokens for
* @returns {Promise<number>} Estimated token count
*/
async count_tokens(input) {
const text = typeof input === "string" ? input : JSON.stringify(input);
return Math.ceil(text.length / 4);
}
get models_request_params() {
return {
url: this.models_endpoint,
method: "GET"
};
}
/**
* Parse model data from OpenRouter API response
* @param {Object} model_data - Raw model data
* @returns {Object} Map of model objects with capabilities and limits
*/
parse_model_data(model_data) {
if (model_data.data) {
model_data = model_data.data;
}
if (model_data.error) throw new Error(model_data.error);
return model_data.reduce((acc, model) => {
acc[model.id] = {
model_name: model.id,
id: model.id,
max_input_tokens: model.context_length,
name: model.name,
description: model.name,
long_desc: model.description,
multimodal: model.architecture.modality === "multimodal",
raw: model
};
return acc;
}, {});
}
};
var SmartChatModelOpenRouterRequestAdapter3 = class extends SmartChatModelRequestAdapter3 {
static {
__name(this, "SmartChatModelOpenRouterRequestAdapter");
}
to_platform(stream = false) {
const req = this.to_openai(stream);
return req;
}
_get_openai_content(message) {
if (message.role === "user") {
if (Array.isArray(message.content) && message.content.every((part) => part.type === "text")) {
return message.content.map((part) => part.text).join("\n");
}
}
return message.content;
}
};
var SmartChatModelOpenRouterResponseAdapter3 = class extends SmartChatModelResponseAdapter3 {
static {
__name(this, "SmartChatModelOpenRouterResponseAdapter");
}
static get platform_res() {
return {
id: "",
object: "chat.completion",
created: 0,
model: "",
choices: [],
usage: {}
};
}
to_platform() {
return this.to_openai();
}
get object() {
return "chat.completion";
}
get error() {
if (!this._res.error) return null;
const error = this._res.error;
if (!error.message) error.message = "";
if (this._res.error.metadata?.raw) {
if (typeof this._res.error.metadata.raw === "string") {
error.message += `

${this._res.error.metadata.raw}`;
} else {
error.message += `

${JSON.stringify(this._res.error.metadata.raw, null, 2)}`;
}
}
if (error.message.startsWith("No cookie auth")) {
error.suggested_action = "Ensure your Open Router API key is set correctly.";
}
return error;
}
};

var SmartChatModelLmStudioAdapter2 = class extends SmartChatModelApiAdapter3 {
static {
__name(this, "SmartChatModelLmStudioAdapter");
}
static key = "lm_studio";
/** @type {import('./_adapter.js').SmartChatModelAdapter['constructor']['defaults']} */
static defaults = {
description: "LM Studio (OpenAI\u2011compatible)",
type: "API",
endpoint: "http://localhost:1234/v1/chat/completions",
streaming: true,
adapter: "LM_Studio_OpenAI_Compat",
models_endpoint: "http://localhost:1234/v1/models",
default_model: "",
signup_url: "https://lmstudio.ai/docs/api/openai-api",
api_key: "no api key required"
};
/* ------------------------------------------------------------------ *
*  Request / Response classes
* ------------------------------------------------------------------ */
get req_adapter() {
return SmartChatModelLmStudioRequestAdapter2;
}
get res_adapter() {
return SmartChatModelLmStudioResponseAdapter2;
}
/* ------------------------------------------------------------------ *
*  Settings
* ------------------------------------------------------------------ */
/**
* Extend the base settings with a read‑only HTML block that reminds the
* user to enable CORS inside LM Studio. The Smart View renderer treats
* `type: "html"` as a static fragment, so no extra runtime logic is needed.
*/
get settings_config() {
const config = super.settings_config;
delete config["[CHAT_ADAPTER].api_key"];
return {
...config,
"[CHAT_ADAPTER].cors_instructions": {
/* visible only when this adapter is selected */
name: "CORS required",
type: "html",
value: `<p>Before you can use LM Studio you must <strong>Enable CORS</strong> inside LM Studio \u2192 Developer \u2192 Settings</p>`
}
};
}
/* ------------------------------------------------------------------ *
*  Model list helpers
* ------------------------------------------------------------------ */
/**
* LM Studio returns an OpenAI‑style list; normalise to the project shape.
*/
parse_model_data(model_data) {
if (model_data.object !== "list" || !Array.isArray(model_data.data)) {
return { _: { id: "No models found." } };
}
const out = {};
for (const m of model_data.data) {
out[m.id] = {
id: m.id,
model_name: m.id,
description: `LM Studio model: ${m.id}`,
multimodal: false
};
}
return out;
}
get models_endpoint_method() {
return "get";
}
/**
* Count tokens in input text (no dedicated endpoint)
* Rough estimate: 1 token ~ 4 chars
* @param {string|Object} input
* @returns {Promise<number>}
*/
async count_tokens(input) {
const text = typeof input === "string" ? input : JSON.stringify(input);
return Math.ceil(text.length / 4);
}
/**
* Test API key - LM Studio doesn't require API key. Always true.
* @returns {Promise<boolean>}
*/
async test_api_key() {
return true;
}
get api_key() {
return "no api key required";
}
};
var SmartChatModelLmStudioRequestAdapter2 = class extends SmartChatModelRequestAdapter3 {
static {
__name(this, "SmartChatModelLmStudioRequestAdapter");
}
to_platform(streaming = false) {
const req = this.to_openai(streaming);
const body = JSON.parse(req.body);
if (this.tool_choice?.function?.name) {
const last_msg = body.messages[body.messages.length - 1];
if (typeof last_msg.content === "string") {
last_msg.content = [
{ type: "text", text: last_msg.content }
];
}
last_msg.content.push({
type: "text",
text: `Use the "${this.tool_choice.function.name}" tool.`
});
body.tool_choice = "required";
} else if (body.tool_choice && typeof body.tool_choice === "object") {
body.tool_choice = "auto";
}
req.body = JSON.stringify(body);
return req;
}
};
var SmartChatModelLmStudioResponseAdapter2 = class extends SmartChatModelResponseAdapter3 {
static {
__name(this, "SmartChatModelLmStudioResponseAdapter");
}
};

var SmartChatModelOllamaAdapter2 = class extends SmartChatModelApiAdapter3 {
static {
__name(this, "SmartChatModelOllamaAdapter");
}
static key = "ollama";
static defaults = {
description: "Ollama (Local)",
type: "API",
api_key: "na",
host: "http://localhost:11434",
endpoint: "/api/chat",
models_endpoint: "/api/tags",
streaming: true
};
req_adapter = SmartChatModelOllamaRequestAdapter2;
res_adapter = SmartChatModelOllamaResponseAdapter2;
get host() {
return this.model.data.host || this.constructor.defaults.host;
}
get endpoint() {
return `${this.host}${this.constructor.defaults.endpoint}`;
}
get models_endpoint() {
return `${this.host}${this.constructor.defaults.models_endpoint}`;
}
get model_show_endpoint() {
return `${this.host}/api/show`;
}
get models_endpoint_method() {
return "GET";
}
/**
* Get available models from local Ollama instance
* @param {boolean} [refresh=false] - Whether to refresh cached models
* @returns {Promise<Object>} Map of model objects
*/
async get_models(refresh = false) {
if (!refresh && typeof this.model_data === "object" && Object.keys(this.model_data || {}).length > 0 && this.model_data_loaded_at && time_now - this.model_data_loaded_at < 1 * 60 * 60 * 1e3) return this.model_data;
try {
const list_resp = await this.http_adapter.request(this.models_request_params);
const list_data = await list_resp.json();
const models_raw_data = [];
for (const model of list_data.models) {
const model_details_resp = await this.http_adapter.request({
url: this.model_show_endpoint,
method: "POST",
body: JSON.stringify({ model: model.name })
});
const model_details_data = await model_details_resp.json();
models_raw_data.push({ ...model_details_data, name: model.name });
}
this.model_data = this.parse_model_data(models_raw_data);
await this.get_enriched_model_data();
this.model.data.provider_models = this.model_data;
if (typeof this.model.re_render_settings === "function") {
this.model.re_render_settings();
}
this.model_data_loaded_at = Date.now();
return this.model_data;
} catch (error) {
console.error("Failed to fetch model data:", error);
return { "_": { id: `Failed to fetch models from ${this.model.adapter_name}` } };
}
}
/**
* Parse model data from Ollama API response
* @param {Object[]} model_data - Raw model data from Ollama
* @returns {Object} Map of model objects with capabilities and limits
*/
parse_model_data(model_data) {
if (!Array.isArray(model_data)) {
this.model_data = {};
console.error("Invalid model data format from Ollama:", model_data);
return {};
}
if (model_data.length === 0) {
this.model_data = { "no_models_available": {
id: "no_models_available",
name: "No models currently available"
} };
return this.model_data;
}
return model_data.reduce((acc, model) => {
if (model.name.includes("embed")) return acc;
const out = {
model_name: model.name,
id: model.name,
multimodal: false,
max_input_tokens: Object.entries(model.model_info).find((m) => m[0].includes(".context_length"))[1]
};
acc[model.name] = out;
return acc;
}, {});
}
/**
* Override settings config to remove API key setting since not needed for local instance
* @returns {Object} Settings configuration object
*/
get settings_config() {
const config = super.settings_config;
delete config["[CHAT_ADAPTER].api_key"];
config["[CHAT_ADAPTER].host"] = {
name: "Ollama host",
type: "text",
description: "Enter the host for your Ollama instance",
default: this.constructor.defaults.host
};
return config;
}
is_end_of_stream(event) {
return event.data.includes('"done_reason"');
}
};
var SmartChatModelOllamaRequestAdapter2 = class extends SmartChatModelRequestAdapter3 {
static {
__name(this, "SmartChatModelOllamaRequestAdapter");
}
/**
* Convert request to Ollama format
* @returns {Object} Request parameters in Ollama format
*/
to_platform(streaming = false) {
const ollama_body = {
model: this.model_id,
messages: this._transform_messages_to_ollama(),
options: this._transform_parameters_to_ollama(),
stream: streaming || this.stream
};
if (this.tools) {
ollama_body.tools = this._transform_functions_to_tools();
if (this.tool_choice?.function?.name) {
ollama_body.messages[ollama_body.messages.length - 1].content += `

Use the "${this.tool_choice.function.name}" tool.`;
ollama_body.format = "json";
}
}
return {
url: this.adapter.endpoint,
method: "POST",
body: JSON.stringify(ollama_body)
};
}
/**
* Transform messages to Ollama format
* @returns {Array} Messages in Ollama format
* @private
*/
_transform_messages_to_ollama() {
return this.messages.map((message) => {
const ollama_message = {
role: message.role,
content: this._transform_content_to_ollama(message.content)
};
const images = this._extract_images_from_content(message.content);
if (images.length > 0) {
ollama_message.images = images.map((img) => img.replace(/^data:image\/[^;]+;base64,/, ""));
}
return ollama_message;
});
}
/**
* Transform content to Ollama format
* @param {string|Array} content - Message content
* @returns {string} Content in Ollama format
* @private
*/
_transform_content_to_ollama(content) {
if (Array.isArray(content)) {
return content.filter((item) => item.type === "text").map((item) => item.text).join("\n");
}
return content;
}
/**
* Extract images from content
* @param {string|Array} content - Message content
* @returns {Array} Array of image URLs
* @private
*/
_extract_images_from_content(content) {
if (!Array.isArray(content)) return [];
return content.filter((item) => item.type === "image_url").map((item) => item.image_url.url);
}
/**
* Transform functions to tools format
* @returns {Array} Tools array in Ollama format
* @private
*/
_transform_functions_to_tools() {
return this.tools;
}
/**
* Transform parameters to Ollama options format
* @returns {Object} Options in Ollama format
* @private
*/
_transform_parameters_to_ollama() {
const options = {};
if (this.max_tokens) options.num_predict = this.max_tokens;
if (this.temperature) options.temperature = this.temperature;
if (this.top_p) options.top_p = this.top_p;
if (this.frequency_penalty) options.frequency_penalty = this.frequency_penalty;
if (this.presence_penalty) options.presence_penalty = this.presence_penalty;
return options;
}
};
var SmartChatModelOllamaResponseAdapter2 = class extends SmartChatModelResponseAdapter3 {
static {
__name(this, "SmartChatModelOllamaResponseAdapter");
}
static get platform_res() {
return {
model: "",
created_at: null,
message: {
role: "",
content: ""
},
total_duration: 0,
load_duration: 0,
prompt_eval_count: 0,
prompt_eval_duration: 0,
eval_count: 0,
eval_duration: 0
};
}
/**
* Convert response to OpenAI format
* @returns {Object} Response in OpenAI format
*/
to_openai() {
if (this.error) return { error: normalize_error3(this.error, this.status) };
return {
id: this._res.created_at,
object: "chat.completion",
created: Date.now(),
model: this._res.model,
choices: [
{
index: 0,
message: this._transform_message_to_openai(),
finish_reason: this._res.done_reason
}
],
usage: this._transform_usage_to_openai()
};
}
/**
* Transform message to OpenAI format
* @returns {Object} Message in OpenAI format
* @private
*/
_transform_message_to_openai() {
return {
role: this._res.message.role,
content: this._res.message.content,
tool_calls: this._res.message.tool_calls
};
}
/**
* Transform usage statistics to OpenAI format
* @returns {Object} Usage statistics in OpenAI format
* @private
*/
_transform_usage_to_openai() {
return {
prompt_tokens: this._res.prompt_eval_count || 0,
completion_tokens: this._res.eval_count || 0,
total_tokens: (this._res.prompt_eval_count || 0) + (this._res.eval_count || 0)
};
}
/**
* Parse chunk adds delta to content as expected output format
*/
handle_chunk(chunk) {
chunk = JSON.parse(chunk || "{}");
if (chunk.created_at && !this._res.created_at) {
this._res.created_at = chunk.created_at;
}
let raw;
if (chunk.message?.content) {
const content = chunk.message.content;
raw = content;
this._res.message.content += content;
}
if (chunk.message?.role) {
this._res.message.role = chunk.message.role;
}
if (chunk.model) {
this._res.model = chunk.model;
}
if (chunk.message?.tool_calls) {
if (!this._res.message.tool_calls) {
this._res.message.tool_calls = [{
id: "",
type: "function",
function: {
name: "",
arguments: ""
}
}];
}
if (chunk.message.tool_calls[0].id) {
this._res.message.tool_calls[0].id += chunk.message.tool_calls[0].id;
}
if (chunk.message.tool_calls[0].function.name) {
this._res.message.tool_calls[0].function.name += chunk.message.tool_calls[0].function.name;
}
if (chunk.message.tool_calls[0].function.arguments) {
if (typeof chunk.message.tool_calls[0].function.arguments === "string") {
this._res.message.tool_calls[0].function.arguments += chunk.message.tool_calls[0].function.arguments;
} else {
this._res.message.tool_calls[0].function.arguments = chunk.message.tool_calls[0].function.arguments;
}
}
}
return raw;
}
};

var adapters_map2 = {
"openai": {
req: SmartChatModelRequestAdapter3,
res: SmartChatModelResponseAdapter3
},
"anthropic": {
req: SmartChatModelAnthropicRequestAdapter2,
res: SmartChatModelAnthropicResponseAdapter2
},
"gemini": {
req: SmartChatModelGeminiRequestAdapter2,
res: SmartChatModelGeminiResponseAdapter2
},
"lm_studio": {
req: SmartChatModelLmStudioRequestAdapter2,
res: SmartChatModelLmStudioResponseAdapter2
},
"ollama": {
req: SmartChatModelOllamaRequestAdapter2,
res: SmartChatModelOllamaResponseAdapter2
}
};
var SmartChatModelCustomAdapter2 = class extends SmartChatModelApiAdapter3 {
static {
__name(this, "SmartChatModelCustomAdapter");
}
static key = "custom";
static defaults = {
description: "Custom API (Local or Remote, OpenAI format)",
type: "API",
/**
* new default property: 'api_adapter' indicates which
* request/response adapter set to use internally
*/
api_adapter: "openai"
};
/**
* Provide dynamic request/response classes
*/
/**
* @override
* @returns {typeof SmartChatModelRequestAdapter}
*/
get req_adapter() {
const adapter_name = this.model.data.api_adapter || "openai";
const map_entry = adapters_map2[adapter_name];
return map_entry && map_entry.req ? map_entry.req : SmartChatModelRequestAdapter3;
}
/**
* @override
* @returns {typeof SmartChatModelResponseAdapter}
*/
get res_adapter() {
const adapter_name = this.model.data.api_adapter || "openai";
const map_entry = adapters_map2[adapter_name];
return map_entry && map_entry.res ? map_entry.res : SmartChatModelResponseAdapter3;
}
/**
* Synthesize a custom endpoint from the config fields.
* All fields are optional; fallback to a minimal default.
* @returns {string}
*/
get endpoint() {
const protocol = this.model.data.protocol || "http";
const hostname = this.model.data.hostname || "localhost";
const port = this.model.data.port ? `:${this.model.data.port}` : "";
let path = this.model.data.path || "";
if (path && !path.startsWith("/")) path = `/${path}`;
return `${protocol}://${hostname}${port}${path}`;
}
get_adapters_as_options() {
return Object.keys(adapters_map2).map((adapter_name) => ({ value: adapter_name, name: adapter_name }));
}
/**
* Provide custom settings for configuring
* the user-defined fields plus the new 'api_adapter'.
* @override
* @returns {Object} settings configuration
*/
get settings_config() {
return {
/**
* Select which specialized request/response adapter
* you'd like to use for your custom endpoint.
*/
"[CHAT_ADAPTER].api_adapter": {
name: "API Adapter",
type: "dropdown",
description: "Pick a built-in or external adapter to parse request/response data.",
options_callback: /* @__PURE__ */ __name(() => {
this.get_adapters_as_options();
}, "options_callback"),
default: "openai"
},
"[CHAT_ADAPTER].id": {
name: "Model Name",
type: "text",
description: "Enter the model name for your endpoint if needed."
},
"[CHAT_ADAPTER].protocol": {
name: "Protocol",
type: "text",
description: "e.g. http or https"
},
"[CHAT_ADAPTER].hostname": {
name: "Hostname",
type: "text",
description: "e.g. localhost or some.remote.host"
},
"[CHAT_ADAPTER].port": {
name: "Port",
type: "number",
description: "Port number or leave blank"
},
"[CHAT_ADAPTER].path": {
name: "Path",
type: "text",
description: "Path portion of the URL (leading slash optional)"
},
"[CHAT_ADAPTER].streaming": {
name: "Streaming",
type: "toggle",
description: "Enable streaming if your API supports it."
},
"[CHAT_ADAPTER].max_input_tokens": {
name: "Max Input Tokens",
type: "number",
description: "Max number of tokens your model can handle in the prompt."
},
"[CHAT_ADAPTER].api_key": {
name: "API Key",
type: "password",
description: "If your service requires an API key, add it here."
}
};
}
};

var SmartChatModelGroqAdapter2 = class extends SmartChatModelApiAdapter3 {
static {
__name(this, "SmartChatModelGroqAdapter");
}
static key = "groq";
static defaults = {
description: "Groq",
type: "API",
endpoint: "https://api.groq.com/openai/v1/chat/completions",
streaming: true,
adapter: "Groq",
models_endpoint: "https://api.groq.com/openai/v1/models",
default_model: "llama3-8b-8192",
signup_url: "https://groq.com"
};
/**
* Request adapter class
* @returns {typeof SmartChatModelGroqRequestAdapter}
*/
get req_adapter() {
return SmartChatModelGroqRequestAdapter2;
}
/**
* Response adapter class
* @returns {typeof SmartChatModelGroqResponseAdapter}
*/
get res_adapter() {
return SmartChatModelGroqResponseAdapter2;
}
get models_endpoint_method() {
return "GET";
}
/**
* Parse model data from Groq API format to a dictionary keyed by model ID.
* The API returns a list of model objects like:
* {
*   "object": "list",
*   "data": [ { "id": "...", "object": "model", ... }, ... ]
* }
*
* We'll convert each model to:
* {
*   model_name: model.id,
*   id: model.id,
*   max_input_tokens: model.context_window,
*   description: `Owned by: ${model.owned_by}, context: ${model.context_window}`,
*   multimodal: Check if model name or description suggests multimodality
* }
*/
parse_model_data(model_data) {
if (model_data.object !== "list" || !Array.isArray(model_data.data)) {
return { "_": { id: "No models found." } };
}
const parsed = {};
for (const m of model_data.data) {
parsed[m.id] = {
model_name: m.id,
id: m.id,
max_input_tokens: m.context_window || 8192,
description: `Owned by: ${m.owned_by}, context: ${m.context_window}`,
multimodal: m.id.includes("vision")
};
}
return parsed;
}
};
var SmartChatModelGroqRequestAdapter2 = class extends SmartChatModelRequestAdapter3 {
static {
__name(this, "SmartChatModelGroqRequestAdapter");
}
_get_openai_content(message) {
if (["assistant", "tool"].includes(message.role)) {
if (Array.isArray(message.content)) {
return message.content.map((part) => {
if (typeof part === "string") return part;
if (part?.text) return part.text;
return "";
}).join("\n");
}
}
return message.content;
}
};
var SmartChatModelGroqResponseAdapter2 = class extends SmartChatModelResponseAdapter3 {
static {
__name(this, "SmartChatModelGroqResponseAdapter");
}
};

var SmartChatModelXaiAdapter2 = class extends SmartChatModelApiAdapter3 {
static {
__name(this, "SmartChatModelXaiAdapter");
}
/** Human-readable platform key used by SmartChatModel */
static key = "xai";
/** @type {import('./_adapter.js').SmartChatModelAdapter['constructor']['defaults']} */
static defaults = {
description: "xAI Grok",
type: "API",
adapter: "xAI_Grok",
endpoint: "https://api.x.ai/v1/chat/completions",
streaming: true,
models_endpoint: "https://api.x.ai/v1/models",
default_model: "grok-3-mini-beta",
signup_url: "https://ide.x.ai"
};
/** Grok is OpenAI-compatible → reuse the stock adapters */
get req_adapter() {
return SmartChatModelRequestAdapter3;
}
get res_adapter() {
return SmartChatModelResponseAdapter3;
}
/* ------------------------------------------------------------------ *
*  Model-list helpers
* ------------------------------------------------------------------ */
/**
* The Grok `/v1/models` route is **GET**, not POST.
* Override the HTTP verb so `get_models()` works.
* @returns {string} 'GET'
*/
get models_endpoint_method() {
return "GET";
}
/**
* Parse `/v1/models` payload to the canonical shape used by SmartChat.
*
* Grok returns:
* ```json
* { "object":"list",
*   "data":[{ "id":"grok-3-beta", "context_length":128000, …}] }
* ```
*/
parse_model_data(model_data = {}) {
const list = model_data.data || model_data.models || [];
return list.reduce((acc, m) => {
const id = m.id || m.name;
acc[id] = {
id,
model_name: id,
description: m.description || `context: ${m.context_length || "n/a"}`,
max_input_tokens: m.context_length || 128e3,
multimodal: !!m.modality && m.modality.includes("vision"),
raw: m
};
return acc;
}, {});
}
};

var SmartChatModelDeepseekAdapter2 = class extends SmartChatModelApiAdapter3 {
static {
__name(this, "SmartChatModelDeepseekAdapter");
}
static key = "deepseek";
static defaults = {
description: "DeepSeek",
type: "API",
endpoint: "https://api.deepseek.com/chat/completions",
streaming: true,
adapter: "DeepSeek",
models_endpoint: "https://api.deepseek.com/models",
default_model: "deepseek-base",
signup_url: "https://deepseek.com/signup"
};
/**
* Get the request adapter class
* @returns {typeof SmartChatModelDeepseekRequestAdapter} Request adapter class
*/
get req_adapter() {
return SmartChatModelDeepseekRequestAdapter2;
}
/**
* Get the response adapter class
* @returns {typeof SmartChatModelDeepseekResponseAdapter} Response adapter class
*/
get res_adapter() {
return SmartChatModelDeepseekResponseAdapter2;
}
get models_endpoint_method() {
return "GET";
}
/**
* Parse the raw model data from DeepSeek's /v1/models endpoint
* into a structured map of model objects keyed by model ID.
* @param {Object} model_data - Raw JSON from DeepSeek
* @returns {Object} Map of model objects
*/
parse_model_data(model_data) {
if (!model_data?.data || !Array.isArray(model_data.data)) {
return { "_": { id: "No models found." } };
}
const parsed = {};
for (const m of model_data.data) {
parsed[m.id] = {
model_name: m.id,
id: m.id,
max_input_tokens: m.context_size || 8192,
description: m.description || m.name || m.id,
raw: m
};
}
return parsed;
}
/**
* Estimate tokens in user input.
* @param {string|Object} input - Input text or structured message
* @returns {Promise<number>} Token count estimate
*/
async count_tokens(input) {
const text = typeof input === "string" ? input : JSON.stringify(input);
return Math.ceil(text.length / 4);
}
/**
* Check if an incoming streaming chunk signals end of stream.
* @param {CustomEvent} event - SSE event with data
* @returns {boolean} True if end of stream
*/
is_end_of_stream(event) {
if (!event?.data) return false;
return event.data.includes('"done":true') || event.data.includes("[DONE]");
}
};
var SmartChatModelDeepseekRequestAdapter2 = class extends SmartChatModelRequestAdapter3 {
static {
__name(this, "SmartChatModelDeepseekRequestAdapter");
}
/**
* Convert incoming request to DeepSeek's expected format
* Often just reuse the base "to_openai()" if that matches DeepSeek's design
* @param {boolean} streaming - True if streaming
* @returns {Object} Request parameters
*/
to_platform(streaming = false) {
return this.to_openai(streaming);
}
};
var SmartChatModelDeepseekResponseAdapter2 = class extends SmartChatModelResponseAdapter3 {
static {
__name(this, "SmartChatModelDeepseekResponseAdapter");
}
};

var import_obsidian84 = require("obsidian");

function parse_blocks2(source, content) {
let { blocks: blocks_obj, task_lines, tasks, codeblock_ranges } = parse_markdown_blocks2(content);
const last_read_at = source.data.last_read?.at || Date.now();
for (const [sub_key, line_range] of Object.entries(blocks_obj)) {
const block_key = source.key + sub_key;
const existing_block = source.block_collection.get(block_key);
const block_content = get_line_range3(content, line_range[0], line_range[1]);
if (existing_block && existing_block.lines[0] === line_range[0] && existing_block.lines[1] === line_range[1] && existing_block.size === block_content.length && existing_block.vec) {
continue;
}
const block_outlinks = get_markdown_links2(block_content);
const bases_links = get_bases_cache_links2({
source,
links: block_outlinks
});
const block_data = {
key: block_key,
lines: line_range,
size: block_content.length,
outlinks: [
...block_outlinks,
...bases_links
],
last_read: {
at: last_read_at,
hash: murmur_hash_32_alphanumeric3(block_content)
}
};
if (!existing_block || existing_block?.data.last_read?.hash !== block_data.last_read.hash) {
const new_item = new source.block_collection.item_type(source.env, block_data);
source.block_collection.set(new_item);
} else {
existing_block.data = {
...existing_block.data,
...block_data
};
}
}
clean_and_update_source_blocks2(source, blocks_obj, task_lines, tasks, codeblock_ranges);
for (const block of source.blocks) {
if (!block.vec) {
block.queue_embed();
}
}
}
__name(parse_blocks2, "parse_blocks");
function clean_and_update_source_blocks2(source, blocks_obj, task_lines = [], tasks = {}, codeblock_ranges = {}) {
const current_block_keys = new Set(Object.keys(blocks_obj).map((sk) => source.key + sk));
const blocks = source.blocks;
for (let i = 0; i < blocks.length; i++) {
if (!current_block_keys.has(blocks[i].key)) {
blocks[i].deleted = true;
blocks[i].queue_save();
}
}
source.data.blocks = blocks_obj;
source.data.task_lines = task_lines;
source.data.tasks = tasks;
source.data.codeblock_ranges = codeblock_ranges;
source.queue_save();
}
__name(clean_and_update_source_blocks2, "clean_and_update_source_blocks");

function ajson_merge3(existing, new_obj) {
if (new_obj === null) return null;
if (new_obj === void 0) return existing;
if (typeof new_obj !== "object") return new_obj;
if (typeof existing !== "object" || existing === null) existing = {};
const keys = Object.keys(new_obj);
const length = keys.length;
for (let i = 0; i < length; i++) {
const key = keys[i];
const new_val = new_obj[key];
const existing_val = existing[key];
if (Array.isArray(new_val)) {
existing[key] = new_val.slice();
} else if (is_object3(new_val)) {
existing[key] = ajson_merge3(is_object3(existing_val) ? existing_val : {}, new_val);
} else if (new_val !== void 0) {
existing[key] = new_val;
}
}
return existing;
}
__name(ajson_merge3, "ajson_merge");
function is_object3(obj) {
return obj !== null && typeof obj === "object" && !Array.isArray(obj);
}
__name(is_object3, "is_object");

var class_to_collection_key6 = {
"SmartSource": "smart_sources",
"SmartNote": "smart_sources",
"SmartBlock": "smart_blocks",
"SmartDirectory": "smart_directories"
};
function _parse_ajson_key3(ajson_key) {
let changed = false;
let [collection_key, ...item_key] = ajson_key.split(":");
if (class_to_collection_key6[collection_key]) {
collection_key = class_to_collection_key6[collection_key];
changed = true;
}
return {
collection_key,
item_key: item_key.join(":"),
changed
};
}
__name(_parse_ajson_key3, "_parse_ajson_key");
var AjsonSingleFileCollectionDataAdapter3 = class extends AjsonMultiFileCollectionDataAdapter3 {
static {
__name(this, "AjsonSingleFileCollectionDataAdapter");
}
/**
* Returns the single shared `.ajson` file path for this collection.
* @param {string} [key] - (unused) Item key, ignored in single-file mode.
* @returns {string} The single .ajson file path for the entire collection.
*/
get_item_data_path(key) {
const file_name = (this.collection?.collection_key || "collection") + ".ajson";
const sep = this.fs?.sep || "/";
const dir = this.collection.data_dir || "data";
return [dir, file_name].join(sep);
}
/**
* Override process_load_queue to parse the entire single-file .ajson once,
* distributing final states to items.
*
* @async
* @returns {Promise<void>}
*/
async process_load_queue() {
this.collection.emit_event("collection:load_started");
this.collection.show_process_notice("loading_collection");
if (!await this.fs.exists(this.collection.data_dir)) {
await this.fs.mkdir(this.collection.data_dir);
}
const path = this.get_item_data_path();
if (!await this.fs.exists(path)) {
for (const item of Object.values(this.collection.items)) {
if (item._queue_load) {
item.queue_import?.();
}
}
this.collection.clear_process_notice("loading_collection");
this.collection.emit_event("collection:load_halted");
return;
}
const raw_data = await this.fs.read(path, "utf-8", { no_cache: true });
if (!raw_data) {
for (const item of Object.values(this.collection.items)) {
if (item._queue_load) {
item.queue_import?.();
}
}
this.collection.clear_process_notice("loading_collection");
this.collection.emit_event("collection:load_halted");
return;
}
const { rewrite, file_data } = this.parse_single_file_ajson(raw_data);
if (rewrite) {
if (file_data.length) {
await this.fs.write(path, file_data);
} else {
await this.fs.remove(path);
}
}
for (const item of Object.values(this.collection.items)) {
item._queue_load = false;
item.loaded_at = Date.now();
}
this.collection.clear_process_notice("loading_collection");
this.collection.emit_event("collection:load_completed");
}
/**
* Helper to parse single-file .ajson content, distributing states to items.
*
* @param {string} raw
* @returns {{ rewrite: boolean, file_data: string }}
*/
parse_single_file_ajson(raw) {
let rewrite = false;
const lines = raw.trim().split("\n").filter(Boolean);
let data_map = {};
let line_count = 0;
for (let i = 0; i < lines.length; i++) {
const line = lines[i].trim();
if (!line.endsWith(",")) {
rewrite = true;
}
const trimmed = line.replace(/,$/, "");
const combined = "{" + trimmed + "}";
try {
const obj = JSON.parse(combined);
const [fullKey, value] = Object.entries(obj)[0];
let { collection_key, item_key, changed } = _parse_ajson_key3(fullKey);
const newKey = `${collection_key}:${item_key}`;
if (!value) {
delete data_map[newKey];
if (changed || newKey !== fullKey) {
delete data_map[fullKey];
}
rewrite = true;
} else {
data_map[newKey] = value;
if (changed || newKey !== fullKey) {
delete data_map[fullKey];
rewrite = true;
}
}
} catch (err) {
console.warn("parse error for line: ", line, err);
rewrite = true;
}
line_count++;
}
for (const [ajson_key, val] of Object.entries(data_map)) {
const [collection_key, ...rest] = ajson_key.split(":");
const item_key = rest.join(":");
const collection = this.collection.env[collection_key];
if (!collection) continue;
let item = collection.get(item_key);
if (!item) {
const ItemClass = collection.item_type;
item = new ItemClass(this.env, val);
collection.set(item);
} else {
item.data = ajson_merge3(item.data, val);
}
item.loaded_at = Date.now();
item._queue_load = false;
if (!val.key) val.key = item_key;
}
if (line_count > Object.keys(data_map).length) {
rewrite = true;
}
let minimal_lines = [];
for (const [ajson_key, val] of Object.entries(data_map)) {
minimal_lines.push(`${JSON.stringify(ajson_key)}: ${JSON.stringify(val)},`);
}
return {
rewrite,
file_data: minimal_lines.join("\n")
};
}
/**
* Override process_save_queue for single-file approach.
* We'll simply call save_item for each queued item, which appends a line to the same `.ajson`.
*
* @async
* @returns {Promise<void>}
*/
async process_save_queue() {
this.collection.emit_event("collection:save_started");
this.collection.show_process_notice("saving_collection");
const save_queue = Object.values(this.collection.items).filter((item) => item._queue_save);
const time_start = Date.now();
const batch_size = 50;
for (let i = 0; i < save_queue.length; i += batch_size) {
const batch = save_queue.slice(i, i + batch_size);
await Promise.all(batch.map((item) => {
const adapter = this.create_item_adapter(item);
return adapter.save().catch((err) => {
console.warn(`Error saving item ${item.key}`, err);
item.queue_save();
});
}));
}
const deleted_items = Object.values(this.collection.items).filter((item) => item.deleted);
if (deleted_items.length) {
deleted_items.forEach((item) => {
delete this.collection.items[item.key];
});
}
console.log(`Saved (single-file) ${this.collection.collection_key} in ${Date.now() - time_start}ms`);
this.collection.clear_process_notice("saving_collection");
this.collection.emit_event("collection:save_completed");
}
};
var AjsonSingleFileItemDataAdapter3 = class extends AjsonMultiFileItemDataAdapter3 {
static {
__name(this, "AjsonSingleFileItemDataAdapter");
}
/**
* Overridden to always return the single file path from the parent collection adapter.
* @returns {string}
*/
get data_path() {
return this.collection_adapter.get_item_data_path(this.item.key);
}
/**
* Load logic:
* In single-file mode, we typically rely on the collection's `process_load_queue()`
* to parse the entire file. This direct `load()` will do a naive re-parse as well
* if used individually.
*/
async load() {
const path = this.data_path;
if (!await this.fs.exists(path)) {
this.item.queue_import?.();
return;
}
try {
const raw_data = await this.fs.read(path, "utf-8", { no_cache: true });
if (!raw_data) {
this.item.queue_import?.();
return;
}
const { rewrite } = this.collection_adapter.parse_single_file_ajson(raw_data);
} catch (err) {
console.warn(`Error loading single-file item ${this.item.key}`, err);
this.item.queue_import?.();
}
}
};
var ajson_single_file_default3 = {
collection: AjsonSingleFileCollectionDataAdapter3,
item: AjsonSingleFileItemDataAdapter3
};

var SmartComponent2 = class extends CollectionItem3 {
static {
__name(this, "SmartComponent");
}
static key = "smart_component";
static collection_key = "smart_components";
collection_key = "smart_components";
get_key() {
if (this.data?.key) return this.data.key;
const scope_key = this.scope_key;
const component_key = this.component_key;
const version2 = Number.isFinite(this.data?.version) ? this.data.version : 0;
const hash = this.data?.hash || "nohash";
const key_pcs = [];
if (!component_key.includes(scope_key) && scope_key !== "global") key_pcs.push(scope_key);
key_pcs.push(component_key);
return `${key_pcs.join("_").replace(/\./g, "_")}#${[version2, hash].join("#")}`;
}
get scope_key() {
return this.data?.scope_key;
}
get component_key() {
return this.data?.component_key;
}
get component_adapter() {
return this._component_adapter;
}
/**
* Delegates render logic to the adapter.
* @param {object} component_scope
* @param {object} [opts={}]
* @returns {Promise<*>}
*/
async render(component_scope, opts = {}) {
if (!this.component_adapter) {
throw new Error(`SmartComponent: adapter missing for ${this.component_key}`);
}
return await this.component_adapter.render(component_scope, opts);
}
};

function parse_component_properties2(component_properties = []) {
const parts = component_properties.filter(Boolean).map((part) => part.toString());
const component_key = parts.pop();
const scope_key = parts.length ? parts.join(".") : "global";
return { scope_key, component_key };
}
__name(parse_component_properties2, "parse_component_properties");
async function build_component_data2(component_properties, component_module) {
const { scope_key, component_key } = parse_component_properties2(component_properties);
if (!component_key) return null;
const render_fn = typeof component_module === "function" ? component_module : component_module?.render;
const version2 = typeof render_fn?.version === "number" ? render_fn.version : 0;
const hash = await murmur_hash_32_alphanumeric3(render_fn.toString());
return { scope_key, component_key, version: version2, hash };
}
__name(build_component_data2, "build_component_data");
var SmartComponentAdapter2 = class {
static {
__name(this, "SmartComponentAdapter");
}
constructor(item, component_module) {
this.item = item;
this.module = component_module;
this.item.env.create_env_getter(this);
}
static should_use_adapter(component_module) {
return true;
}
static async register_component(collection, component_properties, component_module) {
if (!this.should_use_adapter(component_module)) return null;
const data = await build_component_data2(component_properties, component_module);
if (!data) return null;
const item = await collection.create_or_update({ ...data });
if (!item) return null;
item._component_module = component_module;
item._component_adapter = new this(item, component_module);
return item;
}
/**
* Render the component for the provided scope.
* @abstract
* @param {Object} scope - Render scope from the hosting environment.
* @param {Object} [opts] - Optional render options.
* @returns {Promise<*>} Rendered output for the component.
*/
async render(scope, opts) {
throw new Error("render() not implemented");
}
};

var SmartViewComponentAdapter2 = class extends SmartComponentAdapter2 {
static {
__name(this, "SmartViewComponentAdapter");
}
static should_use_adapter(component_module) {
return typeof component_module === "function" || typeof component_module?.render === "function";
}
get smart_view() {
if (!this._smart_view) {
this._smart_view = this.env.init_module("smart_view");
}
return this._smart_view;
}
async render(scope, opts = {}) {
const render_fn = typeof this.module === "function" ? this.module : this.module?.render;
if (typeof render_fn !== "function") {
throw new Error("SmartViewComponentAdapter: render() missing on module");
}
return await render_fn.call(this.smart_view, scope, opts);
}
};

function flatten_components_config2(config, path = [], acc = []) {
if (!config || typeof config !== "object") return acc;
Object.entries(config).forEach(([key, value]) => {
const next_path = [...path, key];
if (!value) return;
if (typeof value === "function" || typeof value?.render === "function") {
acc.push({ properties: next_path, module: value });
return;
}
if (typeof value === "object") {
flatten_components_config2(value, next_path, acc);
}
});
return acc;
}
__name(flatten_components_config2, "flatten_components_config");
var SmartComponents2 = class extends Collection3 {
static {
__name(this, "SmartComponents");
}
static key = "smart_components";
static collection_key = "smart_components";
collection_key = "smart_components";
async init() {
await this.load_components_from_config();
}
get component_adapters() {
if (Array.isArray(this.opts?.component_adapters)) {
return this.opts.component_adapters;
}
if (this.opts?.component_adapters && typeof this.opts.component_adapters === "object") {
return Object.values(this.opts.component_adapters);
}
return this.constructor.default_component_adapters || [];
}
async load_components_from_config() {
const records = flatten_components_config2(this.env.config?.components || {});
for (const record of records) {
await this.register_component(record.properties, record.module);
}
}
async register_component(component_properties, component_module) {
for (const AdapterClass of this.component_adapters) {
const item = await AdapterClass.register_component(this, component_properties, component_module);
if (item) return item;
}
return null;
}
async render_component(component_key, scope, opts = {}) {
const components = this.filter((item) => {
if (item.key.startsWith(component_key + "#")) return true;
return item.component_key === component_key;
}).sort((a, b) => {
const a_scope_match = a.scope_key === scope.key ? 1 : 0;
const b_scope_match = b.scope_key === scope.key ? 1 : 0;
return b_scope_match - a_scope_match;
});
if (components.length === 0) {
throw new Error(`SmartComponents: no component found for key ${component_key}`);
}
const selected_component = components[0];
return await selected_component.render(scope, opts);
}
};
var smart_components_default3 = {
class: SmartComponents2,
item_type: SmartComponent2,
data_adapter: ajson_single_file_default3,
component_adapters: {
SmartViewComponentAdapter: SmartViewComponentAdapter2
}
};

var smart_components_default4 = smart_components_default3;

function filter_redundant_context_items2(items = []) {
const parents = /* @__PURE__ */ new Set();
for (const { key } of items) {
if (!key.includes("#")) parents.add(key);
}
return items.filter(({ key }) => {
if (!key.includes("#")) return true;
const base = key.split("#")[0];
return !parents.has(base);
});
}
__name(filter_redundant_context_items2, "filter_redundant_context_items");

var remove_context_item_data2 = /* @__PURE__ */ __name((context_items, key) => {
if (!key || !context_items?.[key]) return false;
if (context_items[key].folder) {
if (context_items[key].exclude) return false;
context_items[key].exclude = true;
return true;
}
delete context_items[key];
return true;
}, "remove_context_item_data");
var SmartContext2 = class extends CollectionItem3 {
static {
__name(this, "SmartContext");
}
static version = 1;
static get defaults() {
return {
data: {
key: "",
context_items: {},
context_opts: {}
}
};
}
queue_save() {
super.queue_save();
this.collection.queue_save();
}
/**
* add_item
* @param {string|object} item
*/
add_item(item, params = {}) {
const {
emit_updated = true
} = params;
let key;
if (typeof item === "object") {
key = item.key || item.path;
} else {
key = item;
}
const existing = this.data.context_items[key];
const context_item = {
d: 0,
at: Date.now(),
...existing || {},
...typeof item === "object" ? item : {}
};
if (!key) return console.error("SmartContext: add_item called with invalid item", item);
this.data.context_items[key] = context_item;
this.queue_save();
if (emit_updated) this.emit_event("context:updated", { add_item: key });
}
/**
* add_items
* @param {string[]|object[]} items
*/
add_items(items) {
if (!Array.isArray(items)) items = [items];
items.forEach((item) => this.add_item(item, { emit_updated: false }));
this.emit_event("context:updated", { added_items: items.map((item) => typeof item === "object" ? item.key || item.path : item) });
}
/**
* remove_item
* Removes a path/ref from context and emits context:updated
* @param {string} key
* @param {object} params
* @param {boolean} params.emit_updated
*/
remove_item(key, params = {}) {
const { emit_updated = true } = params;
const removed = remove_context_item_data2(this.data.context_items, key);
if (!removed) return;
this.queue_save();
if (emit_updated) this.emit_event("context:updated", { removed_key: key, removed_keys: [key] });
}
/**
* remove_items
* Removes paths/refs from context and emits context:updated once
* @param {string[]|string} keys
* @param {object} params
* @param {boolean} params.emit_updated
* @returns {string[]}
*/
remove_items(keys, params = {}) {
const { emit_updated = true } = params;
const items = Array.isArray(keys) ? keys : [keys];
const removed_keys = [];
items.forEach((item_key) => {
if (remove_context_item_data2(this.data.context_items, item_key)) {
removed_keys.push(item_key);
}
});
if (!removed_keys.length) return [];
this.queue_save();
if (emit_updated) this.emit_event("context:updated", { removed_keys });
return removed_keys;
}
clear_all() {
this.data.context_items = {};
this.queue_save();
this.emit_event("context:updated", { cleared: true });
}
get context_item_keys() {
return Object.entries(this.data?.context_items || {}).filter(([key, item_data]) => !item_data.exclude).map(([key, item_data]) => key);
}
get key() {
if (!this.data.key) {
this.data.key = Date.now().toString();
}
return this.data.key;
}
get has_context_items() {
return Object.keys(this.data.context_items || {}).length > 0;
}
get name() {
return this.data.name;
}
set name(name) {
if (typeof name !== "string") throw new TypeError("Name must be a string");
const was_nameless = !this.data.name || String(this.data.name).trim().length === 0;
this.data.name = name;
if (was_nameless) this.emit_event("context:named");
else this.emit_event("context:renamed", { name });
this.queue_save();
}
get size() {
let size = 0;
const context_items = this.get_context_items();
context_items.forEach((item) => {
if (item.size) size += item.size;
});
return size;
}
get item_count() {
return Object.entries(this.data?.context_items || {}).filter(([key, item_data]) => !item_data.exclude).length;
}
async get_text(params = {}) {
const segments = [];
const context_items = this.context_items.filter(params.filter).sort((a, b) => a.data.d - b.data.d);
console.log("get_text context_items", context_items);
for (const item of context_items) {
if (item.is_media) continue;
const item_text = await item.get_text();
if (typeof item_text === "string") segments.push(item_text);
else this.emit_get_text_error(item, item_text);
}
const context_items_text = segments.join("\n");
if (typeof this.actions.context_merge_template === "function") {
return await this.actions.context_merge_template(context_items_text, { context_items });
}
return context_items_text;
}
async get_media(params = {}) {
const context_items = this.context_items.filter(params.filter);
const out = [];
for (const item of context_items) {
if (!item.is_media) continue;
const item_base64 = await item.get_base64();
if (item_base64.error) this.emit_get_media_error(item, item_base64);
else out.push(item_base64);
}
return out;
}
get context_items() {
if (!this._context_items) {
const config = this.env.config.collections.context_items;
const Class = config.class;
this._context_items = new Class(this.env, { ...config, class: null });
this._context_items.load_from_data(this.data.context_items || {});
if (!this._context_items_listener_registered) {
this.on_event("context:updated", () => {
this._context_items = null;
});
this._context_items_listener_registered = true;
}
}
return this._context_items;
}
emit_get_text_error(item, item_text) {
this.emit_event("notification:error", {
message: `Context item did not return text: ${item.key}`,
...item_text && typeof item_text === "object" ? item_text : {}
});
}
emit_get_media_error(item, item_base64) {
this.emit_event("notification:error", {
message: `Context item did not return media: ${item.key}`,
...item_base64 && typeof item_base64 === "object" ? item_base64 : {}
});
}
/**
* DEPRECATED
*/
/**
* Return *ContextItem* instances (any depth) for a given key array.
* @deprecated use context_items property instead
* @param {string[]} keys
*/
get_context_items(keys = this.context_item_keys) {
return filter_redundant_context_items2(
keys.map((k) => this.get_context_item(k)).filter(Boolean)
);
}
/**
* @deprecated use context_items property instead
*/
get_context_item(key) {
const existing = this.env.context_items.get(key);
if (existing) return existing;
return this.env.context_items.new_item({ key, ...this.data.context_items[key] || {} });
}
/**
* @method get_ref
* @deprecated moving to using ContextItem instances
*/
get_ref(key) {
return this.collection.get_ref(key);
}
/**
* @deprecated
*/
get_item_keys_by_depth(depth) {
return Object.keys(this.data.context_items).filter((k) => {
const item_depth = this.data.context_items[k].d;
if (item_depth === depth) return true;
if (typeof item_depth === "undefined" && depth === 0) return true;
return false;
});
}
};

var SmartContexts2 = class extends Collection3 {
static {
__name(this, "SmartContexts");
}
static version = 0.1;
/**
* new_context
* @param {object} data
* @param {object} opts
* @param {string[]} opts.add_items
* @returns {SmartContext}
*/
new_context(data = {}, opts = {}) {
const item = new this.item_type(this.env, data);
if (Array.isArray(opts.add_items)) item.add_items(opts.add_items);
this.set(item);
item.queue_save();
item.emit_event("context:created");
return item;
}
/**
* Default settings for all SmartContext items in this collection.
* @readonly
*/
static get default_settings() {
return {
template_preset: "xml_structured",
template_before: "<context>\n{{FILE_TREE}}",
template_after: "</context>"
};
}
get settings_config() {
return {
...this.env.config.actions.context_merge_template?.settings_config || {}
};
}
get_ref(key) {
const collection = key.includes("#") ? this.env.smart_blocks : this.env.smart_sources;
return collection.get(key);
}
};

var smart_contexts_default_config2 = {
class: SmartContexts2,
data_adapter: AjsonSingleFileCollectionDataAdapter3,
item_type: SmartContext2
};
var smart_contexts_default2 = smart_contexts_default_config2;

var ContextItem2 = class extends CollectionItem3 {
static {
__name(this, "ContextItem");
}
get collection_key() {
return "context_items";
}
get context_type_adapter() {
if (!this._context_type_adapter) {
const Class = this.collection.context_item_adapters.find((adapter_class) => adapter_class.detect(this.key, this.data));
if (!Class) throw new Error(`No context item adapter found for key: ${this.key}`);
this._context_type_adapter = new Class(this);
}
return this._context_type_adapter;
}
get exists() {
return this.context_type_adapter.exists;
}
async get_text() {
const item_text = await this.context_type_adapter.get_text();
if (typeof item_text !== "string") return item_text;
if (typeof this.actions.context_item_merge_template === "function") {
return await this.actions.context_item_merge_template(item_text);
}
return item_text;
}
async get_base64() {
if (this.is_media) {
return await this.context_type_adapter.get_base64();
}
return { error: `Context item is not media type: ${this.key}` };
}
async open(event = null) {
return await this.context_type_adapter.open(event);
}
get is_media() {
return this.context_type_adapter.is_media || false;
}
get item_ref() {
return this.context_type_adapter.ref || null;
}
get size() {
return this.data.size || this.context_type_adapter.size || 0;
}
get mtime() {
return this.data.mtime || this.context_type_adapter.mtime || null;
}
};

var ContextItemAdapter2 = class {
static {
__name(this, "ContextItemAdapter");
}
constructor(item) {
this.item = item;
}
static detect(key, data = {}) {
return false;
}
get env() {
return this.item.env;
}
get exists() {
return true;
}
/**
* for calculating context size
*/
get size() {
return 0;
}
async get_text() {
}
async open() {
}
};

var BlockContextItemAdapter2 = class extends ContextItemAdapter2 {
static {
__name(this, "BlockContextItemAdapter");
}
static order = 6;
static detect(key) {
return key.includes("#");
}
get ref() {
return this.env.smart_blocks.get(this.item.key);
}
get inlinks() {
return this.ref.inlinks || [];
}
get outlinks() {
return this.ref.outlinks || [];
}
get exists() {
return !!(this.ref && !this.ref.is_gone);
}
get mtime() {
return this.ref?.mtime || null;
}
get size() {
return this.ref?.size || 0;
}
async get_text() {
const block = this.ref;
if (!block) return { error: "Block not found" };
return await block.read();
}
async open(event = null) {
this.ref.actions.source_open(event);
}
};

var SourceContextItemAdapter2 = class extends ContextItemAdapter2 {
static {
__name(this, "SourceContextItemAdapter");
}
static order = 7;
static detect(key) {
return true;
}
get ref() {
return this.env.smart_sources.get(this.item.key);
}
get inlinks() {
return this.ref.inlinks || [];
}
get outlinks() {
return this.ref.outlinks || [];
}
get exists() {
return !!(this.ref && !this.ref.is_gone);
}
get size() {
return this.ref?.size || 0;
}
get mtime() {
return this.ref?.mtime || null;
}
async get_text() {
return await this.ref?.read() || "MISSING SOURCE";
}
async open(event = null) {
this.ref.actions.source_open(event);
}
};

var image_extension_regex2 = /\.(png|jpe?g|gif|bmp|webp|svg|ico|mp4)$/i;

var ImageContextItemAdapter2 = class extends ContextItemAdapter2 {
static {
__name(this, "ImageContextItemAdapter");
}
static detect(key) {
if (image_extension_regex2.test(key)) return "image";
return false;
}
get exists() {
return this.item.env.smart_sources.fs.exists_sync(this.item.key);
}
get is_media() {
return true;
}
async get_base64() {
const ext = this.item.key.split(".").pop().toLowerCase();
try {
const base64_data = await this.item.env.fs.read(this.item.key, "base64");
const base64_url = `data:image/${ext};base64,${base64_data}`;
return {
type: "image_url",
key: this.item.key,
name: this.item.key.split(/[\\/]/).pop(),
url: base64_url
};
} catch (err) {
console.warn(`Failed to convert image ${this.item.key} to base64`, err);
return { error: `Failed to convert image to base64: ${err.message}` };
}
}
};

var PdfContextItemAdapter2 = class extends ContextItemAdapter2 {
static {
__name(this, "PdfContextItemAdapter");
}
static detect(key) {
if (key.endsWith(".pdf")) return "pdf";
return false;
}
async add_to_snapshot(snapshot) {
if (!snapshot.pdfs) snapshot.pdfs = [];
snapshot.pdfs.push(this.item.key);
}
get is_media() {
return true;
}
async get_base64() {
try {
const base64_data = await this.item.env.fs.read(this.item.key, "base64");
const base64_url = `data:application/pdf;base64,${base64_data}`;
return {
type: "pdf_url",
key: this.item.key,
name: this.item.key.split(/[\\/]/).pop(),
url: base64_url
};
} catch (err) {
console.warn(`Failed to convert PDF ${this.item.key} to base64`, err);
return { error: `Failed to convert PDF to base64: ${err.message}` };
}
}
get exists() {
return this.item.env.smart_sources.fs.exists_sync(this.item.key);
}
};

var ContextItems2 = class extends Collection3 {
static {
__name(this, "ContextItems");
}
async load() {
console.log("ContextItems: load called");
}
static version = 1;
get context_item_adapters() {
if (!this._context_item_adapters) {
this._context_item_adapters = Object.values(this.opts.context_item_adapters).sort((a, b) => {
const order_a = a.order || 0;
const order_b = b.order || 0;
return order_a - order_b;
});
}
return this._context_item_adapters;
}
new_item(data) {
const item = new this.item_type(this.env, data);
this.set(item);
return item;
}
process_load_queue() {
}
get settings_config() {
return {
...this.env.config.actions.context_item_merge_template?.settings_config || {}
};
}
get_adapter_class(key, item_data) {
return this.context_item_adapters.find((adapter_class) => adapter_class.detect(key, item_data));
}
static get default_settings() {
return {
template_preset: "xml_structured",
template_before: '<item loc="{{KEY}}" at="{{TIME_AGO}}">',
template_after: "</item>"
};
}
load_from_data(context_items_data) {
delete this.items;
this.items = {};
const entries = Object.entries(context_items_data || {});
for (let i = 0; i < entries.length; i++) {
const [key, item_data] = entries[i];
if (item_data.exclude) continue;
this.new_item({
key,
...item_data
});
}
}
};
var context_items_default2 = {
version: 1,
class: ContextItems2,
collection_key: "context_items",
item_type: ContextItem2,
context_item_adapters: {
BlockContextItemAdapter: BlockContextItemAdapter2,
SourceContextItemAdapter: SourceContextItemAdapter2,
ImageContextItemAdapter: ImageContextItemAdapter2,
PdfContextItemAdapter: PdfContextItemAdapter2
}
};

function next_log_stats2(prev = {}, at_ms) {
const ct = (prev.ct || 0) + 1;
const first_at = prev.first_at ?? at_ms;
const last_at = at_ms;
return { ct, first_at, last_at };
}
__name(next_log_stats2, "next_log_stats");
var EventLog2 = class extends CollectionItem3 {
static {
__name(this, "EventLog");
}
static version = 2e-3;
/** @returns {{data: EventLogData}} */
static get defaults() {
return {
data: {
key: null,
ct: 0,
first_at: null,
last_at: null
}
};
}
/**
* Counters are updated via EventLogs listener.
* @param {Partial<EventLogData>} [_input_data]
*/
init(_input_data) {
}
};

var EXCLUDED_EVENT_KEYS2 = {
"collection:save_started": true,
"collection:save_completed": true
};
var EventLogs2 = class extends Collection3 {
static {
__name(this, "EventLogs");
}
static version = 3e-3;
constructor(env, opts = {}) {
super(env, opts);
this.session_events = [];
this.notification_status = null;
}
/**
* Factory that attaches the collection to env and registers the wildcard listener.
* @param {Object} env
* @param {Object} [opts={}]
* @returns {EventLogs}
*/
static create(env, opts = {}) {
const instance = new this(env, opts);
instance.init();
return instance;
}
/** Prefer an explicit item class to keep wiring thin. */
get item_type() {
return EventLog2;
}
/**
* Instance init
* - Ensure env.events exists
* - Register wildcard listener
* - Idempotent across repeated calls
*/
init() {
if (!this.env?.events) SmartEvents2.create(this.env);
if (this._unsub_wildcard) this._unsub_wildcard();
this._unsub_wildcard = this.env.events.on(WILDCARD_KEY2, (event, event_key) => {
this.on_any_event(event_key, event);
});
}
/**
* Handle any emitted event.
* Persists counters and timestamps in epoch ms.
* @param {string} event_key
* @param {Record<string, unknown>} event
*/
on_any_event(event_key, event) {
if (EXCLUDED_EVENT_KEYS2[event_key]) return;
this.session_events.push({ event_key, event });
if (event_key === "notification:error") this.notification_status = "error";
else if (event_key === "notification:warning" && this.notification_status !== "error") this.notification_status = "warning";
else if (event_key === "notification:attention" && !this.notification_status) this.notification_status = "attention";
try {
if (typeof event_key !== "string") return;
const at_ms = Date.now();
let event_log = this.get(event_key);
if (!event_log) {
event_log = new EventLog2(this.env, { key: event_key });
this.set(event_log);
this.emit_event("event_log:first", { first_of_event_key: event_key });
}
const next = next_log_stats2(
{ ct: event_log.data.ct, first_at: event_log.data.first_at, last_at: event_log.data.last_at },
at_ms
);
event_log.data = { ...event_log.data, ...next };
if (event.event_source) {
if (!event_log.data.event_sources) event_log.data.event_sources = {};
if (!event_log.data.event_sources[event.event_source]) {
event_log.data.event_sources[event.event_source] = 0;
}
event_log.data.event_sources[event.event_source]++;
}
event_log.queue_save();
this.queue_save();
} catch (err) {
console.error("[EventLogs] record failure", event_key, err);
}
}
/**
* Cleanly detach listeners and cancel pending save.
*/
unload() {
if (this._save_timer) {
clearTimeout(this._save_timer);
this._save_timer = null;
}
if (typeof this._unsub_wildcard === "function") {
this._unsub_wildcard();
this._unsub_wildcard = null;
}
return super.unload();
}
};
var event_logs_default2 = {
class: EventLogs2,
collection_key: "event_logs",
data_adapter: AjsonSingleFileCollectionDataAdapter3,
item_type: EventLog2
};

var import_obsidian54 = require("obsidian");

function build_suggest_scope_items2(modal, params = {}) {
if (!modal) return [];
const action_keys = Array.isArray(params.action_keys) ? params.action_keys : [];
const action_configs = modal?.env?.config?.actions || {};
const action_handlers = modal?.item_or_collection?.actions || {};
const unique_action_keys = [...new Set(action_keys)];
return unique_action_keys.reduce((acc, action_key) => {
const action_handler = action_handlers[action_key];
if (typeof action_handler !== "function") return acc;
const action_config = action_configs[action_key] || {};
const display_name9 = action_config.display_name || action_key;
acc.push({
select_action: /* @__PURE__ */ __name(() => {
modal.update_suggestions(action_key);
}, "select_action"),
key: action_key,
display: display_name9
});
return acc;
}, []);
}
__name(build_suggest_scope_items2, "build_suggest_scope_items");
var should_handle_arrow_left2 = /* @__PURE__ */ __name((modal, params = {}) => {
const input_el = modal?.inputEl;
const event_target = params.event_target;
const input_value = typeof params.input_value === "string" ? params.input_value : input_el?.value || "";
if (event_target === input_el && input_value) {
return false;
}
return true;
}, "should_handle_arrow_left");

var SmartFuzzySuggestModal2 = class extends import_obsidian54.FuzzySuggestModal {
static {
__name(this, "SmartFuzzySuggestModal");
}
constructor(item_or_collection) {
const env = item_or_collection.env;
const plugin = env.plugin;
const app = plugin.app;
super(app);
this.app = app;
env.create_env_getter(this);
this.plugin = plugin;
this.item_or_collection = item_or_collection;
this.emptyStateText = "No suggestions available";
this._set_custom_instructions = false;
}
/** Unique type key for this modal class. Subclasses override. */
static get modal_type() {
return "smart-fuzzy-suggest";
}
/** Human label used in commands. Subclasses override as needed. */
static get display_text() {
return "Smart Fuzzy Suggest";
}
/** Event name listened to on env.events to open this modal. */
static get event_domain() {
return `${this.modal_type}`;
}
/** Command id used with addCommand. */
static get command_id() {
return this.modal_type;
}
static open(item_or_collection, params) {
const Modal17 = (
/** @type {typeof SmartFuzzySuggestModal} */
this
);
const modal = new Modal17(item_or_collection, params);
modal.open(params);
return modal;
}
static register_modal(plugin) {
const Modal17 = (
/** @type {typeof SmartFuzzySuggestModal} */
this
);
const env = plugin?.env;
const modal_config = {
...env.config.modals?.[this.modal_key] || {},
class: null
};
console.log(`Registering modal: ${this.display_text}`, { modal_config, Modal: Modal17 });
const open_handler = /* @__PURE__ */ __name((payload = {}) => {
const item = Modal17.resolve_item_from_payload(env, payload);
const modal = Modal17.open(item, {
...modal_config,
...payload
});
return modal;
}, "open_handler");
const disposers = [
env?.events?.on?.(`${Modal17.event_domain}:open`, open_handler)
];
const dispose_all = /* @__PURE__ */ __name(() => {
disposers.forEach((dispose) => typeof dispose === "function" && dispose());
}, "dispose_all");
if (typeof plugin.register === "function") {
plugin.register(() => dispose_all());
}
return {
event_domain: Modal17.event_domain
};
}
static resolve_item_from_payload(env, payload) {
const item = env?.[payload.collection_key]?.items?.[payload.item_key];
return item;
}
setInstructions(instructions, is_custom = true) {
this._set_custom_instructions = is_custom;
super.setInstructions(instructions);
}
set_default_instructions() {
this.setInstructions([
{ command: "Enter", purpose: "Select" }
], false);
}
open(params = {}) {
super.open();
this.modalEl.addEventListener("keydown", (e) => {
if (e.key === "Enter") {
if (e.shiftKey) this.use_shift_select = true;
this.selectActiveSuggestion(e);
}
const is_cursor_end_of_input = this.inputEl.selectionStart === this.inputEl.value.length;
const should_handle_arrow_right = is_cursor_end_of_input || e.target !== this.inputEl || !this.inputEl.value;
const should_handle_arrow_left_action = should_handle_arrow_left2(this, {
event_target: e.target,
input_value: this.inputEl.value
});
if (e.key === "ArrowLeft" && should_handle_arrow_left_action) {
this.use_arrow_left = true;
this.selectActiveSuggestion(e);
return;
}
if (e.key === "ArrowRight" && should_handle_arrow_right) {
e.preventDefault();
this.use_mod_select = true;
this.use_arrow_right = true;
this.selectActiveSuggestion(e);
return;
}
});
}
getItems() {
return this.get_suggestions();
}
getItemText(suggestion_item) {
return suggestion_item.display;
}
filter_suggestions(suggestions) {
return suggestions;
}
get_suggestions() {
if (this.suggestions?.length) {
this.suggestions = this.filter_suggestions(this.suggestions);
if (this.suggestions.length > 0) {
return this.suggestions;
}
}
if (this.default_suggest_action_keys?.length) {
if (this.default_suggest_action_keys.length === 1) {
this.update_suggestions(this.default_suggest_action_keys[0]);
return [];
}
return this.get_suggest_scopes();
}
return [];
}
get_suggest_scopes() {
return build_suggest_scope_items2(this, {
action_keys: this.default_suggest_action_keys
});
}
async update_suggestions(suggest_ref) {
if (typeof suggest_ref === "string") {
suggest_ref = this.item_or_collection.actions[suggest_ref];
}
if (typeof suggest_ref === "function") {
this._set_custom_instructions = false;
const result = await suggest_ref({ modal: this });
console.log("Suggestion action result", result);
if (Array.isArray(result) && result.length) {
this.suggestions = result;
}
} else if (Array.isArray(suggest_ref)) {
this.suggestions = suggest_ref;
}
if (Array.isArray(this.suggestions) && this.suggestions.length) {
this.updateSuggestions();
} else {
this.env.events.emit("notification:error", { message: "Invalid suggestion action" });
console.warn("Invalid suggestion action", suggest_ref);
}
if (!this._set_custom_instructions) {
this.set_default_instructions();
}
}
get default_suggest_action_keys() {
if (Array.isArray(this.params?.default_suggest_action_keys)) {
return this.params.default_suggest_action_keys;
}
return this.env.config.modals[this.modal_key]?.default_suggest_action_keys || [];
}
renderSuggestion(sug, el) {
super.renderSuggestion(sug, el);
if (sug.item.icon) {
el.addClass("sc-modal-suggestion-has-icon");
const icon_el = el.createEl("span");
(0, import_obsidian54.setIcon)(icon_el, sug.item.icon);
}
return el;
}
onChooseSuggestion(selected, evt, ...other) {
this.prevent_close = true;
const suggestion = selected.item;
const is_arrow_left = this.use_arrow_left;
const is_arrow_right = this.use_arrow_right;
const is_shift_select = evt?.shiftKey || this.use_shift_select;
const is_mod_select = import_obsidian54.Keymap.isModifier(evt, "Mod") || this.use_mod_select;
this.use_arrow_right = false;
this.use_mod_select = false;
this.use_arrow_left = false;
this.use_shift_select = false;
if (is_arrow_left) {
if (typeof suggestion.arrow_left_action === "function") {
this.handle_choose_action(suggestion, "arrow_left_action");
} else {
if (this.last_input_value) {
this.inputEl.value = this.last_input_value;
setTimeout(() => {
const len = this.inputEl.value.length;
this.inputEl.setSelectionRange(len, len);
}, 0);
this.last_input_value = null;
}
this.suggestions = null;
this.params.default_suggest_action_keys = null;
this.updateSuggestions();
return;
}
} else if (is_arrow_right && typeof suggestion.arrow_right_action === "function") {
this.handle_choose_action(suggestion, "arrow_right_action");
} else if (is_mod_select && typeof suggestion.mod_select_action === "function") {
this.handle_choose_action(suggestion, "mod_select_action");
} else if (is_shift_select && typeof suggestion.shift_select_action === "function") {
this.handle_choose_action(suggestion, "shift_select_action");
} else if (typeof suggestion.select_action === "function") {
this.handle_choose_action(suggestion, "select_action");
} else {
this.env.events.emit("notification:warning", { selection_display: suggestion.display, message: "No action defined for this suggestion" });
}
}
async handle_choose_action(suggestion, action_key) {
let chosen_action = suggestion[action_key];
const result = await chosen_action({ modal: this });
if (Array.isArray(result) && result.length) {
this.suggestions = result;
} else if (Array.isArray(result)) {
this.env.events.emit("notification:info", { message: "No suggestions returned from action" });
}
const idx = this.chooser.values.findIndex((i) => i.item?.display === suggestion.display);
setTimeout(() => {
this.updateSuggestions();
if (idx !== -1) {
this.chooser.setSelectedItem(idx);
}
}, 100);
}
close() {
setTimeout(() => {
if (!this.prevent_close) super.close();
this.prevent_close = false;
}, 10);
}
onClose() {
this.item_or_collection.emit_event(`${this.constructor.event_domain}:closed`);
}
};

var import_obsidian55 = require("obsidian");
var ContextModal2 = class extends SmartFuzzySuggestModal2 {
static {
__name(this, "ContextModal");
}
/** Modal identity */
static get modal_type() {
return "context_selector";
}
static get display_text() {
return "Context Selector";
}
static get event_domain() {
return "context_selector";
}
static get command_id() {
return this.modal_type;
}
static get modal_key() {
return "context_selector";
}
get modal_key() {
return "context_selector";
}
constructor(smart_context, params = {}) {
super(smart_context);
this.params = { ...params };
this.smart_context = smart_context;
this.set_default_instructions();
}
set_default_instructions() {
this.setInstructions([
{ command: "Enter", purpose: "Add to context" },
{ command: `\u2192 / \u2190`, purpose: "Toggle block view" },
{ command: "Esc", purpose: "Close" }
]);
}
open(params = {}) {
this.params = { ...this.params, ...params };
super.open();
this.render(this.params);
}
async render(params = this.params) {
this.modalEl.style.display = "flex";
this.modalEl.style.flexDirection = "column";
this.modalEl.style.height = "100%";
this.modalEl.prepend(
await this.env.smart_components.render_component(
"smart_context_item",
this.smart_context,
params
)
);
}
filter_suggestions(suggestions) {
return suggestions.filter((s) => {
if (s.key && this.smart_context?.data?.context_items[s.key]) return false;
return true;
});
}
};

var import_obsidian56 = require("obsidian");
var NotificationsFeedModal2 = class extends import_obsidian56.Modal {
static {
__name(this, "NotificationsFeedModal");
}
constructor(app, env) {
super(app);
this.env = env;
}
async onOpen() {
this.titleEl.setText("Smart Env notifications");
this.contentEl.empty();
const event_log = await this.env.smart_components.render_component("notifications_feed", this.env);
this.contentEl.appendChild(event_log);
}
onClose() {
this.contentEl.empty();
}
};

var import_obsidian57 = require("obsidian");
var MILESTONES_HELP_URL2 = "https://smartconnections.app/smart-environment/milestones/?utm_source=milestones_modal_help";
var MilestonesModal2 = class extends import_obsidian57.Modal {
static {
__name(this, "MilestonesModal");
}
constructor(app, env) {
super(app);
this.env = env;
}
async onOpen() {
render_milestones_modal_title2(this.titleEl, this.env);
this.contentEl.empty();
const milestones = await this.env.smart_components.render_component("milestones", this.env, {});
this.contentEl.appendChild(milestones);
}
onClose() {
this.contentEl.empty();
}
};
function render_milestones_modal_title2(title_el, env) {
if (!title_el) return;
title_el.empty();
title_el.classList.add("sc-milestones-modal__title");
const row_el = document.createElement("div");
row_el.className = "sc-milestones-modal__title-row";
const text_el = document.createElement("div");
text_el.className = "sc-milestones-modal__title-text";
text_el.textContent = "Smart Milestones";
const help_btn_el = document.createElement("button");
help_btn_el.type = "button";
help_btn_el.className = "sc-milestones-modal__help-btn";
help_btn_el.setAttribute("aria-label", "Open Smart Milestones help");
help_btn_el.setAttribute("title", "Help");
render_help_icon2(help_btn_el);
help_btn_el.addEventListener("click", (evt) => {
evt.preventDefault();
evt.stopPropagation();
try {
env?.events?.emit?.("milestones:help", {});
} catch (err) {
}
window.open(MILESTONES_HELP_URL2, "_external");
});
row_el.appendChild(text_el);
row_el.appendChild(help_btn_el);
title_el.appendChild(row_el);
}
__name(render_milestones_modal_title2, "render_milestones_modal_title");
function render_help_icon2(icon_el) {
const ok = set_icon_with_fallback3(icon_el, ["circle-help", "help-circle", "help", "info"]);
if (!ok) icon_el.textContent = "?";
}
__name(render_help_icon2, "render_help_icon");
function set_icon_with_fallback3(icon_el, icon_ids) {
if (!icon_el) return false;
const ids = Array.isArray(icon_ids) ? icon_ids : [];
for (const icon_id of ids) {
if (typeof icon_id !== "string" || icon_id.length === 0) continue;
icon_el.textContent = "";
try {
(0, import_obsidian57.setIcon)(icon_el, icon_id);
} catch (err) {
continue;
}
if (icon_el.querySelector("svg")) return true;
}
return false;
}
__name(set_icon_with_fallback3, "set_icon_with_fallback");

var default_settings4 = {
is_obsidian_vault: true,
smart_blocks: {
embed_blocks: true,
min_chars: 200
},
smart_sources: {
min_chars: 200,
embed_model: {
adapter: "transformers",
transformers: {
model_key: "TaylorAI/bge-micro-v2"
}
},
excluded_headings: "",
file_exclusions: "Untitled",
folder_exclusions: ""
},
language: "en",
re_import_wait_time: 13,
smart_chat_threads: {
chat_model: {
adapter: "ollama",
ollama: {}
}
},
smart_notices: {},
smart_view_filter: {
expanded_view: false,
render_markdown: true,
show_full_path: false
},
version: "",
new_user: true,
models: {
embedding_platform: "transformers",
chat_completion_platform: "open_router"
}
};

var Model3 = class extends CollectionItem3 {
static {
__name(this, "Model");
}
/**
* Default properties for an instance of CollectionItem.
* @returns {Object}
*/
static get defaults() {
return {
data: {
api_key: "",
provider_key: "",
model_key: ""
}
};
}
get_key() {
if (!this.data.key) {
this.data.created_at = Date.now();
this.data.key = `${this.data.provider_key}#${this.data.created_at}`;
}
return this.data.key;
}
get provider_key() {
return this.data.provider_key;
}
get env_config() {
return this.collection.env_config;
}
get provider_config() {
return this.env_config.providers?.[this.provider_key] || {};
}
get ProviderAdapterClass() {
return this.provider_config.class;
}
get instance() {
if (!this._instance) {
if (!this.ProviderAdapterClass) {
const new_default_model = this.collection.new_model({ provider_key: this.collection.default_provider_key });
return new_default_model.instance;
}
const Class = this.ProviderAdapterClass;
this._instance = new Class(this);
this._instance.load();
this.once_event("model:changed", () => {
this._instance.unload?.();
this._instance = null;
});
}
return this._instance;
}
async count_tokens(text) {
return this.instance.count_tokens(text);
}
get api_key() {
return this.data.api_key;
}
/**
* Create (or reuse) a proxy around a target settings object so that
* any mutations trigger queue_save on the model.
* Proxies are cached per-target via WeakMap to support deep nested objects.
*
* @param {Object} target - The settings object or nested object to wrap.
* @returns {Object} Proxied object or original value if not an object.
* @private
*/
create_settings_proxy(target) {
if (!target || typeof target !== "object") return target;
if (!this._settings_proxy_map) {
this._settings_proxy_map = /* @__PURE__ */ new WeakMap();
}
const existing = this._settings_proxy_map.get(target);
if (existing) return existing;
const self = this;
const handler = {
get(target_obj, prop, receiver) {
const value = Reflect.get(target_obj, prop, receiver);
if (value && typeof value === "object") {
return self.create_settings_proxy(value);
}
return value;
},
set(target_obj, prop, value, receiver) {
const previous = target_obj[prop];
const result = Reflect.set(target_obj, prop, value, receiver);
if (previous !== value) {
self.debounce_save();
}
return result;
},
deleteProperty(target_obj, prop) {
const had = Object.prototype.hasOwnProperty.call(target_obj, prop);
const result = Reflect.deleteProperty(target_obj, prop);
if (had) {
self.debounce_save();
}
return result;
}
};
const proxy = new Proxy(target, handler);
this._settings_proxy_map.set(target, proxy);
return proxy;
}
debounce_save(ms = 100) {
this.emit_event("model:changed");
if (this._debounce_save_timeout) {
clearTimeout(this._debounce_save_timeout);
}
this._debounce_save_timeout = setTimeout(() => {
this.queue_save();
this.collection.process_save_queue();
this._debounce_save_timeout = null;
}, ms);
}
async get_model_key_options() {
const model_configs = await this.instance.get_models();
return Object.entries(model_configs).map(([key, model_config]) => ({
label: model_config.name || key,
value: model_config.key || key
})).sort((a, b) => {
if (a.label.toLowerCase().includes("free") && !b.label.toLowerCase().includes("free")) {
return -1;
}
if (!a.label.toLowerCase().includes("free") && b.label.toLowerCase().includes("free")) {
return 1;
}
return a.label.localeCompare(b.label);
});
}
model_changed(key, value, elm) {
if (key === "model_key") {
this.data.model_key = value;
const model_defaults = this.data.provider_models?.[this.data.model_key] || {};
const adapter_defaults = this.ProviderAdapterClass.defaults || {};
delete this.data.test_passed;
this.data = {
...this.data,
...adapter_defaults,
...model_defaults
};
}
if (!["api_key", "meta.name"].includes(key)) {
this.emit_event("model:changed");
}
}
/**
* @abstract should be implemented by subclasses
*/
async test_model() {
}
get display_name() {
return this.data.meta?.name || `${this.data.provider_key} - ${this.data.model_key}`;
}
get settings_config() {
return {
provider_key: {
type: "html",
value: `<p><strong>Provider:</strong> ${this.data.provider_key}</p>`
},
"meta.name": {
type: "text",
name: "Name",
description: "A friendly name for this model configuration."
},
model_key: {
type: "dropdown",
name: "Model",
description: "The model to use from the selected provider.",
options_callback: "get_model_key_options",
callback: "model_changed"
},
...Object.fromEntries(
Object.entries(this.provider_config.settings_config || {}).map(
([setting_key, setting_config]) => [setting_key, { ...setting_config, callback: setting_config.callback || "model_changed" }]
)
)
};
}
delete_model() {
this.delete();
this.debounce_save();
}
/**
* Reactive settings view for this model.
* Mutating any property (including nested objects/arrays) via this proxy
* will call queue_save().
*
* @returns {Object} Proxied view of this.data.
*/
get settings() {
return this.create_settings_proxy(this.data);
}
get model_key() {
return this.data.model_key;
}
/**
* @deprecated included for backward compatibility
*/
get opts() {
return this.settings;
}
};

var Models3 = class extends Collection3 {
static {
__name(this, "Models");
}
model_type = "Model type";
new_model(data = {}) {
if (!data.provider_key) throw new Error("provider_key is required to create a new model");
const existing_from_provider = this.filter((m) => m.provider_key === data.provider_key).sort((a, b) => b.data.created_at - a.data.created_at)[0];
if (existing_from_provider) {
if (!data.api_key && existing_from_provider.data.api_key) {
data.api_key = existing_from_provider.data.api_key;
}
}
const item = new this.item_type(this.env, {
...data
});
this.set(item);
this.settings.default_model_key = item.key;
this.emit_event("model:changed");
item.queue_save();
return item;
}
/**
* Retrieve the provider key used when creating a default model.
* @abstract
* @returns {string} provider key for the default model.
*/
get default_provider_key() {
throw new Error("default_provider_key not implemented");
}
get default_model_key() {
const should_update_default = !this.settings.default_model_key || !this.get(this.settings.default_model_key) || this.get(this.settings.default_model_key).deleted;
if (should_update_default) {
const existing = this.filter((m) => !m.deleted).sort((a, b) => b.data.created_at - a.data.created_at)[0];
if (existing) {
this.settings.default_model_key = existing.key;
} else {
const new_default = this.new_model({ provider_key: this.default_provider_key });
new_default.queue_save();
this.process_save_queue();
this.settings.default_model_key = new_default.key;
}
}
return this.settings.default_model_key;
}
get default() {
return this.get(this.default_model_key);
}
get env_config() {
return this.env.config.collections[this.collection_key];
}
get_model_key_options() {
return this.filter((i) => !i.deleted && i.ProviderAdapterClass).map((model) => ({
label: model.data.meta?.name || `${model.provider_key} - ${model.data.model_key}`,
value: model.key
}));
}
};
function settings_config22(scope) {
return {
default_model_key: {
type: "dropdown",
name: `Default ${scope.model_type.toLowerCase()} model`,
description: `Used as the default ${scope.model_type.toLowerCase()} model when no other is specified.`,
options_callback: /* @__PURE__ */ __name(() => {
return scope.get_model_key_options();
}, "options_callback"),
callback: /* @__PURE__ */ __name(async (value, setting) => {
scope.emit_event("model:changed");
}, "callback")
}
};
}
__name(settings_config22, "settings_config");

var EmbeddingModel2 = class extends Model3 {
static {
__name(this, "EmbeddingModel");
}
/**
* Default properties for an instance of CollectionItem.
* @returns {Object}
*/
static get defaults() {
return {
data: {
api_key: "",
provider_key: "transformers",
model_key: "TaylorAI/bge-micro-v2",
dims: 384,
max_tokens: 512
}
};
}
async embed(input) {
if (typeof input === "string") {
input = [{ embed_input: input }];
}
return (await this.embed_batch(input))[0];
}
async embed_batch(inputs) {
return this.instance.embed_batch(inputs);
}
async test_model() {
try {
const resp = await this.embed("test input");
const success = resp && !resp?.error;
this.data.test_passed = success;
this.debounce_save();
return { success, response: resp };
} catch (e) {
this.data.test_passed = false;
return { error: e.message || String(e) };
}
}
};

var EmbeddingModels2 = class extends Models3 {
static {
__name(this, "EmbeddingModels");
}
model_type = "Embedding";
get default_provider_key() {
return "transformers";
}
};
var embedding_models_collection2 = {
class: EmbeddingModels2,
data_dir: "embedding_models",
collection_key: "embedding_models",
data_adapter: ajson_single_file_default3,
item_type: EmbeddingModel2,
providers: {
},
settings_config: settings_config22
};
var embedding_models_default3 = embedding_models_collection2;

var TransformersIframeEmbeddingModelAdapter2 = class extends SmartEmbedTransformersIframeAdapter2 {
static {
__name(this, "TransformersIframeEmbeddingModelAdapter");
}
constructor(model_item) {
super(model_item);
}
get models() {
return {
"TaylorAI/bge-micro-v2": {
"id": "TaylorAI/bge-micro-v2",
"batch_size": 1,
"dims": 384,
"max_tokens": 512,
"name": "BGE-micro-v2 (fastest)",
"description": "Local, 512 tokens, 384 dim (recommended)",
"adapter": "transformers"
},
"Snowflake/snowflake-arctic-embed-xs": {
"id": "Snowflake/snowflake-arctic-embed-xs",
"batch_size": 1,
"dims": 384,
"max_tokens": 512,
"name": "Snowflake Arctic Embed XS (fast)",
"description": "Local, 512 tokens, 384 dim",
"adapter": "transformers"
},
"Xenova/multilingual-e5-small": {
"id": "Xenova/multilingual-e5-small",
"batch_size": 1,
"dims": 384,
"max_tokens": 512,
"name": "Multilingual E5 Small",
"description": "Local, 512 tokens, 384 dim",
"adapter": "transformers"
}
};
}
};
var transformers_iframe_default2 = {
class: TransformersIframeEmbeddingModelAdapter2,
settings_config: settings_config21
};

embedding_models_default3.providers = {
transformers: transformers_iframe_default2
};
var embedding_models_default4 = embedding_models_default3;

var LookupList2 = class extends CollectionItem3 {
static {
__name(this, "LookupList");
}
static key = "lookup_list";
static get defaults() {
return { data: {} };
}
async pre_process(params) {
if (typeof this.actions.lookup_list_pre_process === "function") {
await this.actions.lookup_list_pre_process(params);
}
}
async get_results(params = {}) {
await this.pre_process(params);
let results = this.filter_and_score(params);
if (this.should_post_process) results = await this.post_process(results, params);
this.emit_event("lookup:get_results");
return results;
}
filter_and_score(params = {}) {
const collection = this.env[params.results_collection_key] || this.env[this.collection.results_collection_key];
const score_errors = [];
const { results: raw_results } = Object.values(collection.items).reduce((acc, target) => {
const scored = target.filter_and_score(params);
if (!scored?.score) {
if (scored?.error) score_errors.push(scored.error);
return acc;
}
results_acc3(acc, scored, params.limit || 20);
return acc;
}, { min: 0, results: /* @__PURE__ */ new Set() });
const results = Array.from(raw_results).sort(sort_by_score_descending3);
if (!results.length) return results;
while (!results.some((r) => r.score > 0.5)) {
results.forEach((r) => r.score *= 2);
}
return results;
}
async post_process(results, params = {}) {
return results;
}
get should_post_process() {
return this.settings.lookup_post_process && this.settings.lookup_post_process !== "none";
}
get item() {
return this;
}
};

var settings_config23 = {
results_collection_key: {
name: "Lookup results type",
type: "dropdown",
description: "Choose whether results should be sources or blocks.",
option_1: "smart_sources|Sources",
option_2: "smart_blocks|Blocks",
options_callback: /* @__PURE__ */ __name((scope) => {
const options = [
{ value: "smart_sources", name: "Sources" }
];
if (scope.env.smart_blocks) {
options.push({ value: "smart_blocks", name: "Blocks" });
}
return options;
}, "options_callback")
}
};
var LookupLists2 = class extends Collection3 {
static {
__name(this, "LookupLists");
}
static get default_settings() {
return {
results_collection_key: "smart_blocks",
score_algo_key: "similarity",
results_limit: 20
};
}
static version = 0.01;
new_item({ query, filter }) {
if (!query || typeof query !== "string" || !query.trim()) {
throw new Error("LookupLists.new_item requires a non-empty query string.");
}
const date = format_ymd2(/* @__PURE__ */ new Date());
const hash = murmur_hash_32_alphanumeric3(query);
const key = `${date}+${hash}`;
if (this.items[key]) return this.items[key];
const list = new LookupList2(this.env, {
key,
query,
filter
});
this.set(list);
return list;
}
get settings_config() {
return { ...settings_config23 };
}
process_load_queue() {
}
get results_collection_key() {
const stored_key = this.settings?.results_collection_key;
if (this.env.collections?.[stored_key]) return stored_key;
return "smart_sources";
}
};
function format_ymd2(d) {
const y = d.getFullYear();
const m = String(d.getMonth() + 1).padStart(2, "0");
const day = String(d.getDate()).padStart(2, "0");
return `${y}-${m}-${day}`;
}
__name(format_ymd2, "format_ymd");
var lookup_lists_default2 = {
class: LookupLists2,
collection_key: "lookup_lists",
item_type: LookupList2,
settings_config: settings_config23
};

function format_collection_name2(key) {
return key.replace(/_/g, " ").replace(/\b\w/g, (c) => c.toUpperCase());
}
__name(format_collection_name2, "format_collection_name");

async function build_html30(collection, opts = {}) {
const settings_html = Object.entries(collection.settings_config).map(([setting_key, setting_config]) => {
if (!setting_config.setting) setting_config.setting = setting_key;
return this.render_setting_html(setting_config);
}).join("\n");
const html = `<div><div class="collection-settings-container"><div class="source-settings collection-settings">
<h2>${format_collection_name2(collection.collection_key)}</h2>
${settings_html}
</div></div></div>`;
return html;
}
__name(build_html30, "build_html");
async function render30(collection, opts = {}) {
const html = await build_html30.call(this, collection, opts);
const frag = this.create_doc_fragment(html);
await this.render_setting_components(frag, { scope: collection });
if (opts.settings_container) {
this.empty(opts.settings_container);
opts.settings_container.appendChild(frag.querySelector(".collection-settings"));
} else {
collection.settings_container = frag.querySelector(".collection-settings-container");
}
return collection.settings_container;
}
__name(render30, "render");

var import_obsidian58 = require("obsidian");
function register_block_hover_popover2(parent, target, env, block_key, params = {}) {
const app = env?.plugin?.app || window.app;
target.addEventListener("mouseover", async (ev) => {
if (import_obsidian58.Keymap.isModEvent(ev)) {
const block = env.smart_blocks.get(block_key);
const markdown = await block?.read();
if (markdown) {
const popover = new import_obsidian58.HoverPopover(parent, target);
const frag = env.smart_view.create_doc_fragment(`<div class="markdown-embed is-loaded">
<div class="markdown-embed-content node-insert-event">
<div class="markdown-preview-view markdown-rendered node-insert-event show-indentation-guide allow-fold-headings allow-fold-lists">
<div class="markdown-preview-sizer markdown-preview-section">
</div>
</div>
</div>
</div>`);
popover.hoverEl.classList.add("smart-block-popover");
popover.hoverEl.appendChild(frag);
const sizer = popover.hoverEl.querySelector(".markdown-preview-sizer");
import_obsidian58.MarkdownRenderer.render(app, markdown, sizer, "/", popover);
const event_domain = params.event_key_domain || "block";
block.emit_event(`${event_domain}:hover_preview`);
}
}
});
}
__name(register_block_hover_popover2, "register_block_hover_popover");

var import_obsidian59 = require("obsidian");
function register_item_hover_popover2(container, item, params = {}) {
const app = item.env?.plugin?.app || window.app;
if (item.key.indexOf("{") === -1) {
container.addEventListener("mouseover", (event) => {
const linktext_path = item.key.replace(/#$/, "");
app.workspace.trigger("hover-link", {
event,
source: "smart-connections-view",
hoverParent: container.parentElement,
targetEl: container,
linktext: linktext_path
});
if (import_obsidian59.Keymap.isModEvent(event)) {
const event_domain = params.event_key_domain || item.collection_key || "item";
item.emit_event(`${event_domain}:hover_preview`);
}
});
} else {
register_block_hover_popover2(container.parentElement, container, item.env, item.key);
}
}
__name(register_item_hover_popover2, "register_item_hover_popover");

var import_obsidian60 = require("obsidian");
function format_score2(score) {
const numeric_score = typeof score === "number" ? score : Number.parseFloat(score);
if (!Number.isFinite(numeric_score)) return null;
return Number.parseFloat(numeric_score.toFixed(2)).toString();
}
__name(format_score2, "format_score");
function format_size2(size) {
const numeric_size = typeof size === "number" ? size : Number.parseFloat(size);
if (!Number.isFinite(numeric_size) || numeric_size < 0) return null;
const units = ["B", "KB", "MB", "GB"];
let size_value = numeric_size;
let unit_index = 0;
while (size_value >= 1024 && unit_index < units.length - 1) {
size_value /= 1024;
unit_index += 1;
}
const precision = size_value >= 10 || Number.isInteger(size_value) ? 0 : 1;
const rounded_value = Number.parseFloat(size_value.toFixed(precision));
return `${rounded_value.toString()} ${units[unit_index]}`;
}
__name(format_size2, "format_size");
function build_badge_html2(label, class_name) {
if (!label) return "";
return `<span class="${class_name}">${label}</span>`;
}
__name(build_badge_html2, "build_badge_html");
function build_html31(context_item, params = {}) {
let name;
if (context_item.item_ref) {
if (context_item.item_ref.key.includes("#")) {
const name_pcs = context_item.item_ref.key.split("/").pop().split("#").filter(Boolean);
const last_pc = name_pcs.pop();
const segments = [];
if (last_pc && last_pc.startsWith("{")) {
segments.push(name_pcs.pop());
segments.push(context_item.item_ref.lines.join("-"));
name = segments.join(" > Lines: ");
}
} else {
name = context_item.item_ref.key.split("/").pop();
}
} else {
name = context_item.key.split("/").pop();
}
const score = format_score2(context_item?.data?.score);
const size = format_size2(context_item?.size || context_item?.data?.size);
const score_html = build_badge_html2(score, "sc-context-item-score");
const size_html = build_badge_html2(size, "sc-context-item-size");
return `<span class="sc-context-item-leaf">
<span class="sc-context-item-remove" data-path="${context_item.key}">\xD7</span>
${score_html}
<span class="sc-context-item-name">${name || context_item.key}</span>
${size_html}
</span>`;
}
__name(build_html31, "build_html");
async function render31(context_item, params = {}) {
const html = build_html31(context_item, params);
const frag = this.create_doc_fragment(html);
const container = frag.firstElementChild;
post_process29.call(this, context_item, container, params);
return container;
}
__name(render31, "render");
async function post_process29(context_item, container, params = {}) {
const env = context_item.env;
const remove_btn = container.querySelector(".sc-context-item-remove");
if (remove_btn) {
remove_btn.addEventListener("click", (event) => {
const target = event.currentTarget;
const tree_container = target.closest("[data-context-key]");
const ctx_key = tree_container?.getAttribute("data-context-key");
const ctx = env.smart_contexts.get(ctx_key);
ctx.remove_item(context_item.key);
});
}
if (context_item.item_ref) {
const name2 = container.querySelector(".sc-context-item-name");
name2.setAttribute("title", `Hold ${import_obsidian60.Platform.isMacOS ? "\u2318" : "Ctrl"} to preview`);
register_item_hover_popover2(name2, context_item.item_ref);
}
const name = container.querySelector(".sc-context-item-name");
name.addEventListener("click", (event) => {
context_item.open(event);
});
return container;
}
__name(post_process29, "post_process");

async function build_html32(env, opts = {}) {
const lines = [];
lines.push(`<h2>Collections</h2>`);
const collection_keys = Object.keys(env.collections).filter((key) => ["smart_sources", "smart_blocks"].includes(key)).sort((a, b) => {
if (a === "smart_sources" || a === "smart_blocks") return -1;
if (b === "smart_sources" || b === "smart_blocks") return 1;
return a.localeCompare(b);
});
for (const collection_key of collection_keys) {
const collection = env[collection_key];
if (!collection || !collection.items) {
lines.push(`
<div class="sc-collection-stats">
<h3>${format_collection_name2(collection_key)}</h3>
<p>No valid items.</p>
</div>
`);
continue;
}
const snippet = generate_collection_stats2(collection, collection_key);
lines.push(snippet);
}
return `
<div class="sc-env-stats-container">
${lines.join("\n")}
</div>
`;
}
__name(build_html32, "build_html");
async function render32(env, opts = {}) {
const html = await build_html32.call(this, env, opts);
const frag = this.create_doc_fragment(html);
return await post_process30.call(this, env, frag, opts);
}
__name(render32, "render");
async function post_process30(env, frag, opts = {}) {
return frag;
}
__name(post_process30, "post_process");
function generate_collection_stats2(collection, collectionKey) {
const total_items = Object.values(collection.items).length;
const niceName = format_collection_name2(collectionKey);
const state = collection.env.collections[collectionKey];
if (state !== "loaded") {
return `
<div class="sc-collection-stats">
<h3>${niceName}</h3>
<p>Not loaded yet (${total_items} items known).</p>
</div>
`;
}
const load_time_html = collection.load_time_ms ? `<p>Load time: ${collection.load_time_ms}ms</p>` : "";
const state_html = `<p>State: ${state}</p>`;
let html = get_generic_collection_stats2(collection, niceName, total_items);
let embed_stats = "";
if (typeof collection.process_embed_queue === "function") {
embed_stats = calculate_embed_coverage2(collection, total_items);
}
return `
<div class="sc-collection-stats">
<h3>${niceName}</h3>
${embed_stats}
${html}
${load_time_html}
${state_html}
</div>
`;
}
__name(generate_collection_stats2, "generate_collection_stats");
function get_generic_collection_stats2(collection, niceName, total_items, load_time_html) {
return `
<p><strong>Total:</strong> ${total_items}</p>
`;
}
__name(get_generic_collection_stats2, "get_generic_collection_stats");
function calculate_embed_coverage2(collection, total_items) {
const embedded_items = Object.values(collection.items).filter((item) => item.vec);
if (!embedded_items.length) return "<p>No items embedded</p>";
const stats = Object.values(collection.items).reduce((acc, i) => {
if (i.should_embed) acc.should_embed += 1;
else acc.should_not_embed += 1;
if (i.vec) acc.embedded += 1;
if (i.should_embed && !i.vec) acc.missing_embed += 1;
if (!i.should_embed && i.vec) acc.extraneous_embed += 1;
return acc;
}, { should_embed: 0, embedded: 0, missing_embed: 0, extraneous_embed: 0, should_not_embed: 0 });
const pct = stats.embedded / stats.should_embed * 100;
const percent = Math.round(pct);
return `<p><strong>Embedding coverage:</strong> ${percent}% (${stats.embedded} / ${stats.should_embed})</p>` + (stats.missing_embed ? `<p><strong>Missing embeddings:</strong> ${stats.missing_embed}</p>` : "") + (stats.extraneous_embed ? `<p><strong>Extraneous embeddings:</strong> ${stats.extraneous_embed}</p>` : "") + (stats.should_not_embed ? `<p><strong>Other items (e.g. less than minimum length to embed):</strong> ${stats.should_not_embed}</p>` : "");
}
__name(calculate_embed_coverage2, "calculate_embed_coverage");

var import_obsidian61 = require("obsidian");
function build_html33(scope, params = {}) {
return `<div class="smart-form-dropdown-component"></div>`;
}
__name(build_html33, "build_html");
async function render33(scope, params = {}) {
const html = build_html33.call(this, scope, params);
const frag = this.create_doc_fragment(html);
return await post_process31.call(this, scope, frag, params);
}
__name(render33, "render");
async function post_process31(scope, container, params = {}) {
if (!scope) {
container.textContent = "Error: scope is required for dropdown component.";
return container;
}
const settings = scope.settings;
if (!settings || typeof settings !== "object") {
container.textContent = "Error: scope.settings{} is required for dropdown component.";
return container;
}
const setting_key = params.setting_key;
if (!setting_key) {
container.textContent = "Error: setting_key is required for dropdown component.";
return container;
}
const options = params.options;
if (!Array.isArray(options) || options.length === 0) {
container.textContent = "Error: options[] is required for dropdown component.";
return container;
}
const setting = new import_obsidian61.Setting(container);
if (params.label && typeof setting.setName === "function") {
setting.setName(params.label);
}
if (params.description && typeof setting.setDesc === "function") {
setting.setDesc(params.description);
}
if (params.tooltip && typeof setting.setTooltip === "function") {
setting.setTooltip(params.tooltip);
}
const current_value = get_by_path2(settings, setting_key) ?? "";
let select_el = null;
setting.addDropdown((dropdown) => {
console.log({ dropdown, current_value, scope, options });
select_el = dropdown.selectEl;
if (params.required) {
select_el.setAttribute("required", "true");
}
options.forEach((opt) => {
dropdown.addOption(opt.value, opt.label);
});
select_el.childNodes.forEach((option_el) => {
if (option_el.value === current_value) {
option_el.selected = true;
}
if (options.find((o) => o.value === option_el.value)?.disabled) {
option_el.disabled = true;
}
});
if (select_el) {
select_el.value = current_value;
}
});
const handler = /* @__PURE__ */ __name(() => {
const value = select_el.value;
if (typeof params.on_change === "function") {
params.on_change(value, { scope, setting_key, select_el, container });
} else {
set_by_path2(scope.settings, setting_key, value);
}
}, "handler");
select_el.addEventListener("change", handler);
this.attach_disposer(select_el, () => {
select_el.removeEventListener("change", handler);
});
return container;
}
__name(post_process31, "post_process");
render33.version = 0.2;

var import_obsidian62 = require("obsidian");
function build_html34(env, opts = {}) {
return `<div class="wrapper">
<div id="lean-coffee-callout" data-callout-metadata="" data-callout-fold="" data-callout="info" class="callout" style="mix-blend-mode: unset;">
<div class="callout-title" style="align-items: center;">
<div class="callout-icon">
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-info">
<circle cx="12" cy="12" r="10"></circle>
<path d="M12 16v-4"></path>
<path d="M12 8h.01"></path>
</svg>
</div>
<div class="callout-title-inner">
<strong>Community Lean Coffee</strong>
</div>
</div>
<div class="callout-content">
<p dir="auto">
<span>Ask questions. Bring challenges. Request features. Show workflows. Be ready to share.</span>
<br>
<i>Join the next <a href="https://lu.ma/calendar/cal-ZJtdnzAdURyouM7" target="_external">Community Lean Coffee</a> meeting.</i> Unable to attend? Submit a question <a href="https://docs.google.com/forms/d/e/1FAIpQLSdqOtTjksMwg1BOuGNCncpMQ_QT-wcd-3AgZGIe3A_isut5aQ/viewform?usp=dialog" target="_external">here</a> \u{1F334}
</p>
</div>
</div>
</div>`;
}
__name(build_html34, "build_html");
function render34(env, opts = {}) {
const html = build_html34.call(this, env, opts);
const frag = this.create_doc_fragment(html);
const callout = frag.querySelector("#lean-coffee-callout");
const icon_container = callout.querySelector(".callout-icon");
const icon = (0, import_obsidian62.getIcon)("smart-chat");
if (icon) {
this.empty(icon_container);
icon_container.appendChild(icon);
}
post_process32.call(this, env, callout, opts);
return callout;
}
__name(render34, "render");
function post_process32(env, callout) {
}
__name(post_process32, "post_process");

var milestones_default2 = `.sc-events-checklist {\r
display: flex;\r
flex-direction: column;\r
gap: var(--size-4-3);\r
padding: var(--size-4-2);\r
\r
.sc-events-checklist__header {\r
display: flex;\r
align-items: baseline;\r
justify-content: space-between;\r
gap: var(--size-4-3);\r
}\r
\r
.sc-events-checklist__title {\r
margin: 0;\r
font-size: var(--h2-size);\r
}\r
\r
.sc-events-checklist__summary {\r
font-size: var(--font-ui-small);\r
color: var(--text-normal);\r
font-variant-numeric: tabular-nums;\r
\r
padding: 0.15em 0.6em;\r
border-radius: 999px;\r
background-color: var(--background-secondary);\r
border: 1px solid var(--background-modifier-border);\r
white-space: nowrap;\r
}\r
\r
.sc-events-checklist__hint {\r
font-size: var(--font-ui-small);\r
color: var(--text-muted);\r
text-align: right;\r
}\r
\r
.sc-events-checklist__progress {\r
height: 6px;\r
border-radius: 999px;\r
overflow: hidden;\r
background-color: var(--background-secondary);\r
border: 1px solid var(--background-modifier-border);\r
}\r
\r
.sc-events-checklist__progress-fill {\r
height: 100%;\r
width: var(--sc-events-checklist-progress, 0%);\r
background-color: var(--color-green, var(--interactive-accent));\r
}\r
\r
.sc-events-checklist__group {\r
border-top: 1px solid var(--background-modifier-border);\r
padding-top: var(--size-4-3);\r
}\r
\r
.sc-events-checklist__group-title {\r
margin: 0 0 var(--size-4-2) 0;\r
font-size: var(--h3-size);\r
\r
display: flex;\r
align-items: baseline;\r
justify-content: space-between;\r
gap: var(--size-4-2);\r
}\r
\r
.sc-events-checklist__group-name {\r
display: inline-flex;\r
align-items: center;\r
min-width: 0;\r
}\r
\r
.sc-events-checklist__group-count {\r
font-size: var(--font-ui-small);\r
color: var(--text-muted);\r
white-space: nowrap;\r
font-variant-numeric: tabular-nums;\r
flex: 0 0 auto;\r
}\r
\r
/*\r
Group completion badge:\r
- shows only when every item in the group is checked\r
- uses :has() (no JS needed)\r
- avoids false positives on empty groups by requiring at least one item\r
*/\r
.sc-events-checklist__group:has(.sc-events-checklist__item):not(:has(.sc-events-checklist__item[data-checked='false'])) {\r
.sc-events-checklist__group-name::after {\r
content: "DONE";\r
\r
/* layout */\r
display: inline-flex;\r
align-items: center;\r
justify-content: center;\r
margin-left: 0.5em;\r
padding: 0.08em 0.55em;\r
border-radius: 999px;\r
white-space: nowrap;\r
vertical-align: middle;\r
\r
/* typography */\r
font-size: 0.65em;\r
font-weight: 700;\r
letter-spacing: 0.12em;\r
text-transform: uppercase;\r
\r
/* theme vars (with safe fallback) */\r
color: var(--color-green, var(--text-accent));\r
background-color: var(--background-secondary);\r
border: 1px solid var(--background-modifier-border);\r
\r
/* subtle depth, theme-aware */\r
box-shadow:\r
0 0 0 1px var(--background-primary),\r
0 1px 3px rgba(0, 0, 0, 0.25);\r
transform: translateY(-0.03em);\r
}\r
}\r
\r
.sc-events-checklist__items {\r
list-style: none;\r
padding: 0;\r
margin: 0;\r
display: flex;\r
flex-direction: column;\r
gap: var(--size-2-2);\r
}\r
\r
.sc-events-checklist__item {\r
display: flex;\r
flex-direction: column;\r
gap: 2px;\r
padding: 6px 8px;\r
border-radius: var(--radius-s);\r
\r
cursor: pointer;\r
border: 1px solid transparent;\r
\r
transition:\r
background-color 120ms ease,\r
border-color 120ms ease,\r
transform 120ms ease;\r
\r
&:hover {\r
background: var(--background-modifier-hover);\r
border-color: var(--background-modifier-border);\r
}\r
\r
&:active {\r
transform: translateY(1px);\r
}\r
\r
&:focus-visible {\r
outline: 2px solid var(--interactive-accent);\r
outline-offset: 2px;\r
background: var(--background-modifier-hover);\r
border-color: var(--interactive-accent);\r
}\r
}\r
\r
.sc-events-checklist__label {\r
display: flex;\r
align-items: flex-start;\r
gap: var(--size-2-2);\r
cursor: pointer;\r
}\r
\r
.sc-events-checklist__icon {\r
display: inline-flex;\r
align-items: center;\r
justify-content: center;\r
margin-top: 2px;\r
width: 18px;\r
height: 18px;\r
flex: 0 0 auto;\r
color: var(--text-muted);\r
\r
svg {\r
width: 18px;\r
height: 18px;\r
}\r
}\r
\r
.sc-events-checklist__milestone {\r
line-height: 1.3;\r
user-select: text;\r
cursor: text;\r
}\r
\r
.sc-events-checklist__item[data-checked='true'] {\r
.sc-events-checklist__icon {\r
color: var(--color-green, var(--text-accent));\r
}\r
\r
.sc-events-checklist__milestone {\r
color: var(--text-normal);\r
}\r
}\r
}\r
\r
/* 1) Host elements that should get a PRO badge */\r
.sc-events-checklist__label.pro-milestone > .sc-events-checklist__milestone {\r
position: relative; /* safe default, keeps ::after anchored */\r
}\r
\r
/* 2) The PRO badge itself */\r
.sc-events-checklist__label.pro-milestone > .sc-events-checklist__milestone::after {\r
content: "PRO";\r
\r
/* layout */\r
display: inline-flex;\r
align-items: center;\r
justify-content: center;\r
margin-left: 0.4em;\r
padding: 0.08em 0.55em;\r
border-radius: 999px;\r
white-space: nowrap;\r
vertical-align: middle;\r
\r
/* typography */\r
font-size: 0.7em;\r
font-weight: 600;\r
letter-spacing: 0.14em;\r
text-transform: uppercase;\r
line-height: 1;\r
\r
/* color system: only Obsidian variables */\r
background-color: var(--interactive-accent);\r
background-image: linear-gradient(\r
135deg,\r
var(--interactive-accent),\r
var(--interactive-accent-hover)\r
);\r
color: var(--text-on-accent, var(--background-primary));\r
border: 1px solid var(--background-modifier-border);\r
\r
/* subtle separation & depth, theme-aware */\r
box-shadow:\r
0 0 0 1px var(--background-primary),\r
0 1px 3px rgba(0, 0, 0, 0.35);\r
transform: translateY(-0.03em);\r
}\r
\r
/* 3) Interactive refinement: follow Obsidian's accent hover behavior */\r
.sc-events-checklist__label.pro-milestone > .sc-events-checklist__milestone:hover::after {\r
background-color: var(--interactive-accent-hover);\r
filter: brightness(1.05);\r
}\r
\r
/* Milestones modal: title row help icon */\r
.sc-milestones-modal__title {\r
width: 100%;\r
}\r
\r
.sc-milestones-modal__title-row {\r
display: flex;\r
align-items: center;\r
gap: var(--size-4-2);\r
width: 100%;\r
}\r
\r
.sc-milestones-modal__title-text {\r
min-width: 0;\r
}\r
\r
.sc-milestones-modal__help-btn {\r
display: inline-flex;\r
align-items: center;\r
justify-content: center;\r
\r
width: 28px;\r
height: 28px;\r
padding: 0;\r
border-radius: var(--radius-s);\r
\r
background: transparent;\r
border: 1px solid transparent;\r
color: var(--text-muted);\r
\r
cursor: pointer;\r
}\r
\r
.sc-milestones-modal__help-btn svg {\r
width: 18px;\r
height: 18px;\r
}\r
\r
.sc-milestones-modal__help-btn:hover {\r
background: var(--background-modifier-hover);\r
border-color: var(--background-modifier-border);\r
color: var(--text-normal);\r
}\r
\r
.sc-milestones-modal__help-btn:active {\r
transform: translateY(1px);\r
}\r
\r
.sc-milestones-modal__help-btn:focus-visible {\r
outline: 2px solid var(--interactive-accent);\r
outline-offset: 2px;\r
background: var(--background-modifier-hover);\r
border-color: var(--interactive-accent);\r
}\r
`;

var import_obsidian64 = require("obsidian");

var import_obsidian63 = require("obsidian");

var PLUGIN_INSTALL_EVENT_CONFIG2 = {
"connections:installed": {
ids: ["smart-connections"]
},
"connections_pro:installed": {
ids: ["smart-connections"],
require_pro_name: true
},
"context:installed": {
ids: ["smart-context"]
},
"context_pro:installed": {
ids: ["smart-context"],
require_pro_name: true
},
"chat:installed": {
ids: ["smart-chatgpt", "smart-chat"]
},
"chat_pro:installed": {
ids: ["smart-chat"],
require_pro_name: true
}
};
var EVENTS_CHECKLIST_ITEMS_BY_EVENT_KEY2 = {
"sources:import_completed": {
group: "Environment",
milestone: "Initial vault import completed (all sources discovered).",
link: "https://smartconnections.app/smart-environment/settings/?utm_source=milestones#sources"
},
"embedding:completed": {
group: "Environment",
milestone: "Initial embedding completed, you are ready to make connections!",
link: "https://smartconnections.app/smart-environment/settings/?utm_source=milestones#embedding-models"
},
"connections:installed": {
group: "Connections",
milestone: "Installed Smart Connections (core plugin).",
link: "https://smartconnections.app/smart-connections/list-feature/?utm_source=milestones"
},
"connections:opened": {
group: "Connections",
milestone: "Opened the connections view.",
link: "https://smartconnections.app/smart-connections/list-feature/?utm_source=milestones#quick-start"
},
"connections:drag_result": {
group: "Connections",
milestone: "Dragged a Smart Connections result into a note to create a link.",
link: "https://smartconnections.app/smart-connections/list-feature/?utm_source=milestones#drag-link"
},
"connections:open_result": {
group: "Connections",
milestone: "Opened a Smart Connections result from the UI (list item or inline popover).",
link: "https://smartconnections.app/smart-connections/list-feature/?utm_source=milestones#core-interactions"
},
"connections:sent_to_context": {
group: "Connections",
milestone: "Sent Connections results to Smart Context (turn discovery into a context pack).",
link: "https://smartconnections.app/smart-connections/list-feature/?utm_source=milestones#send-to-context"
},
"connections:copied_list": {
group: "Connections",
milestone: "Copied Connections results as a list of links.",
link: "https://smartconnections.app/smart-connections/list-feature/?utm_source=milestones#copy-list"
},
"connections:hover_preview": {
group: "Connections",
milestone: "Previewed a connection by holding cmd/ctrl while hovering the result.",
link: "https://smartconnections.app/smart-connections/list-feature/?utm_source=milestones#core-interactions"
},
"connections:open_random": {
group: "Connections",
milestone: "Opened a random connection from Smart Connections.",
link: "https://smartconnections.app/smart-connections/getting-started/?utm_source=milestones#open-a-random-connection"
},
"connections:hidden_item": {
group: "Connections",
milestone: "Hidden a connection item from the list.",
link: "https://smartconnections.app/smart-connections/list-feature/?utm_source=milestones#manage-noise"
},
"connections:pinned_item": {
group: "Connections",
milestone: "Pinned a connection item in the list.",
link: "https://smartconnections.app/smart-connections/list-feature/?utm_source=milestones#manage-noise"
},
"connections_pro:installed": {
group: "Connections Pro",
milestone: "Installed Smart Connections Pro.",
link: "https://smartconnections.app/pro-plugins/?utm_source=milestones#connections-pro",
is_pro: true
},
"lookup:hover_preview": {
group: "Lookup",
milestone: "Previewed a Smart Lookup result by holding cmd/ctrl while hovering.",
link: "https://smartconnections.app/smart-connections/lookup/?utm_source=milestones#understanding-results"
},
"lookup:get_results": {
group: "Lookup",
milestone: "Submitted a lookup query (started a semantic search).",
link: "https://smartconnections.app/smart-connections/lookup/?utm_source=milestones"
},
"lookup:drag_result": {
group: "Lookup",
milestone: "Dragged a Smart Lookup result into a note to create a link.",
link: "https://smartconnections.app/smart-connections/lookup/?utm_source=milestones#understanding-results"
},
"lookup:open_result": {
group: "Lookup",
milestone: "Opened a Lookup result.",
link: "https://smartconnections.app/smart-connections/lookup/?utm_source=milestones#understanding-results"
},
"context:created": {
group: "Context",
milestone: "First context created!",
link: "https://smartconnections.app/smart-context/builder/?utm_source=milestones#quick-start"
},
"context:copied": {
group: "Context",
milestone: "Copied context to clipboard.",
link: "https://smartconnections.app/smart-context/clipboard/?utm_source=milestones#copy-current"
},
"context:file_nav_copied": {
group: "Context",
milestone: "Copied context from the file navigator.",
link: "https://smartconnections.app/smart-context/clipboard/?utm_source=milestones#copy-selected"
},
"context_selector:open": {
group: "Context",
milestone: "Opened the Context Builder selector modal.",
link: "https://smartconnections.app/smart-context/builder/?utm_source=milestones#open-builder"
},
"context:named": {
group: "Context",
milestone: "Named a Smart Context (created a reusable saved context).",
link: "https://smartconnections.app/smart-context/builder/?utm_source=milestones#save-reuse"
},
"context:renamed": {
group: "Context",
milestone: "Renamed a Smart Context (increased clarity).",
link: "https://smartconnections.app/smart-context/builder/?utm_source=milestones#save-reuse"
},
"context:copied_with_media": {
group: "Context Pro",
milestone: "Copied context with media (images/PDF pages) for multimodal workflows.",
link: "https://smartconnections.app/smart-context/clipboard/?utm_source=milestones#copy-modes",
is_pro: true
},
"context_pro:installed": {
group: "Context Pro",
milestone: "Installed Smart Context Pro.",
link: "https://smartconnections.app/pro-plugins/?utm_source=milestones#context-pro",
is_pro: true
},
"chat:installed": {
group: "Chat",
milestone: "Installed Smart ChatGPT.",
link: "https://smartconnections.app/smart-chat/?utm_source=milestones"
},
"chat_codeblock:saved_thread": {
group: "Chat",
milestone: "Started a chat in a Smart Chat codeblock (opened the loop).",
link: "https://smartconnections.app/smart-chat/codeblock/?utm_source=milestones#quick-start"
},
"completion:completed": {
group: "Chat Pro",
milestone: "Received the first Smart Chat response (a completion finished).",
link: "https://smartconnections.app/smart-chat/api-integration/?utm_source=milestones#quick-start",
is_pro: true
},
"chat_codeblock:marked_done": {
group: "Chat",
milestone: "Marked the chat thread as done (closed the loop).",
link: "https://smartconnections.app/smart-chat/codeblock/?utm_source=milestones#chat-inbox"
},
"chat_pro:installed": {
group: "Chat Pro",
milestone: "Installed Smart Chat Pro.",
link: "https://smartconnections.app/pro-plugins/?utm_source=milestones#chat-pro",
is_pro: true
},
"smart_plugins_oauth_completed": {
group: "Pro",
milestone: "Connected account (enabled Pro plugins).",
link: "https://smartconnections.app/pro-plugins/?utm_source=milestones"
},
"inline_connections:show": {
group: "Connections Pro",
milestone: "Opened inline connections in-note (used the inline workflow).",
link: "https://smartconnections.app/smart-connections/inline/?utm_source=milestones",
is_pro: true
},
"inline_connections:open_result": {
group: "Connections Pro",
milestone: "Opened an inline connections result (navigated from discovery to source).",
link: "https://smartconnections.app/smart-connections/inline/?utm_source=milestones",
is_pro: true
},
"inline_connections:drag_result": {
group: "Connections Pro",
milestone: "Inserted an inline link from an inline connection (converted discovery into a durable link).",
link: "https://smartconnections.app/smart-connections/inline/?utm_source=milestones",
is_pro: true
}
};
var EVENTS_CHECKLIST_GROUP_ORDER2 = [
"Environment",
"Connections",
"Lookup",
"Context",
"Chat",
"Pro",
"Connections Pro",
"Context Pro",
"Chat Pro"
];
function derive_events_checklist_groups2(items_by_event_key) {
const group_map = Object.entries(items_by_event_key || {}).reduce(
(acc, [event_key, item]) => {
const group = item?.group || "Other";
if (!acc[group]) acc[group] = [];
acc[group].push({ event_key, group, milestone: item?.milestone || "", ...item });
return acc;
},
/** @type {Record<string, Array<{event_key: string, group: string, milestone: string, link: string, is_pro?: boolean}>>} */
{}
);
const all_groups = Object.keys(group_map);
const order_index = EVENTS_CHECKLIST_GROUP_ORDER2.reduce(
(acc, name, idx) => {
acc[name] = idx;
return acc;
},
/** @type {Record<string, number>} */
{}
);
const sorted_groups = all_groups.sort((a, b) => {
const a_has = Object.prototype.hasOwnProperty.call(order_index, a);
const b_has = Object.prototype.hasOwnProperty.call(order_index, b);
if (a_has && b_has) return order_index[a] - order_index[b];
if (a_has) return -1;
if (b_has) return 1;
return a.localeCompare(b);
});
return sorted_groups.map((group) => {
const items = (group_map[group] || []).slice();
return { group, items };
});
}
__name(derive_events_checklist_groups2, "derive_events_checklist_groups");
function check_if_event_emitted2(env, event_key) {
const plugin_event_state = resolve_plugin_install_event2(env, event_key);
if (plugin_event_state === true) return true;
if (env?.event_logs?.items?.[event_key]) return true;
if (plugin_event_state === false) return false;
return false;
}
__name(check_if_event_emitted2, "check_if_event_emitted");
function resolve_plugin_install_event2(env, event_key) {
const config = PLUGIN_INSTALL_EVENT_CONFIG2[event_key];
if (!config) return null;
const manifests = env?.plugin?.app?.plugins?.manifests || {};
const plugin_ids = Array.isArray(config.ids) ? config.ids : [];
for (const plugin_id of plugin_ids) {
const manifest = manifests[plugin_id];
if (!manifest) continue;
if (config.require_pro_name && !is_pro_manifest2(manifest)) continue;
return true;
}
return false;
}
__name(resolve_plugin_install_event2, "resolve_plugin_install_event");
function is_pro_manifest2(manifest) {
const name = manifest?.name;
if (typeof name !== "string") return false;
return name.toLowerCase().includes("pro");
}
__name(is_pro_manifest2, "is_pro_manifest");

function register_first_of_event_notifications2(env) {
env.events.on("event_log:first", (data) => {
const event_key = data?.first_of_event_key;
if (typeof event_key === "string" && event_key in EVENTS_CHECKLIST_ITEMS_BY_EVENT_KEY2) {
const frag = document.createDocumentFragment();
const msg = `You achieved a new Smart Milestone \u{1F389}`;
const msg_el = document.createElement("p");
msg_el.textContent = msg;
frag.appendChild(msg_el);
const milestone_el = document.createElement("p");
milestone_el.textContent = `\u2705 ${EVENTS_CHECKLIST_ITEMS_BY_EVENT_KEY2[event_key].milestone}`;
milestone_el.style.color = "var(--color-green)";
milestone_el.style.fontStyle = "italic";
frag.appendChild(milestone_el);
const btn = document.createElement("button");
btn.textContent = "View milestones";
btn.addEventListener("click", () => {
env.open_milestones_modal();
});
frag.appendChild(btn);
new import_obsidian63.Notice(frag, 7e3);
}
});
}
__name(register_first_of_event_notifications2, "register_first_of_event_notifications");

function build_html35(env, params = {}) {
const groups = derive_events_checklist_groups2(EVENTS_CHECKLIST_ITEMS_BY_EVENT_KEY2);
const checked_count = groups.reduce((acc, g) => {
const c = g.items.reduce((inner, item) => {
return inner + (check_if_event_emitted2(env, item.event_key) ? 1 : 0);
}, 0);
return acc + c;
}, 0);
const total_count = groups.reduce((acc, g) => acc + g.items.length, 0);
const progress_pct = total_count > 0 ? Math.round(checked_count / total_count * 100) : 0;
const groups_html = groups.map((group) => {
const group_checked_count = group.items.reduce((acc, item) => {
return acc + (check_if_event_emitted2(env, item.event_key) ? 1 : 0);
}, 0);
const group_total_count = group.items.length;
const items_html = group.items.map((item) => {
const checked = check_if_event_emitted2(env, item.event_key) === true;
return build_item_html2(item, { checked });
}).join("\n");
return `
<section class="sc-events-checklist__group" data-group="${escape_html2(group.group)}">
<h3 class="sc-events-checklist__group-title">
<span class="sc-events-checklist__group-name">${escape_html2(group.group)}</span>
<span class="sc-events-checklist__group-count" aria-label="Group completion">${group_checked_count.toString()} / ${group_total_count.toString()}</span>
</h3>
<ul class="sc-events-checklist__items">
${items_html}
</ul>
</section>
`;
}).join("\n");
return `
<div
class="sc-events-checklist"
data-component="events_checklist"
style="--sc-events-checklist-progress: ${progress_pct.toString()}%;"
>
<div class="sc-events-checklist__header">
<div class="sc-events-checklist__summary" aria-label="Checklist completion">
${checked_count.toString()} / ${total_count.toString()}
</div>
<div class="sc-events-checklist__hint" aria-hidden="true">
Click a milestone to open docs
</div>
</div>

<div
class="sc-events-checklist__progress"
role="progressbar"
aria-label="Overall progress"
aria-valuenow="${checked_count.toString()}"
aria-valuemin="0"
aria-valuemax="${total_count.toString()}"
title="${escape_html2(`${progress_pct.toString()}% complete`)}"
>
<div class="sc-events-checklist__progress-fill" aria-hidden="true"></div>
</div>

<div class="sc-events-checklist__body">
${groups_html}
</div>
</div>
`;
}
__name(build_html35, "build_html");
async function render35(env, params = {}) {
this.apply_style_sheet(milestones_default2);
const html = build_html35.call(this, env, params);
const frag = this.create_doc_fragment(html);
const container = frag.firstElementChild;
post_process33.call(this, env, container, params);
return container;
}
__name(render35, "render");
async function post_process33(env, container, params = {}) {
attach_item_link_listeners2(container);
render_item_state_icons2(container);
return container;
}
__name(post_process33, "post_process");
function build_item_html2(item, state) {
const checked = state.checked === true;
const checked_flag = checked ? "true" : "false";
const link = typeof item.link === "string" ? item.link : "";
const status_label = checked ? "Completed" : "Incomplete";
const aria_label = `Open docs: ${item.milestone || item.event_key || "milestone"} (${status_label})`;
return `
<li
class="sc-events-checklist__item"
data-event-key="${escape_html2(item.event_key)}"
data-link="${escape_html2(link)}"
data-checked="${checked_flag}"
tabindex="0"
role="button"
aria-label="${escape_html2(aria_label)}"
>
<div class="sc-events-checklist__label${item.is_pro ? " pro-milestone" : ""}">
<span class="sc-events-checklist__icon" aria-hidden="true"></span>
<span class="sc-events-checklist__milestone">${escape_html2(item.milestone)}</span>
</div>
</li>
`;
}
__name(build_item_html2, "build_item_html");
function attach_item_link_listeners2(container) {
if (!container) return;
if (container.getAttribute("data-links-enabled") === "true") return;
container.setAttribute("data-links-enabled", "true");
container.addEventListener("click", (evt) => {
const item_el = get_item_el_from_event2(container, evt);
if (!item_el) return;
const selection = window.getSelection();
if (selection && selection.toString().length > 0) return;
open_item_link2(item_el);
});
container.addEventListener("keydown", (evt) => {
const key = evt && /** @type {KeyboardEvent} */
evt.key;
if (key !== "Enter" && key !== " ") return;
const item_el = get_item_el_from_event2(container, evt);
if (!item_el) return;
evt.preventDefault();
open_item_link2(item_el);
});
}
__name(attach_item_link_listeners2, "attach_item_link_listeners");
function open_item_link2(item_el) {
const link = get_item_link2(item_el);
if (typeof link === "string" && link.length > 0) {
window.open(link, "_external");
}
}
__name(open_item_link2, "open_item_link");
function render_item_state_icons2(container) {
if (!container) return;
const item_els = Array.from(container.querySelectorAll(".sc-events-checklist__item"));
item_els.forEach((item_el) => {
const checked = item_el.getAttribute("data-checked") === "true";
const icon_el = item_el.querySelector(".sc-events-checklist__icon");
if (!icon_el) return;
set_item_icon2(
/** @type {HTMLElement} */
icon_el,
checked
);
});
}
__name(render_item_state_icons2, "render_item_state_icons");
function set_item_icon2(icon_el, checked) {
const icon_ids = checked ? ["circle-check", "check-circle", "check"] : ["circle", "circle-dashed", "dot"];
set_icon_with_fallback4(icon_el, icon_ids);
}
__name(set_item_icon2, "set_item_icon");
function set_icon_with_fallback4(icon_el, icon_ids) {
if (!icon_el) return;
const ids = Array.isArray(icon_ids) ? icon_ids : [];
for (const icon_id of ids) {
if (typeof icon_id !== "string" || icon_id.length === 0) continue;
icon_el.textContent = "";
try {
(0, import_obsidian64.setIcon)(icon_el, icon_id);
} catch (err) {
continue;
}
if (icon_el.querySelector("svg")) return;
}
}
__name(set_icon_with_fallback4, "set_icon_with_fallback");
function get_item_el_from_event2(container, evt) {
const target = evt && /** @type {any} */
evt.target;
if (!target || typeof target.closest !== "function") return null;
const item_el = target.closest(".sc-events-checklist__item");
if (!item_el) return null;
if (!container.contains(item_el)) return null;
return item_el;
}
__name(get_item_el_from_event2, "get_item_el_from_event");
function get_item_link2(item_el) {
const data_link = item_el.getAttribute("data-link");
if (typeof data_link === "string" && data_link.length > 0) return data_link;
const event_key = item_el.getAttribute("data-event-key");
if (typeof event_key !== "string" || event_key.length === 0) return "";
const item = EVENTS_CHECKLIST_ITEMS_BY_EVENT_KEY2[event_key];
if (!item || typeof item.link !== "string") return "";
return item.link;
}
__name(get_item_link2, "get_item_link");

function build_html36() {
return `<div>
<div class="smart-env-notifications-controls">
<button class="copy-all-notifications-btn">Copy All Notifications</button>
</div>
<div class="smart-env-notifications-feed"></div>
<button class="load-more-notifications-btn">Load More</button>
</div>`;
}
__name(build_html36, "build_html");
var default_page_size2 = 100;
var load_more_step2 = 100;
function get_visible_entries2(entries, params = {}) {
const { limit = default_page_size2 } = params;
return entries.slice(-limit).reverse();
}
__name(get_visible_entries2, "get_visible_entries");
function get_visible_count2(entries_length, params = {}) {
const { page_size = default_page_size2 } = params;
return Math.min(entries_length, page_size);
}
__name(get_visible_count2, "get_visible_count");
function get_next_visible_count2(entries_length, params = {}) {
const { current_count = 0, step_size = load_more_step2 } = params;
return Math.min(entries_length, current_count + step_size);
}
__name(get_next_visible_count2, "get_next_visible_count");
function should_show_load_more2(entries_length, visible_count) {
return entries_length > visible_count;
}
__name(should_show_load_more2, "should_show_load_more");
async function render36(env, params = {}) {
const frag = this.create_doc_fragment(build_html36());
const container = frag.firstElementChild;
post_process34.call(this, env, container, params);
return frag;
}
__name(render36, "render");
async function post_process34(env, container, params = {}) {
const feed_container = container.querySelector(".smart-env-notifications-feed");
const copy_btn = container.querySelector(".copy-all-notifications-btn");
const load_more_btn = container.querySelector(".load-more-notifications-btn");
const smart_env2 = this;
this.empty(feed_container);
const entries = Array.isArray(env.event_logs.session_events) ? [...env.event_logs.session_events] : [];
if (!entries.length) {
const empty3 = feed_container.ownerDocument.createElement("p");
empty3.className = "smart-env-notifications-empty";
empty3.textContent = "No Smart Env notifications yet.";
feed_container.appendChild(empty3);
if (load_more_btn) {
load_more_btn.style.display = "none";
}
return;
}
let visible_count = get_visible_count2(entries.length, { page_size: default_page_size2 });
const render_entries = /* @__PURE__ */ __name(() => {
smart_env2.empty(feed_container);
get_visible_entries2(entries, { limit: visible_count }).forEach((entry) => {
append_entry2(feed_container, entry);
});
update_load_more_button2(load_more_btn, {
entries_length: entries.length,
visible_count
});
}, "render_entries");
render_entries();
if (copy_btn) {
copy_btn.addEventListener("click", () => {
const all_text = feed_container.textContent;
navigator.clipboard.writeText(all_text).then(() => {
copy_btn.textContent = "Copied!";
setTimeout(() => {
copy_btn.textContent = "Copy All Notifications";
}, 2e3);
});
});
}
if (load_more_btn) {
load_more_btn.addEventListener("click", () => {
visible_count = get_next_visible_count2(entries.length, {
current_count: visible_count,
step_size: load_more_step2
});
render_entries();
});
}
}
__name(post_process34, "post_process");
function update_load_more_button2(button, params = {}) {
if (!button) return;
const { entries_length = 0, visible_count = 0 } = params;
const is_visible = should_show_load_more2(entries_length, visible_count);
button.style.display = is_visible ? "inline-block" : "none";
if (is_visible) {
const remaining_count = entries_length - visible_count;
const next_step = Math.min(load_more_step2, remaining_count);
button.textContent = `Load ${next_step} more`;
}
}
__name(update_load_more_button2, "update_load_more_button");
function get_level2(entry) {
const [event_domain, event_type] = entry.event_key.split(":");
if (event_domain === "notification") {
return event_type;
}
if (event_type === "error") {
return "error";
}
return "info";
}
__name(get_level2, "get_level");
function append_entry2(feed_container, entry) {
const row = feed_container.ownerDocument.createElement("div");
row.className = "smart-env-notification";
row.dataset.level = get_level2(entry);
feed_container.appendChild(row);
const meta = feed_container.ownerDocument.createElement("div");
meta.className = "smart-env-notification__meta";
const timestamp = typeof entry.event.at === "number" ? entry.event.at : Date.now();
meta.textContent = `${entry.event.collection_key ? entry.event.collection_key + " - " : ""}${entry.event_key} - ${to_time_ago2(timestamp)}
`;
row.appendChild(meta);
const event_payload_content = Object.entries(entry.event).filter(([k, v]) => !["at", "collection_key"].includes(k)).map(([k, v]) => `  ${k}: ${typeof v === "string" ? v : JSON.stringify(v)}`).join("\n");
if (event_payload_content.trim().length) {
row.style.cursor = "pointer";
const message = feed_container.ownerDocument.createElement("pre");
message.className = "smart-env-notification__message";
message.textContent = event_payload_content;
message.textContent += "\n\n";
message.style.display = "none";
row.appendChild(message);
row.addEventListener("click", () => {
if (message.style.display === "none") {
message.style.display = "block";
} else {
message.style.display = "none";
}
});
} else {
meta.textContent += "\n";
}
}
__name(append_entry2, "append_entry");
function to_time_ago2(ms) {
const now_ms = Date.now();
const seconds = Math.floor((now_ms - ms) / 1e3);
if (seconds < 60) return `${seconds} seconds ago`;
const minutes = Math.floor(seconds / 60);
if (minutes < 60) return `${minutes} minutes ago`;
const hours = Math.floor(minutes / 60);
if (hours < 24) return `${hours} hours ago`;
const days = Math.floor(hours / 24);
return `${days} days ago`;
}
__name(to_time_ago2, "to_time_ago");

var import_obsidian66 = require("obsidian");

var import_obsidian65 = require("obsidian");
function get_smart_server_url3() {
if (typeof window !== "undefined" && window.SMART_SERVER_URL_OVERRIDE) {
return window.SMART_SERVER_URL_OVERRIDE;
}
return "https://connect.smartconnections.app";
}
__name(get_smart_server_url3, "get_smart_server_url");
function try_get_zlib2() {
if (typeof window?.require === "function") {
try {
return window.require("zlib");
} catch {
}
}
return null;
}
__name(try_get_zlib2, "try_get_zlib");
function inflate_deflate_data2(compressed) {
const zlib = try_get_zlib2();
if (!zlib) {
throw new Error("zlib not available (maybe Obsidian mobile?).");
}
const buf = Buffer.from(compressed);
const out = zlib.inflateRawSync(buf);
return new Uint8Array(out.buffer, out.byteOffset, out.length);
}
__name(inflate_deflate_data2, "inflate_deflate_data");
async function parse_zip_into_files3(zipBuffer) {
const dv = new DataView(zipBuffer);
let offset = 0;
const length = dv.byteLength;
const files = [];
let pluginManifest = null;
while (offset + 4 <= length) {
const localSig = dv.getUint32(offset, true);
if (localSig === 33639248 || localSig === 134695760) {
break;
}
if (localSig !== 67324752) {
break;
}
offset += 4;
const versionNeeded = dv.getUint16(offset, true);
const generalPurposeBitFlag = dv.getUint16(offset + 2, true);
const compressionMethod = dv.getUint16(offset + 4, true);
offset += 6;
const lastModTimeDate = dv.getUint32(offset, true);
offset += 4;
let crc32 = dv.getUint32(offset, true);
let compressedSize = dv.getUint32(offset + 4, true);
let uncompressedSize = dv.getUint32(offset + 8, true);
offset += 12;
const fileNameLen = dv.getUint16(offset, true);
const extraLen = dv.getUint16(offset + 2, true);
offset += 4;
const fileNameBytes = new Uint8Array(zipBuffer.slice(offset, offset + fileNameLen));
const fileName = new TextDecoder("utf-8").decode(fileNameBytes);
offset += fileNameLen;
offset += extraLen;
const hasDataDescriptor = (generalPurposeBitFlag & 8) !== 0;
let compDataStart = offset;
let compDataEnd;
if (!hasDataDescriptor) {
compDataEnd = compDataStart + compressedSize;
} else {
let scanPos = compDataStart;
let foundSig = false;
while (scanPos + 4 <= length) {
const sig = dv.getUint32(scanPos, true);
if (sig === 134695760 || sig === 67324752 || sig === 33639248) {
foundSig = true;
break;
}
scanPos++;
}
compDataEnd = foundSig ? scanPos : length;
}
if (compDataEnd > length) {
break;
}
const fileDataCompressed = new Uint8Array(zipBuffer.slice(compDataStart, compDataEnd));
offset = compDataEnd;
if (hasDataDescriptor) {
if (offset + 4 <= length) {
const ddSig = dv.getUint32(offset, true);
if (ddSig === 134695760) {
offset += 4;
}
if (offset + 12 <= length) {
crc32 = dv.getUint32(offset, true);
compressedSize = dv.getUint32(offset + 4, true);
uncompressedSize = dv.getUint32(offset + 8, true);
offset += 12;
} else {
break;
}
}
}
let rawData;
if (compressionMethod === 0) {
rawData = fileDataCompressed;
} else if (compressionMethod === 8) {
rawData = inflate_deflate_data2(fileDataCompressed);
} else {
continue;
}
files.push({ fileName, data: rawData });
if (fileName.toLowerCase().endsWith("manifest.json") && !fileName.includes("/")) {
try {
pluginManifest = JSON.parse(new TextDecoder("utf-8").decode(rawData));
} catch {
}
}
}
return { files, pluginManifest };
}
__name(parse_zip_into_files3, "parse_zip_into_files");
function validate_zip_buffer2(zip_buffer, source_label = "Response") {
if (!zip_buffer || zip_buffer.byteLength < 4) {
throw new Error(`${source_label} returned too few bytes, not a valid ZIP.`);
}
const dv = new DataView(zip_buffer);
if (dv.getUint32(0, true) !== 67324752) {
const txt = new TextDecoder().decode(new Uint8Array(zip_buffer));
throw new Error(`${source_label} did not return a valid ZIP. Text:
${txt}`);
}
return zip_buffer;
}
__name(validate_zip_buffer2, "validate_zip_buffer");
async function write_files_with_adapter3(adapter, baseFolder, files) {
const hasWriteBinary = typeof adapter.writeBinary === "function";
if (!await adapter.exists(baseFolder)) {
await adapter.mkdir(baseFolder);
}
for (const { fileName, data } of files) {
const fullPath = baseFolder + "/" + fileName;
if (hasWriteBinary) {
await adapter.writeBinary(fullPath, data);
} else {
const base644 = btoa(String.fromCharCode(...data));
await adapter.write(fullPath, base644);
}
}
}
__name(write_files_with_adapter3, "write_files_with_adapter");
function is_server_version_newer2(localVer, serverVer) {
if (!serverVer || serverVer === "unknown") return false;
const lv = localVer.replace(/[^\d.]/g, "");
const sv = serverVer.replace(/[^\d.]/g, "");
const la = lv.split(".").map(Number);
const sa = sv.split(".").map(Number);
for (let i = 0; i < Math.max(la.length, sa.length); i++) {
const l = la[i] || 0;
const s = sa[i] || 0;
if (s > l) return true;
if (s < l) return false;
}
return false;
}
__name(is_server_version_newer2, "is_server_version_newer");
async function fetch_plugin_zip3(repoName, token) {
const resp = await (0, import_obsidian65.requestUrl)({
url: `${get_smart_server_url3()}/plugin_download`,
method: "POST",
headers: {
"Content-Type": "application/json",
"Authorization": `Bearer ${token}`
},
body: JSON.stringify({ repo: repoName })
});
if (resp.status !== 200) {
throw new Error(`plugin_download error ${resp.status}: ${resp.text}`);
}
return validate_zip_buffer2(resp.arrayBuffer, "Smart Plugins server");
}
__name(fetch_plugin_zip3, "fetch_plugin_zip");
async function fetch_zip_from_url2(download_url, request_fn = import_obsidian65.requestUrl) {
console.log(`[smart_plugins] download plugin from URL: ${download_url}`);
const resp = await request_fn({
url: download_url,
method: "GET",
headers: { Accept: "application/zip" }
});
if (resp.status && resp.status !== 200) {
throw new Error(`Download error ${resp.status}: ${resp.text || ""}`);
}
return validate_zip_buffer2(resp.arrayBuffer, "Download");
}
__name(fetch_zip_from_url2, "fetch_zip_from_url");
async function fetch_plugin_readme2(repo, token, request_fn = import_obsidian65.requestUrl) {
const resp = await request_fn({
url: `${get_smart_server_url3()}/plugin_readme`,
method: "POST",
headers: {
"Content-Type": "application/json",
"Authorization": `Bearer ${token}`
},
body: JSON.stringify({ repo })
});
if (resp.status !== 200) {
throw new Error(`plugin_readme error ${resp.status}: ${resp.text}`);
}
return resp.json.readme;
}
__name(fetch_plugin_readme2, "fetch_plugin_readme");
async function enable_plugin3(app, plugin_id) {
await app.plugins.enablePlugin(plugin_id);
app.plugins.enabledPlugins.add(plugin_id);
app.plugins.requestSaveConfig();
app.plugins.loadManifests();
}
__name(enable_plugin3, "enable_plugin");
function get_oauth_storage_prefix2(app) {
const vault_name = app?.vault?.getName?.() || "";
const safe = vault_name.toLowerCase().replace(/[^a-z0-9]/g, "_");
return `${safe}_smart_plugins_oauth_`;
}
__name(get_oauth_storage_prefix2, "get_oauth_storage_prefix");
async function fetch_server_plugin_list2(token) {
const resp = await (0, import_obsidian65.requestUrl)({
url: `${get_smart_server_url3()}/plugin_list`,
method: "POST",
headers: {
"Content-Type": "application/json",
"Authorization": `Bearer ${token}`
},
body: JSON.stringify({})
});
if (resp.status !== 200) {
throw new Error(`plugin_list error ${resp.status}: ${resp.text}`);
}
return resp.json;
}
__name(fetch_server_plugin_list2, "fetch_server_plugin_list");
async function fetch_referral_stats2(params = {}) {
const token = String(params.token || "").trim();
if (!token) return { ok: false, error: "missing_token" };
const resp = await (0, import_obsidian65.requestUrl)({
url: `${get_smart_server_url3()}/api/referrals/stats`,
method: "GET",
headers: {
"Authorization": `Bearer ${token}`
}
});
if (resp.status === 401) {
return { ok: false, unauthorized: true };
}
if (resp.status !== 200) {
throw new Error(`referrals stats error ${resp.status}: ${resp.text}`);
}
return resp.json;
}
__name(fetch_referral_stats2, "fetch_referral_stats");

var style_default3 = ".get-core-link {\r\n  text-wrap: nowrap;\r\n  font-size: var(--font-ui-small);\r\n}\r\n.core-installed-text {\r\n  text-wrap: nowrap;\r\n  font-size: var(--font-ui-small);\r\n  color: var(--text-muted);\r\n}\r\n\r\n.pro-plugins-list {\r\n  display: flex;\r\n  flex-direction: column;\r\n  row-gap: var(--size-4-3);\r\n  margin-top: var(--size-5);\r\n}\r\n\r\n.pro-plugins-list-item {\r\n  display: flex;\r\n  align-items: center;\r\n  padding: 0.75em 0;\r\n  border-top: 1px solid var(--background-modifier-border);\r\n  row-gap: var(--size-4-3);\r\n}\r\n\r\n.pro-plugins-container > .setting-group {\r\n  .setting-item-name.pro-heading {\r\n    font-size: var(--h1-size);\r\n  }\r\n  &> p {\r\n    padding: 0 var(--size-4-4);\r\n  }\r\n\r\n}\r\n\r\n.smart-plugins-login .setting-item {\r\n  gap: var(--size-4-3);\r\n}\r\n\r\n.smart-plugins-login-manual {\r\n  margin-top: var(--size-4-3);\r\n}\r\n\r\n.smart-plugins-login-manual-instructions {\r\n  font-size: var(--font-ui-small);\r\n  color: var(--text-muted);\r\n  margin-bottom: var(--size-2-2);\r\n}\r\n\r\n.smart-plugins-login-manual-controls {\r\n  display: flex;\r\n  gap: var(--size-2-2);\r\n  align-items: center;\r\n}\r\n\r\n.smart-plugins-login-manual-input {\r\n  flex: 1;\r\n  min-width: 240px;\r\n  font-size: var(--font-ui-small);\r\n}\r\n";

var PRO_PLUGINS_DESC2 = `<a href="https://smartconnections.app/core-plugins/" target="_external">Core plugins</a> provide essential functionality and a "just works" experience. <a href="https://smartconnections.app/pro-plugins/" target="_external">Pro plugins</a> enable advanced configuration and features for Obsidian AI experts.`;
var PRO_PLUGINS_FOOTER2 = `All Pro plugins include advanced configurations and additional model providers. Pro users get priority support via email. <a href="https://smartconnections.app/introducing-pro-plugins/" target="_external">Learn more</a> about Pro plugins.`;
function derive_fallback_plugins2() {
const pro_placeholders = [
{
name: "Chat Pro",
description: "Configure chat to use Local and Cloud API providers (Ollama, LM Studio, OpenAI, Gemini, Anthropic, Open Router, and more).",
core_id: "smart-chatgpt",
url: "https://smartconnections.app/smart-chat/"
},
{
name: "Connections Pro",
description: "More opportunities for connections. Graph view for visualizing. Inline and footer views (great for mobile!). Configurable algorithms and additional embedding model providers.",
core_id: "smart-connections",
url: "https://smartconnections.app/smart-connections/"
},
{
name: "Context Pro",
description: "Advanced tools for context engineering. Utilize Bases, images, and external sources (great for coders!) in your contexts.",
core_id: "smart-context",
url: "https://smartconnections.app/smart-context/"
}
];
return pro_placeholders;
}
__name(derive_fallback_plugins2, "derive_fallback_plugins");
function build_html37(env, params = {}) {
return `
<div class="pro-plugins-container setting-item-heading">
<div class="setting-group">
<div class="setting-item setting-item-heading">
<div class="setting-item-name pro-heading">Pro plugins</div>
<div class="setting-item-control">
<section class="smart-plugins-login"></section>
</div>
</div>
<p>${PRO_PLUGINS_DESC2}</p>
<div class="setting-items pro-plugins-list">
</div>
<p>${PRO_PLUGINS_FOOTER2}</p>
<div class="smart-plugins-referral"></div>
</div>
</div>
`;
}
__name(build_html37, "build_html");
async function render37(env, params = {}) {
this.apply_style_sheet(style_default3);
const html = build_html37.call(this, env, params);
const frag = this.create_doc_fragment(html);
const container = frag.firstElementChild;
await post_process35.call(this, env, container, params);
return container;
}
__name(render37, "render");
async function post_process35(env, container, params = {}) {
const plugin = env.plugin || null;
const app = plugin?.app || window.app;
const oauth_storage_prefix = get_oauth_storage_prefix2(app);
const login_container = container.querySelector(".smart-plugins-login");
const referral_container = container.querySelector(".smart-plugins-referral");
const pro_list_el = container.querySelector(".pro-plugins-list");
const placeholders = derive_fallback_plugins2();
let login_click_count = 0;
let last_login_url = "";
let manual_login_el = null;
const empty_container = /* @__PURE__ */ __name((el) => {
if (!el) return;
if (typeof this.empty === "function") {
this.empty(el);
return;
}
el.innerHTML = "";
}, "empty_container");
const render_manual_login_link = /* @__PURE__ */ __name((login_url) => {
if (!login_container) return;
if (!login_url) return;
if (!manual_login_el || !manual_login_el.isConnected) {
manual_login_el = document.createElement("div");
manual_login_el.classList.add("smart-plugins-login-manual");
login_container.appendChild(manual_login_el);
}
manual_login_el.innerHTML = "";
const instructions = document.createElement("div");
instructions.classList.add("smart-plugins-login-manual-instructions");
instructions.textContent = "If the login page did not open, copy this link and paste it into your browser to open the login page:";
manual_login_el.appendChild(instructions);
const controls = document.createElement("div");
controls.classList.add("smart-plugins-login-manual-controls");
manual_login_el.appendChild(controls);
const input = document.createElement("input");
input.classList.add("smart-plugins-login-manual-input");
input.type = "text";
input.value = login_url;
input.readOnly = true;
input.addEventListener("focus", () => input.select());
controls.appendChild(input);
const btn = document.createElement("button");
btn.classList.add("mod-cta");
btn.textContent = "Copy";
btn.addEventListener("click", async () => {
const ok = await copy_to_clipboard4(login_url);
if (ok) {
new import_obsidian66.Notice("Copied login link to clipboard.");
} else {
new import_obsidian66.Notice("Copy failed. Please select and copy the link manually.");
}
});
controls.appendChild(btn);
}, "render_manual_login_link");
const get_installed_info = /* @__PURE__ */ __name(async () => {
const installed_map = {};
let { manifests } = app.plugins;
while (Object.keys(manifests).length === 0) {
manifests = app.plugins.manifests;
await new Promise((resolve) => setTimeout(resolve, 100));
}
for (const plugin_id in manifests) {
if (!Object.prototype.hasOwnProperty.call(manifests, plugin_id)) continue;
const { name, version: version2 } = manifests[plugin_id];
installed_map[plugin_id] = { name, version: version2 };
}
return installed_map;
}, "get_installed_info");
const initiate_oauth_login = /* @__PURE__ */ __name(async () => {
login_click_count++;
if (login_click_count >= 2 && last_login_url) {
render_manual_login_link(last_login_url);
}
if (env && typeof env.initiate_smart_plugins_oauth === "function") {
last_login_url = initiate_smart_plugins_oauth2();
}
new import_obsidian66.Notice("Please complete the login in your browser.");
}, "initiate_oauth_login");
const render_oauth_login_section = /* @__PURE__ */ __name(() => {
this.empty(login_container);
manual_login_el = null;
const token = localStorage.getItem(oauth_storage_prefix + "token") || "";
if (!token) {
const setting2 = new import_obsidian66.Setting(login_container).setName("Connect account").setDesc("Log in with the key provided in your Pro welcome email.");
setting2.addButton((btn) => {
btn.setButtonText("Login");
btn.onClick(async () => {
await initiate_oauth_login();
});
});
return;
}
const setting = new import_obsidian66.Setting(login_container);
setting.setDesc("Signed in to Smart Plugins Pro account.");
setting.addButton((btn) => {
btn.setButtonText("Logout");
btn.onClick(() => {
localStorage.removeItem(oauth_storage_prefix + "token");
localStorage.removeItem(oauth_storage_prefix + "refresh");
new import_obsidian66.Notice("Logged out of Smart Plugins");
render_oauth_login_section();
render_referral_section();
render_plugin_list_section();
});
});
}, "render_oauth_login_section");
const render_referral_section = /* @__PURE__ */ __name(async (params2 = {}) => {
empty_container(referral_container);
const token = String(params2.token || "").trim();
if (!token) return;
const sub_exp = Number(params2.sub_exp ?? 0) || 0;
if (sub_exp && sub_exp < Date.now()) return;
try {
const stats = await fetch_referral_stats2({ token });
const referral_link = String(stats?.referral_link || "").trim();
if (!referral_link) return;
const setting = new import_obsidian66.Setting(referral_container).setName("Referral link").setDesc("Share your link to give $30 off Pro and earn 30 days of Pro credit.");
setting.addButton((btn) => {
btn.setButtonText("Copy link");
btn.onClick(async () => {
const ok = await copy_to_clipboard4(referral_link);
new import_obsidian66.Notice(ok ? "Referral link copied." : "Copy failed. Please try again.");
});
});
setting.addButton((btn) => {
btn.setButtonText("Open referrals");
btn.onClick(() => {
window.open("https://smartconnections.app/my-referrals/", "_external");
});
});
} catch (err) {
console.error("[pro-plugins:list] Failed to load referral stats:", err);
}
}, "render_referral_section");
const render_fallback_plugin_list = /* @__PURE__ */ __name(async () => {
this.empty(pro_list_el);
if (!pro_list_el || placeholders.length === 0) return;
for (const item of placeholders) {
const row = await env.smart_components.render_component("pro_plugins_list_item", item, {
env,
app,
installed_map: {}
});
pro_list_el.appendChild(row);
}
}, "render_fallback_plugin_list");
const add_update_sub_to_login_section = /* @__PURE__ */ __name(() => {
const setting = new import_obsidian66.Setting(login_container).setName("Subscription Expired").setDesc("Your Smart Connections Pro subscription has expired. Please update your subscription to retain access to Pro plugins.");
setting.addButton((btn) => {
btn.setButtonText("Get Pro");
btn.onClick(() => {
window.open("https://smartconnections.app/subscribe/", "_external");
});
});
setting.addButton((btn) => {
btn.setButtonText("Update subscription");
btn.onClick(() => {
window.open("https://smartconnections.app/subscription-update/", "_external");
});
});
setting.addButton((btn) => {
btn.setButtonText("Refresh");
btn.onClick(() => {
env.events.emit("pro_plugins:refresh");
});
});
}, "add_update_sub_to_login_section");
const render_plugin_list_section = /* @__PURE__ */ __name(async () => {
this.empty(pro_list_el);
const token = localStorage.getItem(oauth_storage_prefix + "token") || "";
if (!token) {
await render_fallback_plugin_list();
await render_referral_section();
return;
}
try {
const installed_map = await get_installed_info();
const resp = await fetch_server_plugin_list2(token);
const { list = [], unauthorized = [], sub_exp } = resp;
if (typeof sub_exp === "number" && sub_exp < Date.now()) {
add_update_sub_to_login_section();
await render_fallback_plugin_list();
await render_referral_section();
return;
}
await render_referral_section({ token, sub_exp });
if (!Array.isArray(list) || list.length === 0) {
await render_fallback_plugin_list();
return;
}
for (const item of list) {
const row = await env.smart_components.render_component("pro_plugins_list_item", item, {
env,
app,
token,
installed_map,
on_installed: render_plugin_list_section
});
pro_list_el.appendChild(row);
}
} catch (err) {
console.error("[pro-plugins:list] Failed to fetch plugin list:", err);
pro_list_el.textContent = "Error fetching plugin list. Check console.";
}
}, "render_plugin_list_section");
const render_smart_plugins = /* @__PURE__ */ __name(async () => {
render_oauth_login_section();
await render_plugin_list_section();
}, "render_smart_plugins");
env.events.on("smart_plugins_oauth_completed", () => {
render_smart_plugins();
});
await render_smart_plugins();
return container;
}
__name(post_process35, "post_process");
function initiate_smart_plugins_oauth2() {
console.log("initiate_smart_plugins_oauth");
const state = Math.random().toString(36).slice(2);
const redirect_uri = encodeURIComponent("obsidian://smart-plugins/callback");
const url = `${get_smart_server_url3()}/oauth?client_id=smart-plugins-op&redirect_uri=${redirect_uri}&state=${state}`;
window.open(url, "_external");
return url;
}
__name(initiate_smart_plugins_oauth2, "initiate_smart_plugins_oauth");
var copy_to_clipboard4 = /* @__PURE__ */ __name(async (text) => {
if (!text) return false;
try {
if (navigator?.clipboard?.writeText) {
await navigator.clipboard.writeText(text);
return true;
}
} catch {
}
try {
const ta = document.createElement("textarea");
ta.value = text;
ta.setAttribute("readonly", "true");
ta.style.position = "fixed";
ta.style.left = "-9999px";
ta.style.top = "0";
document.body.appendChild(ta);
ta.select();
const ok = document.execCommand("copy");
document.body.removeChild(ta);
return Boolean(ok);
} catch {
}
return false;
}, "copy_to_clipboard");

var import_obsidian67 = require("obsidian");
var PRO_PLUGINS_URL2 = "https://smartconnections.app/pro-plugins/";
function build_html38(item, params = {}) {
return `<div class="pro-plugins-list-item"></div>`;
}
__name(build_html38, "build_html");
function is_fallback_item2(item) {
return !item || !item.repo;
}
__name(is_fallback_item2, "is_fallback_item");
function compute_display_state2(item, local_info) {
const repo_name = item.repo;
const server_version = item.version || "unknown";
const plugin_id = item.manifest_id || repo_name.replace("/", "_");
const local_version = local_info?.version || null;
const display_name9 = local_info?.name || item.name || repo_name;
let desc = `Server version: ${server_version}`;
let button_label = "Install";
let is_disabled = false;
if (local_version) {
desc += ` | Installed version: ${local_version}`;
const is_update = is_server_version_newer2(local_version, server_version);
if (is_update) {
button_label = "Update";
} else {
button_label = "Installed";
is_disabled = true;
}
}
if (item.description) {
desc += `
${item.description}`;
}
return { plugin_id, display_name: display_name9, desc, button_label, is_disabled, server_version, local_version };
}
__name(compute_display_state2, "compute_display_state");
async function render38(item, params = {}) {
const html = build_html38(item, params);
const frag = this.create_doc_fragment(html);
const container = frag.firstElementChild;
await post_process36.call(this, item, container, params);
return container;
}
__name(render38, "render");
async function post_process36(item, container, params = {}) {
const { app, token, installed_map = {}, on_installed } = params;
if (is_fallback_item2(item)) {
const row2 = new import_obsidian67.Setting(container).setName(item.name || "Pro plugin").setDesc(item.description || "Login to unlock Pro plugins.");
if (item.core_id) {
if (app.plugins.manifests[item.core_id]) {
const core_installed_text = document.createElement("i");
core_installed_text.classList.add("core-installed-text");
core_installed_text.textContent = "Core installed!";
row2.controlEl.appendChild(core_installed_text);
} else {
const get_core_link = document.createElement("a");
get_core_link.setAttribute("href", `obsidian://show-plugin?id=${item.core_id}`);
get_core_link.setAttribute("target", "_external");
get_core_link.textContent = "Install Core";
get_core_link.style.marginLeft = "10px";
get_core_link.classList.add("get-core-link");
row2.controlEl.appendChild(get_core_link);
}
}
row2.addButton((btn) => {
btn.setButtonText("Get Pro");
btn.onClick(() => {
window.open(PRO_PLUGINS_URL2, "_external");
});
});
row2.addButton((btn) => {
btn.setButtonText("Learn more");
btn.onClick(() => {
window.open(item.url, "_external");
});
});
return container;
}
const plugin_id = item.manifest_id || item.repo.replace("/", "_");
const local = installed_map[plugin_id] || null;
const state = compute_display_state2(item, local);
const row = new import_obsidian67.Setting(container).setName(state.display_name).setDesc(state.desc);
row.addButton((btn) => {
btn.setButtonText(state.button_label);
btn.setDisabled(state.is_disabled);
btn.onClick(() => install_plugin2(item, { app, token, on_installed }));
});
row.addButton((btn) => {
btn.setButtonText("Docs");
if (item.docs_url) {
btn.onClick(() => window.open(item.docs_url, "_external"));
} else {
btn.onClick(() => show_plugin_readme2(item, { app, token, display_name: state.display_name }));
}
});
return container;
}
__name(post_process36, "post_process");
var download_plugin_zip2 = /* @__PURE__ */ __name(async (item, token) => {
const resolved_download_url = typeof item.resolve_download_url === "function" ? await item.resolve_download_url() : item.download_url;
if (resolved_download_url) {
return fetch_zip_from_url2(resolved_download_url);
}
if (!token) {
throw new Error("Login required to install this plugin.");
}
return fetch_plugin_zip3(item.repo, token);
}, "download_plugin_zip");
var install_plugin2 = /* @__PURE__ */ __name(async (item, params = {}) => {
const { app, token, on_installed } = params;
try {
new import_obsidian67.Notice(`Installing "${item.repo}" ...`);
const zip_data = await download_plugin_zip2(item, token);
const { files, pluginManifest } = await parse_zip_into_files3(zip_data);
const folder_name = item.plugin_id;
const base_folder = `${app.vault.configDir}/plugins/${folder_name}`;
await write_files_with_adapter3(app.vault.adapter, base_folder, files);
await app.plugins.loadManifests();
const plugin_id = pluginManifest?.id || item.manifest_id || folder_name;
if (app.plugins.enabledPlugins.has(plugin_id)) {
await app.plugins.disablePlugin(plugin_id);
}
await enable_plugin3(app, plugin_id);
new import_obsidian67.Notice(`${item.repo} installed successfully.`);
if (typeof on_installed === "function") {
await on_installed();
}
} catch (err) {
console.error("[pro-plugins:list_item] Install error:", err);
new import_obsidian67.Notice(`Install failed: ${err.message}`);
}
}, "install_plugin");
var show_plugin_readme2 = /* @__PURE__ */ __name(async (item, params = {}) => {
const { app, token, display_name: display_name9 } = params;
try {
const readme = await fetch_plugin_readme2(item.repo, token);
const modal = new import_obsidian67.Modal(app);
modal.setTitle(display_name9 || item.name || item.repo);
await import_obsidian67.MarkdownRenderer.render(app, readme, modal.contentEl, "", new import_obsidian67.Component());
modal.open();
} catch (err) {
console.error("[pro-plugins:list_item] Failed to load README:", err);
new import_obsidian67.Notice("Failed to load README");
}
}, "show_plugin_readme");

var import_obsidian68 = require("obsidian");
var SmartModelModal2 = class extends import_obsidian68.Modal {
static {
__name(this, "SmartModelModal");
}
/**
* @param {App} app
* @param {EditModelModalOpts} opts
*/
constructor(model, params = {}) {
const app = model.env.plugin.app || window.app;
super(app);
this.model = model;
this.collection = this.model.collection;
this.env = this.model.env;
this.params = params;
}
onOpen() {
this.titleEl.setText("Edit model");
this.contentEl.addClass("smart-model-modal");
this.render_form();
}
onClose() {
this.contentEl.empty();
if (typeof this.params.on_close === "function") {
this.params.on_close();
}
}
async render_form() {
const container = this.contentEl;
container.empty();
const model = this.model;
const model_actions_bar = await this.env.smart_components.render_component("settings_model_actions", model, {
on_before_new: /* @__PURE__ */ __name(async () => {
this.close();
}, "on_before_new"),
on_after_delete: /* @__PURE__ */ __name(async () => {
this.close();
}, "on_after_delete")
});
container.appendChild(model_actions_bar);
const settings = model.settings_config;
const form = await this.env.smart_view.render_settings(settings, {
scope: model
});
container.appendChild(form);
const test_btn = container.createEl("button", { text: "Test model" });
const test_results_el = container.createDiv({ cls: "model-test-container" });
test_btn.addEventListener("click", async () => {
await this.run_test(test_results_el, model);
});
if (this.params.test_on_open) {
await this.run_test(test_results_el, model);
}
}
async run_test(test_results_el, model) {
test_results_el.empty();
const test_result_el = test_results_el.createEl("pre", { cls: "model-test-result", text: "Testing..." });
test_results_el.appendChild(test_result_el);
const test_result = await model.test_model();
test_result_el.textContent = JSON.stringify(test_result, null, 2);
}
};

var env_model_default2 = '.model-settings .model-info {\r\n  border-radius: var(--radius-m);\r\n  padding: 1rem;\r\n  margin-bottom: 1rem;\r\n  background-color: var(--background-secondary);\r\n  pre {\r\n    margin: 0;\r\n    font-size: 0.9rem;\r\n  }\r\n  .test-result-icon {\r\n    vertical-align: middle;\r\n    margin-left: 0.5rem;\r\n  }\r\n  .test-result-icon[data-icon="square-check-big"]{\r\n    color: var(--color-green);\r\n  }\r\n  .test-result-icon[data-icon="circle-x"]{\r\n    color: var(--color-red);\r\n  }\r\n}\r\n\r\n.smart-model-modal{\r\n   pre, .model-note {\r\n    user-select: text;\r\n  }\r\n}';

var import_obsidian69 = require("obsidian");
function build_html39(model, params) {
const details = [
`Provider: ${model.data.provider_key}`,
`Model: ${model.data.model_key || "**MISSING - EDIT & SELECT MODEL**"}`
];
return `<div class="model-info">
<div class="smart-env-settings-header">
<b>Current: ${model.display_name} <span class="test-result-icon" data-icon="${get_test_result_icon_name2(model)}"></span></b>
<div>
<button class="edit-model">Edit</button>
<button class="test-model">Test</button>
</div>
</div>
<pre>${details.join("\n")}</pre>
</div>`;
}
__name(build_html39, "build_html");
async function render39(model, params) {
this.apply_style_sheet(env_model_default2);
const frag = this.create_doc_fragment(build_html39.call(this, model, params));
const container = frag.firstElementChild;
post_process37.call(this, model, container, params);
return container;
}
__name(render39, "render");
async function post_process37(model, container, params) {
const edit_btn = container.querySelector(".edit-model");
const test_btn = container.querySelector(".test-model");
const icon_el = container.querySelector(".test-result-icon");
(0, import_obsidian69.setIcon)(icon_el, get_test_result_icon_name2(model));
edit_btn.addEventListener("click", () => {
new SmartModelModal2(model).open();
});
test_btn.addEventListener("click", () => {
new SmartModelModal2(model, { test_on_open: true }).open();
});
return container;
}
__name(post_process37, "post_process");
function get_test_result_icon_name2(model) {
switch (model.data.test_passed) {
case true:
return "square-check-big";
case false:
return "circle-x";
default:
return "square";
}
}
__name(get_test_result_icon_name2, "get_test_result_icon_name");

var import_obsidian70 = require("obsidian");

var provider_options2 = {
chat_completion_models: [
{
label: "Open Router (cloud)",
value: "open_router"
},
{
label: "PRO: LM Studio (local, requires LM Studio app)",
value: "lm_studio",
disabled: true
},
{
label: "PRO: Ollama (local, requires Ollama app)",
value: "ollama",
disabled: true
},
{
label: "PRO: OpenAI (cloud)",
value: "openai",
disabled: true
},
{
label: "PRO: Google Gemini (cloud)",
value: "google",
disabled: true
},
{
label: "PRO: Cohere (cloud)",
value: "cohere",
disabled: true
},
{
label: "PRO: xAI Grok (cloud)",
value: "xai",
disabled: true
},
{
label: "PRO: Anthropic Claude (cloud)",
value: "anthropic",
disabled: true
},
{
label: "PRO: Deepseek (cloud)",
value: "deepseek",
disabled: true
},
{
label: "PRO: Azure OpenAI (cloud)",
value: "azure",
disabled: true
}
],
embedding_models: [
{
label: "Transformers (easy, local, built-in)",
value: "transformers"
},
{
label: "PRO: LM Studio (local, requires LM Studio app)",
value: "lm_studio",
disabled: true
},
{
label: "PRO: Ollama (local, requires Ollama app)",
value: "ollama",
disabled: true
},
{
label: "PRO: OpenAI (cloud)",
value: "openai",
disabled: true
},
{
label: "PRO: Google Gemini (cloud)",
value: "gemini",
disabled: true
},
{
label: "PRO: Open Router (cloud)",
value: "open_router",
disabled: true
}
],
ranking_models: [
{
label: "PRO: Cohere (cloud)",
value: "cohere",
disabled: true
}
]
};

function show_new_model_menu2(models_collection, event, params = {}) {
const providers = (provider_options2[models_collection.collection_key] || []).map((p) => ({ ...p, disabled: !models_collection.env_config.providers[p.value] }));
if (providers.length === 0) {
if (event.target.tagName.toLowerCase() === "button") {
event.target.disabled = true;
event.title = "No providers available to create new models.";
}
} else {
const menu = new import_obsidian70.Menu();
providers.forEach((provider) => {
menu.addItem((item) => {
item.setTitle(provider.label);
if (provider.disabled) {
item.setDisabled(true);
}
item.onClick(async () => {
if (typeof params.on_before_new === "function") {
await params.on_before_new();
}
const model = models_collection.new_model({ provider_key: provider.value });
const on_new_close = /* @__PURE__ */ __name(async () => {
}, "on_new_close");
new SmartModelModal2(model, { on_close: on_new_close }).open();
});
});
});
menu.showAtMouseEvent(event);
}
}
__name(show_new_model_menu2, "show_new_model_menu");

function build_html40(models_collection, params) {
return `<div class="model-settings" data-model-type="${models_collection.collection_key}">
<div class="global-settings"></div>
</div>`;
}
__name(build_html40, "build_html");
async function render40(models_collection, params) {
const frag = this.create_doc_fragment(build_html40.call(this, models_collection, params));
const container = frag.firstElementChild;
post_process38.call(this, models_collection, container, params);
return container;
}
__name(render40, "render");
async function post_process38(models_collection, container, params) {
const disposers = [];
const render_current_model_info = /* @__PURE__ */ __name(async (current_model) => {
this.empty(container);
const [settings_group] = render_settings_config2(
models_collection.env_config.settings_config,
models_collection,
container,
{
default_group_name: `${models_collection.model_type} models`,
heading_btn: {
btn_text: "+ New",
callback: /* @__PURE__ */ __name((event, setting) => {
show_new_model_menu2(models_collection, event);
}, "callback")
}
}
);
models_collection.env.smart_components.render_component("settings_env_model", current_model, {}).then((model_info_el) => {
settings_group.listEl.appendChild(model_info_el);
});
}, "render_current_model_info");
render_current_model_info(models_collection.default);
disposers.push(models_collection.on_event("settings:changed", async (payload) => {
const default_setting_path = `${models_collection.collection_key}.default_model_key`;
if (payload.path_string === default_setting_path) {
await render_current_model_info(models_collection.default);
}
}));
disposers.push(models_collection.on_event("model:changed", async () => {
await render_current_model_info(models_collection.default);
}));
this.attach_disposer(container, disposers);
}
__name(post_process38, "post_process");

function build_html41(env, params) {
const models_collections = [
env.embedding_models,
env.chat_completion_models,
env.ranking_models
].filter(Boolean);
const type_containers = models_collections.map((models_collection) => {
return `<div data-collection-key="${models_collection.collection_key}"></div>`;
}).join("\n");
return `<div class="env-model-types">
${type_containers}
</div>`;
}
__name(build_html41, "build_html");
async function render41(env, params) {
const frag = this.create_doc_fragment(build_html41(env, params));
const container = frag.firstElementChild;
post_process39.call(this, env, container, params);
return container;
}
__name(render41, "render");
async function post_process39(env, container, params) {
const collection_containers = container.querySelectorAll("div[data-collection-key]");
for (const collection_container of collection_containers) {
const collection_key = collection_container.getAttribute("data-collection-key");
const models_collection = env[collection_key];
env.smart_components.render_component("settings_env_model_type", models_collection).then((model_type_el) => {
this.empty(collection_container);
collection_container.appendChild(model_type_el);
});
}
return container;
}
__name(post_process39, "post_process");

function build_html42(model, params = {}) {
return `<div class="smart-model-modal-actions">
<button class="new-model-btn">New</button>
<button class="delete-model-btn">Delete</button>
<div class="confirm-delete-container" style="display:none;">
<span>Are you sure?</span>
<button class="confirm-delete-yes-btn">Yes</button>
<button class="confirm-delete-no-btn">No</button>
</div>
</div>`;
}
__name(build_html42, "build_html");
async function render42(model, params = {}) {
const frag = this.create_doc_fragment(build_html42(model, params));
const container = frag.firstElementChild;
post_process40.call(this, model, container, params);
return container;
}
__name(render42, "render");
async function post_process40(model, container, params = {}) {
const new_model_btn = container.querySelector(".new-model-btn");
new_model_btn.addEventListener("click", async (event) => {
const on_before_new = params.on_before_new;
const opts = {};
if (typeof on_before_new === "function") {
opts.on_before_new = on_before_new;
}
show_new_model_menu2(model.collection, event, opts);
});
const delete_model_btn = container.querySelector(".delete-model-btn");
const confirm_delete_container = container.querySelector(".confirm-delete-container");
const confirm_delete_yes_btn = container.querySelector(".confirm-delete-yes-btn");
const confirm_delete_no_btn = container.querySelector(".confirm-delete-no-btn");
delete_model_btn.addEventListener("click", async () => {
confirm_delete_container.style.display = "";
});
confirm_delete_no_btn.addEventListener("click", async () => {
confirm_delete_container.style.display = "none";
});
confirm_delete_yes_btn.addEventListener("click", async () => {
await model.delete_model();
if (typeof params.on_after_delete === "function") {
params.on_after_delete();
}
});
return container;
}
__name(post_process40, "post_process");

async function build_html43(env, opts = {}) {
let html = `<div class="settings-group">
<div class="setting-item setting-item-heading">
<div class="setting-item-name">Muted notices</div>
</div>
<div class="setting-items">
`;
if (Object.keys(env.notices.settings?.muted || {}).length) {
for (const notice in env.notices.settings?.muted) {
html += `<div class="muted-notice setting-item" data-notice="${notice}" style="display: flex; align-items: center; justify-content: space-between; gap: 10px;">
<div class="setting-item-info">
<div class="setting-item-name">
${notice}
</div>
</div>
<div class="setting-item-control">
<button class="unmute-button">Unmute</button>
</div>
</div>`;
}
} else {
html += `<div class="setting-item"><div class="setting-item-info"><div class="setting-item-name">No muted notices.</div></div></div>`;
}
html += `</div>`;
return html;
}
__name(build_html43, "build_html");
async function render43(env, opts = {}) {
let html = await build_html43.call(this, env, opts);
const frag = this.create_doc_fragment(html);
const container = frag.firstElementChild;
post_process41.call(this, env, container, opts);
return container;
}
__name(render43, "render");
async function post_process41(env, frag, opts = {}) {
const unmute_buttons = frag.querySelectorAll(".unmute-button");
unmute_buttons.forEach((button) => {
button.addEventListener("click", () => {
const row = button.closest(".muted-notice");
const notice = row.dataset.notice;
env.notices.settings.muted[notice] = false;
delete env.notices.settings.muted[notice];
row.remove();
});
});
}
__name(post_process41, "post_process");

var style_default4 = ".sc-env-settings-container {\n  margin: 1rem 0;\n}\n\n.smart-env-settings-header {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  margin-bottom: 0.5rem;\n}\n\n.toggle-env-settings-btn {\n  cursor: pointer;\n}\n\n\n.setting-group .setting-items .setting-item.env-setting-highlight {\n  border: 1px solid var(--interactive-accent);\n  background-color: var(--interactive-hover);\n  padding: 0.5rem;\n  margin: 0.5rem 0;\n}\n\n.settings-group {\n  .setting-item {\n    border-top: none;\n  }\n}\n\n.sc-inline-confirm-row {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  margin-top: 0.5rem;\n}\n";

async function build_html44(env, params = {}) {
return `<div class="smart-env-settings-container">
<div class="sources-container">
<h1>Sources</h1>
</div>
<div class="models-container">
<h1>Models</h1>
</div>
<div class="notifications-container">
<h1>Notifications</h1>
</div>
</div>`;
}
__name(build_html44, "build_html");
async function render44(env, params = {}) {
this.apply_style_sheet(style_default4);
const html = await build_html44.call(this, env, params);
const frag = this.create_doc_fragment(html);
const container = frag.firstElementChild;
post_process42.call(this, env, container, params);
return container;
}
__name(render44, "render");
async function post_process42(env, container, opts = {}) {
const models_container = container.querySelector(".models-container");
const sources_container = container.querySelector(".sources-container");
const notifications_container = container.querySelector(".notifications-container");
render_if_available2.call(this, "settings_env_sources", env, sources_container);
render_if_available2.call(this, "settings_env_models", env, models_container);
render_if_available2.call(this, "settings_notifications", env, notifications_container);
return container;
}
__name(post_process42, "post_process");
function render_if_available2(component_key, env, container) {
if (env.config.components[component_key]) {
const placeholder = this.create_doc_fragment(`<div data-component="${component_key}"></div>`).firstElementChild;
container.appendChild(placeholder);
env.smart_components.render_component(component_key, env).then((comp_el) => {
this.empty(placeholder);
placeholder.appendChild(comp_el);
});
}
}
__name(render_if_available2, "render_if_available");

var import_obsidian71 = require("obsidian");
function build_html45() {
return `
<div class="sc-context-actions">
<div class="sc-context-actions-left">
</div>
<div class="sc-context-actions-right">
</div>
</div>
`;
}
__name(build_html45, "build_html");
async function render45(ctx, opts = {}) {
const html = build_html45();
const frag = this.create_doc_fragment(html);
const container = frag.firstElementChild;
post_process43.call(this, ctx, container, opts);
return container;
}
__name(render45, "render");
async function post_process43(ctx, container, opts = {}) {
const render_ctx_actions = /* @__PURE__ */ __name(() => {
const actions_left = container.querySelector(".sc-context-actions-left");
this.empty(actions_left);
const actions_right = container.querySelector(".sc-context-actions-right");
this.empty(actions_right);
render_btn_open_selector2(ctx, actions_right);
render_btn_copy_context2(ctx, actions_right);
render_btn_clear_context2(ctx, actions_right);
render_btn_help2(ctx, actions_right);
}, "render_ctx_actions");
render_ctx_actions();
const disposers = [];
disposers.push(ctx.on_event("context:updated", render_ctx_actions));
this.attach_disposer(container, disposers);
return container;
}
__name(post_process43, "post_process");
function render_btn_open_selector2(ctx, container) {
const add_btn = document.createElement("button");
add_btn.type = "button";
add_btn.className = "sc-add-context-btn";
add_btn.textContent = "Add context";
container.appendChild(add_btn);
add_btn.addEventListener("click", () => {
ctx.emit_event("context_selector:open");
});
}
__name(render_btn_open_selector2, "render_btn_open_selector");
function render_btn_copy_context2(ctx, container) {
const copy_btn = document.createElement("button");
copy_btn.type = "button";
copy_btn.className = "sc-copy-clipboard";
copy_btn.textContent = "Copy to clipboard";
if (!ctx.has_context_items) {
copy_btn.style.display = "none";
}
container.appendChild(copy_btn);
copy_btn.addEventListener("click", async () => {
ctx.actions.context_copy_to_clipboard();
});
}
__name(render_btn_copy_context2, "render_btn_copy_context");
function render_btn_clear_context2(ctx, container) {
const clear_btn = document.createElement("button");
clear_btn.type = "button";
clear_btn.className = "sc-clear-context-btn";
clear_btn.textContent = "Clear";
if (!ctx.has_context_items) {
clear_btn.style.display = "none";
}
container.appendChild(clear_btn);
clear_btn.addEventListener("click", () => {
ctx.clear_all();
ctx.emit_event("context:cleared");
});
}
__name(render_btn_clear_context2, "render_btn_clear_context");
function render_btn_help2(ctx, container) {
const help_btn = document.createElement("button");
help_btn.type = "button";
help_btn.className = "sc-help-btn";
help_btn.setAttribute("aria-label", "Learn more");
container.appendChild(help_btn);
(0, import_obsidian71.setIcon)(help_btn, "help-circle");
help_btn.addEventListener("click", () => {
window.open("https://smartconnections.app/smart-context/builder/?utm_source=context-selector-modal", "_external");
ctx.emit_event("context_selector:help");
});
}
__name(render_btn_help2, "render_btn_help");

var styles_default2 = "/* Modal view adjustments */\r\n.modal-container .sc-context-view {\r\n  max-height: 60%;\r\n  display: flex;\r\n  flex-direction: column;\r\n  .sc-context-view-body {\r\n    overflow: auto;\r\n  }\r\n  .sc-add-context-btn {\r\n    display: none;\r\n  }\r\n  .sc-context-view-header {\r\n    padding: var(--size-4-2);\r\n  }\r\n  .sc-context-actions {\r\n    display: flex;\r\n    justify-content: space-between;\r\n  }\r\n  .sc-context-actions-right {\r\n    display: flex;\r\n    gap: var(--size-4-2);\r\n  }\r\n\r\n  .sc-context-view-body {\r\n    padding: var(--size-4-2);\r\n  }\r\n\r\n  .sc-context-view-footer {\r\n    padding: var(--size-4-2);\r\n  }\r\n\r\n}\r\n\r\n/* make hover popover work in builder modal */\r\n.hover-popover {\r\n  z-index: 100;\r\n}\r\n";

var import_obsidian72 = require("obsidian");
async function copy_to_clipboard5(text) {
try {
if (navigator?.clipboard?.writeText) {
await navigator.clipboard.writeText(text);
} else if (!import_obsidian72.Platform.isMobile) {
const { clipboard } = require("electron");
clipboard.writeText(text);
} else {
new import_obsidian72.Notice("Unable to copy text: no valid method found.");
}
} catch (err) {
console.error("Failed to copy text:", err);
new import_obsidian72.Notice("Failed to copy.");
}
}
__name(copy_to_clipboard5, "copy_to_clipboard");

var schedule_next_frame3 = /* @__PURE__ */ __name((callback) => {
if (typeof requestAnimationFrame === "function") {
requestAnimationFrame(callback);
return;
}
setTimeout(callback, 0);
}, "schedule_next_frame");
var create_render_scheduler3 = /* @__PURE__ */ __name((render_fn) => {
let render_pending = false;
return () => {
if (render_pending) return;
render_pending = true;
schedule_next_frame3(async () => {
render_pending = false;
await render_fn();
});
};
}, "create_render_scheduler");
function build_html46(ctx, opts = {}) {
return `<div>
<div class="sc-context-view" data-context-key="${ctx.data.key}">
<div class="sc-context-view-header">
<div class="sc-context-actions"></div>
</div>
<div class="sc-context-view-body">
<div class="sc-context-tree"></div>
</div>
<div class="sc-context-view-footer">
<div class="sc-context-meta"></div>
</div>
</div>
</div>`;
}
__name(build_html46, "build_html");
async function render46(ctx, opts = {}) {
const html = build_html46(ctx, opts);
this.apply_style_sheet(styles_default2);
const frag = this.create_doc_fragment(html);
const container = frag.querySelector(".sc-context-view");
post_process44.call(this, ctx, container, opts);
return container;
}
__name(render46, "render");
async function post_process44(ctx, container, opts = {}) {
const disposers = [];
const render_children = /* @__PURE__ */ __name(async () => {
const header = container.querySelector(".sc-context-view-header");
ctx.env.smart_components.render_component("smart_context_actions", ctx, opts).then((actions) => {
this.empty(header);
header.appendChild(actions);
});
const body = container.querySelector(".sc-context-view-body");
ctx.env.smart_components.render_component("smart_context_tree", ctx, opts).then((tree) => {
this.empty(body);
body.appendChild(tree);
});
const footer = container.querySelector(".sc-context-view-footer");
ctx.env.smart_components.render_component("smart_context_meta", ctx, opts).then((meta) => {
this.empty(footer);
footer.appendChild(meta);
});
}, "render_children");
const schedule_render_children = create_render_scheduler3(render_children);
const plugin = ctx.env.plugin;
const app = plugin?.app || window.app;
const register = plugin?.registerDomEvent?.bind(plugin) || ((el, evt, cb) => el.addEventListener(evt, cb));
register(container, "contextmenu", (ev) => {
ev.preventDefault();
ev.stopPropagation();
if (!app) return;
const menu = new Menu(app);
menu.addItem(
(mi) => mi.setTitle("Copy link tree").setIcon("copy").onClick(async () => {
const md = tree_dom_to_wikilinks2(container);
await copy_to_clipboard5(md);
})
);
menu.showAtMouseEvent(ev);
});
await render_children();
disposers.push(ctx.on_event("context:updated", schedule_render_children));
this.attach_disposer(container, disposers);
return container;
}
__name(post_process44, "post_process");
function tree_dom_to_wikilinks2(container) {
const lines = [];
const walk = /* @__PURE__ */ __name((li, depth) => {
const path = li.dataset.path;
if (!path) return;
let rel = path.replace(/^external:/, "").replace(/^selection:/, "");
const label = li.querySelector(":scope > .sc-tree-label")?.textContent?.trim() || "";
if (li.classList.contains("file")) {
let file = rel.split("/").pop().replace(/\.md$/, "");
lines.push(`${"	".repeat(depth)}- [[${file}]]`);
} else if (li.classList.contains("dir")) {
lines.push(`${"	".repeat(depth)}- ${label}`);
}
li.querySelectorAll(":scope > ul > li").forEach((child) => walk(child, depth + 1));
}, "walk");
container.querySelectorAll(":scope > ul > li").forEach((li) => walk(li, 0));
return lines.join("\n");
}
__name(tree_dom_to_wikilinks2, "tree_dom_to_wikilinks");

function estimate_tokens2(char_count) {
return Math.ceil((char_count || 0) / 4);
}
__name(estimate_tokens2, "estimate_tokens");
function build_html47() {
return `
<div class="sc-context-meta" aria-live="polite"></div>
`;
}
__name(build_html47, "build_html");
async function render47(ctx, params = {}) {
const html = build_html47();
const frag = this.create_doc_fragment(html);
const container = frag.firstElementChild;
post_process45.call(this, ctx, container, params);
return container;
}
__name(render47, "render");
async function post_process45(ctx, container, params = {}) {
const render_meta = /* @__PURE__ */ __name(() => {
if (ctx?.has_context_items) {
const chars = ctx.size || 0;
const tokens = estimate_tokens2(chars);
container.textContent = `\u2248 ${chars.toLocaleString()} chars \xB7 ${tokens.toLocaleString()} tokens`;
} else {
container.textContent = "No context items selected";
}
}, "render_meta");
render_meta();
const disposers = [];
disposers.push(ctx.on_event("context:updated", render_meta));
this.attach_disposer(container, disposers);
return container;
}
__name(post_process45, "post_process");

function build_tree_item2(item, selected_paths, child_html = "") {
let { key, path, name, is_file } = item;
const has_children = child_html.trim() !== "";
let remove_btn = "";
let connections_btn = "";
let links_btn = "";
if (!key) key = path;
if (selected_paths.has(key) || has_children) {
remove_btn = `<span class="sc-context-item-remove" data-path="${key}">\xD7</span>`;
}
if (selected_paths.has(key) && !key.startsWith("external:../")) {
connections_btn = `<span class="sc-tree-connections" data-path="${key}" title="Connections for ${name}"></span>`;
links_btn = `<span class="sc-tree-links" data-path="${key}" title="Links for ${name}"></span>`;
}
const label_classes = ["sc-tree-label"];
if (item.exists === false) label_classes.push("missing");
return `<li data-path="${key}" class="sc-tree-item ${is_file ? "file" : "dir"}${key.startsWith("external:") ? " sc-external" : ""}">
${remove_btn}
<span class="${label_classes.join(" ")}">${name}</span>
${connections_btn}
${links_btn}
${child_html}
</li>`;
}
__name(build_tree_item2, "build_tree_item");

function build_tree_html2(items) {
const tree_root = build_path_tree2(items);
const selected_set = new Set(items.map((it) => it.key || it.path));
const tree_list_html = tree_to_html2(tree_root, selected_set);
return tree_list_html;
}
__name(build_tree_html2, "build_tree_html");
function build_path_tree2(selected_items = []) {
const get_item_key = /* @__PURE__ */ __name((item) => item?.key || item?.path || "", "get_item_key");
const split_path_segments = /* @__PURE__ */ __name((item_path) => {
const BLOCK_ID_RE = /#\{\d+\}$/u;
let remainder = item_path;
let block_id_seg = null;
let block_key_seg = null;
let has_block = false;
const id_match = remainder.match(BLOCK_ID_RE);
if (id_match) {
block_id_seg = id_match[0];
remainder = remainder.slice(0, -block_id_seg.length);
has_block = true;
}
const key_idx = remainder.indexOf("##");
if (key_idx !== -1) {
block_key_seg = remainder.slice(key_idx);
remainder = remainder.slice(0, key_idx);
has_block = true;
}
const segments = [];
if (remainder) {
let seg = "";
let in_wikilink = false;
for (let i = 0; i < remainder.length; i++) {
if (!in_wikilink && remainder.slice(i, i + 2) === "[[") {
in_wikilink = true;
seg += "[[";
i++;
} else if (in_wikilink && remainder.slice(i, i + 2) === "]]") {
in_wikilink = false;
seg += "]]";
i++;
} else if (!in_wikilink && remainder[i] === "/") {
segments.push(seg);
seg = "";
} else {
seg += remainder[i];
}
}
if (seg) segments.push(seg);
}
if (block_key_seg) segments.push(block_key_seg);
if (block_id_seg) segments.push(block_id_seg);
return { segments, has_block };
}, "split_path_segments");
const root = { name: "", children: {}, selected: false };
const is_redundant = /* @__PURE__ */ __name((p, selected_folders2) => selected_folders2.some((folder) => p.startsWith(`${folder}/`)), "is_redundant");
const selected_folders = selected_items.filter((it) => {
const item_key = get_item_key(it);
if (!item_key) return false;
const for_ext_check = item_key.includes("#") ? item_key.split("#")[0] : item_key;
return !for_ext_check.match(/\.[a-zA-Z0-9]+$/u);
}).map((it) => get_item_key(it)).filter(Boolean);
for (const item of selected_items) {
const item_key = get_item_key(item);
const exists = item?.exists;
if (!item_key) continue;
if (is_redundant(item_key, selected_folders.filter((p) => p !== item_key))) continue;
const { segments, has_block } = split_path_segments(item_key);
let node = root;
let running = "";
segments.forEach((seg, idx) => {
running = running ? `${running}/${seg}` : seg;
if (seg.startsWith("external:..")) return;
const is_last = idx === segments.length - 1;
const is_block_leaf = is_last && has_block;
if (!node.children[seg]) {
node.children[seg] = {
name: seg,
path: is_block_leaf ? item_key : running,
children: is_block_leaf ? [] : {},
selected: false,
is_file: is_block_leaf || is_last && seg.includes(".")
};
}
node = node.children[seg];
if (is_last) {
node.selected = true;
node.exists = exists;
}
});
}
return root;
}
__name(build_path_tree2, "build_path_tree");
function tree_to_html2(node, selected_paths) {
if (!node.children || !Object.keys(node.children).length) return "";
const child_html = Object.values(node.children).sort((a, b) => {
if (a.is_file !== b.is_file) return a.is_file ? 1 : -1;
return a.name.localeCompare(b.name);
}).map((child) => build_tree_item2(child, selected_paths, tree_to_html2(child, selected_paths))).join("");
return `<ul>${child_html}</ul>`;
}
__name(tree_to_html2, "tree_to_html");

var tree_default2 = ".sc-context-tree {\r\n  ul {\r\n    padding-inline-start: 1.7rem;\r\n  }\r\n  li:has(> .sc-context-item-leaf > .sc-context-item-remove) {\r\n    list-style-type: none;\r\n  }\r\n  .sc-context-item-remove:hover {\r\n    font-weight: bold;\r\n    filter: brightness(1.8);\r\n  }\r\n  .sc-context-item-remove {\r\n    padding: 0 0.2rem;\r\n    margin-left: -1.4rem;\r\n  }\r\n}\r\n.sc-context-item-leaf, .sc-context-item-remove {\r\n  cursor: pointer;\r\n}\r\n.sc-context-item-score,\r\n.sc-context-item-size {\r\n  display: inline-block;\r\n  min-width: 4.5ch;\r\n  height: 1.7em;\r\n  line-height: 1.7em;\r\n  text-align: center;\r\n  font-weight: 600 !important;\r\n  font-size: 0.8em !important;\r\n  color: var(--nav-item-color) !important;\r\n  background: var(--background-modifier-hover);\r\n  border-radius: 6px;\r\n  padding: 0 0.4em;\r\n  margin-right: 0.35em;\r\n}\r\n.sc-context-item-size {\r\n  min-width: 0;\r\n}";

var is_nested_context_item2 = /* @__PURE__ */ __name((item_key, target_path) => {
if (!item_key || !target_path) return false;
if (item_key === target_path) return true;
if (item_key.startsWith(`${target_path}/`)) return true;
return item_key.startsWith(`${target_path}#`);
}, "is_nested_context_item");
function get_nested_context_item_keys2(ctx, params = {}) {
const { target_path } = params;
if (!target_path) return [];
const context_item_keys = Object.keys(ctx?.data?.context_items || {});
const nested_keys = context_item_keys.filter((item_key) => is_nested_context_item2(item_key, target_path));
return [...new Set(nested_keys)];
}
__name(get_nested_context_item_keys2, "get_nested_context_item_keys");

var schedule_next_frame4 = /* @__PURE__ */ __name((callback) => {
if (typeof requestAnimationFrame === "function") {
requestAnimationFrame(callback);
return;
}
setTimeout(callback, 0);
}, "schedule_next_frame");
var create_render_scheduler4 = /* @__PURE__ */ __name((render_fn) => {
let render_pending = false;
return () => {
if (render_pending) return;
render_pending = true;
schedule_next_frame4(() => {
render_pending = false;
render_fn();
});
};
}, "create_render_scheduler");
var remove_nested_context_items2 = /* @__PURE__ */ __name((ctx, params = {}) => {
const { target_path } = params;
const nested_keys = get_nested_context_item_keys2(ctx, { target_path });
ctx.remove_items(nested_keys);
}, "remove_nested_context_items");
function build_html48(ctx, params = {}) {
return `
<div class="sc-context-tree" data-context-key="${ctx.data.key}"></div>
`;
}
__name(build_html48, "build_html");
async function render48(ctx, params = {}) {
this.apply_style_sheet(tree_default2);
const html = build_html48(ctx, params);
const frag = this.create_doc_fragment(html);
const container = frag.firstElementChild;
post_process46.call(this, ctx, container, params);
return container;
}
__name(render48, "render");
async function post_process46(ctx, container, params = {}) {
const plugin = ctx?.env?.plugin;
const register_dom_event = plugin?.registerDomEvent?.bind(plugin) || ((el, evt, cb) => el.addEventListener(evt, cb));
const render_tree_leaves = /* @__PURE__ */ __name(() => {
const env = ctx.env;
const items = ctx.context_items.filter(params.filter);
const list_html = build_tree_html2(items);
const list_frag = this.create_doc_fragment(list_html);
this.empty(container);
container.appendChild(list_frag);
for (let i = 0; i < items.length; i++) {
const item = items[i];
const li = container.querySelector(`.sc-tree-item[data-path="${item.key}"]`);
if (!li) {
console.warn(`Smart Context: Could not find tree item for path: ${item.key}`);
continue;
}
env.smart_components.render_component("context_item_leaf", item).then((leaf) => {
this.empty(li);
li.appendChild(leaf);
});
}
}, "render_tree_leaves");
const schedule_render_tree_leaves = create_render_scheduler4(render_tree_leaves);
render_tree_leaves();
register_dom_event(container, "click", (event) => {
const target = event.target.closest(".sc-context-item-remove");
if (!target) return;
event.preventDefault();
event.stopPropagation();
const target_path = target.getAttribute("data-path");
remove_nested_context_items2(ctx, { target_path });
});
const disposers = [];
disposers.push(ctx.on_event("context:updated", schedule_render_tree_leaves));
this.attach_disposer(container, disposers);
return container;
}
__name(post_process46, "post_process");

var source_inspector_default2 = ".source-inspector {\r\n  background-color: var(--background-secondary-alt);\r\n  margin: var(--size-4-3) 0;\r\n  padding: var(--size-4-3);\r\n  border-radius: var(--radius-m);\r\n}\r\n\r\n.source-inspector-blocks-container {\r\n  margin-top: var(--size-4-2);\r\n  display: flex;\r\n  flex-direction: column;\r\n  gap: var(--size-4-3);\r\n}\r\n\r\n.source-inspector-blocks-container blockquote {\r\n  margin-left: var(--size-4-3);\r\n  padding-left: var(--size-4-3);\r\n  border-left: 2px solid var(--text-faint);\r\n}\r\n";

function build_html49(source, opts = {}) {
return `<div>
<div class="source-inspector-source-info">
<button class="source-inspector-show-data-btn" type="button">Show source data</button>
<div class="source-inspector-source-data" style="display:none; margin: 0.5em 0;">
<pre style="max-height:300px; overflow:auto; background:#222; color:#fff; padding:0.5em; border-radius:4px;"></pre>
</div>
</div>
<div class="smart-chat-message source-inspector">
<h2>Blocks</h2>
<div class="source-inspector-blocks-container"></div>
</div>
</div>`;
}
__name(build_html49, "build_html");
async function render49(source, opts = {}) {
const html = build_html49(source, opts);
const frag = this.create_doc_fragment(html);
this.apply_style_sheet(source_inspector_default2);
await post_process47.call(this, source, frag, opts);
return frag;
}
__name(render49, "render");
async function post_process47(source, frag, opts = {}) {
const container = frag.querySelector(".source-inspector .source-inspector-blocks-container");
if (!container) return frag;
const source_info = frag.querySelector(".source-inspector-source-info");
const btn = frag.querySelector(".source-inspector-show-data-btn");
const data_div = frag.querySelector(".source-inspector-source-data");
const pre = data_div?.querySelector("pre");
if (btn && data_div && pre) {
btn.addEventListener("click", () => {
if (data_div.style.display === "none") {
pre.textContent = JSON.stringify(source.data, null, 2);
data_div.style.display = "";
btn.textContent = "Hide source data";
} else {
data_div.style.display = "none";
btn.textContent = "Show source data";
}
});
}
const source_should_embed = source.should_embed ? `<span style="color: green;">should embed</span>` : `<span style="color: orange;">embedding skipped</span>`;
const source_embed_status = source.vec ? `<span style="color: green;">vectorized</span>` : `<span style="color: orange;">not vectorized</span>`;
const source_info_frag = this.create_doc_fragment(`<p>${source_should_embed} | ${source_embed_status}</p>`);
source_info.appendChild(source_info_frag);
if (!source || !source.blocks || source.blocks.length === 0) {
this.safe_inner_html(container, `<p>No blocks</p>`);
return frag;
}
const sorted_blocks = source.blocks.sort((a, b) => a.line_start - b.line_start);
for (const block of sorted_blocks) {
const sub_key_display = block.sub_key.split("#").join(" > ");
const block_info = `${sub_key_display} (${block.size} chars; lines: ${block.line_start}-${block.line_end})`;
const should_embed = block.should_embed ? `<span style="color: green;">should embed</span>` : `<span style="color: orange;">embedding skipped</span>`;
const embed_status = block.vec ? `<span style="color: green;">vectorized</span>` : `<span style="color: orange;">not vectorized</span>`;
let block_content = "";
let embed_input = "";
try {
const raw = await block.read();
block_content = raw.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\n/g, "<br>").replace(/\t/g, "&nbsp;&nbsp;");
const embed_raw = await block.get_embed_input(raw);
embed_input = embed_raw.replace(/</g, "&lt;").replace(/>/g, "&gt;");
} catch (err) {
console.error("[source_inspector] Error reading block:", err);
block_content = `<em style="color:red;">Error reading block content</em>`;
}
const block_frag = this.create_doc_fragment(`
<p>
${block_info}<br>
${should_embed} | ${embed_status}
</p>
<details class="source-inspector-embed-input">
<summary>Embed input</summary>
<pre style="max-height:300px; overflow:auto; background:#222; color:#fff; padding:0.5em; border-radius:4px;">${embed_input}</pre>
</details>
<blockquote>${block_content}</blockquote>
<hr>
`);
container.appendChild(block_frag);
}
return frag;
}
__name(post_process47, "post_process");

var import_obsidian76 = require("obsidian");

var import_obsidian75 = require("obsidian");

var import_obsidian73 = require("obsidian");
var SmartNoteInspectModal2 = class extends import_obsidian73.Modal {
static {
__name(this, "SmartNoteInspectModal");
}
constructor(smart_connections_plugin, entity) {
super(smart_connections_plugin.app);
this.smart_connections_plugin = smart_connections_plugin;
this.entity = entity;
}
get env() {
return this.smart_connections_plugin.env;
}
onOpen() {
this.titleEl.innerText = this.entity.key;
this.render();
}
async render() {
this.contentEl.empty();
const frag = await this.env.render_component("source_inspector", this.entity);
this.contentEl.appendChild(frag);
}
};

var import_obsidian74 = require("obsidian");
var EnvStatsModal2 = class extends import_obsidian74.Modal {
static {
__name(this, "EnvStatsModal");
}
constructor(app, env) {
super(app);
this.env = env;
}
onOpen() {
this.titleEl.setText("Smart Environment");
this.contentEl.empty();
this.contentEl.createEl("p", { text: "Loading stats..." });
setTimeout(this.render.bind(this), 100);
}
async render() {
const frag = await this.env.render_component("env_stats", this.env);
this.contentEl.empty();
if (frag) {
this.contentEl.appendChild(frag);
} else {
this.contentEl.createEl("p", { text: "Failed to load stats." });
}
}
};

function register_status_bar_context_menu2(env, status_container, deps = {}) {
const { Menu: MenuClass = import_obsidian75.Menu } = deps;
const plugin = env.main;
const on_context_menu = /* @__PURE__ */ __name((ev) => {
ev.preventDefault();
ev.stopPropagation();
const menu = new MenuClass(plugin.app);
menu.addItem(
(item) => item.setTitle("Inspect active note").setIcon("search").onClick(async () => {
const active_file = plugin.app.workspace.getActiveFile();
if (!active_file) {
new import_obsidian75.Notice("No active note found");
return;
}
const src = env.smart_sources?.get(active_file.path);
if (!src) {
new import_obsidian75.Notice("Active note is not indexed by Smart Environment");
return;
}
new SmartNoteInspectModal2(plugin, src).open();
})
);
menu.addItem(
(item) => item.setTitle("Show stats").setIcon("chart-pie").onClick(() => {
const modal = new EnvStatsModal2(plugin.app, env);
modal.open();
})
);
menu.addItem(
(item) => item.setTitle("Export data").setIcon("download").onClick(() => {
env.export_json();
new import_obsidian75.Notice("Smart Env exported");
})
);
menu.addItem(
(item) => item.setTitle("Milestones").setIcon("flag").onClick(() => {
env.open_milestones_modal();
})
);
menu.addItem(
(item) => item.setTitle("Notifications").setIcon("bell").onClick(() => {
env.open_notifications_feed_modal();
})
);
menu.addSeparator();
menu.addItem(
(item) => item.setTitle("Learn about Community Supporters").setIcon("hand-heart").onClick(() => {
const url = "https://smartconnections.app/community-supporters/?utm_source=status-bar";
window.open(url, "_external");
})
);
menu.showAtPosition({ x: ev.pageX, y: ev.pageY });
}, "on_context_menu");
plugin.registerDomEvent(status_container, "contextmenu", on_context_menu);
return on_context_menu;
}
__name(register_status_bar_context_menu2, "register_status_bar_context_menu");

var status_bar_default2 = ".status-bar-item:has(.smart-env-status-container) {\n  padding: 0 0.5em;\n\n  &:hover {\n    background-color: var(--background-modifier-hover);\n  }\n  &> .smart-env-status-container {\n    display: flex;\n    align-items: center;\n    gap: 0.5em;\n    text-decoration: none;\n    color: var(--status-bar-text-color);\n  }\n}\n\n.smart-env-status-indicator {\n  width: 0.6em;\n  height: 0.6em;\n  border-radius: 999px;\n  background-color: var(--interactive-accent);\n  opacity: 0;\n  transform: scale(0.3);\n  transition: opacity 150ms ease, transform 150ms ease;\n}\n.smart-env-status-indicator[data-level='info'] {\n  background-color: var(--interactive-accent);\n}\n.smart-env-status-indicator[data-level='attention'] {\n  background-color: var(--color-yellow);\n}\n.smart-env-status-indicator[data-level='warning'] {\n  background-color: var(--color-orange);\n}\n.smart-env-status-indicator[data-level='error'] {\n  background-color: var(--color-red);\n}\n\n.smart-env-status-indicator[data-count] {\n  opacity: 1;\n  transform: scale(1);\n}\n\n.smart-env-notifications-feed {\n  display: flex;\n  flex-direction: column;\n  padding: 0.5rem 0;\n  gap: 0.42rem;\n}\n\n.smart-env-notifications-empty {\n  margin: 0;\n  color: var(--text-muted);\n}\n\n.smart-env-notification {\n  font-size: var(--font-smaller);\n  display: flex;\n  flex-direction: column;\n  border-left: 3px solid var(--interactive-accent);\n  padding-left: 0.75rem;\n}\n\n.smart-env-notification[data-level='attention'] {\n  border-color: var(--color-yellow);\n}\n\n.smart-env-notification[data-level='warning'] {\n  border-color: var(--color-orange);\n}\n\n.smart-env-notification[data-level='error'] {\n  border-color: var(--color-red);\n}\n\n.smart-env-notification__message {\n  margin: 0;\n  font-weight: 500;\n  white-space: pre-wrap;\n}\n\n.smart-env-notification__meta {\n  color: var(--text-muted);\n  padding: 0.37rem 0;\n}\n\n.status-bar-mobile {\n  position: var(--status-bar-position);\n  bottom: 0;\n  border-radius: 0 8px 0 0;\n  border-style: solid;\n  border-width: 1px;\n  border-color: var(--status-bar-border-color);\n  background-color: var(--status-bar-background);\n  color: var(--status-bar-text-color);\n  font-size: var(--status-bar-font-size);\n  min-height: 18px;\n  padding: var(--size-4-1);\n  user-select: none;\n  z-index: var(--layer-status-bar);\n  font-variant-numeric: tabular-nums;\n  &> .smart-env-status-container {\n    padding: 5px 5px 5px 0;\n  }\n}\n\n/* footer view on mobile */\n.embedded-backlinks > .status-bar-mobile {\n  position: relative;\n  border-style: none;\n}";

function build_html50() {
return `
<a
class="smart-env-status-container"
role="button"
title="Smart Environment status"
aria-label="Smart Environment status"
tabindex="0"
>
<span class="smart-env-status-icon" aria-hidden="true"></span>
<span class="smart-env-status-msg" aria-live="polite"></span>
<span
class="smart-env-status-indicator"
title="Open notifications"
aria-label="Open notifications feed"
role="button"
tabindex="0"
></span>
</a>
`;
}
__name(build_html50, "build_html");
async function render50(env, opts = {}) {
this.apply_style_sheet(status_bar_default2);
const frag = this.create_doc_fragment(build_html50());
const anchor = frag.firstElementChild;
post_process48.call(this, env, anchor, opts);
return anchor;
}
__name(render50, "render");
function post_process48(env, container, opts = {}) {
const icon_slot = container?.querySelector?.(".smart-env-status-icon");
const status_indicator = container?.querySelector?.(".smart-env-status-indicator");
const status_msg = container?.querySelector?.(".smart-env-status-msg");
const version2 = env.is_pro ? "Pro" : env.constructor?.version;
const get_session_event_count = /* @__PURE__ */ __name(() => {
return env.event_logs?.session_events?.length || 0;
}, "get_session_event_count");
const get_embed_queue = /* @__PURE__ */ __name(() => {
return Object.keys(env.smart_sources.sources_re_import_queue || {}).length;
}, "get_embed_queue");
const render_status_elm = /* @__PURE__ */ __name(() => {
const embed_queue = get_embed_queue();
let message = `Smart Env${version2 ? " " + version2 : ""}`;
let title = "Smart Environment status";
let indicator_count = get_session_event_count();
let indicator_level = env.event_logs?.notification_status || "info";
if (embed_queue > 0) {
message = `Embed now (${embed_queue})`;
title = "Click to re-import.";
indicator_level = "attention";
}
if (icon_slot) {
(0, import_obsidian76.setIcon)(icon_slot, "smart-connections");
}
if (status_indicator) {
if (!status_indicator._click_handler) {
status_indicator._click_handler = (event) => {
event.stopPropagation();
env.open_notifications_feed_modal?.();
};
status_indicator.addEventListener("click", status_indicator._click_handler);
}
if (indicator_count > 0) {
status_indicator.dataset.count = String(indicator_count);
} else {
delete status_indicator.dataset.count;
}
if (indicator_level) {
status_indicator.dataset.level = String(indicator_level);
} else {
delete status_indicator.dataset.level;
}
}
status_msg.setText?.(message);
container.setAttribute?.("title", title);
container.removeAttribute?.("href");
container.removeAttribute?.("target");
if (!container._click_handler) {
container._click_handler = (event) => {
const curr_embed_queue = get_embed_queue();
if (curr_embed_queue > 0) {
event.preventDefault();
event.stopPropagation();
status_msg?.setText?.("Embedding...");
env.run_re_import?.();
} else {
const context_event = new MouseEvent("contextmenu", event);
container.dispatchEvent?.(context_event);
}
};
container.addEventListener("click", container._click_handler);
}
}, "render_status_elm");
register_status_bar_context_menu2(env, container);
render_status_elm();
let debounce_timeout = null;
const debounce_refresh_status_bar = /* @__PURE__ */ __name(() => {
if (debounce_timeout) clearTimeout(debounce_timeout);
debounce_timeout = setTimeout(() => {
render_status_elm();
debounce_timeout = null;
}, 100);
}, "debounce_refresh_status_bar");
const disposers = [];
disposers.push(env.events.on("*", debounce_refresh_status_bar));
this.attach_disposer(container, disposers);
}
__name(post_process48, "post_process");

var import_obsidian77 = require("obsidian");
function build_html51(plugin, opts = {}) {
const { plugin_name = plugin.manifest.name } = opts;
return `<div class="wrapper">
<div id="footer-callout" data-callout-metadata="" data-callout-fold="" data-callout="info" class="callout" style="mix-blend-mode: unset;">
<div class="callout-title" style="align-items: center;">
<div class="callout-icon">
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-info">
<circle cx="12" cy="12" r="10"></circle>
<path d="M12 16v-4"></path>
<path d="M12 8h.01"></path>
</svg>
</div>
<div class="callout-title-inner"><strong>Become a Supporter</strong></div>
</div>
<div class="callout-content">
<p>Try early &amp; experimental features:
<ul>
<li><b>Smart Connections Early Release:</b>
<ul>
<li>Inline block connections</li>
<li>Footer connections view</li>
<li>Connections re-ranking</li>
</ul>
</li>
<li><b>Smart Context Early Release:</b>
<ul>
<li>Named contexts</li>
<li>External sources: include code from external repositories</li>
<li>Context codeblocks: embed context in notes ("My most valuable workflow" - \u{1F334} Brian)</li>
</ul>
</li>
<li><b>Smart Editor:</b>
<ul>
<li>Generate &amp; review changes</li>
</ul>
</li>
<li><em>Be the first to know what's coming next!</em></li>
</ul>
</p>
<p>Access the Supporter Community Campfire Chat:
<ul>
<li>Supporter-only private discussions</li>
<li>Share workflows</li>
<li>Get priority help &amp; support</li>
</ul>
</p>
<p>Guaranteed seat in the Community Lean Coffee meetings.</p>
<p><i>Your support shapes the future of ${plugin_name}.</i></p>
<p>
<strong>Fuel the circle of empowerment.</strong> <a href="https://smartconnections.app/community-supporters?utm_source=obsidian-${plugin_name.replace(/[^a-zA-Z0-9]/g, "-").toLowerCase()}" class="button" target="_external">Become a Supporter</a>
</p>
</div>
</div>
</div>`;
}
__name(build_html51, "build_html");
function render51(plugin, opts = {}) {
const html = build_html51.call(this, plugin, opts);
const frag = this.create_doc_fragment(html);
const container = frag.querySelector(".wrapper");
post_process49.call(this, plugin, container, opts);
return container;
}
__name(render51, "render");
async function post_process49(plugin, container) {
const icon_container = container.querySelector(".callout-icon");
const icon = (0, import_obsidian77.getIcon)("hand-heart");
if (icon) {
this.empty(icon_container);
icon_container.appendChild(icon);
}
const oauth_storage_prefix = plugin.app.vault.getName().toLowerCase().replace(/[^a-z0-9]/g, "_") + "_smart_plugins_oauth_";
const is_logged_in = !!localStorage.getItem(oauth_storage_prefix + "token");
if (is_logged_in) container.querySelector("#footer-callout").style.display = "none";
await this.render_setting_components(container, { scope: plugin.env });
}
__name(post_process49, "post_process");

var import_obsidian78 = require("obsidian");
function build_html52(plugin, opts = {}) {
const { plugin_name = plugin.manifest.name } = opts;
return `<div class="wrapper">
<div id="footer-callout" data-callout-metadata="" data-callout-fold="" data-callout="info" class="callout" style="mix-blend-mode: unset;">
<div class="callout-title" style="align-items: center;">
<div class="callout-icon">
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-info">
<circle cx="12" cy="12" r="10"></circle>
<path d="M12 16v-4"></path>
<path d="M12 8h.01"></path>
</svg>
</div>
<div class="callout-title-inner"><strong>User Agreement</strong></div>
</div>
<div class="callout-content">
<p>By using ${plugin_name} you agree to share how it helps you with at least one other person \u{1F60A}\u{1F334}</p>
</div>
</div>
</div>`;
}
__name(build_html52, "build_html");
function render52(plugin, opts = {}) {
const html = build_html52.call(this, plugin, opts);
const frag = this.create_doc_fragment(html);
const callout = frag.querySelector("#footer-callout");
const icon_container = callout.querySelector(".callout-icon");
const icon = (0, import_obsidian78.getIcon)("smart-connections");
if (icon) {
this.empty(icon_container);
icon_container.appendChild(icon);
}
post_process50.call(this, plugin, callout, opts);
return callout;
}
__name(render52, "render");
function post_process50(plugin, callout) {
}
__name(post_process50, "post_process");

var import_obsidian79 = require("obsidian");
async function copy_to_clipboard6(params = {}) {
const context_items = this.context_items.filter(params.filter);
if (!context_items.length) {
this.emit_event("notification:warning", { message: "No context items to copy." });
return new import_obsidian79.Notice("No context items to copy.");
}
const content = await this.get_text(params);
await copy_to_clipboard5(content);
const message = format_stats_message2({
item_count: context_items.length,
char_count: content.length,
max_depth: params.max_depth,
exclusions: params.exclusions
});
this.emit_event("context:copied");
new import_obsidian79.Notice(message);
}
__name(copy_to_clipboard6, "copy_to_clipboard");
function format_stats_message2(stats = {}) {
const item_count = Number.isFinite(stats.item_count) ? stats.item_count : 0;
const char_count = Number.isFinite(stats.char_count) ? stats.char_count : 0;
const segments = [];
segments.push(`${item_count} file(s)`);
segments.push(`${format_char_count2(char_count)} chars`);
if (Number.isFinite(stats.max_depth)) {
segments.push(`depth\u2264${stats.max_depth}`);
}
const excluded_total = sum_exclusions2(stats.exclusions);
if (excluded_total > 0) {
segments.push(`${excluded_total} section(s) excluded`);
}
return `Copied to clipboard! (${segments.join(", ")})`;
}
__name(format_stats_message2, "format_stats_message");
function format_char_count2(char_count) {
if (!Number.isFinite(char_count)) return "0";
if (char_count >= 1e5) {
return `~${Math.round(char_count / 1e3)}k`;
}
return char_count.toLocaleString();
}
__name(format_char_count2, "format_char_count");
function sum_exclusions2(exclusions) {
if (!exclusions) return 0;
return Object.values(exclusions).reduce((total, value) => {
const numeric = Number.isFinite(value) ? value : 0;
return total + numeric;
}, 0);
}
__name(sum_exclusions2, "sum_exclusions");

var DEFAULT_TEMPLATE_PRESET2 = "xml_structured";
var template_presets2 = {
xml_structured: {
label: "XML-style (default)",
context_template_before: "<context>\n{{FILE_TREE}}",
context_template_after: "</context>",
item_template_before: '<item loc="{{KEY}}" at="{{TIME_AGO}}" depth="{{LINK_DEPTH}}">',
item_template_after: "</item>"
},
markdown_headings: {
label: "Markdown headings",
context_template_before: "{{FILE_TREE}}",
context_template_after: "",
item_template_before: [
"## {{KEY}}",
"Updated: {{TIME_AGO}} | Depth: {{LINK_DEPTH}}",
"````{{EXT}}"
].join("\n"),
item_template_after: "````\n"
},
json_structured: {
label: "JSON structured",
context_template_before: '{\n  "context": {',
context_template_after: "  }\n}",
item_template_before: '    "{{KEY}}": { "name": "{{ITEM_NAME}}", "updated": "{{TIME_AGO}}", "depth": {{LINK_DEPTH}}, "content": ',
item_template_after: "    },",
json_stringify: true
},
custom: {
label: "Custom (PRO)"
}
};
var get_preset_key2 = /* @__PURE__ */ __name((settings = {}) => {
const preset_key = settings.template_preset || DEFAULT_TEMPLATE_PRESET2;
if (template_presets2[preset_key]) return preset_key;
return "custom";
}, "get_preset_key");
var get_template_value2 = /* @__PURE__ */ __name((settings, defaults, preset_field_key, settings_field_key) => {
const preset_key = get_preset_key2(settings);
const preset = template_presets2[preset_key];
const value_from_settings = settings?.[settings_field_key];
if (preset_key !== "custom" && preset && typeof preset[preset_field_key] === "string") {
return preset[preset_field_key];
}
if (preset_key === "custom" && typeof value_from_settings === "string") {
return value_from_settings;
}
return defaults?.[settings_field_key];
}, "get_template_value");
function get_template_preset_options2() {
return Object.entries(template_presets2).map(([value, config]) => ({
value,
label: config.label || value
}));
}
__name(get_template_preset_options2, "get_template_preset_options");
function get_context_templates2(settings = {}, defaults = {}) {
return {
template_before: get_template_value2(settings, defaults, "context_template_before", "template_before"),
template_after: get_template_value2(settings, defaults, "context_template_after", "template_after")
};
}
__name(get_context_templates2, "get_context_templates");
function get_item_templates2(settings = {}, defaults = {}) {
const preset_key = get_preset_key2(settings);
const preset = template_presets2[preset_key];
const include_json_stringify = preset_key === "custom" && typeof settings.json_stringify === "boolean";
return {
...preset && typeof preset === "object" ? preset : {},
...include_json_stringify ? { json_stringify: settings.json_stringify } : {},
template_before: get_template_value2(settings, defaults, "item_template_before", "template_before"),
template_after: get_template_value2(settings, defaults, "item_template_after", "template_after")
};
}
__name(get_item_templates2, "get_item_templates");

var derive_item_name_from_key2 = /* @__PURE__ */ __name((key = "") => {
if (typeof key !== "string" || key.trim().length === 0) return "";
const [filename_with_fragment] = key.split(/[\\/]/).slice(-1);
const [source_name, ...block_parts] = (filename_with_fragment || "").split("#");
const src_no_ext = source_name.includes(".") ? source_name.slice(0, source_name.lastIndexOf(".")) : source_name;
if (block_parts.length > 0) {
return `${src_no_ext}#${block_parts.join("#")}`;
}
return src_no_ext;
}, "derive_item_name_from_key");
var get_item_name2 = /* @__PURE__ */ __name((context_item) => {
return derive_item_name_from_key2(context_item.key);
}, "get_item_name");
async function merge_template3(item_text, params = {}) {
const MERGE_VARS = {
"KEY": this.key,
"ITEM_NAME": get_item_name2(this),
"TIME_AGO": convert_to_time_ago2(this.mtime) || "Missing",
"LINK_DEPTH": this.data.d || "0",
"EXT": this.item_ref?.file_type || ""
};
const replace_vars = /* @__PURE__ */ __name(async (template) => {
const re_var = /{{([\w_]+)}}/g;
const number_of_var_matches = (template.match(re_var) || []).length;
for (let i = 0; i < number_of_var_matches; i++) {
template = template.replace(/{{(\w+)}}/g, (match, p1) => {
return MERGE_VARS[p1] || "";
});
}
return template;
}, "replace_vars");
const templates = get_item_templates2(this.settings, default_settings5);
if (params.json_stringify || templates.json_stringify) {
item_text = JSON.stringify(item_text);
}
const before = await replace_vars(templates.template_before);
const after = await replace_vars(templates.template_after);
return ["", before, item_text, after, ""].join("\n");
}
__name(merge_template3, "merge_template");
var settings_config24 = {
template_preset: {
group: "Item templates",
type: "dropdown",
name: "Select template",
description: "Wraps each context item with a pre-configured template.",
options_callback: /* @__PURE__ */ __name(() => get_template_preset_options2(), "options_callback")
},
template_before: {
group: "Item templates",
type: "textarea",
name: "Template Before",
description: "Template to wrap before the context item content.",
scope_class: "pro-setting"
},
template_after: {
group: "Item templates",
type: "textarea",
name: "Template After",
description: "Template to wrap after the context item content.",
scope_class: "pro-setting"
},
item_explanation: {
type: "html",
group: "Item templates",
value: `
<b>Available variables:</b>
<ul>
<li><code>{{KEY}}</code> - Full path of the item</li>
<li><code>{{ITEM_NAME}}</code> - Source file or block name without folder path or file extension</li>
<li><code>{{TIME_AGO}}</code> - Time since the item was last modified</li>
<li><code>{{LINK_DEPTH}}</code> - Depth level of the item</li>
<li><code>{{EXT}}</code> - File extension of the item</li>
</ul>
`
},
json_stringify: {
group: "Item templates",
type: "toggle",
name: "JSON Stringify",
description: "Convert the item content to a JSON string (forces full content into single line in quotes).",
scope_class: "pro-setting"
}
};
var default_settings5 = {
template_preset: "xml_structured",
template_before: '<item loc="{{KEY}}" at="{{TIME_AGO}}">',
template_after: "</item>"
};

function build_file_tree_string2(paths = []) {
if (!Array.isArray(paths) || paths.length === 0) return "";
const root = {};
for (const path of paths) {
const isFolder = is_folder_path2(path);
const parts = path.split("/").filter(Boolean);
let node = root;
for (let i = 0; i < parts.length; i++) {
const part = parts[i];
const isLast = i === parts.length - 1;
if (isLast) {
if (isFolder) {
node[part] = node[part] ?? { __isExplicitFolder: true };
} else {
node[part] = null;
}
} else {
node = node[part] ??= {};
}
}
}
compress_single_child_dirs2(root);
return build_tree_string2(root).trimEnd();
}
__name(build_file_tree_string2, "build_file_tree_string");
function is_folder_path2(path) {
return typeof path === "string" && path.endsWith("/");
}
__name(is_folder_path2, "is_folder_path");
function compress_single_child_dirs2(node) {
if (!node || typeof node !== "object") return;
for (const key of Object.keys(node)) {
const child = node[key];
if (child && typeof child === "object") {
if (child.__isExplicitFolder) {
delete child.__isExplicitFolder;
compress_single_child_dirs2(child);
continue;
}
const childKeys = Object.keys(child);
if (childKeys.length === 1 && child[childKeys[0]] !== null && !child[childKeys[0]].__isExplicitFolder) {
const mergedKey = `${key}/${childKeys[0]}`;
node[mergedKey] = child[childKeys[0]];
delete node[key];
compress_single_child_dirs2(node[mergedKey]);
} else {
compress_single_child_dirs2(child);
}
}
}
}
__name(compress_single_child_dirs2, "compress_single_child_dirs");
function build_tree_string2(node, prefix = "") {
let output = "";
const entries = Object.entries(node).sort((a, b) => {
const aIsDir = a[1] !== null;
const bIsDir = b[1] !== null;
if (aIsDir && !bIsDir) return -1;
if (!aIsDir && bIsDir) return 1;
return a[0].localeCompare(b[0]);
});
entries.forEach(([name, child], idx) => {
const isLast = idx === entries.length - 1;
const connector = isLast ? "\u2514\u2500\u2500 " : "\u251C\u2500\u2500 ";
if (child === null) {
output += `${prefix}${connector}${name}
`;
} else {
output += `${prefix}${connector}${name}/
`;
output += build_tree_string2(child, prefix + (isLast ? "    " : "\u2502   "));
}
});
return output;
}
__name(build_tree_string2, "build_tree_string");

async function merge_template4(context_items_text, params = {}) {
const context_items = params.context_items || [];
const MERGE_VARS = {
"FILE_TREE": /* @__PURE__ */ __name(() => {
return build_file_tree_string2(context_items.map((c) => c.key));
}, "FILE_TREE")
};
const replace_vars = /* @__PURE__ */ __name(async (template) => {
const number_of_var_matches = (template.match(/{{(\w+)}}/g) || []).length;
for (let i = 0; i < number_of_var_matches; i++) {
template = template.replace(/{{(\w+)}}/gi, (match, p1) => {
return MERGE_VARS[p1]?.() || "";
});
}
return template;
}, "replace_vars");
const templates = get_context_templates2(this.settings, default_settings6);
const before = await replace_vars(templates.template_before);
const after = await replace_vars(templates.template_after);
return [before, context_items_text, after].join("\n");
}
__name(merge_template4, "merge_template");
var settings_config25 = {
template_preset: {
type: "dropdown",
group: "Context templates",
name: "Select template",
description: "Wraps the full context with a pre-configured template.",
options_callback: /* @__PURE__ */ __name(() => get_template_preset_options2(), "options_callback")
},
template_before: {
type: "textarea",
group: "Context templates",
name: "Template Before",
description: "Template to wrap before the context.",
scope_class: "pro-setting"
},
template_after: {
type: "textarea",
group: "Context templates",
name: "Template After",
description: "Template to wrap after the context.",
scope_class: "pro-setting"
},
context_explanation: {
type: "html",
group: "Context templates",
value: `<b>Available variables:</b>
<ul>
<li><code>{{FILE_TREE}}</code> - Shows hierarchical view of all files</li>
</ul>
`
}
};
var default_settings6 = {
template_preset: "xml_structured",
template_before: "<context>\n{{FILE_TREE}}",
template_after: "</context>"
};

function context_suggest_blocks2(params = {}) {
params?.modal?.setInstructions([
{ command: "Enter", purpose: "Add block to context" },
{ command: "\u2190", purpose: "Back to sources" }
]);
let blocks = [];
if (params.source_key) {
const src = this.env.smart_sources.get(params.source_key);
blocks = src.blocks;
} else {
blocks = Object.values(this.env.smart_blocks.items);
}
return blocks.sort((a, b) => {
const a_line = Array.isArray(a.lines) && a.lines.length ? a.lines[0] : Infinity;
const b_line = Array.isArray(b.lines) && b.lines.length ? b.lines[0] : Infinity;
return a_line - b_line;
}).map((block) => ({
key: block.key,
display: get_block_display_name5(block, { show_full_path: false }),
select_action: /* @__PURE__ */ __name(() => {
this.add_item(block.key);
}, "select_action"),
arrow_left_action: /* @__PURE__ */ __name(({ modal }) => {
modal.update_suggestions("context_suggest_sources");
}, "arrow_left_action")
}));
}
__name(context_suggest_blocks2, "context_suggest_blocks");
function get_block_display_name5(item, settings = {}) {
if (!item?.key) return "";
const show_full_path = settings.show_full_path ?? true;
if (show_full_path) {
return item.key.replace(/#/g, " > ").replace(/\//g, " > ");
}
const pcs = [];
const [source_key, ...block_parts] = item.key.split("#");
const filename = source_key.split("/").pop();
pcs.push(filename);
if (block_parts.length) {
const last = block_parts[block_parts.length - 1];
if (last.startsWith("{") && last.endsWith("}")) {
block_parts.pop();
pcs.push(block_parts.pop());
if (item.lines) pcs.push(`Lines: ${item.lines.join("-")}`);
} else {
pcs.push(block_parts.pop());
}
}
return pcs.filter(Boolean).join(" > ");
}
__name(get_block_display_name5, "get_block_display_name");
var display_name4 = "Add blocks";

var import_obsidian80 = require("obsidian");
var MOD_CHAR2 = import_obsidian80.Platform.isMacOS ? "\u2318" : "Ctrl";
function normalize_folder_path2(folder_path) {
if (typeof folder_path !== "string") return "";
return folder_path.replace(/\/+$/g, "");
}
__name(normalize_folder_path2, "normalize_folder_path");
function is_source_in_folder2(source_key, folder_path) {
const normalized_folder_path = normalize_folder_path2(folder_path);
if (!normalized_folder_path) return true;
if (source_key === normalized_folder_path) return true;
return source_key.startsWith(`${normalized_folder_path}/`);
}
__name(is_source_in_folder2, "is_source_in_folder");
function reset_modal_input2(modal) {
if (!modal?.inputEl) return;
modal.last_input_value = modal.inputEl.value;
modal.inputEl.value = "";
}
__name(reset_modal_input2, "reset_modal_input");
function get_sources_list2(ctx, folder_path) {
const items = Object.values(ctx.env?.smart_sources?.items || {});
return items.filter((source) => is_source_in_folder2(source.key, folder_path));
}
__name(get_sources_list2, "get_sources_list");
function build_source_suggestions2(ctx, sources) {
return sources.map((source) => ({
key: source.key,
display: source.key,
select_action: /* @__PURE__ */ __name(() => {
ctx.add_item(source.key);
}, "select_action"),
mod_select_action: /* @__PURE__ */ __name(({ modal } = {}) => {
reset_modal_input2(modal);
return context_suggest_blocks2.call(ctx, { source_key: source.key, modal });
}, "mod_select_action"),
arrow_right_action: /* @__PURE__ */ __name(({ modal } = {}) => {
reset_modal_input2(modal);
return context_suggest_blocks2.call(ctx, { source_key: source.key, modal });
}, "arrow_right_action")
}));
}
__name(build_source_suggestions2, "build_source_suggestions");
function context_suggest_sources2(params = {}) {
console.log("context_suggest_sources", params);
const modal = params?.modal;
if (modal) {
modal.setInstructions([
{ command: "Enter", purpose: "Add source to context" },
{ command: `${MOD_CHAR2} + Enter / \u2192`, purpose: "Suggest source blocks" }
]);
}
const sources = get_sources_list2(this, params?.folder_path || "");
return build_source_suggestions2(this, sources);
}
__name(context_suggest_sources2, "context_suggest_sources");
var display_name5 = "Add sources";

async function pre_process2(params) {
const query = params.query;
if (!query || typeof query !== "string" || query.trim().length === 0) {
throw new Error("Invalid or empty query provided to lookup list.");
}
const embed_model = this.env.smart_sources.embed_model;
if (!embed_model) {
throw new Error("No embed model available in environment for lookup list.");
}
const embedding = await embed_model.embed(query);
params.to_item = { ...embedding };
if (!params.score_algo_key) params.score_algo_key = "similarity";
return params;
}
__name(pre_process2, "pre_process");

function similarity2(params) {
if (!this.vec) return { score: null, error: `Missing this.vec for ${this.key}` };
if (!params.to_item?.vec) return { score: null, error: "Missing params.to_item.vec" };
return {
score: cos_sim3(this.vec || [], params.to_item.vec || [])
};
}
__name(similarity2, "similarity");
similarity2.action_type = "score";
var display_name6 = "Cosine Similarity";
var display_description2 = "Ranks by cosine similarity between the current note and candidates.";
var settings_config26 = {
similarity_algo_description: {
group: "Score algorithm",
type: "html",
name: `${display_name6} algorithm`,
value: `${display_description2}`
}
};

var import_obsidian81 = require("obsidian");
async function open_source2(item, event = null) {
try {
const env = item.env;
const obsidian_app = env.obsidian_app;
let target_path = item.key;
if (target_path.endsWith("#")) target_path = target_path.slice(0, -1);
let target_file;
if (target_path.includes("#")) {
const [file_path] = target_path.split("#");
target_file = obsidian_app.metadataCache.getFirstLinkpathDest(file_path, "");
} else {
target_file = obsidian_app.metadataCache.getFirstLinkpathDest(target_path, "");
}
if (!target_file) {
console.warn(`[open_note] Unable to resolve file for ${target_path}`);
return;
}
let leaf;
if (event) {
const is_mod = import_obsidian81.Keymap.isModEvent(event);
const is_alt = import_obsidian81.Keymap.isModifier(event, "Alt");
if (is_mod && is_alt) {
leaf = obsidian_app.workspace.splitActiveLeaf("vertical");
} else if (is_mod) {
leaf = obsidian_app.workspace.getLeaf(true);
} else {
leaf = obsidian_app.workspace.getMostRecentLeaf();
}
} else {
leaf = obsidian_app.workspace.getMostRecentLeaf();
}
await leaf.openFile(target_file);
if (typeof item?.line_start === "number") {
const { editor } = leaf.view;
const pos = { line: item.line_start, ch: 0 };
editor.setCursor(pos);
editor.scrollIntoView({ to: pos, from: pos }, true);
}
item.emit_event("sources:opened", { event_source: "open_source method" });
} catch (e) {
console.error("Error in open_source:", e);
item.emit_event("notification:error", { message: e.message, event_source: "open_source method" });
}
}
__name(open_source2, "open_source");

async function source_open2(event = null) {
await open_source2(this, event);
}
__name(source_open2, "source_open");

var smart_env_config4 = {
collections: {
embedding_models: embedding_models_default4,
lookup_lists: lookup_lists_default2
},
item_types: {
EmbeddingModel: EmbeddingModel2,
LookupList: LookupList2
},
items: {
embedding_model: { class: EmbeddingModel2 },
lookup_list: { class: LookupList2 }
},
modules: {},
components: {
collection_settings: { render: render30 },
context_item_leaf: { render: render31 },
env_stats: { render: render32 },
form_dropdown: { render: render33 },
lean_coffee_callout: { render: render34 },
milestones: { render: render35 },
notifications_feed: { render: render36 },
pro_plugins_list: { render: render37 },
pro_plugins_list_item: { render: render38 },
settings_env_model: { render: render39 },
settings_env_model_type: { render: render40 },
settings_env_models: { render: render41 },
settings_env_sources: { render: render26 },
settings_model_actions: { render: render42 },
settings_notifications: { render: render43 },
settings_smart_env: { render: render44 },
smart_context_actions: { render: render45 },
smart_context_item: { render: render46 },
smart_context_meta: { render: render47 },
smart_context_tree: { render: render48 },
source_inspector: { render: render49 },
status_bar: { render: render50 },
supporter_callout: { render: render51 },
user_agreement_callout: { render: render52 }
},
actions: {
context_copy_to_clipboard: { action: copy_to_clipboard6 },
context_item_merge_template: { action: merge_template3, settings_config: settings_config24, default_settings: default_settings5 },
context_merge_template: { action: merge_template4, settings_config: settings_config25, default_settings: default_settings6 },
context_suggest_blocks: { action: context_suggest_blocks2, display_name: display_name4 },
context_suggest_sources: { action: context_suggest_sources2, display_name: display_name5 },
lookup_list_pre_process: { action: pre_process2, pre_process: pre_process2 },
similarity: { action: similarity2, settings_config: settings_config26, display_name: display_name6, display_description: display_description2 },
source_open: { action: source_open2 }
}
};

var smart_env_config5 = {
env_path: "",
modules: {
smart_fs: {
class: SmartFs2,
adapter: ObsidianFsAdapter2
},
smart_view: {
class: SmartView2,
adapter: SmartViewObsidianAdapter2
},
smart_embed_model: {
class: SmartEmbedModel2,
adapters: {
transformers: SmartEmbedTransformersIframeAdapter2,
openai: SmartEmbedOpenAIAdapter2,
ollama: SmartEmbedOllamaAdapter2,
gemini: GeminiEmbedModelAdapter2,
lm_studio: LmStudioEmbedModelAdapter2
}
},
smart_chat_model: {
class: SmartChatModel2,
adapters: {
anthropic: SmartChatModelAnthropicAdapter2,
azure: SmartChatModelAzureAdapter2,
custom: SmartChatModelCustomAdapter2,
google: SmartChatModelGoogleAdapter2,
gemini: SmartChatModelGeminiAdapter2,
groq: SmartChatModelGroqAdapter2,
lm_studio: SmartChatModelLmStudioAdapter2,
ollama: SmartChatModelOllamaAdapter2,
open_router: SmartChatModelOpenRouterAdapter3,
openai: SmartChatModelOpenaiAdapter2,
xai: SmartChatModelXaiAdapter2,
deepseek: SmartChatModelDeepseekAdapter2
},
http_adapter: new SmartHttpRequest3({
adapter: SmartHttpObsidianRequestAdapter3,
obsidian_request_url: import_obsidian84.requestUrl
})
},
http_adapter: {
class: SmartHttpRequest3,
adapter: SmartHttpObsidianRequestAdapter3,
obsidian_request_url: import_obsidian84.requestUrl
}
},
collections: {
context_items: context_items_default2,
event_logs: event_logs_default2,
smart_components: smart_components_default4,
smart_contexts: smart_contexts_default2,
smart_sources: {
collection_key: "smart_sources",
class: SmartSources2,
data_adapter: AjsonMultiFileSourcesDataAdapter2,
source_adapters: {
"md": ObsidianMarkdownSourceContentAdapter2,
"txt": ObsidianMarkdownSourceContentAdapter2,
"excalidraw.md": ExcalidrawSourceContentAdapter2,
"base": BasesSourceContentAdapter2,
"canvas": CanvasSourceContentAdapter2,
"rendered": RenderedSourceContentAdapter2
},
content_parsers: [
parse_blocks2
],
process_embed_queue: true,
load_order: 100
},
smart_blocks: {
collection_key: "smart_blocks",
class: SmartBlocks3,
data_adapter: AjsonMultiFileBlocksDataAdapter2,
block_adapters: {
"md": MarkdownBlockContentAdapter2,
"txt": MarkdownBlockContentAdapter2,
"excalidraw.md": MarkdownBlockContentAdapter2
}
}
},
item_types: {
SmartSource: SmartSource2,
SmartBlock: SmartBlock3
},
items: {
smart_source: smart_source_default2,
smart_block: smart_block_default2
},
default_settings: default_settings4,
modals: {
context_selector: {
class: ContextModal2,
default_suggest_action_keys: [
"context_suggest_sources"
]
},
milestones_modal: {
class: MilestonesModal2
},
notifications_feed_modal: {
class: NotificationsFeedModal2
}
}
};
merge_env_config2(smart_env_config5, smart_env_config4);
var default_config_default2 = smart_env_config5;

var import_obsidian85 = require("obsidian");
function add_smart_chat_icon2() {
(0, import_obsidian85.addIcon)("smart-chat", `<defs>
<symbol id="smart-chat-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round">
<path d="M2 4c0-1.1.9-2 2-2h16c1.1 0 2 .9 2 2v11c0 1.1-.9 2-2 2h-8l-5 4v-4H4c-1.1 0-2-.9-2-2Z" stroke-width="2"></path>
<path d="M7 8c.5.3 1.3.3 1.8 0" stroke-width="2"></path>
<path d="M15.2 8c.5.3 1.3.3 1.8 0" stroke-width="2"></path>
<path d="M8 11.5c1 .8 2.5 1.2 4 1.2s3-.4 4-1.2" stroke-width="2"></path>
</symbol>
</defs>
<use href="#smart-chat-icon" />`);
}
__name(add_smart_chat_icon2, "add_smart_chat_icon");
function add_smart_connections_icon2() {
(0, import_obsidian85.addIcon)("smart-connections", `<path d="M50,20 L80,40 L80,60 L50,100" stroke="currentColor" stroke-width="4" fill="none"/>
<path d="M30,50 L55,70" stroke="currentColor" stroke-width="5" fill="none"/>
<circle cx="50" cy="20" r="9" fill="currentColor"/>
<circle cx="80" cy="40" r="9" fill="currentColor"/>
<circle cx="80" cy="70" r="9" fill="currentColor"/>
<circle cx="50" cy="100" r="9" fill="currentColor"/>
<circle cx="30" cy="50" r="9" fill="currentColor"/>`);
}
__name(add_smart_connections_icon2, "add_smart_connections_icon");
function add_smart_lookup_icon2() {
(0, import_obsidian85.addIcon)("smart-lookup", `<defs>
<clipPath id="sc-in-search-clip" clipPathUnits="userSpaceOnUse">
<circle cx="11" cy="11" r="8"></circle>
</clipPath>
<symbol id="smart-lookup-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round">
<g clip-path="url(#sc-in-search-clip)">
<path d="M10.3,5.4 L14.5,8.2 L14.5,11.0 L10.3,16.6" stroke="currentColor" stroke-width="0.56" fill="none"></path>
<path d="M7.5,9.6 L11.0,12.4" stroke="currentColor" stroke-width="0.7" fill="none"></path>
<circle cx="10.3" cy="5.4" r="0.3" fill="currentColor"></circle>
<circle cx="14.5" cy="8.2" r="0.3" fill="currentColor"></circle>
<circle cx="14.5" cy="12.4" r="0.3" fill="currentColor"></circle>
<circle cx="10.3" cy="16.6" r="0.3" fill="currentColor"></circle>
<circle cx="7.5" cy="9.6" r="0.3" fill="currentColor"></circle>
</g>
<circle cx="11" cy="11" r="8"></circle>
<path d="m21 21-4.3-4.3"></path>
</symbol>
</defs>
<use href="#smart-lookup-icon" />`);
}
__name(add_smart_lookup_icon2, "add_smart_lookup_icon");

var import_obsidian86 = require("obsidian");

var NOTICES2 = {
item_excluded: {
en: "Cannot show Smart Connections for excluded entity: {{entity_key}}"
},
load_env: {
en: "Mobile detected: to prevent performance issues, click to load Smart Environment when ready.",
button: {
en: `Load Smart Env`,
callback: /* @__PURE__ */ __name((env) => {
env.load(true);
}, "callback")
},
timeout: 1e4
},
/** @deprecated in favor of in-component insctructions (2025-06-22) */
missing_entity: {
en: "No entity found for key: {{key}}"
},
notice_muted: {
en: "Notice muted"
},
new_version_available: {
en: "A new version is available! (v{{version}})",
timeout: 15e3,
button: {
en: "Release notes",
callback: /* @__PURE__ */ __name((scope) => {
window.open("https://github.com/brianpetro/obsidian-smart-connections/releases", "_blank");
}, "callback")
}
},
new_early_access_version_available: {
en: "A new early access version is available! (v{{version}})"
},
supporter_key_required: {
en: "Supporter license key required for early access update"
},
revert_to_stable_release: {
en: 'Click "Check for Updates" in the community plugins tab and complete the update for Smart Connections to finish reverting to the stable release.',
timeout: 0
},
action_installed: {
en: 'Installed action "{{name}}"'
},
action_install_error: {
en: 'Error installing action "{{name}}": {{error}}',
timeout: 0
},
embed_model_not_loaded: {
en: "Embed model not loaded. Please wait for the model to load and try again."
},
embed_search_text_failed: {
en: "Failed to embed search text."
},
error_in_embedding_search: {
en: "Error in embedding search. See console for details."
},
copied_to_clipboard: {
en: "Message: {{content}} copied successfully."
},
copy_failed: {
en: "Unable to copy message to clipboard."
},
copied_chatgpt_url_to_clipboard: {
en: "ChatGPT URL copied to clipboard."
},
loading_collection: {
en: "Loading {{collection_key}}..."
},
done_loading_collection: {
en: "{{collection_key}} loaded."
},
saving_collection: {
en: "Saving {{collection_key}}..."
},
initial_scan: {
en: "[{{collection_key}}] Starting initial scan...",
timeout: 0
},
done_initial_scan: {
en: "[{{collection_key}}] Initial scan complete.",
timeout: 3e3
},
pruning_collection: {
en: "Pruning {{collection_key}}..."
},
done_pruning_collection: {
en: "Pruned {{count}} items from {{collection_key}}."
},
embedding_progress: {
en: "Embedding progress: {{progress}} / {{total}}\n{{tokens_per_second}} tokens/sec using {{model_name}}",
button: {
en: "Pause",
callback: /* @__PURE__ */ __name((env) => {
console.log("pausing");
env.smart_sources.entities_vector_adapter.halt_embed_queue_processing();
}, "callback")
},
timeout: 0
},
embedding_complete: {
en: "Embedding complete. {{total_embeddings}} embeddings created. {{tokens_per_second}} tokens/sec using {{model_name}}",
timeout: 0
},
embedding_paused: {
en: "Embedding paused. Progress: {{progress}} / {{total}}\n{{tokens_per_second}} tokens/sec using {{model_name}}",
button: {
en: "Resume",
callback: /* @__PURE__ */ __name((env) => {
env.smart_sources.entities_vector_adapter.resume_embed_queue_processing(100);
}, "callback")
},
timeout: 0
},
embedding_error: {
en: "Error embedding: {{error}}",
timeout: 0
},
import_progress: {
en: "Importing... {{progress}} / {{total}} sources",
timeout: 0
},
done_import: {
en: "Import complete. {{count}} sources imported in {{time_in_seconds}}s",
timeout: 0
},
no_import_queue: {
en: "No items in import queue"
},
clearing_all: {
en: "Clearing all data...",
timeout: 0
},
done_clearing_all: {
en: "All data cleared and reimported",
timeout: 3e3
},
image_extracting: {
en: "Extracting text from Image(s)",
timeout: 0
},
pdf_extracting: {
en: "Extracting text from PDF(s)",
timeout: 0
},
insufficient_settings: {
en: "Insufficient settings for {{key}}, missing: {{missing}}",
timeout: 0
},
unable_to_init_source: {
en: "Unable to initialize source: {{key}}",
timeout: 0
},
reload_sources: {
en: "Reloaded sources in {{time_ms}}ms"
}
};

function define_default_create_methods2(notices) {
for (const key of Object.keys(notices)) {
const notice_obj = notices[key];
if (typeof notice_obj.create !== "function") {
notice_obj.create = function(opts = {}) {
let text = this.en ?? key;
for (const [k, v] of Object.entries(opts)) {
text = text.replace(new RegExp(`{{${k}}}`, "g"), String(v));
}
let button;
if (!opts.button && this.button) {
const btn_label = typeof this.button.en === "string" ? this.button.en : "OK";
button = {
text: btn_label,
callback: typeof this.button.callback === "function" ? this.button.callback : () => {
}
};
} else {
button = opts.button;
}
let final_timeout = opts.timeout ?? this.timeout ?? 5e3;
return {
text,
button,
timeout: final_timeout,
confirm: opts.confirm,
immutable: opts.immutable
};
};
}
}
return notices;
}
__name(define_default_create_methods2, "define_default_create_methods");
var SmartNotices2 = class {
static {
__name(this, "SmartNotices");
}
/**
* @param {Object} scope - The main plugin instance
*/
constructor(env, opts = {}) {
env?.create_env_getter(this);
this.active = {};
this.adapter = opts.adapter || this.env.config.modules.smart_notices.adapter;
define_default_create_methods2(NOTICES2);
}
/** plugin settings for notices (muted, etc.) */
get settings() {
if (!this.env?.settings?.smart_notices) {
this.env.settings.smart_notices = {};
}
if (!this.env?.settings?.smart_notices?.muted) {
this.env.settings.smart_notices.muted = {};
}
return this.env?.settings?.smart_notices;
}
/**
* Displays a notice by key or custom message.
* Usage:
*   notices.show('load_env', { scope: this });
*
* @param {string} id - The notice key or custom ID
* @param {object} opts - Additional user opts
*/
show(id, opts = {}) {
let message = null;
if (typeof opts === "string") {
message = opts;
} else {
opts = opts || {};
}
const normalized_id = this._normalize_notice_key(id);
if (this.settings?.muted?.[normalized_id]) {
if (opts.confirm?.callback) {
opts.confirm.callback();
}
return;
}
const notice_entry = NOTICES2[id];
let derived = {
text: message || id,
timeout: opts.timeout ?? 5e3,
button: opts.button,
immutable: opts.immutable,
confirm: opts.confirm
};
if (notice_entry?.create) {
const result = notice_entry.create({ ...opts });
derived.text = message || result.text;
derived.timeout = result.timeout;
derived.button = result.button;
derived.immutable = result.immutable;
derived.confirm = result.confirm;
}
const content_fragment = this._build_fragment(normalized_id, derived.text, derived);
if (this.active[normalized_id]?.noticeEl?.isConnected) {
return this.active[normalized_id].setMessage(content_fragment, derived.timeout);
}
return this._render_notice(normalized_id, content_fragment, derived);
}
/**
* Normalizes the notice key to a safe string.
*/
_normalize_notice_key(key) {
return key.replace(/[^a-zA-Z0-9_-]/g, "_");
}
/**
* Creates and tracks the notice instance
*/
_render_notice(normalized_id, content_fragment, { timeout }) {
this.active[normalized_id] = new this.adapter(content_fragment, timeout);
return this.active[normalized_id];
}
/**
* Builds a DocumentFragment with notice text & possible buttons
*/
_build_fragment(id, text, { button, confirm: confirm2, immutable }) {
const frag = document.createDocumentFragment();
frag.createEl("p", {
cls: "sc-notice-head",
text: `[Smart Env v${this.env.constructor.version}]`
});
const content = frag.createEl("p", { cls: "sc-notice-content", text });
const actions = frag.createEl("div", { cls: "sc-notice-actions" });
if (confirm2?.text && typeof confirm2.callback === "function") {
this._add_button(confirm2, actions);
}
if (button?.text && typeof button.callback === "function") {
this._add_button(button, actions);
}
if (!immutable) {
this._add_mute_button(id, actions);
}
return frag;
}
/**
* Creates a <button> appended to the container
*/
_add_button(btnConfig, container) {
const btn = document.createElement("button");
this.env.smart_view.safe_inner_html(btn, btnConfig.text);
btn.addEventListener("click", (e) => {
if (btnConfig.stay_open) {
e.preventDefault();
e.stopPropagation();
}
btnConfig.callback?.(this.env);
});
container.appendChild(btn);
}
/**
* Mute button
*/
_add_mute_button(id, container) {
const btn = document.createElement("button");
(0, import_obsidian86.setIcon)(btn, "bell-off");
btn.addEventListener("click", () => {
if (!this.settings.muted) this.settings.muted = {};
this.settings.muted[id] = true;
if (NOTICES2["notice muted"]) {
this.show("notice muted", null, { timeout: 2e3 });
}
});
container.appendChild(btn);
}
/**
* Hides & clears all active notices
*/
unload() {
for (const id in this.active) {
this.remove(id);
}
}
/**
* Removes an active notice by key
*/
remove(id) {
const normalized_id = this._normalize_notice_key(id);
this.active[normalized_id]?.hide();
delete this.active[normalized_id];
}
};

var import_obsidian88 = require("obsidian");

var import_obsidian87 = require("obsidian");
function get_smart_server_url4() {
if (typeof window !== "undefined" && window.SMART_SERVER_URL_OVERRIDE) {
return window.SMART_SERVER_URL_OVERRIDE;
}
return "https://connect.smartconnections.app";
}
__name(get_smart_server_url4, "get_smart_server_url");

var CLIENT_ID2 = "smart-plugins-op";
var CLIENT_SECRET2 = "smart-plugins-op-secret";
function set_local_storage_token2({ access_token, refresh_token }, oauth_storage_prefix) {
localStorage.setItem(oauth_storage_prefix + "token", access_token);
if (refresh_token) {
localStorage.setItem(oauth_storage_prefix + "refresh", refresh_token);
}
}
__name(set_local_storage_token2, "set_local_storage_token");
async function exchange_code_for_tokens2(code, plugin) {
const oauth_storage_prefix = build_oauth_storage_prefix2(plugin.app.vault.getName());
const url = `${get_smart_server_url4()}/auth/oauth_exchange2`;
const resp = await (0, import_obsidian88.requestUrl)({
url,
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({
client_id: CLIENT_ID2,
client_secret: CLIENT_SECRET2,
code
})
});
if (resp.status !== 200) {
throw new Error(`OAuth exchange error ${resp.status} ${resp.text}`);
}
const { access_token, refresh_token } = resp.json;
if (!access_token) {
throw new Error("No access_token in response");
}
set_local_storage_token2({ access_token, refresh_token }, oauth_storage_prefix);
}
__name(exchange_code_for_tokens2, "exchange_code_for_tokens");
var OAUTH_SUFFIX2 = "_smart_plugins_oauth_";
function build_oauth_storage_prefix2(vault_name) {
const safe_name = String(vault_name || "").toLowerCase().replace(/[^a-z0-9]/g, "_");
return `${safe_name}${OAUTH_SUFFIX2}`;
}
__name(build_oauth_storage_prefix2, "build_oauth_storage_prefix");

function replace_folder_tree_var2(prompt) {
const env = this;
let paths = env.smart_sources?.fs?.folder_paths ?? [];
paths = paths.map((p) => p.endsWith("/") ? p : p + "/");
const tree = build_file_tree_string2([...new Set(paths)]);
return prompt.replace(/{{\s*folder_tree\s*}}/gi, tree);
}
__name(replace_folder_tree_var2, "replace_folder_tree_var");

function replace_folders_top_var2(prompt) {
const env = this;
let paths = env.smart_sources?.fs?.folder_paths ?? [];
paths = paths.map((p) => (p.split("/")[0] || "") + "/");
const tree = build_file_tree_string2([...new Set(paths)]);
return prompt.replace(/{{\s*folders_top\s*}}/gi, tree);
}
__name(replace_folders_top_var2, "replace_folders_top_var");

function replace_recent_n_var2(prompt) {
console.log("replace_recent_n_var", prompt);
const env = this;
return prompt.replace(/{{\s*recent_(\d+)\s*}}/gi, (_, count) => {
const n = parseInt(count, 10) || 0;
const files = Object.values(env.smart_sources?.fs?.files ?? {}).sort((a, b) => b.stat.mtime - a.stat.mtime).slice(0, n).map((f) => f.path).join("\n  - ");
console.log("replace_recent_n_var", n, files);
return files ? `
- ${files}` : "";
}).trim();
}
__name(replace_recent_n_var2, "replace_recent_n_var");

function replace_vault_tags_var2(prompt) {
const appRef = this.app;
const tags = appRef?.metadataCache?.getTags?.() || {};
const vault_tags = Object.keys(tags).map((tag) => tag.replace("#", "")).join("\n  - ");
return prompt.replace(/{{\s*(?:vault_tags|tags)\s*}}/gi, `
- ${vault_tags}
`).trim();
}
__name(replace_vault_tags_var2, "replace_vault_tags_var");

function register_completion_variable_adapter_replacements2(variable_adapter_class) {
variable_adapter_class.register(
(txt) => /{{\s*folder_tree\s*}}/i.test(txt),
replace_folder_tree_var2,
"{{ folder_tree }}"
);
variable_adapter_class.register(
(txt) => /{{\s*folders_top\s*}}/i.test(txt),
replace_folders_top_var2,
"{{ folders_top }}"
);
variable_adapter_class.register(
(txt) => /{{\s*(?:tags|vault_tags)\s*}}/i.test(txt),
replace_vault_tags_var2,
"{{ tags }}"
);
variable_adapter_class.register(
(txt) => /{{\s*recent_(\d+)\s*}}/i.test(txt),
replace_recent_n_var2,
"{{ recent_10 }}"
);
}
__name(register_completion_variable_adapter_replacements2, "register_completion_variable_adapter_replacements");

async function remove_smart_plugins_plugin2({ app, plugin_ids = [] } = {}) {
if (!app) return;
const adapter = app.vault?.adapter;
for (const plugin_id of plugin_ids) {
const disabled = await disable_plugin_if_present2(app.plugins, plugin_id);
if (disabled) console.warn(`Disabled legacy plugin: ${plugin_id}`);
const removed = await remove_plugin_folder2(adapter, plugin_id);
if (removed) console.warn(`Removed legacy plugin: ${plugin_id}`);
}
}
__name(remove_smart_plugins_plugin2, "remove_smart_plugins_plugin");
async function disable_plugin_if_present2(app_plugins, plugin_id) {
if (!app_plugins) return;
const has_plugin = Boolean(
app_plugins.plugins?.[plugin_id] || app_plugins.enabledPlugins?.has?.(plugin_id) || app_plugins.manifests && plugin_id in app_plugins.manifests
);
if (!has_plugin) return;
if (app_plugins.plugins?.[plugin_id]) {
await app_plugins.unloadPlugin?.(plugin_id);
}
if (app_plugins.disablePluginAndSave) {
await app_plugins.disablePluginAndSave(plugin_id);
}
if (app_plugins.enabledPlugins?.has?.(plugin_id)) {
app_plugins.enabledPlugins.delete(plugin_id);
}
if (app_plugins.manifests && plugin_id in app_plugins.manifests) {
delete app_plugins.manifests[plugin_id];
}
await app_plugins.loadManifests?.();
return true;
}
__name(disable_plugin_if_present2, "disable_plugin_if_present");
async function remove_plugin_folder2(adapter, plugin_id) {
if (!adapter?.exists) return;
const plugin_path = `.obsidian/plugins/${plugin_id}`;
const exists = await adapter.exists(plugin_path);
if (!exists) return;
if (adapter.rmdir) {
await adapter.rmdir(plugin_path, true);
return;
}
if (adapter.list && adapter.remove) {
const stack = [plugin_path];
while (stack.length) {
const current_path = stack.pop();
const listing = await adapter.list(current_path);
for (const file of listing?.files || []) {
await adapter.remove(`${current_path}/${file}`);
}
for (const folder of listing?.folders || []) {
stack.push(`${current_path}/${folder}`);
}
}
await adapter.remove(plugin_path);
return true;
}
}
__name(remove_plugin_folder2, "remove_plugin_folder");

var SmartEnv4 = class extends SmartEnv3 {
static {
__name(this, "SmartEnv");
}
/**
* Creates and initializes a SmartEnv instance tailored for Obsidian.
* @param {Object} plugin - The Obsidian plugin instance.
* @param {Object} [env_config] - Required environment configuration object.
* @returns {Promise<SmartEnv>} The initialized SmartEnv instance.
*/
static async create(plugin, env_config) {
if (!plugin) throw new Error("SmartEnv.create: 'plugin' parameter is required.");
if (!env_config) throw new Error("SmartEnv.create: 'env_config' parameter is required.");
env_config.version = this.version;
add_smart_chat_icon2();
add_smart_connections_icon2();
add_smart_lookup_icon2();
if (window.smart_env && !window.smart_env.constructor.version) {
const update_notice = "Detected ancient SmartEnv. Removing it to prevent issues with new plugins. Make sure your Smart Plugins are up-to-date!";
console.warn(update_notice);
new import_obsidian89.Notice(update_notice, 0);
window.smart_env = null;
}
const opts = merge_env_config2(env_config, default_config_default2);
opts.env_path = "";
return await super.create(plugin, opts);
}
async load(force_load = false) {
this.run_migrations();
if (!this.plugin.app.workspace.protocolHandlers.has("smart-plugins/callback")) {
this.plugin.registerObsidianProtocolHandler("smart-plugins/callback", async (params) => {
await this.handle_smart_plugins_oauth_callback(params);
});
}
if (import_obsidian89.Platform.isMobile && !force_load) {
const frag = this.smart_view.create_doc_fragment(`<div><p>Smart Environment loading deferred on mobile.</p><button>Load Environment</button></div>`);
frag.querySelector("button").addEventListener("click", this.load.bind(this, true));
new import_obsidian89.Notice(frag, 0);
return;
}
await super.load();
this.smart_sources?.register_source_watchers?.(this.smart_sources);
const plugin = this.main;
plugin.registerEvent(
plugin.app.workspace.on("active-leaf-change", (leaf) => {
this.smart_sources?.debounce_re_import_queue?.();
const current_path = leaf.view?.file?.path;
this.emit_source_opened(current_path, "active-leaf-change");
})
);
plugin.registerEvent(
plugin.app.workspace.on("file-open", (file) => {
this.smart_sources?.debounce_re_import_queue?.();
const current_path = file?.path;
this.emit_source_opened(current_path, "file-open");
})
);
if (this._config.collections.smart_completions?.completion_adapters?.SmartCompletionVariableAdapter) {
register_completion_variable_adapter_replacements2(this._config.collections.smart_completions.completion_adapters.SmartCompletionVariableAdapter);
}
const ContextModal3 = this._config.modals.context_selector.class;
ContextModal3.register_modal(this.main);
this.register_status_bar();
register_first_of_event_notifications2(this);
}
emit_source_opened(current_path, event_source = null) {
if (this._current_opened_source === current_path) return;
const current_source = this.smart_sources.get(current_path);
if (current_source) {
this._current_opened_source = current_path;
current_source.emit_event("sources:opened", { event_source });
}
}
queue_source_re_import(source) {
this.smart_sources?.queue_source_re_import?.(source);
}
debounce_re_import_queue() {
this.smart_sources?.debounce_re_import_queue?.();
}
async run_re_import() {
await this.smart_sources?.run_re_import?.();
}
register_status_bar() {
const status_container = this.main?.app?.statusBar?.containerEl;
status_container?.querySelector?.(".smart-env-status-container")?.closest?.(".status-bar-item")?.remove?.();
this.status_elm = this.main.addStatusBarItem();
this.smart_components?.render_component("status_bar", this).then((container) => {
this.status_elm.empty?.();
this.status_elm.appendChild(container);
});
}
/**
* @deprecated see events
*/
get notices() {
if (!this._notices) {
this._notices = new SmartNotices2(this, {
adapter: import_obsidian89.Notice
});
}
return this._notices;
}
/**
* This is the function that is called by the new "Sign in with Smart Plugins" button.
* @deprecated 2025-12-13 moved to components/pro-plugins/list.js
* It replicates the old 'initiate_oauth()' logic from sc_settings_tab.js
*/
initiate_smart_plugins_oauth() {
console.log("initiate_smart_plugins_oauth");
const state = Math.random().toString(36).slice(2);
const redirect_uri = encodeURIComponent("obsidian://smart-plugins/callback");
const url = `${get_smart_server_url4()}/oauth?client_id=smart-plugins-op&redirect_uri=${redirect_uri}&state=${state}`;
window.open(url, "_external");
return url;
}
/**
* Handles the OAuth callback from the Smart Plugins server.
* @param {Object} params - The URL parameters from the OAuth callback.
*/
async handle_smart_plugins_oauth_callback(params) {
const code = params.code;
if (!code) {
new import_obsidian89.Notice("No OAuth code provided in URL. Login failed.");
return;
}
try {
await exchange_code_for_tokens2(code, this.plugin);
this.events.emit("smart_plugins_oauth_completed");
} catch (err) {
console.error("OAuth callback error", err);
new import_obsidian89.Notice(`OAuth callback error: ${err.message}`);
}
}
/**
* Serializes the environment and, when in a browser, triggers a download.
* @param {string} [filename='smart_env.json']
* @returns {string} stringified JSON
*/
export_json(filename = "smart_env.json") {
const json = JSON.stringify(this.to_json(), null, 2);
if (typeof document !== "undefined") {
download_json2(json, filename);
}
return json;
}
async ready_to_load_collections() {
await new Promise((r) => setTimeout(r, 3e3));
await this.wait_for_obsidian_sync();
}
async wait_for_obsidian_sync() {
while (this.obsidian_is_syncing) {
console.log("Smart Connections: Waiting for Obsidian Sync to finish");
await new Promise((r) => setTimeout(r, 1e3));
if (!this.plugin) throw new Error("Plugin disabled while waiting for obsidian sync, reload required.");
}
}
get obsidian_is_syncing() {
const obsidian_sync_instance = this.plugin?.app?.internalPlugins?.plugins?.sync?.instance;
if (!obsidian_sync_instance) return false;
if (obsidian_sync_instance?.syncStatus.startsWith("Uploading")) return false;
if (obsidian_sync_instance?.syncStatus.startsWith("Fully synced")) return false;
return obsidian_sync_instance?.syncing;
}
get obsidian_app() {
return this.plugin?.app ?? window.app;
}
open_notifications_feed_modal() {
const NotificationsModalClass = this.config.modals.notifications_feed_modal.class;
const modal = new NotificationsModalClass(this.obsidian_app, this);
modal.open();
}
open_milestones_modal() {
const MilestonesModalClass = this.config.modals.milestones_modal.class;
const modal = new MilestonesModalClass(this.obsidian_app, this);
modal.open();
}
run_migrations() {
remove_smart_plugins_plugin2({ app: this.plugin.app, plugin_ids: ["smart-plugins"] });
remove_smart_plugins_plugin2({ app: this.plugin.app, plugin_ids: ["smart-editor"] });
remove_smart_plugins_plugin2({ app: this.plugin.app, plugin_ids: ["smart-sources"] });
remove_smart_plugins_plugin2({ app: this.plugin.app, plugin_ids: ["smart-claude"] });
remove_smart_plugins_plugin2({ app: this.plugin.app, plugin_ids: ["smart-gemini"] });
remove_smart_plugins_plugin2({ app: this.plugin.app, plugin_ids: ["smart-deepseek"] });
remove_smart_plugins_plugin2({ app: this.plugin.app, plugin_ids: ["smart-perplexity"] });
remove_smart_plugins_plugin2({ app: this.plugin.app, plugin_ids: ["smart-grok"] });
remove_smart_plugins_plugin2({ app: this.plugin.app, plugin_ids: ["smart-aistudio"] });
}
};
function download_json2(json, filename) {
const blob = new Blob([json], { type: "application/json" });
const url = URL.createObjectURL(blob);
const anchor = document.createElement("a");
anchor.href = url;
anchor.download = filename;
document.body.appendChild(anchor);
anchor.click();
document.body.removeChild(anchor);
URL.revokeObjectURL(url);
}
__name(download_json2, "download_json");

var import_obsidian91 = require("obsidian");

var import_obsidian90 = require("obsidian");

var import_obsidian92 = require("obsidian");

var SmartEmbedAdapter3 = class extends SmartModelAdapter2 {
static {
__name(this, "SmartEmbedAdapter");
}
/**
* @override in sub-class with adapter-specific default configurations
* @property {string} id - The adapter identifier
* @property {string} description - Human-readable description
* @property {string} type - Adapter type ("API")
* @property {string} endpoint - API endpoint
* @property {string} adapter - Adapter identifier
* @property {string} default_model - Default model to use
*/
static defaults = {};
/**
* Count tokens in input text
* @abstract
* @param {string} input - Text to tokenize
* @returns {Promise<Object>} Token count result
* @property {number} tokens - Number of tokens in input
* @throws {Error} If not implemented by subclass
*/
async count_tokens(input) {
throw new Error("count_tokens method not implemented");
}
/**
* Generate embeddings for single input
* @abstract
* @param {string|Object} input - Text to embed
* @returns {Promise<Object>} Embedding result
* @property {number[]} vec - Embedding vector
* @property {number} tokens - Number of tokens in input
* @throws {Error} If not implemented by subclass
*/
async embed(input) {
if (typeof input === "string") input = { embed_input: input };
return (await this.embed_batch([input]))[0];
}
/**
* Generate embeddings for multiple inputs
* @abstract
* @param {Array<string|Object>} inputs - Texts to embed
* @returns {Promise<Array<Object>>} Array of embedding results
* @property {number[]} vec - Embedding vector for each input
* @property {number} tokens - Number of tokens in each input
* @throws {Error} If not implemented by subclass
*/
async embed_batch(inputs) {
throw new Error("embed_batch method not implemented");
}
get settings_config() {
return {
"[ADAPTER].model_key": {
name: "Embedding model",
type: "dropdown",
description: "Select an embedding model.",
options_callback: "adapter.get_models_as_options",
callback: "model_changed",
default: this.constructor.defaults.default_model
}
};
}
get dims() {
return this.model.data.dims;
}
get max_tokens() {
return this.model.data.max_tokens;
}
get batch_size() {
return this.model.data.batch_size || 1;
}
};

var import_base64_js3 = __toESM(require_base64_js3(), 1);
var __defProp4 = Object.defineProperty;
var __defNormalProp3 = /* @__PURE__ */ __name((obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value, "__defNormalProp");
var __publicField3 = /* @__PURE__ */ __name((obj, key, value) => {
__defNormalProp3(obj, typeof key !== "symbol" ? key + "" : key, value);
return value;
}, "__publicField");
function bytePairMerge3(piece, ranks) {
let parts = Array.from(
{ length: piece.length },
(_, i) => ({ start: i, end: i + 1 })
);
while (parts.length > 1) {
let minRank = null;
for (let i = 0; i < parts.length - 1; i++) {
const slice = piece.slice(parts[i].start, parts[i + 1].end);
const rank = ranks.get(slice.join(","));
if (rank == null)
continue;
if (minRank == null || rank < minRank[0]) {
minRank = [rank, i];
}
}
if (minRank != null) {
const i = minRank[1];
parts[i] = { start: parts[i].start, end: parts[i + 1].end };
parts.splice(i + 1, 1);
} else {
break;
}
}
return parts;
}
__name(bytePairMerge3, "bytePairMerge");
function bytePairEncode3(piece, ranks) {
if (piece.length === 1)
return [ranks.get(piece.join(","))];
return bytePairMerge3(piece, ranks).map((p) => ranks.get(piece.slice(p.start, p.end).join(","))).filter((x) => x != null);
}
__name(bytePairEncode3, "bytePairEncode");
function escapeRegex3(str) {
return str.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
}
__name(escapeRegex3, "escapeRegex");
var _Tiktoken3 = class {
static {
__name(this, "_Tiktoken");
}
/** @internal */
specialTokens;
/** @internal */
inverseSpecialTokens;
/** @internal */
patStr;
/** @internal */
textEncoder = new TextEncoder();
/** @internal */
textDecoder = new TextDecoder("utf-8");
/** @internal */
rankMap = /* @__PURE__ */ new Map();
/** @internal */
textMap = /* @__PURE__ */ new Map();
constructor(ranks, extendedSpecialTokens) {
this.patStr = ranks.pat_str;
const uncompressed = ranks.bpe_ranks.split("\n").filter(Boolean).reduce((memo, x) => {
const [_, offsetStr, ...tokens] = x.split(" ");
const offset = Number.parseInt(offsetStr, 10);
tokens.forEach((token, i) => memo[token] = offset + i);
return memo;
}, {});
for (const [token, rank] of Object.entries(uncompressed)) {
const bytes = import_base64_js3.default.toByteArray(token);
this.rankMap.set(bytes.join(","), rank);
this.textMap.set(rank, bytes);
}
this.specialTokens = { ...ranks.special_tokens, ...extendedSpecialTokens };
this.inverseSpecialTokens = Object.entries(this.specialTokens).reduce((memo, [text, rank]) => {
memo[rank] = this.textEncoder.encode(text);
return memo;
}, {});
}
encode(text, allowedSpecial = [], disallowedSpecial = "all") {
const regexes = new RegExp(this.patStr, "ug");
const specialRegex = _Tiktoken3.specialTokenRegex(
Object.keys(this.specialTokens)
);
const ret = [];
const allowedSpecialSet = new Set(
allowedSpecial === "all" ? Object.keys(this.specialTokens) : allowedSpecial
);
const disallowedSpecialSet = new Set(
disallowedSpecial === "all" ? Object.keys(this.specialTokens).filter(
(x) => !allowedSpecialSet.has(x)
) : disallowedSpecial
);
if (disallowedSpecialSet.size > 0) {
const disallowedSpecialRegex = _Tiktoken3.specialTokenRegex([
...disallowedSpecialSet
]);
const specialMatch = text.match(disallowedSpecialRegex);
if (specialMatch != null) {
throw new Error(
`The text contains a special token that is not allowed: ${specialMatch[0]}`
);
}
}
let start = 0;
while (true) {
let nextSpecial = null;
let startFind = start;
while (true) {
specialRegex.lastIndex = startFind;
nextSpecial = specialRegex.exec(text);
if (nextSpecial == null || allowedSpecialSet.has(nextSpecial[0]))
break;
startFind = nextSpecial.index + 1;
}
const end = nextSpecial?.index ?? text.length;
for (const match of text.substring(start, end).matchAll(regexes)) {
const piece = this.textEncoder.encode(match[0]);
const token2 = this.rankMap.get(piece.join(","));
if (token2 != null) {
ret.push(token2);
continue;
}
ret.push(...bytePairEncode3(piece, this.rankMap));
}
if (nextSpecial == null)
break;
let token = this.specialTokens[nextSpecial[0]];
ret.push(token);
start = nextSpecial.index + nextSpecial[0].length;
}
return ret;
}
decode(tokens) {
const res = [];
let length = 0;
for (let i2 = 0; i2 < tokens.length; ++i2) {
const token = tokens[i2];
const bytes = this.textMap.get(token) ?? this.inverseSpecialTokens[token];
if (bytes != null) {
res.push(bytes);
length += bytes.length;
}
}
const mergedArray = new Uint8Array(length);
let i = 0;
for (const bytes of res) {
mergedArray.set(bytes, i);
i += bytes.length;
}
return this.textDecoder.decode(mergedArray);
}
};
var Tiktoken3 = _Tiktoken3;
__publicField3(Tiktoken3, "specialTokenRegex", (tokens) => {
return new RegExp(tokens.map((i) => escapeRegex3(i)).join("|"), "g");
});

async function fetch_json_cached3(url, cache_key = url) {
const is_browser = typeof window !== "undefined" && typeof window.document !== "undefined";
if (is_browser) {
const cached_text = window.localStorage.getItem(cache_key);
if (cached_text) return JSON.parse(cached_text);
const remote2 = await do_fetch3(url);
window.localStorage.setItem(cache_key, JSON.stringify(remote2));
return remote2;
}
const fs = await import("node:fs/promises");
const path = await import("node:path");
const os = await import("node:os");
const cache_dir = path.join(os.homedir(), ".cache", "smart-embed-model");
const cache_file = path.join(cache_dir, cache_key);
try {
const txt = await fs.readFile(cache_file, "utf8");
return JSON.parse(txt);
} catch {
}
const remote = await do_fetch3(url);
await fs.mkdir(cache_dir, { recursive: true });
await fs.writeFile(cache_file, JSON.stringify(remote), "utf8");
return remote;
}
__name(fetch_json_cached3, "fetch_json_cached");
async function do_fetch3(url) {
const resp = await fetch(url);
if (!resp.ok) throw new Error(`failed to download ${url} \u2013 ${resp.status}`);
return await resp.json();
}
__name(do_fetch3, "do_fetch");

var CL100K_URL3 = "https://raw.githubusercontent.com/brianpetro/jsbrains/refs/heads/main/smart-embed-model/cl100k_base.json";
var SmartEmbedModelApiAdapter3 = class extends SmartEmbedAdapter3 {
static {
__name(this, "SmartEmbedModelApiAdapter");
}
/**
* Get the request adapter class.
* @returns {SmartEmbedModelRequestAdapter} The request adapter class
*/
get req_adapter() {
return SmartEmbedModelRequestAdapter3;
}
/**
* Get the response adapter class.
* @returns {SmartEmbedModelResponseAdapter} The response adapter class
*/
get res_adapter() {
return SmartEmbedModelResponseAdapter3;
}
/** @returns {string} API endpoint URL */
get endpoint() {
return this.model.data.endpoint;
}
/**
* Get HTTP request adapter instance
* @returns {SmartHttpRequest} HTTP request handler
*/
get http_adapter() {
if (!this._http_adapter) {
if (this.model.opts.http_adapter)
this._http_adapter = this.model.opts.http_adapter;
else
this._http_adapter = new SmartHttpRequest2({
adapter: SmartHttpRequestFetchAdapter2
});
}
return this._http_adapter;
}
/**
* Get API key for authentication
* @returns {string} API key
*/
get api_key() {
return this.model.data.api_key;
}
/**
* Count tokens in input text
* @abstract
* @param {string} input - Text to tokenize
* @returns {Promise<Object>} Token count result
* @throws {Error} If not implemented by subclass
*/
async count_tokens(input) {
throw new Error("count_tokens not implemented");
}
/**
* Estimate token count for input text
* Uses character-based estimation (3.7 chars per token)
* @param {string|Object} input - Input to estimate tokens for
* @returns {number} Estimated token count
*/
estimate_tokens(input) {
if (typeof input === "object") input = JSON.stringify(input);
return Math.ceil(input.length / 3.7);
}
/**
* Process a batch of inputs for embedding
* @param {Array<Object>} inputs - Array of input objects
* @returns {Promise<Array<Object>>} Processed inputs with embeddings
* @throws {Error} If API key is not set
*/
async embed_batch(inputs) {
if (!this.api_key) throw new Error("API key not set");
inputs = inputs.filter((item) => item.embed_input?.length > 0);
if (inputs.length === 0) {
console.log("Empty batch (or all items have empty embed_input)");
return [];
}
const embed_inputs = await Promise.all(
inputs.map((item) => this.prepare_embed_input(item.embed_input))
);
const _req = new this.req_adapter(this, embed_inputs);
const request_params = _req.to_platform();
const resp = await this.request(request_params);
if (!resp) {
console.error("No response received for embedding request.");
return [];
}
if (resp.error) return [resp];
const _res = new this.res_adapter(this, resp);
const embeddings = _res.to_openai();
if (!embeddings) {
console.error("Failed to parse embeddings.");
return [];
}
return inputs.map((item, i) => {
item.vec = embeddings[i].vec;
item.tokens = embeddings[i].tokens;
return item;
});
}
/**
* Prepare input text for embedding
* @abstract
* @param {string} embed_input - Raw input text
* @returns {Promise<string>} Processed input text
* @throws {Error} If not implemented by subclass
*/
async prepare_embed_input(embed_input) {
throw new Error("prepare_embed_input not implemented");
}
/**
* Prepare request headers
* @returns {Object} Headers object with authorization
*/
prepare_request_headers() {
let headers = {
"Content-Type": "application/json"
};
if (this.api_key) {
headers["Authorization"] = `Bearer ${this.api_key}`;
}
return headers;
}
/**
* Make API request with retry logic
* @param {Object} req - Request configuration
* @param {number} [retries=0] - Number of retries attempted
* @returns {Promise<Object>} API response
*/
async request(req, retries = 0) {
try {
req.throw = false;
const resp = await this.http_adapter.request({
url: this.endpoint,
...req
});
const resp_json = await this.get_resp_json(resp);
if (resp_json.error) {
return { error: normalize_error2(resp_json, resp.status()) };
}
return resp_json;
} catch (error) {
console.warn("Request error:", error);
return await this.handle_request_err(error, req, retries);
}
}
/**
* Handle API request errors with retry logic
* @param {Error|Object} error - Error object
* @param {Object} req - Original request
* @param {number} retries - Number of retries attempted
* @returns {Promise<Object|null>} Retry response or null
*/
async handle_request_err(error, req, retries) {
if (error.status === 429 && retries < 3) {
const backoff = Math.pow(retries + 1, 2);
console.log(`Retrying request (429) in ${backoff} seconds...`);
await new Promise((r) => setTimeout(r, 1e3 * backoff));
return await this.request(req, retries + 1);
}
console.error(error);
return null;
}
/**
* Parse response body as JSON
* @param {Response} resp - Response object
* @returns {Promise<Object>} Parsed JSON
*/
async get_resp_json(resp) {
return typeof resp.json === "function" ? await resp.json() : await resp.json;
}
/**
* Validate API key by making test request
* @returns {Promise<boolean>} True if API key is valid
*/
async validate_api_key() {
const resp = await this.embed_batch([{ embed_input: "test" }]);
return Array.isArray(resp) && resp.length > 0 && resp[0].vec !== null;
}
/**
* Trim input text to satisfy `max_tokens`.
* @param {string} embed_input - Input text
* @param {number} tokens_ct - Existing token count
* @returns {Promise<string|null>} Trimmed text
*/
async trim_input_to_max_tokens(embed_input, tokens_ct) {
const reduce_ratio = (tokens_ct - this.max_tokens) / tokens_ct;
const new_length = Math.floor(embed_input.length * (1 - reduce_ratio));
let trimmed_input = embed_input.slice(0, new_length);
const last_space_index = trimmed_input.lastIndexOf(" ");
if (last_space_index > 0) trimmed_input = trimmed_input.slice(0, last_space_index);
const prepared = await this.prepare_embed_input(trimmed_input);
if (prepared === null) return null;
return prepared;
}
async load_tiktoken() {
const cl100k_base = await fetch_json_cached3(CL100K_URL3, "cl100k_base.json");
this.tiktoken = new Tiktoken3(cl100k_base);
}
};
var SmartEmbedModelRequestAdapter3 = class {
static {
__name(this, "SmartEmbedModelRequestAdapter");
}
/**
* @constructor
* @param {SmartEmbedModelApiAdapter} adapter - The SmartEmbedModelApiAdapter instance
* @param {Array<string>} embed_inputs - The array of input texts
*/
constructor(adapter, embed_inputs) {
this.adapter = adapter;
this.embed_inputs = embed_inputs;
}
get model_id() {
return this.adapter.model.data.model_key;
}
get model_dims() {
return this.adapter.model.data.dims;
}
/**
* Get request headers
* @returns {Object} Headers object
*/
get_headers() {
return this.adapter.prepare_request_headers();
}
/**
* Convert request to platform-specific format
* @returns {Object} Platform-specific request parameters
*/
to_platform() {
return {
method: "POST",
headers: this.get_headers(),
body: JSON.stringify(this.prepare_request_body())
};
}
/**
* Prepare request body for API call
* @abstract
* @returns {Object} Request body object
* @throws {Error} If not implemented by subclass
*/
prepare_request_body() {
throw new Error("prepare_request_body not implemented");
}
};
var SmartEmbedModelResponseAdapter3 = class {
static {
__name(this, "SmartEmbedModelResponseAdapter");
}
/**
* @constructor
* @param {SmartEmbedModelApiAdapter} adapter - The SmartEmbedModelApiAdapter instance
* @param {Object} response - The response object
*/
constructor(adapter, response) {
this.adapter = adapter;
this.response = response;
}
/**
* Convert response to standard format
* @returns {Array<Object>} Array of embedding results
*/
to_openai() {
return this.parse_response();
}
/**
* Parse API response
* @abstract
* @returns {Array<Object>} Parsed embedding results
* @throws {Error} If not implemented by subclass
*/
parse_response() {
throw new Error("parse_response not implemented");
}
};

var GeminiEmbedModelAdapter3 = class extends SmartEmbedModelApiAdapter3 {
static {
__name(this, "GeminiEmbedModelAdapter");
}
static defaults = {
adapter: "gemini",
description: "Google Gemini (API)",
default_model: "gemini-embedding-001",
endpoint: "https://generativelanguage.googleapis.com/v1beta/models/gemini-embedding-001:batchEmbedContents",
dims: 768,
max_tokens: 2048,
batch_size: 50
};
/**
* Count tokens in input text using tokenizer
* @param {string} input - Text to tokenize
* @returns {Promise<Object>} Token count result
*/
async count_tokens(input) {
if (!this.tiktoken) await this.load_tiktoken();
return { tokens: this.tiktoken.encode(input).length };
}
/**
* Prepare input text for embedding
* Handles token limit truncation
* @param {string} embed_input - Raw input text
* @returns {Promise<string|null>} Processed input text
*/
async prepare_embed_input(embed_input) {
if (typeof embed_input !== "string") {
throw new TypeError("embed_input must be a string");
}
if (embed_input.length === 0) {
console.log("Warning: prepare_embed_input received an empty string");
return null;
}
const { tokens } = await this.count_tokens(embed_input);
if (tokens <= this.max_tokens) {
return embed_input;
}
return await this.trim_input_to_max_tokens(embed_input, tokens);
}
/**
* Trim input text to fit token limit
* @private
* @param {string} embed_input - Input text to trim
* @param {number} tokens_ct - Current token count
* @returns {Promise<string|null>} Trimmed input text
*/
async trim_input_to_max_tokens(embed_input, tokens_ct) {
const reduce_ratio = (tokens_ct - this.max_tokens) / tokens_ct;
const new_length = Math.floor(embed_input.length * (1 - reduce_ratio));
let trimmed_input = embed_input.slice(0, new_length);
const last_space_index = trimmed_input.lastIndexOf(" ");
if (last_space_index > 0) {
trimmed_input = trimmed_input.slice(0, last_space_index);
}
const prepared_input = await this.prepare_embed_input(trimmed_input);
if (prepared_input === null) {
console.log(
"Warning: prepare_embed_input resulted in an empty string after trimming"
);
return null;
}
return prepared_input;
}
/**
* Get the request adapter class.
* @returns {SmartEmbedGeminiRequestAdapter} The request adapter class
*/
get req_adapter() {
return SmartEmbedGeminiRequestAdapter3;
}
/**
* Get the response adapter class.
* @returns {SmartEmbedGeminiResponseAdapter} The response adapter class
*/
get res_adapter() {
return SmartEmbedGeminiResponseAdapter3;
}
/** @returns {Object} Settings configuration for Gemini adapter */
get settings_config() {
return {
...super.settings_config,
"[ADAPTER].api_key": {
name: "Google API Key for Gemini embeddings",
type: "password",
description: "Required for Gemini embedding models",
placeholder: "Enter Google API Key"
}
};
}
/**
* Get available models (hardcoded list)
* @returns {Promise<Object>} Map of model objects
*/
get_models() {
return Promise.resolve(this.models);
}
get models() {
return {
"gemini-embedding-001": {
"id": "gemini-embedding-001",
"batch_size": 50,
"dims": 768,
"max_tokens": 2048,
"name": "Gemini Embedding",
"description": "API, 2,048 tokens, 768 dim",
"endpoint": "https://generativelanguage.googleapis.com/v1beta/models/gemini-embedding-001:batchEmbedContents",
"adapter": "gemini"
}
};
}
prepare_request_headers() {
return {
"Content-Type": "application/json",
"x-goog-api-key": this.api_key
};
}
backoff_wait_time = 5e3;
backoff_factor = 1;
async embed_batch(inputs, retries = 0) {
if (smart_env.smart_sources.entities_vector_adapter.is_queue_halted) {
throw new Error("Embedding queue halted during backoff wait due to rate limit errors.");
}
const token_cts = inputs.map((item) => this.estimate_tokens(item.embed_input));
const resp = await super.embed_batch(inputs);
if (resp[0].error && resp[0].error.details && resp[0].error.details.code === 429) {
console.warn("Rate limit error detected in Gemini embed_batch response.", resp);
if (retries > 3) {
console.error("Max retries reached for rate limit errors.");
throw new Error("Max retries reached for rate limit errors.");
}
console.warn(resp[0].error.message);
const retry_detail = resp[0].error.details?.details?.find((d) => d.retryDelay);
if (retry_detail.retryDelay) {
const wait_time_ms = parseInt(retry_detail.retryDelay) * 1e3 * 2;
console.warn(`Using server-specified retry delay of ${wait_time_ms} ms`);
await new Promise((resolve) => setTimeout(resolve, wait_time_ms));
return await this.embed_batch(inputs, retries + 1);
} else {
this.backoff_factor += 1;
console.warn(`Rate limit exceeded, backing off for ${this.backoff_wait_time * this.backoff_factor} ms`);
await new Promise((resolve) => setTimeout(resolve, this.backoff_wait_time * this.backoff_factor));
return await this.embed_batch(inputs, retries + 1);
}
} else if (resp[0].error) {
console.error("Error in Gemini embed_batch response:", resp[0].error);
throw new Error(`Gemini embed_batch error: ${resp[0].error.message}`);
}
resp.forEach((item, idx) => {
item.tokens = token_cts[idx];
});
console.log("Gemini embed_batch response:", resp);
return resp;
}
};
var SmartEmbedGeminiRequestAdapter3 = class extends SmartEmbedModelRequestAdapter3 {
static {
__name(this, "SmartEmbedGeminiRequestAdapter");
}
get model_id() {
let model_id = this.adapter.model.data.model_key;
return `models/${model_id}`;
}
/**
* Prepare request body for Gemini API
* @returns {Object} Request body for API
*/
prepare_request_body() {
const requests = this.embed_inputs.map((input) => {
const [title, ...content] = input.split("\n");
const doc_content = content.join("\n").trim() || "";
if (doc_content.length) {
return {
model: this.model_id,
content: {
parts: [{ text: doc_content }]
},
outputDimensionality: this.model_dims,
taskType: "RETRIEVAL_DOCUMENT",
title
};
} else {
return {
model: this.model_id,
content: {
parts: [{ text: title }]
},
outputDimensionality: this.model_dims,
taskType: "RETRIEVAL_DOCUMENT"
};
}
});
return {
requests
};
}
};
var SmartEmbedGeminiResponseAdapter3 = class extends SmartEmbedModelResponseAdapter3 {
static {
__name(this, "SmartEmbedGeminiResponseAdapter");
}
/**
* Parse Gemini API response
* @returns {Array<Object>} Parsed embedding results
*/
parse_response() {
const resp = this.response;
console.log("Gemini response:", resp);
if (!resp || !resp.embeddings || !resp.embeddings[0].values) {
console.error("Invalid Gemini embedding response format", resp);
return [];
}
return resp.embeddings.map((embedding, i) => {
if (!embedding.values || embedding.values.length === 0) {
console.warn(`No values for embedding at index ${i}`);
return { vec: [], tokens: 0 };
}
return {
vec: embedding.values,
tokens: null
};
});
}
};

var GoogleGeminiEmbeddingModelAdapter = class extends GeminiEmbedModelAdapter3 {
static {
__name(this, "GoogleGeminiEmbeddingModelAdapter");
}
constructor(model_item) {
super(model_item);
}
get http_adapter() {
if (!this._http_adapter) {
const HttpClass = this.model.env.config.modules.http_adapter.class;
const http_params = { ...this.model.env.config.modules.http_adapter, class: void 0 };
this._http_adapter = new HttpClass(http_params);
}
return this._http_adapter;
}
};
var settings_config27 = {
api_key: {
name: "API Key",
type: "password",
description: "Enter your Google Gemini API key."
},
"gemini_note": {
name: "Note about using Gemini Embeddings API",
type: "html",
value: `<p class="model-note"><b>WARNING: Gemini rate-limiting:</b> Google imposes strict rate limits on the Gemini Embeddings API. Smart Environment will attempt to retry. Retry details can be found in the developer console logs. Consistent rate limit errors may prevent all items from being properly embedded. Restarting Obsidian will attempt to re-embed any failed items. If you continue to experience issues, try disabling blocks to reduce the number of embeddings required by your Smart Environment.</p>`
}
};
var google_default = {
class: GoogleGeminiEmbeddingModelAdapter,
settings_config: settings_config27
};

function parse_lm_studio_models3(list, adapter_key = "lm_studio") {
if (list.object !== "list" || !Array.isArray(list.data)) {
return { _: { id: "No models found." } };
}
console.log("LM Studio models", list);
return list.data.filter((m) => m.id && m.type === "embeddings").reduce((acc, m) => {
acc[m.id] = {
id: m.id,
model_name: m.id,
max_tokens: m.loaded_context_length || 512,
description: `LM Studio model: ${m.id}`,
adapter: adapter_key
};
return acc;
}, {});
}
__name(parse_lm_studio_models3, "parse_lm_studio_models");
var LmStudioEmbedModelAdapter3 = class extends SmartEmbedModelApiAdapter3 {
static {
__name(this, "LmStudioEmbedModelAdapter");
}
static key = "lm_studio";
static defaults = {
description: "LM Studio",
type: "API",
host: "http://localhost:1234",
endpoint: "/api/v0/embeddings",
models_endpoint: "/api/v0/models",
default_model: "",
streaming: false,
api_key: "na",
batch_size: 10,
max_tokens: 512
};
get req_adapter() {
return LmStudioEmbedModelRequestAdapter3;
}
get res_adapter() {
return LmStudioEmbedModelResponseAdapter3;
}
get host() {
return this.model.data.host || this.constructor.defaults.host;
}
get endpoint() {
return `${this.host}${this.constructor.defaults.endpoint}`;
}
get models_endpoint() {
return `${this.host}${this.constructor.defaults.models_endpoint}`;
}
get settings_config() {
const cfg = { ...super.settings_config };
delete cfg["[ADAPTER].api_key"];
cfg["[ADAPTER].refresh_models"] = {
name: "Refresh Models",
type: "button",
description: "Refresh the list of available models.",
callback: "adapter.refresh_models"
};
cfg["[ADAPTER].current_model"] = {
type: "html",
value: `<p>Embedding Model Max Tokens: ${this.max_tokens} (may be configured in LM Studio)</p>`
};
cfg["[ADAPTER].batch_size"] = {
name: "Embedding Batch Size",
type: "number",
description: "Number of embeddings to process in parallel. Adjusting this may improve performance.",
value: this.batch_size,
default: this.constructor.defaults.batch_size
};
cfg["[ADAPTER].cors_note"] = {
name: "CORS required",
type: "html",
value: `<p>Before you can use LM Studio you must <strong>Enable CORS</strong> inside LM Studio \u2192 Developer \u2192 Settings</p>`
};
return cfg;
}
async get_models(refresh = false) {
if (!refresh && this.model.data.provider_models) return this.model.data.provider_models;
const resp = await this.http_adapter.request({
url: this.models_endpoint,
method: "GET"
});
const raw = await resp.json();
const parsed = this.parse_model_data(raw);
this.model.data.provider_models = parsed;
this.model.re_render_settings();
return parsed;
}
parse_model_data(list) {
return parse_lm_studio_models3(list, this.constructor.key);
}
async count_tokens(input) {
return { tokens: this.estimate_tokens(input) };
}
/**
* Prepare input text and ensure it fits within `max_tokens`.
* @param {string} embed_input - Raw input text
* @returns {Promise<string|null>} Processed input text
*/
async prepare_embed_input(embed_input) {
if (typeof embed_input !== "string") throw new TypeError("embed_input must be a string");
if (embed_input.length === 0) return null;
const { tokens } = await this.count_tokens(embed_input);
if (tokens <= this.max_tokens) return embed_input;
return await this.trim_input_to_max_tokens(embed_input, tokens);
}
/**
* Refresh available models.
*/
refresh_models() {
console.log("refresh_models");
this.get_models(true);
}
async embed_batch(inputs) {
const token_cts = inputs.map((item) => this.estimate_tokens(item.embed_input));
const resp = await super.embed_batch(inputs);
resp.forEach((item, idx) => {
item.tokens = token_cts[idx];
});
return resp;
}
};
var LmStudioEmbedModelRequestAdapter3 = class extends SmartEmbedModelRequestAdapter3 {
static {
__name(this, "LmStudioEmbedModelRequestAdapter");
}
/**
* Prepare request body for LM Studio API
* @returns {Object} Request body for API
*/
prepare_request_body() {
const body = {
model: this.model_id,
input: this.embed_inputs
};
return body;
}
};
var LmStudioEmbedModelResponseAdapter3 = class extends SmartEmbedModelResponseAdapter3 {
static {
__name(this, "LmStudioEmbedModelResponseAdapter");
}
/**
* Parse LM Studio API response
* @returns {Array<Object>} Parsed embedding results
*/
parse_response() {
const resp = this.response;
if (!resp || !resp.data) {
console.error("Invalid response format", resp);
return [];
}
return resp.data.map((item) => ({
vec: item.embedding,
tokens: null
}));
}
};

var LmStudioEmbeddingModelAdapter = class extends LmStudioEmbedModelAdapter3 {
static {
__name(this, "LmStudioEmbeddingModelAdapter");
}
constructor(model_item) {
super(model_item);
}
get http_adapter() {
if (!this._http_adapter) {
const HttpClass = this.model.env.config.modules.http_adapter.class;
const http_params = { ...this.model.env.config.modules.http_adapter, class: void 0 };
this._http_adapter = new HttpClass(http_params);
}
return this._http_adapter;
}
};
var lm_studio_default = {
class: LmStudioEmbeddingModelAdapter
};

var SmartEmbedOllamaAdapter3 = class extends SmartEmbedModelApiAdapter3 {
static {
__name(this, "SmartEmbedOllamaAdapter");
}
static defaults = {
description: "Ollama (Local)",
type: "API",
host: "http://localhost:11434",
endpoint: "/api/embed",
models_endpoint: "/api/tags",
api_key: "na",
streaming: false,
max_tokens: 512,
signup_url: null,
batch_size: 30,
models: {}
};
get host() {
return this.model.data.host || this.constructor.defaults.host;
}
get endpoint() {
return `${this.host}${this.constructor.defaults.endpoint}`;
}
get models_endpoint() {
return `${this.host}${this.constructor.defaults.models_endpoint}`;
}
get model_show_endpoint() {
return `${this.host}/api/show`;
}
async load() {
await this.get_models();
await super.load();
}
/**
* Estimate token count for input text.
* Ollama does not expose a tokenizer so we use a character based heuristic.
* @param {string} input - Text to tokenize
* @returns {Promise<Object>} Token count result
*/
async count_tokens(input) {
return { tokens: this.estimate_tokens(input) };
}
/**
* Prepare input text and ensure it fits within `max_tokens`.
* @param {string} embed_input - Raw input text
* @returns {Promise<string|null>} Processed input text
*/
async prepare_embed_input(embed_input) {
if (typeof embed_input !== "string") throw new TypeError("embed_input must be a string");
if (embed_input.length === 0) return null;
const { tokens } = await this.count_tokens(embed_input);
if (tokens <= this.max_tokens) return embed_input;
return await this.trim_input_to_max_tokens(embed_input, tokens);
}
/**
* Trim input text to satisfy `max_tokens`.
* @private
* @param {string} embed_input - Input text
* @param {number} tokens_ct - Existing token count
* @returns {Promise<string|null>} Trimmed text
*/
async trim_input_to_max_tokens(embed_input, tokens_ct) {
const reduce_ratio = (tokens_ct - this.max_tokens) / tokens_ct;
const new_length = Math.floor(embed_input.length * (1 - reduce_ratio));
let trimmed_input = embed_input.slice(0, new_length);
const last_space_index = trimmed_input.lastIndexOf(" ");
if (last_space_index > 0) trimmed_input = trimmed_input.slice(0, last_space_index);
const prepared = await this.prepare_embed_input(trimmed_input);
if (prepared === null) return null;
return prepared;
}
/** @returns {number} Maximum tokens for an input */
get max_tokens() {
return this.model.data.max_tokens || this.constructor.defaults.max_tokens;
}
/**
* Get the request adapter class.
* @returns {SmartEmbedModelOllamaRequestAdapter} The request adapter class
*/
get req_adapter() {
return SmartEmbedModelOllamaRequestAdapter3;
}
/**
* Get the response adapter class.
* @returns {SmartEmbedModelOllamaResponseAdapter} The response adapter class
*/
get res_adapter() {
return SmartEmbedModelOllamaResponseAdapter3;
}
/**
* Get available models from local Ollama instance.
* @param {boolean} [refresh=false] - Whether to refresh cached models
* @returns {Promise<Object>} Map of model objects
*/
async get_models(refresh = false) {
if (!this.model_data || refresh) {
const list_resp = await this.http_adapter.request({
url: this.models_endpoint,
method: "GET"
});
if (list_resp.ok === false) {
throw new Error(`Failed to fetch models list: ${list_resp.statusText}`);
}
const list_data = await list_resp.json();
const models_raw = [];
for (const m of filter_embedding_models3(list_data.models || [])) {
const detail_resp = await this.http_adapter.request({
url: this.model_show_endpoint,
method: "POST",
body: JSON.stringify({ model: m.name })
});
models_raw.push({ ...await detail_resp.json(), name: m.name });
}
const model_data = this.parse_model_data(models_raw);
this.model_data = model_data;
if (typeof this.model.re_render_settings === "function") {
this.model.re_render_settings();
}
return model_data;
}
return this.model_data;
}
/**
* Get available models as dropdown options synchronously.
* @returns {Array<Object>} Array of model options.
*/
get_models_as_options() {
const models = this.model_data;
if (!Object.keys(models || {}).length) {
this.get_models(true);
return [{ value: "", name: "No models currently available" }];
}
return Object.values(models).map((model) => ({ value: model.id, name: model.name || model.id })).sort((a, b) => a.name.localeCompare(b.name));
}
/**
* Parse model data from Ollama API response.
* @param {Object} model_data - Raw model data from Ollama
* @returns {Object} Map of model objects with capabilities and limits
*/
parse_model_data(model_data) {
if (!Array.isArray(model_data)) {
this.model_data = {};
console.error("Invalid model data format from Ollama:", model_data);
return {};
}
if (model_data.length === 0) {
this.model_data = { "no_models_available": {
id: "no_models_available",
name: "No models currently available"
} };
return this.model_data;
}
this.model_data = model_data.reduce((acc, model) => {
const info = model.model_info || {};
const ctx = Object.entries(info).find(([k]) => k.includes("context_length"))?.[1];
const dims = Object.entries(info).find(([k]) => k.includes("embedding_length"))?.[1];
acc[model.name] = {
model_name: model.name,
id: model.name,
multimodal: false,
max_tokens: ctx || this.max_tokens,
dims,
description: model.description || `Model: ${model.name}`
};
return acc;
}, {});
this._models = this.model_data;
return this.model_data;
}
/**
* Get the models.
* @returns {Object} Map of model objects
*/
get models() {
if (typeof this._models === "object" && Object.keys(this._models || {}).length > 0) return this._models;
else {
return {};
}
}
/**
* Override settings config to remove API key setting since not needed for local instance.
* @returns {Object} Settings configuration object
*/
get settings_config() {
const config = super.settings_config;
delete config["[ADAPTER].api_key"];
config["[ADAPTER].host"] = {
name: "Ollama host",
type: "text",
description: "Enter the host for your Ollama instance",
default: this.constructor.defaults.host
};
return config;
}
};
var SmartEmbedModelOllamaRequestAdapter3 = class extends SmartEmbedModelRequestAdapter3 {
static {
__name(this, "SmartEmbedModelOllamaRequestAdapter");
}
/**
* Convert request to Ollama's embed API format.
* @returns {Object} Request parameters in Ollama's format
*/
to_platform() {
const ollama_body = {
model: this.model_id,
input: this.embed_inputs
};
return {
url: this.adapter.endpoint,
method: "POST",
headers: this.get_headers(),
body: JSON.stringify(ollama_body)
};
}
/**
* Prepare request headers for Ollama API.
* @returns {Object} Headers object
*/
get_headers() {
return {
"Content-Type": "application/json"
};
}
};
var SmartEmbedModelOllamaResponseAdapter3 = class extends SmartEmbedModelResponseAdapter3 {
static {
__name(this, "SmartEmbedModelOllamaResponseAdapter");
}
/**
* Convert Ollama's response to a standardized OpenAI-like format.
* @returns {Array<Object>} Array of embedding results
*/
to_openai() {
const resp = this.response;
if (!resp || !resp.embeddings) {
console.error("Invalid response format from Ollama:", resp);
return [];
}
const tokens = Math.ceil(resp.prompt_eval_count / this.adapter.batch_size);
const embeddings = resp.embeddings.map((vec) => ({
vec,
tokens
}));
return embeddings;
}
/**
* Parse the response object.
* @returns {Array<Object>} Parsed embedding results
*/
parse_response() {
return this.to_openai();
}
};
var is_embedding_model3 = /* @__PURE__ */ __name((mod) => {
return ["embed", "embedding", "bge"].some((keyword) => mod.name.toLowerCase().includes(keyword));
}, "is_embedding_model");
var filter_embedding_models3 = /* @__PURE__ */ __name((models) => {
if (!Array.isArray(models)) {
throw new TypeError("models must be an array");
}
return models.filter(is_embedding_model3);
}, "filter_embedding_models");

var OllamaEmbeddingModelAdapter = class extends SmartEmbedOllamaAdapter3 {
static {
__name(this, "OllamaEmbeddingModelAdapter");
}
constructor(model_item) {
super(model_item);
}
/**
* Get HTTP request adapter instance
* @returns {SmartHttpRequest} HTTP request handler
*/
get http_adapter() {
if (!this._http_adapter) {
const HttpClass = this.model.env.config.modules.http_adapter.class;
const http_params = { ...this.model.env.config.modules.http_adapter, class: void 0 };
this._http_adapter = new HttpClass(http_params);
}
return this._http_adapter;
}
};
var settings_config28 = {
host: {
name: "Ollama host",
type: "text",
description: "Enter the host for your Ollama instance",
default: "http://localhost:11434"
}
};
var ollama_default = {
class: OllamaEmbeddingModelAdapter,
settings_config: settings_config28
};

var SmartEmbedOpenRouterAdapter = class extends SmartEmbedModelApiAdapter3 {
static {
__name(this, "SmartEmbedOpenRouterAdapter");
}
static key = "open_router";
static defaults = {
description: "OpenRouter (Embeddings)",
type: "API",
adapter: "OpenRouterEmbeddings",
endpoint: "https://openrouter.ai/api/v1/embeddings",
models_endpoint: "https://openrouter.ai/api/v1/models",
default_model: "text-embedding-3-small",
signup_url: "https://accounts.openrouter.ai/sign-up?redirect_url=https%3A%2F%2Fopenrouter.ai%2Fkeys",
streaming: false,
api_key: null,
batch_size: 50,
max_tokens: 8191
};
/**
* Request adapter class
* @returns {typeof SmartEmbedOpenRouterRequestAdapter}
*/
get req_adapter() {
return SmartEmbedOpenRouterRequestAdapter;
}
/**
* Response adapter class
* @returns {typeof SmartEmbedOpenRouterResponseAdapter}
*/
get res_adapter() {
return SmartEmbedOpenRouterResponseAdapter;
}
/**
* Override settings config to label the API key clearly.
* @returns {Object} Settings configuration for OpenRouter adapter
*/
get settings_config() {
return {
...super.settings_config,
"[ADAPTER].api_key": {
name: "OpenRouter API key for embeddings",
type: "password",
description: "Required for OpenRouter embedding models.",
placeholder: "Enter OpenRouter API key"
}
};
}
/**
* Estimate token count for input text.
* OpenRouter does not expose a tokenizer, so we use a character-based heuristic.
* @param {string|Object} input
* @returns {Promise<{tokens:number}>}
*/
async count_tokens(input) {
return { tokens: this.estimate_tokens(input) };
}
/**
* Prepare input text and ensure it fits within `max_tokens`.
* @param {string} embed_input - Raw input text
* @returns {Promise<string|null>} Processed input text
*/
async prepare_embed_input(embed_input) {
if (typeof embed_input !== "string") {
throw new TypeError("embed_input must be a string");
}
if (embed_input.length === 0) return null;
const { tokens } = await this.count_tokens(embed_input);
if (tokens <= this.max_tokens) return embed_input;
return await this.trim_input_to_max_tokens(embed_input, tokens);
}
/**
* Get the OpenRouter models endpoint.
* @returns {string} Models endpoint URL
*/
get models_endpoint() {
return this.constructor.defaults.models_endpoint;
}
/**
* Fetch available models from OpenRouter and filter to embedding models.
* Results are cached in model.data.provider_models and used by the settings UI.
*
* @param {boolean} [refresh=false] - Force refresh of model list
* @returns {Promise<Object>} Map of model objects keyed by model id
*/
async get_models(refresh = false) {
if (!refresh && this.model.data.provider_models) {
return this.model.data.provider_models;
}
if (!this.api_key) {
console.warn(
"[SmartEmbedOpenRouterAdapter] API key missing; cannot fetch models from OpenRouter."
);
const fallback_id = this.constructor.defaults.default_model;
const fallback_models = {
[fallback_id]: {
id: fallback_id,
model_name: fallback_id,
description: "OpenRouter embedding model",
max_tokens: this.max_tokens,
adapter: this.constructor.key
}
};
this.model.data.provider_models = fallback_models;
return fallback_models;
}
try {
const resp = await this.http_adapter.request({
url: this.models_endpoint,
method: "GET",
headers: {
Authorization: `Bearer ${this.api_key}`
}
});
const raw = await resp.json();
const parsed = this.parse_model_data(raw);
this.model.data.provider_models = parsed;
this.model.re_render_settings();
return parsed;
} catch (error) {
console.error("[SmartEmbedOpenRouterAdapter] Failed to fetch models:", error);
if (this.model.data.provider_models) return this.model.data.provider_models;
const fallback_id = this.constructor.defaults.default_model;
const fallback_models = {
[fallback_id]: {
id: fallback_id,
model_name: fallback_id,
description: "OpenRouter embedding model",
max_tokens: this.max_tokens,
adapter: this.constructor.key
}
};
this.model.data.provider_models = fallback_models;
return fallback_models;
}
}
/**
* Parse OpenRouter /v1/models response into standard format,
* but only keep models that look like embeddings.
*
* @param {Object|Array} model_data - Raw models payload from OpenRouter
* @returns {Object} Map of model objects keyed by id
*/
parse_model_data(model_data) {
let list = [];
if (Array.isArray(model_data?.data)) list = model_data.data;
else if (Array.isArray(model_data)) list = model_data;
else {
console.error(
"[SmartEmbedOpenRouterAdapter] Invalid model data format from OpenRouter:",
model_data
);
return { _: { id: "No models found." } };
}
const out = {};
for (const model of list) {
const model_id = model.id || model.name;
if (!model_id) continue;
if (!is_embedding_model4(model_id)) continue;
out[model_id] = {
id: model_id,
model_name: model_id,
max_tokens: model.context_length || this.max_tokens,
description: model.name || model.description || `Model: ${model_id}`,
adapter: this.constructor.key
};
}
if (!Object.keys(out).length) {
return { _: { id: "No embedding models found." } };
}
return out;
}
};
var SmartEmbedOpenRouterRequestAdapter = class extends SmartEmbedModelRequestAdapter3 {
static {
__name(this, "SmartEmbedOpenRouterRequestAdapter");
}
/**
* Prepare request body for OpenRouter API.
* The embeddings endpoint is OpenAI-compatible:
*   POST /v1/embeddings
*   { model: string, input: string | string[] }
*
* @returns {Object} Request body for API
*/
prepare_request_body() {
return {
model: this.model_id,
input: this.embed_inputs
};
}
};
var SmartEmbedOpenRouterResponseAdapter = class extends SmartEmbedModelResponseAdapter3 {
static {
__name(this, "SmartEmbedOpenRouterResponseAdapter");
}
/**
* Parse OpenRouter embedding response.
* Expected shape (OpenAI-compatible):
* {
*   data: [{ embedding: number[], index: number, object: "embedding" }, ...],
*   model: string,
*   usage?: { prompt_tokens: number, total_tokens: number }
* }
*
* @returns {Array<{vec:number[], tokens:number|null}>}
*/
parse_response() {
const resp = this.response;
if (!resp || !Array.isArray(resp.data)) {
console.error(
"[SmartEmbedOpenRouterResponseAdapter] Invalid embedding response format:",
resp
);
return [];
}
let avg_tokens = null;
if (resp.usage?.total_tokens && resp.data.length > 0) {
avg_tokens = resp.usage.total_tokens / resp.data.length;
}
return resp.data.map((item) => {
const vec = item.embedding || item.data || [];
return {
vec,
tokens: avg_tokens
};
});
}
};
var is_embedding_model4 = /* @__PURE__ */ __name((id) => {
const lower = String(id || "").toLowerCase();
const segments = lower.split(/[-:/_]/);
if (segments.some((seg) => ["embed", "embedding", "bge"].includes(seg))) return true;
if (lower.includes("text-embedding")) return true;
return false;
}, "is_embedding_model");

var OpenRouterEmbeddingModelAdapter = class extends SmartEmbedOpenRouterAdapter {
static {
__name(this, "OpenRouterEmbeddingModelAdapter");
}
constructor(model_item) {
super(model_item);
}
get http_adapter() {
if (!this._http_adapter) {
const HttpClass = this.model.env.config.modules.http_adapter.class;
const http_params = { ...this.model.env.config.modules.http_adapter, class: void 0 };
this._http_adapter = new HttpClass(http_params);
}
return this._http_adapter;
}
};
var open_router_default2 = {
class: OpenRouterEmbeddingModelAdapter
};

var SmartEmbedOpenAIAdapter3 = class extends SmartEmbedModelApiAdapter3 {
static {
__name(this, "SmartEmbedOpenAIAdapter");
}
static defaults = {
adapter: "openai",
description: "OpenAI (API)",
default_model: "text-embedding-3-small",
endpoint: "https://api.openai.com/v1/embeddings"
};
/**
* Count tokens in input text using OpenAI's tokenizer
* @param {string} input - Text to tokenize
* @returns {Promise<Object>} Token count result
*/
async count_tokens(input) {
if (!this.tiktoken) await this.load_tiktoken();
return { tokens: this.tiktoken.encode(input).length };
}
/**
* Prepare input text for embedding
* Handles token limit truncation
* @param {string} embed_input - Raw input text
* @returns {Promise<string|null>} Processed input text
*/
async prepare_embed_input(embed_input) {
if (typeof embed_input !== "string") {
throw new TypeError("embed_input must be a string");
}
if (embed_input.length === 0) {
console.log("Warning: prepare_embed_input received an empty string");
return null;
}
const { tokens } = await this.count_tokens(embed_input);
if (tokens <= this.max_tokens) {
return embed_input;
}
return await this.trim_input_to_max_tokens(embed_input, tokens);
}
/**
* Trim input text to fit token limit
* @private
* @param {string} embed_input - Input text to trim
* @param {number} tokens_ct - Current token count
* @returns {Promise<string|null>} Trimmed input text
*/
async trim_input_to_max_tokens(embed_input, tokens_ct) {
const reduce_ratio = (tokens_ct - this.max_tokens) / tokens_ct;
const new_length = Math.floor(embed_input.length * (1 - reduce_ratio));
let trimmed_input = embed_input.slice(0, new_length);
const last_space_index = trimmed_input.lastIndexOf(" ");
if (last_space_index > 0) {
trimmed_input = trimmed_input.slice(0, last_space_index);
}
const prepared_input = await this.prepare_embed_input(trimmed_input);
if (prepared_input === null) {
console.log(
"Warning: prepare_embed_input resulted in an empty string after trimming"
);
return null;
}
return prepared_input;
}
/**
* Get the request adapter class.
* @returns {SmartEmbedOpenAIRequestAdapter} The request adapter class
*/
get req_adapter() {
return SmartEmbedOpenAIRequestAdapter3;
}
/**
* Get the response adapter class.
* @returns {SmartEmbedOpenAIResponseAdapter} The response adapter class
*/
get res_adapter() {
return SmartEmbedOpenAIResponseAdapter3;
}
/** @returns {number} Maximum tokens per input */
get max_tokens() {
return this.model.data.max_tokens || 8191;
}
/** @returns {Object} Settings configuration for OpenAI adapter */
get settings_config() {
return {
...super.settings_config,
"[ADAPTER].api_key": {
name: "OpenAI API key for embeddings",
type: "password",
description: "Required for OpenAI embedding models.",
placeholder: "Enter OpenAI API key"
}
};
}
/**
* Get available models (hardcoded list)
* @returns {Promise<Object>} Map of model objects
*/
get_models() {
return Promise.resolve(this.models);
}
get models() {
return {
"text-embedding-3-small": {
"id": "text-embedding-3-small",
"batch_size": 50,
"dims": 1536,
"max_tokens": 8191,
"name": "OpenAI Text-3 Small",
"description": "API, 8,191 tokens, 1,536 dim",
"endpoint": "https://api.openai.com/v1/embeddings",
"adapter": "openai"
},
"text-embedding-3-large": {
"id": "text-embedding-3-large",
"batch_size": 50,
"dims": 3072,
"max_tokens": 8191,
"name": "OpenAI Text-3 Large",
"description": "API, 8,191 tokens, 3,072 dim",
"endpoint": "https://api.openai.com/v1/embeddings",
"adapter": "openai"
},
"text-embedding-ada-002": {
"id": "text-embedding-ada-002",
"batch_size": 50,
"dims": 1536,
"max_tokens": 8191,
"name": "OpenAI Ada",
"description": "API, 8,191 tokens, 1,536 dim",
"endpoint": "https://api.openai.com/v1/embeddings",
"adapter": "openai"
}
};
}
};
var SmartEmbedOpenAIRequestAdapter3 = class extends SmartEmbedModelRequestAdapter3 {
static {
__name(this, "SmartEmbedOpenAIRequestAdapter");
}
/**
* Prepare request body for OpenAI API
* @returns {Object} Request body for API
*/
prepare_request_body() {
const body = {
model: this.model_id,
input: this.embed_inputs
};
if (this.model_id.startsWith("text-embedding-3")) {
body.dimensions = this.model_dims;
}
return body;
}
};
var SmartEmbedOpenAIResponseAdapter3 = class extends SmartEmbedModelResponseAdapter3 {
static {
__name(this, "SmartEmbedOpenAIResponseAdapter");
}
/**
* Parse OpenAI API response
* @returns {Array<Object>} Parsed embedding results
*/
parse_response() {
const resp = this.response;
if (!resp || !resp.data || !resp.usage) {
console.error("Invalid response format", resp);
return [];
}
const avg_tokens = resp.usage.total_tokens / resp.data.length;
return resp.data.map((item) => ({
vec: item.embedding,
tokens: avg_tokens
}));
}
};

var OpenAIEmbeddingModelAdapter = class extends SmartEmbedOpenAIAdapter3 {
static {
__name(this, "OpenAIEmbeddingModelAdapter");
}
constructor(model_item) {
super(model_item);
}
get http_adapter() {
if (!this._http_adapter) {
const HttpClass = this.model.env.config.modules.http_adapter.class;
const http_params = { ...this.model.env.config.modules.http_adapter, class: void 0 };
this._http_adapter = new HttpClass(http_params);
}
return this._http_adapter;
}
get batch_size() {
return 30;
}
get models() {
return {
"text-embedding-3-small": {
"id": "text-embedding-3-small",
"batch_size": 50,
"dims": 1536,
"max_tokens": 8191,
"name": "OpenAI Text-3 Small",
"description": "API, 8,191 tokens, 1,536 dim",
"endpoint": "https://api.openai.com/v1/embeddings",
"adapter": "openai"
},
"text-embedding-3-large": {
"id": "text-embedding-3-large",
"batch_size": 50,
"dims": 3072,
"max_tokens": 8191,
"name": "OpenAI Text-3 Large",
"description": "API, 8,191 tokens, 3,072 dim",
"endpoint": "https://api.openai.com/v1/embeddings",
"adapter": "openai"
},
"text-embedding-ada-002": {
"id": "text-embedding-ada-002",
"batch_size": 50,
"dims": 1536,
"max_tokens": 8191,
"name": "OpenAI Ada",
"description": "API, 8,191 tokens, 1,536 dim",
"endpoint": "https://api.openai.com/v1/embeddings",
"adapter": "openai"
}
};
}
};
var settings_config29 = {
"api_key": {
name: "API Key",
type: "password",
description: "Enter your OpenAI API key."
},
"dimensions": {
name: "Embedding Dimensions",
type: "dropdown",
description: "Select the number of dimensions for the embeddings (only for text-embedding-3 models).",
option_1: "256|256 (equivalent to ada using 'large' model)",
option_2: "512|512 (equivalent to ada using 'small' model)",
option_3: "1536|1536",
option_4: "3072|3072 (uses >10X more RAM/storage than 256)",
default: "512"
}
};
var openai_default = {
class: OpenAIEmbeddingModelAdapter,
settings_config: settings_config29
};

var SmartChatModelAnthropicAdapter3 = class extends SmartChatModelApiAdapter2 {
static {
__name(this, "SmartChatModelAnthropicAdapter");
}
static key = "anthropic";
static defaults = {
description: "Anthropic Claude",
type: "API",
endpoint: "https://api.anthropic.com/v1/messages",
streaming: true,
api_key_header: "x-api-key",
headers: {
"anthropic-version": "2023-06-01",
"anthropic-beta": "tools-2024-04-04",
"anthropic-dangerous-direct-browser-access": true
},
adapter: "Anthropic",
models_endpoint: false,
default_model: "claude-opus-4-1-20250805",
signup_url: "https://console.anthropic.com/login?returnTo=%2Fsettings%2Fkeys"
};
/**
* Get request adapter class
* @returns {typeof SmartChatModelAnthropicRequestAdapter} Request adapter class
*/
get req_adapter() {
return SmartChatModelAnthropicRequestAdapter3;
}
/**
* Get response adapter class
* @returns {typeof SmartChatModelAnthropicResponseAdapter} Response adapter class
*/
res_adapter = SmartChatModelAnthropicResponseAdapter3;
/**
* Get available models (hardcoded list) and enrich via models.dev
* @returns {Promise<Object>} Map of model objects
*/
async get_models() {
try {
this.model_data = await this.get_enriched_model_data();
this.model_data_loaded_at = Date.now();
this.model.data.provider_models = this.model_data;
setTimeout(() => {
this.model.re_render_settings();
}, 100);
return this.model_data;
} catch {
return this.anthropic_models;
}
}
is_end_of_stream(event) {
return event.data.includes("message_stop");
}
/**
* Get hardcoded list of available models
* @deprecated use get_enriched_model_data() instead (remove after no-incidents)
* @returns {Object} Map of model objects with capabilities and limits
*/
get anthropic_models() {
return {
"claude-opus-4-1-20250805": {
name: "Claude Opus 4.1 (2025-08-05)",
id: "claude-opus-4-1-20250805",
model_name: "claude-opus-4-1-20250805",
description: "Anthropic Claude Opus 4.1 snapshot (2025-08-05)",
max_input_tokens: 2e5,
max_output_tokens: 32e3,
multimodal: true
},
"claude-opus-4-20250514": {
name: "Claude Opus 4 (2025-05-14)",
id: "claude-opus-4-20250514",
model_name: "claude-opus-4-20250514",
description: "Anthropic Claude Opus 4 snapshot (2025-05-14)",
max_input_tokens: 2e5,
max_output_tokens: 32e3,
multimodal: true
},
"claude-sonnet-4-20250514": {
name: "Claude Sonnet 4 (2025-05-14)",
id: "claude-sonnet-4-20250514",
model_name: "claude-sonnet-4-20250514",
description: "Anthropic Claude Sonnet 4 snapshot (2025-05-14)",
max_input_tokens: 2e5,
max_output_tokens: 64e3,
multimodal: true
},
"claude-3-7-sonnet-latest": {
name: "Claude 3.7 Sonnet (latest)",
id: "claude-3-7-sonnet-latest",
model_name: "claude-3-7-sonnet-latest",
description: "Anthropic Claude 3.7 Sonnet (rolling-latest)",
max_input_tokens: 2e5,
max_output_tokens: 64e3,
multimodal: true
},
"claude-3-7-sonnet-20250219": {
name: "Claude 3.7 Sonnet (2025-02-19)",
id: "claude-3-7-sonnet-20250219",
model_name: "claude-3-7-sonnet-20250219",
description: "Anthropic Claude 3.7 Sonnet snapshot (2025-02-19)",
max_input_tokens: 2e5,
max_output_tokens: 64e3,
multimodal: true
},
"claude-3-5-sonnet-latest": {
name: "Claude 3.5 Sonnet (latest)",
id: "claude-3-5-sonnet-latest",
model_name: "claude-3-5-sonnet-latest",
description: "Anthropic Claude 3.5 Sonnet (rolling-latest)",
max_input_tokens: 2e5,
max_output_tokens: 8192,
multimodal: true
},
"claude-3-5-sonnet-20241022": {
name: "Claude 3.5 Sonnet (2024-10-22)",
id: "claude-3-5-sonnet-20241022",
model_name: "claude-3-5-sonnet-20241022",
description: "Anthropic Claude 3.5 Sonnet snapshot (2024-10-22)",
max_input_tokens: 2e5,
max_output_tokens: 8192,
multimodal: true
},
"claude-3-5-haiku-latest": {
name: "Claude 3.5 Haiku (latest)",
id: "claude-3-5-haiku-latest",
model_name: "claude-3-5-haiku-latest",
description: "Anthropic Claude 3.5 Haiku (rolling-latest)",
max_input_tokens: 2e5,
max_output_tokens: 8192
},
"claude-3-5-haiku-20241022": {
name: "Claude 3.5 Haiku (2024-10-22)",
id: "claude-3-5-haiku-20241022",
model_name: "claude-3-5-haiku-20241022",
description: "Anthropic Claude 3.5 Haiku snapshot (2024-10-22)",
max_input_tokens: 2e5,
max_output_tokens: 8192
},
"claude-3-opus-latest": {
name: "Claude 3 Opus (latest)",
id: "claude-3-opus-latest",
model_name: "claude-3-opus-latest",
description: "Anthropic Claude 3 Opus (rolling-latest)",
max_input_tokens: 2e5,
max_output_tokens: 4096,
multimodal: true
},
"claude-3-opus-20240229": {
name: "Claude 3 Opus (2024-02-29)",
id: "claude-3-opus-20240229",
model_name: "claude-3-opus-20240229",
description: "Anthropic Claude 3 Opus snapshot (2024-02-29)",
max_input_tokens: 2e5,
max_output_tokens: 4096,
multimodal: true
},
"claude-3-sonnet-20240229": {
name: "Claude 3 Sonnet (2024-02-29)",
id: "claude-3-sonnet-20240229",
model_name: "claude-3-sonnet-20240229",
description: "Anthropic Claude 3 Sonnet snapshot (2024-02-29)",
max_input_tokens: 2e5,
max_output_tokens: 4096,
multimodal: true
},
"claude-3-haiku-20240307": {
name: "Claude 3 Haiku (2024-03-07)",
id: "claude-3-haiku-20240307",
model_name: "claude-3-haiku-20240307",
description: "Anthropic Claude 3 Haiku snapshot (2024-03-07)",
max_input_tokens: 2e5,
max_output_tokens: 4096,
multimodal: true
}
};
}
};
var SmartChatModelAnthropicRequestAdapter3 = class extends SmartChatModelRequestAdapter2 {
static {
__name(this, "SmartChatModelAnthropicRequestAdapter");
}
/**
* Convert request to Anthropic format
* @returns {Object} Request parameters in Anthropic format
*/
to_platform(streaming = false) {
return this.to_anthropic(streaming);
}
/**
* Convert request to Anthropic format
* @returns {Object} Request parameters in Anthropic format
*/
to_anthropic(streaming = false) {
this.anthropic_body = {
model: this.model_id,
max_tokens: this.max_tokens,
temperature: this.temperature,
stream: streaming
};
this.anthropic_body.messages = this._transform_messages_to_anthropic();
if (this.tools) {
this.anthropic_body.tools = this._transform_tools_to_anthropic();
}
if (this.tool_choice) {
this.anthropic_body.tool_choice = this.tool_choice === "auto" ? { type: "auto" } : { type: "tool", name: this.tool_choice.function.name };
}
return {
url: this.adapter.endpoint,
method: "POST",
headers: this.get_headers(),
body: JSON.stringify(this.anthropic_body)
};
}
/**
* Transform messages to Anthropic format
* @returns {Array<Object>} Messages in Anthropic format
* @private
*/
_transform_messages_to_anthropic() {
let anthropic_messages = [];
for (const message of this.messages) {
if (message.role === "system") {
if (!this.anthropic_body.system) this.anthropic_body.system = "";
else this.anthropic_body.system += "\n\n";
this.anthropic_body.system += Array.isArray(message.content) ? message.content.map((part) => part.text).join("\n") : message.content;
} else if (message.role === "tool") {
const msg = {
role: "user",
content: [
{
type: "tool_result",
tool_use_id: message.tool_call_id,
content: message.content
}
]
};
anthropic_messages.push(msg);
} else {
const msg = {
role: this._get_anthropic_role(message.role),
content: this._get_anthropic_content(message.content)
};
if (message.tool_calls?.length > 0) msg.content = this._transform_tool_calls_to_content(message.tool_calls);
anthropic_messages.push(msg);
}
}
return anthropic_messages;
}
/**
* Transform tool calls to Anthropic format
* @param {Array<Object>} tool_calls - Tool calls
* @returns {Array<Object>} Tool calls in Anthropic format
* @private
*/
_transform_tool_calls_to_content(tool_calls) {
return tool_calls.map((tool_call) => ({
type: "tool_use",
id: tool_call.id,
name: tool_call.function.name,
input: JSON.parse(tool_call.function.arguments)
}));
}
/**
* Transform role to Anthropic format
* @param {string} role - Original role
* @returns {string} Role in Anthropic format
* @private
*/
_get_anthropic_role(role) {
const role_map = {
function: "assistant",
tool: "user"
};
return role_map[role] || role;
}
/**
* Transform content to Anthropic format
* @param {string|Array} content - Original content
* @returns {string|Array} Content in Anthropic format
* @private
*/
_get_anthropic_content(content) {
if (Array.isArray(content)) {
return content.map((item) => {
if (item.type === "text") return { type: "text", text: item.text };
if (item.type === "image_url") {
return {
type: "image",
source: {
type: "base64",
media_type: item.image_url.url.split(";")[0].split(":")[1],
data: item.image_url.url.split(",")[1]
}
};
}
if (item.type === "file" && item.file?.filename?.toLowerCase().endsWith(".pdf")) {
if (item.file?.file_data) {
return {
type: "document",
source: {
type: "base64",
media_type: "application/pdf",
data: item.file.file_data.split(",")[1]
}
};
}
}
return item;
});
}
return content;
}
/**
* Transform tools to Anthropic format
* @returns {Array<Object>} Tools in Anthropic format
* @private
*/
_transform_tools_to_anthropic() {
if (!this.tools) return void 0;
return this.tools.map((tool2) => ({
name: tool2.function.name,
description: tool2.function.description,
input_schema: tool2.function.parameters
}));
}
};
var SmartChatModelAnthropicResponseAdapter3 = class extends SmartChatModelResponseAdapter2 {
static {
__name(this, "SmartChatModelAnthropicResponseAdapter");
}
static get platform_res() {
return {
content: [],
id: "",
model: "",
role: "assistant",
stop_reason: null,
stop_sequence: null,
type: "message",
usage: {
input_tokens: 0,
output_tokens: 0
}
};
}
/**
* Convert response to OpenAI format
* @returns {Object} Response in OpenAI format
*/
to_openai() {
if (this.error) return { error: normalize_error2(this.error, this.status) };
return {
id: this._res.id,
object: "chat.completion",
created: Date.now(),
choices: [
{
index: 0,
message: this._transform_message_to_openai(),
finish_reason: this._get_openai_finish_reason(this._res.stop_reason)
}
],
usage: this._transform_usage_to_openai()
};
}
/**
* Transform message to OpenAI format
* @returns {Object} Message in OpenAI format
* @private
*/
_transform_message_to_openai() {
const message = {
role: "assistant",
content: "",
tool_calls: []
};
if (Array.isArray(this._res.content)) {
for (const content of this._res.content) {
if (content.type === "text") {
message.content += (message.content ? "\n\n" : "") + content.text;
} else if (content.type === "tool_use") {
message.tool_calls.push({
id: content.id,
type: "function",
function: {
name: content.name,
arguments: JSON.stringify(content.input)
}
});
}
}
} else {
message.content = this._res.content;
}
if (message.tool_calls.length === 0) {
delete message.tool_calls;
}
return message;
}
/**
* Transform finish reason to OpenAI format
* @param {string} stop_reason - Original finish reason
* @returns {string} Finish reason in OpenAI format
* @private
*/
_get_openai_finish_reason(stop_reason) {
const reason_map = {
"end_turn": "stop",
"max_tokens": "length",
"tool_use": "function_call"
};
return reason_map[stop_reason] || stop_reason;
}
/**
* Transform usage statistics to OpenAI format
* @returns {Object} Usage statistics in OpenAI format
* @private
*/
_transform_usage_to_openai() {
if (!this._res.usage) {
return {
prompt_tokens: 0,
completion_tokens: 0,
total_tokens: 0
};
}
return {
prompt_tokens: this._res.usage.input_tokens || 0,
completion_tokens: this._res.usage.output_tokens || 0,
total_tokens: (this._res.usage.input_tokens || 0) + (this._res.usage.output_tokens || 0)
};
}
handle_chunk(chunk) {
if (!chunk.startsWith("data: ")) return;
chunk = JSON.parse(chunk.slice(6));
if (!this._res.content.length) {
this._res.content = [
{
type: "text",
text: ""
}
];
}
if (chunk.message?.id) {
this._res.id = chunk.message.id;
}
if (chunk.message?.model) {
this._res.model = chunk.message.model;
}
if (chunk.message?.role) {
this._res.role = chunk.message.role;
}
let raw;
if (chunk.delta?.type === "text_delta") {
const content = chunk.delta?.text;
raw = content;
this._res.content[0].text += content;
}
if (chunk.delta?.stop_reason) {
this._res.stop_reason = chunk.delta.stop_reason;
}
if (chunk.usage) {
this._res.usage = {
...this._res.usage,
...chunk.usage
};
}
return raw;
}
};

var AnthropicChatCompletionModelAdapter = class extends SmartChatModelAnthropicAdapter3 {
static {
__name(this, "AnthropicChatCompletionModelAdapter");
}
constructor(model_item) {
super(model_item);
}
get http_adapter() {
if (!this._http_adapter) {
const HttpClass = this.model.env.config.modules.http_adapter.class;
const http_params = { ...this.model.env.config.modules.http_adapter, class: void 0 };
this._http_adapter = new HttpClass(http_params);
}
return this._http_adapter;
}
};
var settings_config30 = {
"api_key": {
name: "API Key",
type: "password",
description: "Enter your Anthropic API key."
}
};
var anthropic_default = {
class: AnthropicChatCompletionModelAdapter,
settings_config: settings_config30
};

var EXCLUDED_PREFIXES3 = [
"text-",
"davinci",
"babbage",
"ada",
"curie",
"dall-e",
"whisper",
"omni",
"tts",
"gpt-4o-mini-tts",
"computer-use",
"codex",
"gpt-4o-transcribe",
"gpt-4o-mini-transcribe",
"gpt-4o-mini-realtime",
"gpt-4o-realtime",
"o4-mini-deep-research",
"o3-deep-research",
"gpt-image"
];
var SmartChatModelOpenaiAdapter3 = class extends SmartChatModelApiAdapter2 {
static {
__name(this, "SmartChatModelOpenaiAdapter");
}
static key = "openai";
static defaults = {
description: "OpenAI",
type: "API",
endpoint: "https://api.openai.com/v1/chat/completions",
streaming: true,
models_endpoint: "https://api.openai.com/v1/models",
default_model: "gpt-5-nano",
signup_url: "https://platform.openai.com/api-keys"
};
res_adapter = SmartChatModelOpenaiResponseAdapter3;
/**
* Parse model data from OpenAI API response.
* Filters for GPT models and adds context window information.
* @param {Object} model_data - Raw model data from OpenAI
* @returns {Object} Map of model objects with capabilities and limits
*/
parse_model_data(model_data) {
return model_data.data.filter((model) => !EXCLUDED_PREFIXES3.some((m) => model.id.startsWith(m)) && !model.id.includes("-instruct")).reduce((acc, model) => {
const out = {
model_name: model.id,
id: model.id,
multimodal: true,
max_input_tokens: get_max_input_tokens3(model.id)
};
acc[model.id] = out;
return acc;
}, {});
}
/**
* Override the HTTP method for fetching models.
*/
models_endpoint_method = "GET";
/**
* Test the API key by attempting to fetch models.
* @returns {Promise<boolean>} True if API key is valid
*/
async test_api_key() {
const models = await this.get_models();
return models.length > 0;
}
/**
* Get settings configuration for OpenAI adapter.
* Adds image resolution setting for multimodal models.
* @returns {Object} Settings configuration object
*/
get settings_config() {
const config = super.settings_config;
config["[CHAT_ADAPTER].open_ai_note"] = {
name: "Note about using OpenAI",
type: "html",
value: "<b>OpenAI models:</b> Some models require extra verification steps in your OpenAI account for them to appear in the model list."
};
return config;
}
};
function get_max_input_tokens3(model_id) {
if (model_id.startsWith("gpt-4.1")) {
return 1e6;
}
if (model_id.startsWith("o")) {
return 2e5;
}
if (model_id.startsWith("gpt-5")) {
return 4e5;
}
if (model_id.startsWith("gpt-4o") || model_id.startsWith("gpt-4.5") || model_id.startsWith("gpt-4-turbo")) {
return 128e3;
}
if (model_id.startsWith("gpt-4")) {
return 8192;
}
if (model_id.startsWith("gpt-3")) {
return 16385;
}
return 8e3;
}
__name(get_max_input_tokens3, "get_max_input_tokens");
var SmartChatModelOpenaiResponseAdapter3 = class extends SmartChatModelResponseAdapter2 {
static {
__name(this, "SmartChatModelOpenaiResponseAdapter");
}
};

var SmartChatModelAzureAdapter3 = class extends SmartChatModelOpenaiAdapter3 {
static {
__name(this, "SmartChatModelAzureAdapter");
}
static key = "azure";
static defaults = {
description: "Azure OpenAI",
type: "API",
adapter: "AzureOpenAI",
streaming: true,
api_key_header: "api-key",
azure_resource_name: "",
azure_deployment_name: "",
azure_api_version: "2024-10-01-preview",
default_model: "gpt-35-turbo",
signup_url: "https://learn.microsoft.com/azure/cognitive-services/openai/quickstart?tabs=command-line",
models_endpoint: "https://{azure_resource_name}.openai.azure.com/openai/deployments?api-version={azure_api_version}"
};
/**
* Override the settings configuration to include Azure-specific fields.
*/
get settings_config() {
return {
...super.settings_config,
"[CHAT_ADAPTER].azure_resource_name": {
name: "Azure Resource Name",
type: "text",
description: "The name of your Azure OpenAI resource (e.g. 'my-azure-openai').",
default: ""
},
"[CHAT_ADAPTER].azure_deployment_name": {
name: "Azure Deployment Name",
type: "text",
description: "The name of your specific model deployment (e.g. 'gpt35-deployment').",
default: ""
},
"[CHAT_ADAPTER].azure_api_version": {
name: "Azure API Version",
type: "text",
description: "The API version for Azure OpenAI (e.g. '2024-10-01-preview').",
default: "2024-10-01-preview"
}
};
}
/**
* Build the endpoint dynamically based on Azure settings.
* Example:
*  https://<RESOURCE>.openai.azure.com/openai/deployments/<DEPLOYMENT>/chat/completions?api-version=2023-05-15
*/
get endpoint() {
const { azure_resource_name, azure_deployment_name, azure_api_version } = this.model.data;
return `https://${azure_resource_name}.openai.azure.com/openai/deployments/${azure_deployment_name}/chat/completions?api-version=${azure_api_version}`;
}
/**
* For streaming, we can reuse the same endpoint.
* The request body includes `stream: true` which the base class uses.
*/
get endpoint_streaming() {
return this.endpoint;
}
/**
* The models endpoint for retrieving a list of your deployments.
* E.g.:
*   https://<RESOURCE>.openai.azure.com/openai/deployments?api-version=2023-05-15
*/
get models_endpoint() {
const { azure_resource_name, azure_api_version } = this.model.data;
return `https://${azure_resource_name}.openai.azure.com/openai/deployments?api-version=${azure_api_version}`;
}
/**
* Azure returns a list of deployments in the shape:
* {
*   "object": "list",
*   "data": [
*     {
*       "id": "mydeployment",
*       "model": "gpt-35-turbo",
*       "status": "succeeded",
*       "createdAt": ...
*       "updatedAt": ...
*       ...
*     },
*     ...
*   ]
* }
* We'll parse them into a dictionary keyed by deployment ID.
*/
parse_model_data(model_data) {
if (model_data.object !== "list" || !Array.isArray(model_data.data)) {
return { "_": { id: "No deployments found." } };
}
const parsed = {};
for (const d of model_data.data) {
parsed[d.id] = {
model_name: d.id,
id: d.id,
raw: d,
description: `Model: ${d.model}, Status: ${d.status}`,
max_input_tokens: 4e3
};
}
return parsed;
}
};

var AzureChatCompletionModelAdapter = class extends SmartChatModelAzureAdapter3 {
static {
__name(this, "AzureChatCompletionModelAdapter");
}
constructor(model_item) {
super(model_item);
}
get http_adapter() {
if (!this._http_adapter) {
const HttpClass = this.model.env.config.modules.http_adapter.class;
const http_params = { ...this.model.env.config.modules.http_adapter, class: void 0 };
this._http_adapter = new HttpClass(http_params);
}
return this._http_adapter;
}
};
var settings_config31 = {
"api_key": {
name: "API Key",
type: "password",
description: "Enter your Anthropic API key."
},
"azure_resource_name": {
name: "Azure Resource Name",
type: "text",
description: "The name of your Azure OpenAI resource (e.g. 'my-azure-openai').",
default: ""
},
"azure_deployment_name": {
name: "Azure Deployment Name",
type: "text",
description: "The name of your specific model deployment (e.g. 'gpt35-deployment').",
default: ""
},
"azure_api_version": {
name: "Azure API Version",
type: "text",
description: "The API version for Azure OpenAI (e.g. '2024-10-01-preview').",
default: "2024-10-01-preview"
}
};
var azure_default = {
class: AzureChatCompletionModelAdapter,
settings_config: settings_config31
};

var SmartChatModelCohereAdapter3 = class extends SmartChatModelApiAdapter2 {
static {
__name(this, "SmartChatModelCohereAdapter");
}
static key = "cohere";
static defaults = {
description: "Cohere Command-R",
type: "API",
endpoint: "https://api.cohere.ai/v1/chat",
streaming: false,
adapter: "Cohere",
models_endpoint: "https://api.cohere.ai/v1/models",
default_model: "command-r",
signup_url: "https://dashboard.cohere.com/welcome/register?redirect_uri=%2Fapi-keys"
};
/**
* Get request adapter class
* @returns {typeof SmartChatModelCohereRequestAdapter} Request adapter class
*/
get req_adapter() {
return SmartChatModelCohereRequestAdapter;
}
/**
* Get response adapter class
* @returns {typeof SmartChatModelCohereResponseAdapter} Response adapter class
*/
get res_adapter() {
return SmartChatModelCohereResponseAdapter;
}
/**
* Count tokens in input text using Cohere's tokenize endpoint
* @param {string|Object} input - Text to count tokens for
* @returns {Promise<number>} Token count
*/
async count_tokens(input) {
const req = {
url: `${this.endpoint}/tokenize`,
method: "POST",
headers: {
"Content-Type": "application/json",
"Authorization": `Bearer ${this.api_key}`
},
body: JSON.stringify({ text: typeof input === "string" ? input : JSON.stringify(input) })
};
const resp = await this.http_adapter.request(req);
return resp.json.tokens.length;
}
/**
* Parse model data from Cohere API response
* @param {Object} model_data - Raw model data from API
* @returns {Object} Map of model objects with capabilities and limits
*/
parse_model_data(model_data) {
return model_data.models.filter((model) => model.name.startsWith("command-")).reduce((acc, model) => {
acc[model.name] = {
model_name: model.name,
id: model.name,
max_input_tokens: model.context_length,
tokenizer_url: model.tokenizer_url,
finetuned: model.finetuned,
description: `Max input tokens: ${model.context_length}, Finetuned: ${model.finetuned}`,
raw: model
};
return acc;
}, {});
}
};
var SmartChatModelCohereRequestAdapter = class extends SmartChatModelRequestAdapter2 {
static {
__name(this, "SmartChatModelCohereRequestAdapter");
}
/**
* Convert request to Cohere format
* @returns {Object} Request parameters in Cohere format
*/
to_platform() {
return this.to_cohere();
}
/**
* Convert request to Cohere format
* @returns {Object} Request parameters in Cohere format
*/
to_cohere() {
const cohere_body = {
model: this.model_id,
message: this._get_latest_user_message(),
chat_history: this._transform_messages_to_cohere_chat_history(),
max_tokens: this.max_tokens,
temperature: this.temperature,
stream: this.stream,
...this.tools && { tools: this._transform_tools_to_cohere() },
...this._req.tool_choice && { tool_choice: this._req.tool_choice },
...this._req.preamble && { preamble: this._req.preamble },
...this._req.conversation_id && { conversation_id: this._req.conversation_id },
...this._req.connectors && { connectors: this._req.connectors },
...this._req.documents && { documents: this._req.documents }
};
if (this._req.response_format) {
cohere_body.response_format = {
type: this._req.response_format.type,
...this._req.response_format.schema && { schema: this._req.response_format.schema }
};
}
return {
url: this.adapter.endpoint,
method: "POST",
headers: this.get_headers(),
body: JSON.stringify(cohere_body)
};
}
/**
* Get the latest user message from the messages array
* @returns {string} Latest user message content
* @throws {Error} If image input is detected (not supported by Cohere)
* @private
*/
_get_latest_user_message() {
if (this.messages.some((msg) => Array.isArray(msg.content) && msg.content.some((part) => part.type === "image_url"))) {
throw new Error("Cohere API does not support image input");
}
const user_messages = this.messages.filter((msg) => msg.role === "user");
return user_messages[user_messages.length - 1]?.content || "";
}
/**
* Transform messages to Cohere chat history format
* @returns {Array<Object>} Messages in Cohere format
* @private
*/
_transform_messages_to_cohere_chat_history() {
return this.messages.slice(0, -1).map((message) => ({
role: this._get_cohere_role(message.role),
message: this._get_cohere_content(message.content)
}));
}
/**
* Transform role to Cohere format
* @param {string} role - Original role
* @returns {string} Role in Cohere format
* @private
*/
_get_cohere_role(role) {
const role_map = {
system: "SYSTEM",
user: "USER",
assistant: "CHATBOT",
function: "CHATBOT"
};
return role_map[role] || role.toUpperCase();
}
/**
* Transform content to Cohere format
* @param {string|Array} content - Original content
* @returns {string} Content in Cohere format
* @throws {Error} If image input is detected
* @private
*/
_get_cohere_content(content) {
if (Array.isArray(content)) {
for (const part of content) {
if (part.type === "image_url") {
throw new Error("Cohere API does not support image input");
}
}
return content.map((part) => {
if (part.type === "text") return part.text;
return JSON.stringify(part);
}).join("\n");
}
return content;
}
/**
* Transform tools to Cohere format
* @returns {Array<Object>} Tools in Cohere format
* @private
*/
_transform_tools_to_cohere() {
return this.tools.map((tool2) => ({
name: tool2.function.name,
description: tool2.function.description,
parameters: tool2.function.parameters
}));
}
};
var SmartChatModelCohereResponseAdapter = class extends SmartChatModelResponseAdapter2 {
static {
__name(this, "SmartChatModelCohereResponseAdapter");
}
/**
* Convert response to OpenAI format
* @returns {Object} Response in OpenAI format
* @throws {Error} If response contains an error message
*/
to_openai() {
if (this._res.message) {
throw new Error(this._res.message);
}
return {
id: this._res.generation_id || "cohere_" + Date.now(),
object: "chat.completion",
created: Date.now(),
model: this.adapter.model_key,
choices: [
{
index: 0,
message: this._transform_message_to_openai(),
finish_reason: this._get_openai_finish_reason(this._res.finish_reason)
}
],
usage: this._transform_usage_to_openai()
};
}
/**
* Transform message to OpenAI format
* @returns {Object} Message in OpenAI format
* @private
*/
_transform_message_to_openai() {
const message = {
role: "assistant",
content: this._res.text || ""
};
if (this._res.citations) {
message.citations = this._res.citations;
}
if (this._res.documents) {
message.documents = this._res.documents;
}
if (this._res.search_queries) {
message.search_queries = this._res.search_queries;
}
if (this._res.search_results) {
message.search_results = this._res.search_results;
}
return message;
}
/**
* Transform finish reason to OpenAI format
* @param {string} finish_reason - Original finish reason
* @returns {string} Finish reason in OpenAI format
* @private
*/
_get_openai_finish_reason(finish_reason) {
const reason_map = {
"COMPLETE": "stop",
"MAX_TOKENS": "length",
"ERROR": "error",
"STOP_SEQUENCE": "stop"
};
return reason_map[finish_reason] || "stop";
}
/**
* Transform usage statistics to OpenAI format
* @returns {Object} Usage statistics in OpenAI format
* @private
*/
_transform_usage_to_openai() {
if (!this._res.meta || !this._res.meta.billed_units) {
return {
prompt_tokens: null,
completion_tokens: null,
total_tokens: null
};
}
return {
prompt_tokens: this._res.meta.billed_units.input_tokens || null,
completion_tokens: this._res.meta.billed_units.output_tokens || null,
total_tokens: (this._res.meta.billed_units.input_tokens || 0) + (this._res.meta.billed_units.output_tokens || 0)
};
}
};

var CohereChatCompletionModelAdapter = class extends SmartChatModelCohereAdapter3 {
static {
__name(this, "CohereChatCompletionModelAdapter");
}
constructor(model_item) {
super(model_item);
}
get http_adapter() {
if (!this._http_adapter) {
const HttpClass = this.model.env.config.modules.http_adapter.class;
const http_params = { ...this.model.env.config.modules.http_adapter, class: void 0 };
this._http_adapter = new HttpClass(http_params);
}
return this._http_adapter;
}
};
var settings_config32 = {
api_key: {
name: "API Key",
type: "password",
description: "Enter your Cohere API key."
}
};
var cohere_default2 = {
class: CohereChatCompletionModelAdapter,
settings_config: settings_config32
};

var SmartChatModelDeepseekAdapter3 = class extends SmartChatModelApiAdapter2 {
static {
__name(this, "SmartChatModelDeepseekAdapter");
}
static key = "deepseek";
static defaults = {
description: "DeepSeek",
type: "API",
endpoint: "https://api.deepseek.com/chat/completions",
streaming: true,
adapter: "DeepSeek",
models_endpoint: "https://api.deepseek.com/models",
default_model: "deepseek-base",
signup_url: "https://deepseek.com/signup"
};
/**
* Get the request adapter class
* @returns {typeof SmartChatModelDeepseekRequestAdapter} Request adapter class
*/
get req_adapter() {
return SmartChatModelDeepseekRequestAdapter3;
}
/**
* Get the response adapter class
* @returns {typeof SmartChatModelDeepseekResponseAdapter} Response adapter class
*/
get res_adapter() {
return SmartChatModelDeepseekResponseAdapter3;
}
get models_endpoint_method() {
return "GET";
}
/**
* Parse the raw model data from DeepSeek's /v1/models endpoint
* into a structured map of model objects keyed by model ID.
* @param {Object} model_data - Raw JSON from DeepSeek
* @returns {Object} Map of model objects
*/
parse_model_data(model_data) {
if (!model_data?.data || !Array.isArray(model_data.data)) {
return { "_": { id: "No models found." } };
}
const parsed = {};
for (const m of model_data.data) {
parsed[m.id] = {
model_name: m.id,
id: m.id,
max_input_tokens: m.context_size || 8192,
description: m.description || m.name || m.id,
raw: m
};
}
return parsed;
}
/**
* Estimate tokens in user input.
* @param {string|Object} input - Input text or structured message
* @returns {Promise<number>} Token count estimate
*/
async count_tokens(input) {
const text = typeof input === "string" ? input : JSON.stringify(input);
return Math.ceil(text.length / 4);
}
/**
* Check if an incoming streaming chunk signals end of stream.
* @param {CustomEvent} event - SSE event with data
* @returns {boolean} True if end of stream
*/
is_end_of_stream(event) {
if (!event?.data) return false;
return event.data.includes('"done":true') || event.data.includes("[DONE]");
}
};
var SmartChatModelDeepseekRequestAdapter3 = class extends SmartChatModelRequestAdapter2 {
static {
__name(this, "SmartChatModelDeepseekRequestAdapter");
}
/**
* Convert incoming request to DeepSeek's expected format
* Often just reuse the base "to_openai()" if that matches DeepSeek's design
* @param {boolean} streaming - True if streaming
* @returns {Object} Request parameters
*/
to_platform(streaming = false) {
return this.to_openai(streaming);
}
};
var SmartChatModelDeepseekResponseAdapter3 = class extends SmartChatModelResponseAdapter2 {
static {
__name(this, "SmartChatModelDeepseekResponseAdapter");
}
};

var DeepseekChatCompletionModelAdapter = class extends SmartChatModelDeepseekAdapter3 {
static {
__name(this, "DeepseekChatCompletionModelAdapter");
}
constructor(model_item) {
super(model_item);
}
get http_adapter() {
if (!this._http_adapter) {
const HttpClass = this.model.env.config.modules.http_adapter.class;
const http_params = { ...this.model.env.config.modules.http_adapter, class: void 0 };
this._http_adapter = new HttpClass(http_params);
}
return this._http_adapter;
}
};
var settings_config33 = {
api_key: {
name: "API Key",
type: "password",
description: "Enter your Deepseek API key."
}
};
var deepseek_default = {
class: DeepseekChatCompletionModelAdapter,
settings_config: settings_config33
};

var SmartChatModelGoogleAdapter3 = class extends SmartChatModelApiAdapter2 {
static {
__name(this, "SmartChatModelGoogleAdapter");
}
static key = "google";
static defaults = {
description: "Google (Gemini)",
type: "API",
api_key_header: "none",
endpoint: "https://generativelanguage.googleapis.com/v1beta/models/MODEL_NAME:generateContent",
endpoint_streaming: "https://generativelanguage.googleapis.com/v1beta/models/MODEL_NAME:streamGenerateContent",
streaming: true,
adapter: "Gemini",
models_endpoint: "https://generativelanguage.googleapis.com/v1beta/models",
default_model: "gemini-1.5-pro",
signup_url: "https://ai.google.dev/"
};
streaming_chunk_splitting_regex = /(\r\n|\n|\r){2}/g;
/**
* Get request adapter class
*/
req_adapter = SmartChatModelGeminiRequestAdapter3;
/**
* Get response adapter class
*/
res_adapter = SmartChatModelGeminiResponseAdapter3;
/**
* Uses Gemini's dedicated token counting endpoint
*/
async count_tokens(input) {
const req = {
url: `https://generativelanguage.googleapis.com/v1beta/models/${this.model_key}:countTokens?key=${this.api_key}`,
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify(this.prepare_token_count_body(input))
};
const resp = await this.http_adapter.request(req);
return resp.json.totalTokens;
}
/**
* Formats input for token counting based on type
* @private
*/
prepare_token_count_body(input) {
if (typeof input === "string") {
return { contents: [{ parts: [{ text: input }] }] };
} else if (Array.isArray(input)) {
return { contents: input.map((msg) => this.transform_message_for_token_count(msg)) };
} else if (typeof input === "object") {
return { contents: [this.transform_message_for_token_count(input)] };
}
throw new Error("Invalid input for count_tokens");
}
/**
* Transforms message for token counting, handling text and images
* @private
*/
transform_message_for_token_count(message) {
return {
role: message.role === "assistant" ? "model" : message.role,
parts: Array.isArray(message.content) ? message.content.map((part) => {
if (part.type === "text") return { text: part.text };
if (part.type === "image_url") return {
inline_data: {
mime_type: part.image_url.url.split(";")[0].split(":")[1],
data: part.image_url.url.split(",")[1]
}
};
return part;
}) : [{ text: message.content }]
};
}
/**
* Builds endpoint URLs with model and API key
*/
get endpoint() {
return `https://generativelanguage.googleapis.com/v1beta/models/${this.model_key}:generateContent?key=${this.api_key}`;
}
get endpoint_streaming() {
return `https://generativelanguage.googleapis.com/v1beta/models/${this.model_key}:streamGenerateContent?key=${this.api_key}`;
}
/**
* Get models endpoint URL with API key
* @returns {string} Complete models endpoint URL
*/
get models_endpoint() {
return `${this.constructor.defaults.models_endpoint}?key=${this.api_key}`;
}
/**
* Get HTTP method for models endpoint
* @returns {string} HTTP method ("GET")
*/
get models_endpoint_method() {
return "GET";
}
get models_request_params() {
return {
url: this.models_endpoint,
method: this.models_endpoint_method
};
}
/**
* Parse model data from Gemini API response
* @param {Object} model_data - Raw model data from API
* @returns {Object} Map of model objects with capabilities and limits
*/
parse_model_data(model_data) {
return model_data.models.filter((model) => model.name.startsWith("models/gemini")).reduce((acc, model) => {
const out = {
model_name: model.name.split("/").pop(),
id: model.name.split("/").pop(),
max_input_tokens: model.inputTokenLimit,
max_output_tokens: model.maxOutputTokens,
description: model.description,
multimodal: model.name.includes("vision") || model.description.includes("multimodal"),
raw: model
};
acc[model.name.split("/").pop()] = out;
return acc;
}, {});
}
is_end_of_stream(event) {
return event.data.includes('"finishReason"');
return false;
}
};
var SmartChatModelGeminiRequestAdapter3 = class extends SmartChatModelRequestAdapter2 {
static {
__name(this, "SmartChatModelGeminiRequestAdapter");
}
to_platform(streaming = false) {
return this.to_gemini(streaming);
}
to_gemini(streaming = false) {
const gemini_body = {
contents: this._transform_messages_to_gemini(),
generationConfig: {
temperature: this.temperature,
maxOutputTokens: this.max_tokens,
topK: this._req.topK || 1,
topP: this._req.topP || 1,
stopSequences: this._req.stop || []
},
safetySettings: [
{
category: "HARM_CATEGORY_HARASSMENT",
threshold: "BLOCK_NONE"
},
{
category: "HARM_CATEGORY_HATE_SPEECH",
threshold: "BLOCK_NONE"
},
{
category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
threshold: "BLOCK_NONE"
},
{
category: "HARM_CATEGORY_DANGEROUS_CONTENT",
threshold: "BLOCK_NONE"
}
]
};
if (this.tools) gemini_body.tools = this._transform_tools_to_gemini();
if (gemini_body.tools && this.tool_choice !== "none") gemini_body.tool_config = this._transform_tool_choice_to_gemini();
return {
url: streaming ? this.adapter.endpoint_streaming : this.adapter.endpoint,
method: "POST",
headers: this.get_headers(),
body: JSON.stringify(gemini_body)
};
}
_transform_messages_to_gemini() {
let gemini_messages = [];
let system_message = "";
for (const message of this.messages) {
if (message.role === "system") {
system_message += message.content + "\n";
} else {
gemini_messages.push({
role: this._get_gemini_role(message.role),
parts: this._transform_content_to_gemini(message.content)
});
}
}
if (system_message) {
gemini_messages.unshift({
role: "user",
parts: [{ text: system_message.trim() }]
});
}
return gemini_messages;
}
_get_gemini_role(role) {
const role_map = {
user: "user",
assistant: "model",
function: "model"
};
return role_map[role] || role;
}
_transform_content_to_gemini(content) {
if (Array.isArray(content)) {
return content.map((part) => {
if (part.type === "text") return { text: part.text };
if (part.type === "image_url") {
let mime_type = part.image_url.url.split(";")[0].split(":")[1];
if (mime_type === "image/jpg") mime_type = "image/jpeg";
return {
inline_data: {
mime_type,
data: part.image_url.url.split(",")[1]
}
};
}
if (part.type === "file" && part.file?.filename?.toLowerCase().endsWith(".pdf")) {
if (part.file?.file_data) {
return {
inline_data: {
mime_type: "application/pdf",
data: part.file.file_data.split(",")[1]
}
};
}
}
return part;
});
}
return [{ text: content }];
}
_transform_tools_to_gemini() {
return [{
function_declarations: this.tools.map((tool2) => ({
name: tool2.function.name,
description: tool2.function.description,
parameters: tool2.function.parameters
}))
}];
}
_transform_tool_choice_to_gemini() {
return {
function_calling_config: {
mode: "ANY",
allowed_function_names: this.tools.map((tool2) => tool2.function.name)
}
};
}
};
var SmartChatModelGeminiResponseAdapter3 = class extends SmartChatModelResponseAdapter2 {
static {
__name(this, "SmartChatModelGeminiResponseAdapter");
}
static get platform_res() {
return {
candidates: [{
content: {
parts: [
{
text: ""
}
],
role: ""
},
finishReason: ""
}],
promptFeedback: {},
usageMetadata: {}
};
}
to_openai() {
if (this.error) return { error: normalize_error2(this.error, this.status) };
const first_candidate = this._res.candidates[0];
if (!this._res.id) this._res.id = "gemini-" + Date.now().toString();
return {
id: this._res.id,
object: "chat.completion",
created: Date.now(),
model: this.adapter.model_key,
choices: [{
index: 0,
message: first_candidate?.content ? this._transform_message_to_openai(first_candidate.content) : "",
finish_reason: this._get_openai_finish_reason(first_candidate.finishReason)
}],
usage: this._transform_usage_to_openai()
};
}
_transform_message_to_openai(content) {
const message = {
role: "assistant",
content: content.parts.filter((part) => part.text).map((part) => part.text).join("")
};
const function_call = content.parts.find((part) => part.functionCall);
if (function_call) {
message.tool_calls = [{
type: "function",
function: {
name: function_call.functionCall.name,
arguments: JSON.stringify(function_call.functionCall.args)
}
}];
}
return message;
}
_get_openai_finish_reason(finish_reason) {
const reason_map = {
"STOP": "stop",
"MAX_TOKENS": "length",
"SAFETY": "content_filter",
"RECITATION": "content_filter",
"OTHER": "null"
};
return reason_map[finish_reason] || finish_reason.toLowerCase();
}
_transform_usage_to_openai() {
if (!this._res.usageMetadata) {
return {
prompt_tokens: null,
completion_tokens: null,
total_tokens: null
};
}
return {
prompt_tokens: this._res.usageMetadata.promptTokenCount || null,
completion_tokens: this._res.usageMetadata.candidatesTokenCount || null,
total_tokens: this._res.usageMetadata.totalTokenCount || null
};
}
handle_chunk(chunk) {
let chunk_trimmed = chunk.trim();
if (["[", ","].includes(chunk_trimmed[0])) chunk_trimmed = chunk_trimmed.slice(1);
if (["]", ","].includes(chunk_trimmed[chunk_trimmed.length - 1])) chunk_trimmed = chunk_trimmed.slice(0, -1);
const data = JSON.parse(chunk_trimmed);
let raw;
if (data.candidates?.[0]?.content?.parts?.[0]?.text?.length) {
const content = data.candidates[0].content.parts[0].text;
raw = content;
this._res.candidates[0].content.parts[0].text += content;
}
if (data.candidates?.[0]?.content?.role?.length) {
this._res.candidates[0].content.role = data.candidates[0].content.role;
}
if (data.candidates?.[0]?.finishReason?.length) {
this._res.candidates[0].finishReason += data.candidates[0].finishReason;
}
if (data.promptFeedback) {
this._res.promptFeedback = {
...this._res.promptFeedback || {},
...data.promptFeedback
};
}
if (data.usageMetadata) {
this._res.usageMetadata = {
...this._res.usageMetadata || {},
...data.usageMetadata
};
}
if (data.candidates?.[0]?.content?.parts?.[0]?.functionCall) {
if (!this._res.candidates[0].content.parts[0].functionCall) {
this._res.candidates[0].content.parts[0].functionCall = {
name: "",
args: {}
};
}
this._res.candidates[0].content.parts[0].functionCall.name += data.candidates[0].content.parts[0].functionCall.name;
if (data.candidates[0].content.parts[0].functionCall.args) {
Object.entries(data.candidates[0].content.parts[0].functionCall.args).forEach(([key, value]) => {
if (!this._res.candidates[0].content.parts[0].functionCall.args[key]) {
this._res.candidates[0].content.parts[0].functionCall.args[key] = "";
}
this._res.candidates[0].content.parts[0].functionCall.args[key] += value;
});
}
}
return raw;
}
};

var GoogleChatCompletionModelAdapter = class extends SmartChatModelGoogleAdapter3 {
static {
__name(this, "GoogleChatCompletionModelAdapter");
}
constructor(model_item) {
super(model_item);
}
get http_adapter() {
if (!this._http_adapter) {
const HttpClass = this.model.env.config.modules.http_adapter.class;
const http_params = { ...this.model.env.config.modules.http_adapter, class: void 0 };
this._http_adapter = new HttpClass(http_params);
}
return this._http_adapter;
}
};
var settings_config34 = {
api_key: {
name: "API Key",
type: "password",
description: "Enter your Google Gemini API key."
}
};
var google_default2 = {
class: GoogleChatCompletionModelAdapter,
settings_config: settings_config34
};

var SmartChatModelGroqAdapter3 = class extends SmartChatModelApiAdapter2 {
static {
__name(this, "SmartChatModelGroqAdapter");
}
static key = "groq";
static defaults = {
description: "Groq",
type: "API",
endpoint: "https://api.groq.com/openai/v1/chat/completions",
streaming: true,
adapter: "Groq",
models_endpoint: "https://api.groq.com/openai/v1/models",
default_model: "llama3-8b-8192",
signup_url: "https://groq.com"
};
/**
* Request adapter class
* @returns {typeof SmartChatModelGroqRequestAdapter}
*/
get req_adapter() {
return SmartChatModelGroqRequestAdapter3;
}
/**
* Response adapter class
* @returns {typeof SmartChatModelGroqResponseAdapter}
*/
get res_adapter() {
return SmartChatModelGroqResponseAdapter3;
}
get models_endpoint_method() {
return "GET";
}
/**
* Parse model data from Groq API format to a dictionary keyed by model ID.
* The API returns a list of model objects like:
* {
*   "object": "list",
*   "data": [ { "id": "...", "object": "model", ... }, ... ]
* }
*
* We'll convert each model to:
* {
*   model_name: model.id,
*   id: model.id,
*   max_input_tokens: model.context_window,
*   description: `Owned by: ${model.owned_by}, context: ${model.context_window}`,
*   multimodal: Check if model name or description suggests multimodality
* }
*/
parse_model_data(model_data) {
if (model_data.object !== "list" || !Array.isArray(model_data.data)) {
return { "_": { id: "No models found." } };
}
const parsed = {};
for (const m of model_data.data) {
parsed[m.id] = {
model_name: m.id,
id: m.id,
max_input_tokens: m.context_window || 8192,
description: `Owned by: ${m.owned_by}, context: ${m.context_window}`,
multimodal: m.id.includes("vision")
};
}
return parsed;
}
};
var SmartChatModelGroqRequestAdapter3 = class extends SmartChatModelRequestAdapter2 {
static {
__name(this, "SmartChatModelGroqRequestAdapter");
}
_get_openai_content(message) {
if (["assistant", "tool"].includes(message.role)) {
if (Array.isArray(message.content)) {
return message.content.map((part) => {
if (typeof part === "string") return part;
if (part?.text) return part.text;
return "";
}).join("\n");
}
}
return message.content;
}
};
var SmartChatModelGroqResponseAdapter3 = class extends SmartChatModelResponseAdapter2 {
static {
__name(this, "SmartChatModelGroqResponseAdapter");
}
};

var GroqChatCompletionModelAdapter = class extends SmartChatModelGroqAdapter3 {
static {
__name(this, "GroqChatCompletionModelAdapter");
}
constructor(model_item) {
super(model_item);
}
get http_adapter() {
if (!this._http_adapter) {
const HttpClass = this.model.env.config.modules.http_adapter.class;
const http_params = { ...this.model.env.config.modules.http_adapter, class: void 0 };
this._http_adapter = new HttpClass(http_params);
}
return this._http_adapter;
}
};
var settings_config35 = {
api_key: {
name: "API Key",
type: "password",
description: "Enter your Groq API key."
}
};
var groq_default = {
class: GroqChatCompletionModelAdapter,
settings_config: settings_config35
};

var SmartChatModelLmStudioAdapter3 = class extends SmartChatModelApiAdapter2 {
static {
__name(this, "SmartChatModelLmStudioAdapter");
}
static key = "lm_studio";
/** @type {import('./_adapter.js').SmartChatModelAdapter['constructor']['defaults']} */
static defaults = {
description: "LM Studio (OpenAI\u2011compatible)",
type: "API",
endpoint: "http://localhost:1234/v1/chat/completions",
streaming: true,
adapter: "LM_Studio_OpenAI_Compat",
models_endpoint: "http://localhost:1234/v1/models",
default_model: "",
signup_url: "https://lmstudio.ai/docs/api/openai-api",
api_key: "no api key required"
};
/* ------------------------------------------------------------------ *
*  Request / Response classes
* ------------------------------------------------------------------ */
get req_adapter() {
return SmartChatModelLmStudioRequestAdapter3;
}
get res_adapter() {
return SmartChatModelLmStudioResponseAdapter3;
}
/* ------------------------------------------------------------------ *
*  Settings
* ------------------------------------------------------------------ */
/**
* Extend the base settings with a read‑only HTML block that reminds the
* user to enable CORS inside LM Studio. The Smart View renderer treats
* `type: "html"` as a static fragment, so no extra runtime logic is needed.
*/
get settings_config() {
const config = super.settings_config;
delete config["[CHAT_ADAPTER].api_key"];
return {
...config,
"[CHAT_ADAPTER].cors_instructions": {
/* visible only when this adapter is selected */
name: "CORS required",
type: "html",
value: `<p>Before you can use LM Studio you must <strong>Enable CORS</strong> inside LM Studio \u2192 Developer \u2192 Settings</p>`
}
};
}
/* ------------------------------------------------------------------ *
*  Model list helpers
* ------------------------------------------------------------------ */
/**
* LM Studio returns an OpenAI‑style list; normalise to the project shape.
*/
parse_model_data(model_data) {
if (model_data.object !== "list" || !Array.isArray(model_data.data)) {
return { _: { id: "No models found." } };
}
const out = {};
for (const m of model_data.data) {
out[m.id] = {
id: m.id,
model_name: m.id,
description: `LM Studio model: ${m.id}`,
multimodal: false
};
}
return out;
}
get models_endpoint_method() {
return "get";
}
/**
* Count tokens in input text (no dedicated endpoint)
* Rough estimate: 1 token ~ 4 chars
* @param {string|Object} input
* @returns {Promise<number>}
*/
async count_tokens(input) {
const text = typeof input === "string" ? input : JSON.stringify(input);
return Math.ceil(text.length / 4);
}
/**
* Test API key - LM Studio doesn't require API key. Always true.
* @returns {Promise<boolean>}
*/
async test_api_key() {
return true;
}
get api_key() {
return "no api key required";
}
};
var SmartChatModelLmStudioRequestAdapter3 = class extends SmartChatModelRequestAdapter2 {
static {
__name(this, "SmartChatModelLmStudioRequestAdapter");
}
to_platform(streaming = false) {
const req = this.to_openai(streaming);
const body = JSON.parse(req.body);
if (this.tool_choice?.function?.name) {
const last_msg = body.messages[body.messages.length - 1];
if (typeof last_msg.content === "string") {
last_msg.content = [
{ type: "text", text: last_msg.content }
];
}
last_msg.content.push({
type: "text",
text: `Use the "${this.tool_choice.function.name}" tool.`
});
body.tool_choice = "required";
} else if (body.tool_choice && typeof body.tool_choice === "object") {
body.tool_choice = "auto";
}
req.body = JSON.stringify(body);
return req;
}
};
var SmartChatModelLmStudioResponseAdapter3 = class extends SmartChatModelResponseAdapter2 {
static {
__name(this, "SmartChatModelLmStudioResponseAdapter");
}
};

var LmStudioChatCompletionModelAdapter = class extends SmartChatModelLmStudioAdapter3 {
static {
__name(this, "LmStudioChatCompletionModelAdapter");
}
constructor(model_item) {
super(model_item);
}
get http_adapter() {
if (!this._http_adapter) {
const HttpClass = this.model.env.config.modules.http_adapter.class;
const http_params = { ...this.model.env.config.modules.http_adapter, class: void 0 };
this._http_adapter = new HttpClass(http_params);
}
return this._http_adapter;
}
};
var settings_config36 = {
};
var lm_studio_default2 = {
class: LmStudioChatCompletionModelAdapter,
settings_config: settings_config36
};

var SmartChatModelOllamaAdapter3 = class extends SmartChatModelApiAdapter2 {
static {
__name(this, "SmartChatModelOllamaAdapter");
}
static key = "ollama";
static defaults = {
description: "Ollama (Local)",
type: "API",
api_key: "na",
host: "http://localhost:11434",
endpoint: "/api/chat",
models_endpoint: "/api/tags",
streaming: true
};
req_adapter = SmartChatModelOllamaRequestAdapter3;
res_adapter = SmartChatModelOllamaResponseAdapter3;
get host() {
return this.model.data.host || this.constructor.defaults.host;
}
get endpoint() {
return `${this.host}${this.constructor.defaults.endpoint}`;
}
get models_endpoint() {
return `${this.host}${this.constructor.defaults.models_endpoint}`;
}
get model_show_endpoint() {
return `${this.host}/api/show`;
}
get models_endpoint_method() {
return "GET";
}
/**
* Get available models from local Ollama instance
* @param {boolean} [refresh=false] - Whether to refresh cached models
* @returns {Promise<Object>} Map of model objects
*/
async get_models(refresh = false) {
if (!refresh && typeof this.model_data === "object" && Object.keys(this.model_data || {}).length > 0 && this.model_data_loaded_at && time_now - this.model_data_loaded_at < 1 * 60 * 60 * 1e3) return this.model_data;
try {
const list_resp = await this.http_adapter.request(this.models_request_params);
const list_data = await list_resp.json();
const models_raw_data = [];
for (const model of list_data.models) {
const model_details_resp = await this.http_adapter.request({
url: this.model_show_endpoint,
method: "POST",
body: JSON.stringify({ model: model.name })
});
const model_details_data = await model_details_resp.json();
models_raw_data.push({ ...model_details_data, name: model.name });
}
this.model_data = this.parse_model_data(models_raw_data);
await this.get_enriched_model_data();
this.model.data.provider_models = this.model_data;
if (typeof this.model.re_render_settings === "function") {
this.model.re_render_settings();
}
this.model_data_loaded_at = Date.now();
return this.model_data;
} catch (error) {
console.error("Failed to fetch model data:", error);
return { "_": { id: `Failed to fetch models from ${this.model.adapter_name}` } };
}
}
/**
* Parse model data from Ollama API response
* @param {Object[]} model_data - Raw model data from Ollama
* @returns {Object} Map of model objects with capabilities and limits
*/
parse_model_data(model_data) {
if (!Array.isArray(model_data)) {
this.model_data = {};
console.error("Invalid model data format from Ollama:", model_data);
return {};
}
if (model_data.length === 0) {
this.model_data = { "no_models_available": {
id: "no_models_available",
name: "No models currently available"
} };
return this.model_data;
}
return model_data.reduce((acc, model) => {
if (model.name.includes("embed")) return acc;
const out = {
model_name: model.name,
id: model.name,
multimodal: false,
max_input_tokens: Object.entries(model.model_info).find((m) => m[0].includes(".context_length"))[1]
};
acc[model.name] = out;
return acc;
}, {});
}
/**
* Override settings config to remove API key setting since not needed for local instance
* @returns {Object} Settings configuration object
*/
get settings_config() {
const config = super.settings_config;
delete config["[CHAT_ADAPTER].api_key"];
config["[CHAT_ADAPTER].host"] = {
name: "Ollama host",
type: "text",
description: "Enter the host for your Ollama instance",
default: this.constructor.defaults.host
};
return config;
}
is_end_of_stream(event) {
return event.data.includes('"done_reason"');
}
};
var SmartChatModelOllamaRequestAdapter3 = class extends SmartChatModelRequestAdapter2 {
static {
__name(this, "SmartChatModelOllamaRequestAdapter");
}
/**
* Convert request to Ollama format
* @returns {Object} Request parameters in Ollama format
*/
to_platform(streaming = false) {
const ollama_body = {
model: this.model_id,
messages: this._transform_messages_to_ollama(),
options: this._transform_parameters_to_ollama(),
stream: streaming || this.stream
};
if (this.tools) {
ollama_body.tools = this._transform_functions_to_tools();
if (this.tool_choice?.function?.name) {
ollama_body.messages[ollama_body.messages.length - 1].content += `

Use the "${this.tool_choice.function.name}" tool.`;
ollama_body.format = "json";
}
}
return {
url: this.adapter.endpoint,
method: "POST",
body: JSON.stringify(ollama_body)
};
}
/**
* Transform messages to Ollama format
* @returns {Array} Messages in Ollama format
* @private
*/
_transform_messages_to_ollama() {
return this.messages.map((message) => {
const ollama_message = {
role: message.role,
content: this._transform_content_to_ollama(message.content)
};
const images = this._extract_images_from_content(message.content);
if (images.length > 0) {
ollama_message.images = images.map((img) => img.replace(/^data:image\/[^;]+;base64,/, ""));
}
return ollama_message;
});
}
/**
* Transform content to Ollama format
* @param {string|Array} content - Message content
* @returns {string} Content in Ollama format
* @private
*/
_transform_content_to_ollama(content) {
if (Array.isArray(content)) {
return content.filter((item) => item.type === "text").map((item) => item.text).join("\n");
}
return content;
}
/**
* Extract images from content
* @param {string|Array} content - Message content
* @returns {Array} Array of image URLs
* @private
*/
_extract_images_from_content(content) {
if (!Array.isArray(content)) return [];
return content.filter((item) => item.type === "image_url").map((item) => item.image_url.url);
}
/**
* Transform functions to tools format
* @returns {Array} Tools array in Ollama format
* @private
*/
_transform_functions_to_tools() {
return this.tools;
}
/**
* Transform parameters to Ollama options format
* @returns {Object} Options in Ollama format
* @private
*/
_transform_parameters_to_ollama() {
const options = {};
if (this.max_tokens) options.num_predict = this.max_tokens;
if (this.temperature) options.temperature = this.temperature;
if (this.top_p) options.top_p = this.top_p;
if (this.frequency_penalty) options.frequency_penalty = this.frequency_penalty;
if (this.presence_penalty) options.presence_penalty = this.presence_penalty;
return options;
}
};
var SmartChatModelOllamaResponseAdapter3 = class extends SmartChatModelResponseAdapter2 {
static {
__name(this, "SmartChatModelOllamaResponseAdapter");
}
static get platform_res() {
return {
model: "",
created_at: null,
message: {
role: "",
content: ""
},
total_duration: 0,
load_duration: 0,
prompt_eval_count: 0,
prompt_eval_duration: 0,
eval_count: 0,
eval_duration: 0
};
}
/**
* Convert response to OpenAI format
* @returns {Object} Response in OpenAI format
*/
to_openai() {
if (this.error) return { error: normalize_error2(this.error, this.status) };
return {
id: this._res.created_at,
object: "chat.completion",
created: Date.now(),
model: this._res.model,
choices: [
{
index: 0,
message: this._transform_message_to_openai(),
finish_reason: this._res.done_reason
}
],
usage: this._transform_usage_to_openai()
};
}
/**
* Transform message to OpenAI format
* @returns {Object} Message in OpenAI format
* @private
*/
_transform_message_to_openai() {
return {
role: this._res.message.role,
content: this._res.message.content,
tool_calls: this._res.message.tool_calls
};
}
/**
* Transform usage statistics to OpenAI format
* @returns {Object} Usage statistics in OpenAI format
* @private
*/
_transform_usage_to_openai() {
return {
prompt_tokens: this._res.prompt_eval_count || 0,
completion_tokens: this._res.eval_count || 0,
total_tokens: (this._res.prompt_eval_count || 0) + (this._res.eval_count || 0)
};
}
/**
* Parse chunk adds delta to content as expected output format
*/
handle_chunk(chunk) {
chunk = JSON.parse(chunk || "{}");
if (chunk.created_at && !this._res.created_at) {
this._res.created_at = chunk.created_at;
}
let raw;
if (chunk.message?.content) {
const content = chunk.message.content;
raw = content;
this._res.message.content += content;
}
if (chunk.message?.role) {
this._res.message.role = chunk.message.role;
}
if (chunk.model) {
this._res.model = chunk.model;
}
if (chunk.message?.tool_calls) {
if (!this._res.message.tool_calls) {
this._res.message.tool_calls = [{
id: "",
type: "function",
function: {
name: "",
arguments: ""
}
}];
}
if (chunk.message.tool_calls[0].id) {
this._res.message.tool_calls[0].id += chunk.message.tool_calls[0].id;
}
if (chunk.message.tool_calls[0].function.name) {
this._res.message.tool_calls[0].function.name += chunk.message.tool_calls[0].function.name;
}
if (chunk.message.tool_calls[0].function.arguments) {
if (typeof chunk.message.tool_calls[0].function.arguments === "string") {
this._res.message.tool_calls[0].function.arguments += chunk.message.tool_calls[0].function.arguments;
} else {
this._res.message.tool_calls[0].function.arguments = chunk.message.tool_calls[0].function.arguments;
}
}
}
return raw;
}
};

var OllamaChatCompletionModelAdapter = class extends SmartChatModelOllamaAdapter3 {
static {
__name(this, "OllamaChatCompletionModelAdapter");
}
constructor(model_item) {
super(model_item);
}
get http_adapter() {
if (!this._http_adapter) {
const HttpClass = this.model.env.config.modules.http_adapter.class;
const http_params = { ...this.model.env.config.modules.http_adapter, class: void 0 };
this._http_adapter = new HttpClass(http_params);
}
return this._http_adapter;
}
};
var settings_config37 = {
"host": {
name: "Ollama host",
type: "text",
description: "Enter the host for your Ollama instance",
default: "http://localhost:11434"
}
};
var ollama_default2 = {
class: OllamaChatCompletionModelAdapter,
settings_config: settings_config37
};

var OpenAIChatCompletionModelAdapter = class extends SmartChatModelOpenaiAdapter3 {
static {
__name(this, "OpenAIChatCompletionModelAdapter");
}
constructor(model_item) {
super(model_item);
}
get http_adapter() {
if (!this._http_adapter) {
const HttpClass = this.model.env.config.modules.http_adapter.class;
const http_params = { ...this.model.env.config.modules.http_adapter, class: void 0 };
this._http_adapter = new HttpClass(http_params);
}
return this._http_adapter;
}
};
var settings_config38 = {
"api_key": {
name: "API Key",
type: "password",
description: "Enter your OpenAI API key."
},
"openai_note": {
name: "Note about using OpenAI",
type: "html",
value: "<b>OpenAI models:</b> Some models require extra verification steps in your OpenAI account for them to appear in the model list."
}
};
var openai_default2 = {
class: OpenAIChatCompletionModelAdapter,
settings_config: settings_config38
};

var SmartChatModelXaiAdapter3 = class extends SmartChatModelApiAdapter2 {
static {
__name(this, "SmartChatModelXaiAdapter");
}
/** Human-readable platform key used by SmartChatModel */
static key = "xai";
/** @type {import('./_adapter.js').SmartChatModelAdapter['constructor']['defaults']} */
static defaults = {
description: "xAI Grok",
type: "API",
adapter: "xAI_Grok",
endpoint: "https://api.x.ai/v1/chat/completions",
streaming: true,
models_endpoint: "https://api.x.ai/v1/models",
default_model: "grok-3-mini-beta",
signup_url: "https://ide.x.ai"
};
/** Grok is OpenAI-compatible → reuse the stock adapters */
get req_adapter() {
return SmartChatModelRequestAdapter2;
}
get res_adapter() {
return SmartChatModelResponseAdapter2;
}
/* ------------------------------------------------------------------ *
*  Model-list helpers
* ------------------------------------------------------------------ */
/**
* The Grok `/v1/models` route is **GET**, not POST.
* Override the HTTP verb so `get_models()` works.
* @returns {string} 'GET'
*/
get models_endpoint_method() {
return "GET";
}
/**
* Parse `/v1/models` payload to the canonical shape used by SmartChat.
*
* Grok returns:
* ```json
* { "object":"list",
*   "data":[{ "id":"grok-3-beta", "context_length":128000, …}] }
* ```
*/
parse_model_data(model_data = {}) {
const list = model_data.data || model_data.models || [];
return list.reduce((acc, m) => {
const id = m.id || m.name;
acc[id] = {
id,
model_name: id,
description: m.description || `context: ${m.context_length || "n/a"}`,
max_input_tokens: m.context_length || 128e3,
multimodal: !!m.modality && m.modality.includes("vision"),
raw: m
};
return acc;
}, {});
}
};

var XaiChatCompletionModelAdapter = class extends SmartChatModelXaiAdapter3 {
static {
__name(this, "XaiChatCompletionModelAdapter");
}
constructor(model_item) {
super(model_item);
}
get http_adapter() {
if (!this._http_adapter) {
const HttpClass = this.model.env.config.modules.http_adapter.class;
const http_params = { ...this.model.env.config.modules.http_adapter, class: void 0 };
this._http_adapter = new HttpClass(http_params);
}
return this._http_adapter;
}
};
var settings_config39 = {
"api_key": {
name: "API Key",
type: "password",
description: "Enter your xAI API key."
}
};
var xai_default = {
class: XaiChatCompletionModelAdapter,
settings_config: settings_config39
};

var smart_env_config6 = {
collections: {
embedding_models: {
providers: {
gemini: google_default,
lm_studio: lm_studio_default,
ollama: ollama_default,
open_router: open_router_default2,
openai: openai_default
}
},
chat_completion_models: {
providers: {
anthropic: anthropic_default,
azure: azure_default,
cohere: cohere_default2,
deepseek: deepseek_default,
google: google_default2,
groq: groq_default,
lm_studio: lm_studio_default2,
ollama: ollama_default2,
open_router: open_router_default,
openai: openai_default2,
xai: xai_default
}
}
}
};

var import_obsidian93 = require("obsidian");
async function update_installed_smart_plugins(env) {
const app = env.plugin?.app || window.app;
const oauth_storage_prefix = get_oauth_storage_prefix2(app);
const token = (typeof localStorage !== "undefined" ? localStorage.getItem(oauth_storage_prefix + "token") : "") || "";
if (!token) {
console.warn("[smart_plugins] No OAuth token found; skipping Smart Plugins auto\u2011update.");
show_notice("Smart Plugins: connect your Smart Plugins account to keep using Pro plugins.");
const auth_misses_key = oauth_storage_prefix + "auth_misses";
const current_misses = parseInt(localStorage.getItem(auth_misses_key) || "0", 10);
localStorage.setItem(auth_misses_key, (current_misses + 1).toString());
return { updated: [], skipped: [], checked: 0 };
}
try {
const installed_map = await build_installed_plugins_map(app);
console.log("[smart_plugins] Built installed plugins map:", installed_map);
const resp = await fetch_server_plugin_list2(token);
console.log("[smart_plugins] Fetched server plugin list:", resp);
const server_list = Array.isArray(resp.list) ? resp.list : [];
const unauthorized_list = Array.isArray(resp.unauthorized) ? resp.unauthorized : [];
const sub_exp = resp.sub_exp;
const has_expired = typeof sub_exp === "number" && sub_exp < Date.now();
const removed = [];
const replaced = [];
const not_installed = [];
if (has_expired) {
if (unauthorized_list.length) {
console.log("[smart_plugins] Subscription expired; handling unauthorized plugins.", {
unauthorized_list
});
for (const list_item of unauthorized_list) {
if (!installed_map[list_item.plugin_id]) {
not_installed.push(list_item.plugin_id);
continue;
}
if (!list_item.core_repo) {
const removed_item = await remove_main_js_for_plugin(app, list_item.plugin_id);
if (removed_item) {
removed.push(list_item.plugin_id);
}
continue;
} else {
const replaced_item = await replace_pro_with_core(app, list_item);
if (replaced_item) replaced.push(list_item.plugin_id);
}
}
}
const update_result = {
updated: [],
skipped: [],
checked: 0,
removed,
replaced,
not_installed,
unauthorized_count: unauthorized_list.length,
sub_exp: sub_exp || null
};
console.log({ update_result });
return update_result;
}
const checked = server_list.length;
const plugins_to_update = [];
for (const item of server_list) {
if (!item || !item.repo) continue;
const server_version = item.version || "unknown";
const plugin_id = (item.manifest_id || item.repo.replace("/", "_")).trim();
const local = installed_map[plugin_id];
if (!local || !local.version) {
continue;
}
if (is_server_version_newer2(local.version, server_version)) {
plugins_to_update.push({
item,
plugin_id,
local_version: local.version,
server_version
});
}
}
if (!plugins_to_update.length) {
return { updated: [], skipped: [], checked };
}
const updated = [];
const skipped = [];
for (const entry of plugins_to_update) {
const { item, plugin_id, local_version, server_version } = entry;
try {
const zip_buffer = await fetch_plugin_zip3(item.repo, token);
const { files, pluginManifest } = await parse_zip_into_files3(zip_buffer);
const folder_name = pluginManifest.id;
const base_folder = `${app.vault.configDir}/plugins/${folder_name}`;
await write_files_with_adapter3(app.vault.adapter, base_folder, files);
updated.push(`${item.repo}@${server_version}`);
} catch (err) {
console.error("[smart_plugins] Failed to auto\u2011update plugin:", {
repo: item.repo,
plugin_id,
local_version,
server_version,
error: err
});
skipped.push(item.repo);
}
}
if (updated.length) {
const plural = updated.length === 1 ? "" : "s";
show_notice(
`Smart Plugins: updated ${updated.length} plugin${plural}. Please restart Obsidian to apply updates.`
);
} else if (!skipped.length) {
show_notice("Smart Plugins: no updates applied.");
}
return { updated, skipped, checked };
} catch (err) {
console.error("[smart_plugins] update_installed_smart_plugins error:", err);
show_notice("Smart Plugins: failed to check for updates. See console for details.");
return { updated: [], skipped: [], checked: 0 };
}
}
__name(update_installed_smart_plugins, "update_installed_smart_plugins");
async function replace_pro_with_core(app, plugin) {
const resp = await (0, import_obsidian93.requestUrl)({
url: `https://api.github.com/repos/${plugin.core_repo}/releases/latest`,
method: "GET"
});
const parsed = resp?.json || {};
const version2 = parsed?.tag_name || null;
if (!version2) {
console.error("[smart_plugins] Failed to get latest core plugin version from GitHub:", {
core_repo: plugin.core_repo,
response: resp
});
return null;
}
try {
const zip_asset_url = parsed?.assets?.find((a) => a.name.endsWith(".zip"))?.browser_download_url || null;
if (!zip_asset_url) {
console.error("[smart_plugins] Failed to find core plugin zip asset in GitHub release:", {
core_repo: plugin.core_repo,
release: parsed
});
return null;
}
const zip_data = await fetch_zip_from_public_url(zip_asset_url);
const { files, pluginManifest } = await parse_zip_into_files3(zip_data);
const folder_name = plugin.plugin_id;
const base_folder = `${app.vault.configDir}/plugins/${folder_name}`;
await write_files_with_adapter3(app.vault.adapter, base_folder, files);
return true;
} catch (err) {
console.error("[smart_plugins] Failed to install core plugin:", {
core_repo: plugin.core_repo,
error: err
});
return null;
}
}
__name(replace_pro_with_core, "replace_pro_with_core");
async function fetch_zip_from_public_url(download_url) {
console.log(`[smart_plugins] download plugin from URL: ${download_url}`);
const resp = await (0, import_obsidian93.requestUrl)({
url: download_url,
method: "GET",
headers: { Accept: "application/zip" }
});
if (resp.status && resp.status !== 200) {
throw new Error(`Download error ${resp.status}: ${resp.text || ""}`);
}
return validate_zip_buffer2(resp.arrayBuffer, "Download");
}
__name(fetch_zip_from_public_url, "fetch_zip_from_public_url");
async function build_installed_plugins_map(app) {
const installed_map = {};
const plugins_api = app.plugins;
if (!plugins_api) return installed_map;
await plugins_api.loadManifests();
const manifests = plugins_api.manifests || {};
for (const plugin_id in manifests) {
if (!Object.prototype.hasOwnProperty.call(manifests, plugin_id)) continue;
const manifest = manifests[plugin_id] || {};
installed_map[plugin_id] = {
id: manifest.id || plugin_id,
name: manifest.name || plugin_id,
version: manifest.version || ""
};
}
return installed_map;
}
__name(build_installed_plugins_map, "build_installed_plugins_map");
function show_notice(message) {
try {
if (typeof import_obsidian93.Notice === "function") {
new import_obsidian93.Notice(message);
} else {
console.log("[smart_plugins]", message);
}
} catch (err) {
console.log("[smart_plugins] notice error", err, message);
}
}
__name(show_notice, "show_notice");
async function remove_main_js_for_plugin(app, plugin_id) {
const adapter = app?.vault?.adapter;
if (!adapter) return false;
const base_folder = `${app.vault.configDir}/plugins/${plugin_id}`;
const main_path = `${base_folder}/main.js`;
const manifest_path = `${base_folder}/manifest.json`;
try {
if (await adapter.exists(main_path)) {
await adapter.remove(main_path);
}
if (await adapter.exists(manifest_path)) {
await adapter.remove(manifest_path);
}
return true;
} catch (err) {
console.error("[smart_plugins] Failed to remove main.js for unauthorized plugin", {
plugin_id,
error: err
});
}
return false;
}
__name(remove_main_js_for_plugin, "remove_main_js_for_plugin");

var SmartEnv5 = class _SmartEnv extends SmartEnv4 {
static {
__name(this, "SmartEnv");
}
static version = "2.3.11";
is_pro = true;
async load(force_load = false) {
await super.load(force_load);
_SmartEnv.wait_for({ loaded: true }).then(async () => {
console.warn("[smart_env] Checking for Smart Plugins updates...");
update_installed_smart_plugins(this);
if (!this._registered_refresh_event) {
this._registered_refresh_event = true;
this.events.on("pro_plugins:refresh", async () => {
console.warn("[smart_env] Refreshing Smart Plugins list...");
update_installed_smart_plugins(this);
});
}
});
}
};
var version = SmartEnv5.version;

var smart_env_config7 = merge_env_config2(smart_env_config3, smart_env_config6);

var settings_tab_default = "@media (max-width: 768px) {\r\n  .smart-chat-model-settings-container .setting-item {\r\n    flex-direction: column;\r\n    align-items: flex-start;\r\n  }\r\n}\r\n";

var SmartChatSettingTab = class extends SmartPluginSettingsTab {
static {
__name(this, "SmartChatSettingTab");
}
/**
* @param {import('obsidian').App} app - The current Obsidian app instance
* @param {import('./main.js').default} plugin - The main plugin object
*/
constructor(app, plugin) {
super(app, plugin);
this.plugin = plugin;
this.name = "Chat Pro";
this.id = "smart-chat";
this.icon = "smart-chat";
}
async render_plugin_settings(container) {
if (!container) return;
container.empty?.();
if (!this.env) {
container.createEl?.("p", { text: "Smart Environment not yet initialized." });
return;
}
this.env.smart_view.apply_style_sheet(settings_tab_default);
const chat_container = container.createDiv({ cls: "smart-chat-settings-container" });
const model_container = container.createDiv({ cls: "smart-chat-model-settings-container" });
this.env.smart_components.render_component("settings_env_model_type", this.env.chat_completion_models).then((settings_el) => {
model_container.empty?.();
model_container.appendChild(settings_el);
});
render_settings_config(
this.env.chat_threads.settings_config,
this.env.chat_threads,
chat_container
);
}
};

var CollectionDataAdapter4 = class {
static {
__name(this, "CollectionDataAdapter");
}
/**
* @constructor
* @param {Object} collection - The collection instance that this adapter manages.
*/
constructor(collection) {
this.collection = collection;
this.env = collection.env;
}
/**
* The class to use for item adapters.
* @type {typeof ItemDataAdapter}
*/
ItemDataAdapter = ItemDataAdapter4;
/**
* Optional factory method to create item adapters.
* If `this.item_adapter_class` is not null, it uses that; otherwise can be overridden by subclasses.
* @param {Object} item - The item to create an adapter for.
* @returns {ItemDataAdapter}
*/
create_item_adapter(item) {
if (!this.ItemDataAdapter) {
throw new Error("No item_adapter_class specified and create_item_adapter not overridden.");
}
return new this.ItemDataAdapter(item);
}
/**
* Load a single item by its key using an `ItemDataAdapter`.
* @async
* @abstract
* @param {string} key - The key of the item to load.
* @returns {Promise<void>} Resolves when the item is loaded.
*/
async load_item(key) {
throw new Error("Not implemented");
}
/**
* Save a single item by its key using its associated `ItemDataAdapter`.
* @async
* @abstract
* @param {string} key - The key of the item to save.
* @returns {Promise<void>} Resolves when the item is saved.
*/
async save_item(key) {
throw new Error("Not implemented");
}
/**
* Delete a single item by its key. This may involve updating or removing its file,
* as handled by the `ItemDataAdapter`.
* @async
* @abstract
* @param {string} key - The key of the item to delete.
* @returns {Promise<void>} Resolves when the item is deleted.
*/
async delete_item(key) {
throw new Error("Not implemented");
}
/**
* Process any queued load operations. Typically orchestrates calling `load_item()`
* on items that have been flagged for loading.
* @async
* @abstract
* @returns {Promise<void>}
*/
async process_load_queue() {
throw new Error("Not implemented");
}
/**
* Process any queued save operations. Typically orchestrates calling `save_item()`
* on items that have been flagged for saving.
* @async
* @abstract
* @returns {Promise<void>}
*/
async process_save_queue() {
throw new Error("Not implemented");
}
/**
* Load the item's data from storage if it has been updated externally.
* @async
* @param {string} key - The key of the item to load.
* @returns {Promise<void>} Resolves when the item is loaded.
*/
async load_item_if_updated(item) {
const adapter = this.create_item_adapter(item);
await adapter.load_if_updated();
}
/**
* Clear all data associated with this collection.
* @async
* @abstract
* @returns {Promise<void>}
*/
async clear_all() {
throw new Error("Not implemented");
}
};
var ItemDataAdapter4 = class {
static {
__name(this, "ItemDataAdapter");
}
/**
* @constructor
* @param {Object} item - The collection item instance that this adapter manages.
*/
constructor(item) {
this.item = item;
}
/**
* Load the item's data from storage. May involve reading a file and parsing
* its contents, then updating `item.data`.
* @async
* @abstract
* @returns {Promise<void>} Resolves when the item is fully loaded.
*/
async load() {
throw new Error("Not implemented");
}
/**
* Save the item's data to storage. May involve writing to a file or appending
* lines in an append-only format.
* @async
* @abstract
* @param {string|null} [ajson=null] - An optional serialized representation of the item’s data.
*                                     If not provided, the adapter should derive it from the item.
* @returns {Promise<void>} Resolves when the item is saved.
*/
async save(ajson = null) {
throw new Error("Not implemented");
}
/**
* Delete the item's data from storage. May involve removing a file or writing
* a `null` entry in an append-only file to signify deletion.
* @async
* @abstract
* @returns {Promise<void>} Resolves when the item’s data is deleted.
*/
async delete() {
throw new Error("Not implemented");
}
/**
* Returns the file path or unique identifier used by this adapter to locate and store
* the item's data. This may be a file name derived from the item's key.
* @abstract
* @returns {string} The path or identifier for the item's data.
*/
get data_path() {
throw new Error("Not implemented");
}
/**
* @returns {CollectionDataAdapter} The collection data adapter that this item data adapter belongs to.
*/
get collection_adapter() {
return this.item.collection.data_adapter;
}
get env() {
return this.item.env;
}
/**
* Load the item's data from storage if it has been updated externally.
* @async
* @abstract
* @returns {Promise<void>} Resolves when the item is loaded.
*/
async load_if_updated() {
throw new Error("Not implemented");
}
};

var FileCollectionDataAdapter4 = class extends CollectionDataAdapter4 {
static {
__name(this, "FileCollectionDataAdapter");
}
/**
* The class to use for item adapters.
* @type {typeof ItemDataAdapter}
*/
ItemDataAdapter = FileItemDataAdapter4;
/**
* @returns {Object} Filesystem interface derived from environment or collection settings.
*/
get fs() {
return this.collection.data_fs || this.collection.env.data_fs;
}
async clear_all() {
await this.fs.remove_dir(this.collection.data_dir, true);
}
};
var FileItemDataAdapter4 = class extends ItemDataAdapter4 {
static {
__name(this, "FileItemDataAdapter");
}
/**
* @returns {Object} Filesystem interface derived from environment or collection settings.
*/
get fs() {
return this.item.collection.data_fs || this.item.collection.env.data_fs;
}
/**
* Resolve the file path for the item's data.
* @abstract
* @returns {string} Path to the persisted item data.
*/
get data_path() {
throw new Error("Not implemented");
}
async load_if_updated() {
const data_path = this.data_path;
if (await this.fs.exists(data_path)) {
const loaded_at = this.item.loaded_at || 0;
const data_file_stat = await this.fs.stat(data_path);
if (data_file_stat.mtime > loaded_at + 1 * 60 * 1e3) {
console.log(`Smart Collections: Re-loading item ${this.item.key} because it has been updated on disk`);
await this.load();
}
}
}
};

var class_to_collection_key7 = {
"SmartSource": "smart_sources",
"SmartNote": "smart_sources",
"SmartBlock": "smart_blocks",
"SmartDirectory": "smart_directories"
};
var AjsonMultiFileCollectionDataAdapter4 = class extends FileCollectionDataAdapter4 {
static {
__name(this, "AjsonMultiFileCollectionDataAdapter");
}
/**
* The class to use for item adapters.
* @type {typeof ItemDataAdapter}
*/
ItemDataAdapter = AjsonMultiFileItemDataAdapter4;
/**
* Load a single item by its key.
* @async
* @param {string} key
* @returns {Promise<void>}
*/
async load_item(key) {
const item = this.collection.get(key);
if (!item) return;
const adapter = this.create_item_adapter(item);
await adapter.load();
}
/**
* Save a single item by its key.
* @async
* @param {string} key
* @returns {Promise<void>}
*/
async save_item(key) {
const item = this.collection.get(key);
if (!item) return;
const adapter = this.create_item_adapter(item);
await adapter.save();
}
/**
* Process any queued load operations.
* @async
* @returns {Promise<void>}
*/
async process_load_queue() {
this.collection.emit_event("collection:load_started");
this.collection.show_process_notice("loading_collection");
if (!await this.fs.exists(this.collection.data_dir)) {
await this.fs.mkdir(this.collection.data_dir);
}
const load_queue = Object.values(this.collection.items).filter((item) => item._queue_load);
if (!load_queue.length) {
this.collection.clear_process_notice("loading_collection");
return;
}
const now = Date.now();
console.log(`Loading ${this.collection.collection_key}: ${load_queue.length} items from disk`);
const batch_size = 100;
for (let i = 0; i < load_queue.length; i += batch_size) {
const batch = load_queue.slice(i, i + batch_size);
await Promise.all(batch.map((item) => {
const adapter = this.create_item_adapter(item);
return adapter.load().catch((err) => {
console.warn(`Error loading item ${item.key}`, err);
item.queue_load();
});
}));
}
console.log(`Loaded ${this.collection.collection_key} from disk in ${Date.now() - now}ms`);
this.collection.loaded = load_queue.length;
this.collection.clear_process_notice("loading_collection");
this.collection.emit_event("collection:load_completed");
}
/**
* Process any queued save operations.
* @async
* @returns {Promise<void>}
*/
async process_save_queue() {
this.collection.emit_event("collection:save_started");
this.collection.show_process_notice("saving_collection");
const save_queue = Object.values(this.collection.items).filter((item) => item._queue_save);
console.log(`Saving ${this.collection.collection_key}: ${save_queue.length} items`);
const time_start = Date.now();
const batch_size = 50;
for (let i = 0; i < save_queue.length; i += batch_size) {
const batch = save_queue.slice(i, i + batch_size);
await Promise.all(batch.map((item) => {
const adapter = this.create_item_adapter(item);
return adapter.save().catch((err) => {
console.warn(`Error saving item ${item.key}`, err);
item.queue_save();
});
}));
}
const deleted_items = Object.values(this.collection.items).filter((item) => item.deleted);
if (deleted_items.length) {
deleted_items.forEach((item) => {
delete this.collection.items[item.key];
});
}
console.log(`Saved ${this.collection.collection_key} in ${Date.now() - time_start}ms`);
this.collection.clear_process_notice("saving_collection");
this.collection.emit_event("collection:save_completed");
}
get_item_data_path(key) {
return [
this.collection.data_dir || "multi",
this.fs?.sep || "/",
this.get_data_file_name(key) + ".ajson"
].join("");
}
/**
* Transforms the item key into a safe filename.
* Replaces spaces, slashes, and dots with underscores.
* @returns {string} safe file name
*/
get_data_file_name(key) {
return key.split("#")[0].replace(/[\s\/\.]/g, "_").replace(".md", "");
}
/**
* Build a single AJSON line for the given item and data.
* @param {Object} item
* @returns {string}
*/
get_item_ajson(item) {
const collection_key = item.collection_key;
const key = item.key;
const data_value = item.deleted ? "null" : JSON.stringify(item.data);
return `${JSON.stringify(`${collection_key}:${key}`)}: ${data_value},`;
}
};
var AjsonMultiFileItemDataAdapter4 = class extends FileItemDataAdapter4 {
static {
__name(this, "AjsonMultiFileItemDataAdapter");
}
/**
* Derives the `.ajson` file path from the collection's data_dir and item key.
* @returns {string}
*/
get data_path() {
return this.collection_adapter.get_item_data_path(this.item.key);
}
/**
* Load the item from its `.ajson` file.
* @async
* @returns {Promise<void>}
*/
async load() {
try {
const raw_data = await this.fs.adapter.read(this.data_path, "utf-8", { no_cache: true });
if (!raw_data) {
this.item.queue_import();
return;
}
const { rewrite, file_data } = this._parse(raw_data);
if (rewrite) {
if (file_data.length) await this.fs.write(this.data_path, file_data);
else await this.fs.remove(this.data_path);
}
const last_import_mtime = this.item.data.last_import?.at || 0;
if (last_import_mtime && this.item.init_file_mtime > last_import_mtime) {
this.item.queue_import();
}
} catch (e) {
this.item.queue_import();
}
}
/**
* Parse the entire AJSON content as a JSON object, handle legacy keys, and extract final state.
* @private
* @param {string} ajson
* @returns {boolean}
*/
_parse(ajson) {
try {
let rewrite = false;
if (!ajson.length) return false;
ajson = ajson.trim();
const original_line_count = ajson.split("\n").length;
const json_str = "{" + ajson.slice(0, -1) + "}";
const data = JSON.parse(json_str);
const entries = Object.entries(data);
for (let i = 0; i < entries.length; i++) {
const [ajson_key, value] = entries[i];
if (!value) {
delete data[ajson_key];
rewrite = true;
continue;
}
const { collection_key, item_key, changed } = this._parse_ajson_key(ajson_key);
if (changed) {
rewrite = true;
data[collection_key + ":" + item_key] = value;
delete data[ajson_key];
}
const collection = this.env[collection_key];
if (!collection) continue;
const existing_item = collection.get(item_key);
if (!value.key) value.key = item_key;
if (existing_item) {
existing_item.data = value;
existing_item._queue_load = false;
existing_item.loaded_at = Date.now();
} else {
const ItemClass = collection.item_type;
const new_item = new ItemClass(this.env, value);
new_item._queue_load = false;
new_item.loaded_at = Date.now();
collection.set(new_item);
}
}
if (rewrite || original_line_count > entries.length) {
rewrite = true;
}
return {
rewrite,
file_data: rewrite ? Object.entries(data).map(([key, value]) => `${JSON.stringify(key)}: ${JSON.stringify(value)},`).join("\n") : null
};
} catch (e) {
if (ajson.split("\n").some((line) => !line.endsWith(","))) {
console.warn("fixing trailing comma error");
ajson = ajson.split("\n").map((line) => line.endsWith(",") ? line : line + ",").join("\n");
return this._parse(ajson);
}
console.warn("Error parsing JSON:", e);
return { rewrite: true, file_data: null };
}
}
_parse_ajson_key(ajson_key) {
let changed;
let [collection_key, ...item_key] = ajson_key.split(":");
if (class_to_collection_key7[collection_key]) {
collection_key = class_to_collection_key7[collection_key];
changed = true;
}
return {
collection_key,
item_key: item_key.join(":"),
changed
};
}
/**
* Save the current state of the item by appending a new line to its `.ajson` file.
* @async
* @returns {Promise<void>}
*/
async save(retries = 0) {
try {
const ajson_line = this.get_item_ajson();
await this.fs.append(this.data_path, "\n" + ajson_line);
this.item._queue_save = false;
} catch (e) {
if (e.code === "ENOENT" && retries < 1) {
const dir = this.collection_adapter.collection.data_dir;
if (!await this.fs.exists(dir)) {
await this.fs.mkdir(dir);
}
return await this.save(retries + 1);
}
console.warn("Error saving item", this.data_path, this.item.key, e);
}
}
/**
* Build a single AJSON line for the given item and data.
* @param {Object} item
* @returns {string}
*/
get_item_ajson() {
return this.collection_adapter.get_item_ajson(this.item);
}
};

function ajson_merge4(existing, new_obj) {
if (new_obj === null) return null;
if (new_obj === void 0) return existing;
if (typeof new_obj !== "object") return new_obj;
if (typeof existing !== "object" || existing === null) existing = {};
const keys = Object.keys(new_obj);
const length = keys.length;
for (let i = 0; i < length; i++) {
const key = keys[i];
const new_val = new_obj[key];
const existing_val = existing[key];
if (Array.isArray(new_val)) {
existing[key] = new_val.slice();
} else if (is_object4(new_val)) {
existing[key] = ajson_merge4(is_object4(existing_val) ? existing_val : {}, new_val);
} else if (new_val !== void 0) {
existing[key] = new_val;
}
}
return existing;
}
__name(ajson_merge4, "ajson_merge");
function is_object4(obj) {
return obj !== null && typeof obj === "object" && !Array.isArray(obj);
}
__name(is_object4, "is_object");

var class_to_collection_key8 = {
"SmartSource": "smart_sources",
"SmartNote": "smart_sources",
"SmartBlock": "smart_blocks",
"SmartDirectory": "smart_directories"
};
function _parse_ajson_key4(ajson_key) {
let changed = false;
let [collection_key, ...item_key] = ajson_key.split(":");
if (class_to_collection_key8[collection_key]) {
collection_key = class_to_collection_key8[collection_key];
changed = true;
}
return {
collection_key,
item_key: item_key.join(":"),
changed
};
}
__name(_parse_ajson_key4, "_parse_ajson_key");
var AjsonSingleFileCollectionDataAdapter4 = class extends AjsonMultiFileCollectionDataAdapter4 {
static {
__name(this, "AjsonSingleFileCollectionDataAdapter");
}
/**
* Returns the single shared `.ajson` file path for this collection.
* @param {string} [key] - (unused) Item key, ignored in single-file mode.
* @returns {string} The single .ajson file path for the entire collection.
*/
get_item_data_path(key) {
const file_name = (this.collection?.collection_key || "collection") + ".ajson";
const sep = this.fs?.sep || "/";
const dir = this.collection.data_dir || "data";
return [dir, file_name].join(sep);
}
/**
* Override process_load_queue to parse the entire single-file .ajson once,
* distributing final states to items.
*
* @async
* @returns {Promise<void>}
*/
async process_load_queue() {
this.collection.emit_event("collection:load_started");
this.collection.show_process_notice("loading_collection");
if (!await this.fs.exists(this.collection.data_dir)) {
await this.fs.mkdir(this.collection.data_dir);
}
const path = this.get_item_data_path();
if (!await this.fs.exists(path)) {
for (const item of Object.values(this.collection.items)) {
if (item._queue_load) {
item.queue_import?.();
}
}
this.collection.clear_process_notice("loading_collection");
this.collection.emit_event("collection:load_halted");
return;
}
const raw_data = await this.fs.read(path, "utf-8", { no_cache: true });
if (!raw_data) {
for (const item of Object.values(this.collection.items)) {
if (item._queue_load) {
item.queue_import?.();
}
}
this.collection.clear_process_notice("loading_collection");
this.collection.emit_event("collection:load_halted");
return;
}
const { rewrite, file_data } = this.parse_single_file_ajson(raw_data);
if (rewrite) {
if (file_data.length) {
await this.fs.write(path, file_data);
} else {
await this.fs.remove(path);
}
}
for (const item of Object.values(this.collection.items)) {
item._queue_load = false;
item.loaded_at = Date.now();
}
this.collection.clear_process_notice("loading_collection");
this.collection.emit_event("collection:load_completed");
}
/**
* Helper to parse single-file .ajson content, distributing states to items.
*
* @param {string} raw
* @returns {{ rewrite: boolean, file_data: string }}
*/
parse_single_file_ajson(raw) {
let rewrite = false;
const lines = raw.trim().split("\n").filter(Boolean);
let data_map = {};
let line_count = 0;
for (let i = 0; i < lines.length; i++) {
const line = lines[i].trim();
if (!line.endsWith(",")) {
rewrite = true;
}
const trimmed = line.replace(/,$/, "");
const combined = "{" + trimmed + "}";
try {
const obj = JSON.parse(combined);
const [fullKey, value] = Object.entries(obj)[0];
let { collection_key, item_key, changed } = _parse_ajson_key4(fullKey);
const newKey = `${collection_key}:${item_key}`;
if (!value) {
delete data_map[newKey];
if (changed || newKey !== fullKey) {
delete data_map[fullKey];
}
rewrite = true;
} else {
data_map[newKey] = value;
if (changed || newKey !== fullKey) {
delete data_map[fullKey];
rewrite = true;
}
}
} catch (err) {
console.warn("parse error for line: ", line, err);
rewrite = true;
}
line_count++;
}
for (const [ajson_key, val] of Object.entries(data_map)) {
const [collection_key, ...rest] = ajson_key.split(":");
const item_key = rest.join(":");
const collection = this.collection.env[collection_key];
if (!collection) continue;
let item = collection.get(item_key);
if (!item) {
const ItemClass = collection.item_type;
item = new ItemClass(this.env, val);
collection.set(item);
} else {
item.data = ajson_merge4(item.data, val);
}
item.loaded_at = Date.now();
item._queue_load = false;
if (!val.key) val.key = item_key;
}
if (line_count > Object.keys(data_map).length) {
rewrite = true;
}
let minimal_lines = [];
for (const [ajson_key, val] of Object.entries(data_map)) {
minimal_lines.push(`${JSON.stringify(ajson_key)}: ${JSON.stringify(val)},`);
}
return {
rewrite,
file_data: minimal_lines.join("\n")
};
}
/**
* Override process_save_queue for single-file approach.
* We'll simply call save_item for each queued item, which appends a line to the same `.ajson`.
*
* @async
* @returns {Promise<void>}
*/
async process_save_queue() {
this.collection.emit_event("collection:save_started");
this.collection.show_process_notice("saving_collection");
const save_queue = Object.values(this.collection.items).filter((item) => item._queue_save);
const time_start = Date.now();
const batch_size = 50;
for (let i = 0; i < save_queue.length; i += batch_size) {
const batch = save_queue.slice(i, i + batch_size);
await Promise.all(batch.map((item) => {
const adapter = this.create_item_adapter(item);
return adapter.save().catch((err) => {
console.warn(`Error saving item ${item.key}`, err);
item.queue_save();
});
}));
}
const deleted_items = Object.values(this.collection.items).filter((item) => item.deleted);
if (deleted_items.length) {
deleted_items.forEach((item) => {
delete this.collection.items[item.key];
});
}
console.log(`Saved (single-file) ${this.collection.collection_key} in ${Date.now() - time_start}ms`);
this.collection.clear_process_notice("saving_collection");
this.collection.emit_event("collection:save_completed");
}
};
var AjsonSingleFileItemDataAdapter4 = class extends AjsonMultiFileItemDataAdapter4 {
static {
__name(this, "AjsonSingleFileItemDataAdapter");
}
/**
* Overridden to always return the single file path from the parent collection adapter.
* @returns {string}
*/
get data_path() {
return this.collection_adapter.get_item_data_path(this.item.key);
}
/**
* Load logic:
* In single-file mode, we typically rely on the collection's `process_load_queue()`
* to parse the entire file. This direct `load()` will do a naive re-parse as well
* if used individually.
*/
async load() {
const path = this.data_path;
if (!await this.fs.exists(path)) {
this.item.queue_import?.();
return;
}
try {
const raw_data = await this.fs.read(path, "utf-8", { no_cache: true });
if (!raw_data) {
this.item.queue_import?.();
return;
}
const { rewrite } = this.collection_adapter.parse_single_file_ajson(raw_data);
} catch (err) {
console.warn(`Error loading single-file item ${this.item.key}`, err);
this.item.queue_import?.();
}
}
};
var ajson_single_file_default4 = {
collection: AjsonSingleFileCollectionDataAdapter4,
item: AjsonSingleFileItemDataAdapter4
};

function collection_instance_name_from4(class_name) {
if (class_name.endsWith("Item")) {
return class_name.replace(/Item$/, "").replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
}
return class_name.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase().replace(/y$/, "ie") + "s";
}
__name(collection_instance_name_from4, "collection_instance_name_from");

function deep_merge4(target = {}, source = {}) {
for (const key in source) {
if (!Object.prototype.hasOwnProperty.call(source, key)) continue;
if (is_plain_object8(source[key]) && is_plain_object8(target[key])) {
deep_merge4(target[key], source[key]);
} else {
target[key] = source[key];
}
}
return target;
}
__name(deep_merge4, "deep_merge");
function is_plain_object8(o) {
return o && typeof o === "object" && !Array.isArray(o);
}
__name(is_plain_object8, "is_plain_object");

function create_uid4(data) {
const str = JSON.stringify(data);
let hash = 0;
if (str.length === 0) return hash;
for (let i = 0; i < str.length; i++) {
const char = str.charCodeAt(i);
hash = (hash << 5) - hash + char;
hash = hash & hash;
if (hash < 0) hash = hash * -1;
}
return hash.toString() + str.length;
}
__name(create_uid4, "create_uid");

function camel_case_to_snake_case4(str = "") {
return str.replace(/([A-Z])/g, (m) => `_${m.toLowerCase()}`).replace(/^_/, "").replace(/2$/, "");
}
__name(camel_case_to_snake_case4, "camel_case_to_snake_case");

function deep_equal4(obj1, obj2, visited = /* @__PURE__ */ new WeakMap()) {
if (obj1 === obj2) return true;
if (obj1 === null || obj2 === null || obj1 === void 0 || obj2 === void 0) return false;
if (typeof obj1 !== typeof obj2 || Array.isArray(obj1) !== Array.isArray(obj2)) return false;
if (Array.isArray(obj1)) {
if (obj1.length !== obj2.length) return false;
return obj1.every((item, index) => deep_equal4(item, obj2[index], visited));
}
if (typeof obj1 === "object") {
if (visited.has(obj1)) return visited.get(obj1) === obj2;
visited.set(obj1, obj2);
const keys1 = Object.keys(obj1);
const keys2 = Object.keys(obj2);
if (keys1.length !== keys2.length) return false;
return keys1.every((key) => deep_equal4(obj1[key], obj2[key], visited));
}
return obj1 === obj2;
}
__name(deep_equal4, "deep_equal");

function get_item_display_name4(key, show_full_path) {
if (show_full_path) {
return key.split("/").join(" > ").replace(".md", "");
}
return key.split("/").pop().replace(".md", "");
}
__name(get_item_display_name4, "get_item_display_name");

function create_actions_proxy4(ctx, actions_source) {
const input = actions_source || {};
const is_plain_object9 = /* @__PURE__ */ __name((val) => typeof val === "object" && val !== null && !Array.isArray(val), "is_plain_object");
const is_function = /* @__PURE__ */ __name((val) => typeof val === "function", "is_function");
const is_class_export = /* @__PURE__ */ __name((val) => is_function(val) && /^class\s/.test(Function.prototype.toString.call(val)), "is_class_export");
const is_action_object = /* @__PURE__ */ __name((val) => is_plain_object9(val) && is_function(val.action), "is_action_object");
const is_action_candidate = /* @__PURE__ */ __name((val) => is_function(val) || is_action_object(val) || is_class_export(val), "is_action_candidate");
const ignored_meta_keys = /* @__PURE__ */ new Set(["length", "name", "prototype"]);
const clone_with_descriptors = /* @__PURE__ */ __name((obj) => {
if (!is_plain_object9(obj)) return obj;
const out = Object.create(Object.getPrototypeOf(obj) || null);
for (const key of Reflect.ownKeys(obj)) {
const descriptor = Object.getOwnPropertyDescriptor(obj, key);
if (!descriptor) continue;
const next = { ...descriptor };
if ("value" in next && is_plain_object9(next.value)) {
next.value = clone_with_descriptors(next.value);
}
try {
Object.defineProperty(out, key, next);
} catch {
out[key] = next.value;
}
}
return out;
}, "clone_with_descriptors");
const should_bucket_actions = /* @__PURE__ */ __name((val) => {
if (!is_plain_object9(val)) return false;
if (is_action_object(val)) return false;
const keys = Reflect.ownKeys(val);
if (keys.length === 0) return false;
let found_candidate = false;
for (const key of keys) {
const descriptor = Object.getOwnPropertyDescriptor(val, key);
if (!descriptor) continue;
if ("value" in descriptor) {
const entry = descriptor.value;
if (is_action_candidate(entry)) {
found_candidate = true;
continue;
}
if (is_plain_object9(entry)) {
if (should_bucket_actions(entry)) {
found_candidate = true;
continue;
}
return false;
}
if (typeof entry === "undefined") continue;
return false;
}
return false;
}
return found_candidate;
}, "should_bucket_actions");
const clone_descriptor = /* @__PURE__ */ __name((descriptor) => {
if (!descriptor) return descriptor;
if (!("value" in descriptor)) return { ...descriptor };
const cloned = is_plain_object9(descriptor.value) ? clone_with_descriptors(descriptor.value) : descriptor.value;
return { ...descriptor, value: cloned };
}, "clone_descriptor");
const build_sources = /* @__PURE__ */ __name((src) => {
const global_source2 = /* @__PURE__ */ Object.create(null);
const scoped_sources2 = /* @__PURE__ */ new Map();
for (const key of Reflect.ownKeys(src)) {
const descriptor = Object.getOwnPropertyDescriptor(src, key);
if (!descriptor) continue;
if ("value" in descriptor && should_bucket_actions(descriptor.value)) {
scoped_sources2.set(key, clone_with_descriptors(descriptor.value));
continue;
}
try {
Object.defineProperty(global_source2, key, clone_descriptor(descriptor));
} catch {
global_source2[key] = descriptor.value;
}
}
return { global_source: global_source2, scoped_sources: scoped_sources2 };
}, "build_sources");
const { global_source, scoped_sources } = build_sources(input);
const has_own = /* @__PURE__ */ __name((obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop), "has_own");
const cache = /* @__PURE__ */ Object.create(null);
const copy_metadata = /* @__PURE__ */ __name((source, target, omit = []) => {
if (!source || !target) return;
const skips = /* @__PURE__ */ new Set([...ignored_meta_keys, ...omit]);
for (const key of Reflect.ownKeys(source)) {
if (skips.has(key)) continue;
const descriptor = Object.getOwnPropertyDescriptor(source, key);
if (!descriptor) continue;
try {
Object.defineProperty(target, key, descriptor);
} catch {
target[key] = descriptor.value;
}
}
}, "copy_metadata");
const instantiate_class = /* @__PURE__ */ __name((Ctor) => {
const instance = new Ctor(ctx);
const candidate = instance.action || instance.run || instance.execute || instance.call;
if (is_function(candidate)) {
const bound = candidate.bind(instance);
copy_metadata(Ctor, bound);
copy_metadata(instance, bound);
bound.instance = instance;
return bound;
}
copy_metadata(Ctor, instance);
return instance;
}, "instantiate_class");
const bind_or_clone = /* @__PURE__ */ __name((val) => {
if (is_class_export(val)) {
return instantiate_class(val);
}
if (is_action_object(val)) {
const bound = val.action.bind(ctx);
copy_metadata(val, bound, ["action"]);
return bound;
}
if (is_function(val)) {
const bound = val.bind(ctx);
copy_metadata(val, bound);
return bound;
}
if (is_plain_object9(val)) {
return clone_with_descriptors(val);
}
return val;
}, "bind_or_clone");
const scope_actions_for = /* @__PURE__ */ __name(() => {
const scope_key = ctx?.constructor?.key;
if (typeof scope_key === "undefined" || scope_key === null) return null;
const bucket = scoped_sources.get(scope_key);
return bucket && is_plain_object9(bucket) ? bucket : null;
}, "scope_actions_for");
const cache_result = /* @__PURE__ */ __name((target, prop, value) => {
target[prop] = value;
return value;
}, "cache_result");
const compute_and_cache = /* @__PURE__ */ __name((target, prop) => {
const scoped = scope_actions_for();
if (scoped && has_own(scoped, prop)) {
return cache_result(target, prop, bind_or_clone(scoped[prop]));
}
if (has_own(global_source, prop)) {
return cache_result(target, prop, bind_or_clone(global_source[prop]));
}
return cache_result(target, prop, void 0);
}, "compute_and_cache");
const union_keys = /* @__PURE__ */ __name(() => {
const scoped = scope_actions_for();
const keys = new Set(Reflect.ownKeys(cache));
for (const key of Reflect.ownKeys(global_source)) {
keys.add(key);
}
if (scoped) {
for (const key of Reflect.ownKeys(scoped)) {
keys.add(key);
}
}
return Array.from(keys);
}, "union_keys");
const descriptor_for = /* @__PURE__ */ __name((target, prop) => ({
configurable: true,
enumerable: true,
value: target[prop]
}), "descriptor_for");
return new Proxy(cache, {
get: /* @__PURE__ */ __name((target, prop) => {
if (prop === Symbol.toStringTag) return "ActionsProxy";
if (prop in target) return target[prop];
return compute_and_cache(target, prop);
}, "get"),
has: /* @__PURE__ */ __name((target, prop) => {
if (prop in target) return true;
const scoped = scope_actions_for();
if (scoped && has_own(scoped, prop)) return true;
return has_own(global_source, prop);
}, "has"),
ownKeys: /* @__PURE__ */ __name(() => union_keys(), "ownKeys"),
getOwnPropertyDescriptor: /* @__PURE__ */ __name((target, prop) => {
if (has_own(target, prop)) {
return descriptor_for(target, prop);
}
const scoped = scope_actions_for();
if (scoped && has_own(scoped, prop)) {
if (!has_own(target, prop)) {
compute_and_cache(target, prop);
}
return descriptor_for(target, prop);
}
if (has_own(global_source, prop)) {
if (!has_own(target, prop)) {
compute_and_cache(target, prop);
}
return descriptor_for(target, prop);
}
return void 0;
}, "getOwnPropertyDescriptor"),
defineProperty: /* @__PURE__ */ __name((target, prop, descriptor) => {
if ("value" in descriptor) {
target[prop] = descriptor.value;
return true;
}
return false;
}, "defineProperty"),
set: /* @__PURE__ */ __name((target, prop, value) => {
target[prop] = value;
return true;
}, "set"),
deleteProperty: /* @__PURE__ */ __name((target, prop) => {
if (has_own(target, prop)) {
delete target[prop];
}
return true;
}, "deleteProperty")
});
}
__name(create_actions_proxy4, "create_actions_proxy");

var CollectionItem4 = class _CollectionItem {
static {
__name(this, "CollectionItem");
}
static version = 2e-3;
/**
* Default properties for an instance of CollectionItem.
* Override in subclasses to define different defaults.
* @returns {Object}
*/
static get defaults() {
return {
data: {}
};
}
/**
* @param {Object} env - The environment/context.
* @param {Object|null} [data=null] - Initial data for the item.
*/
constructor(env, data = null) {
env.create_env_getter(this);
this.config = this.env?.config;
this.merge_defaults();
if (data) deep_merge4(this.data, data);
if (!this.data.class_name) this.data.class_name = this.collection.item_class_name;
}
/**
* Loads an item from data and initializes it.
* @param {Object} env
* @param {Object} data
* @returns {CollectionItem}
*/
static load(env, data) {
const item = new this(env, data);
item.init();
return item;
}
/**
* Merge default properties from the entire inheritance chain.
* @private
*/
merge_defaults() {
let current_class = this.constructor;
while (current_class) {
for (let key in current_class.defaults) {
const default_val = current_class.defaults[key];
if (typeof default_val === "object") {
this[key] = { ...default_val, ...this[key] };
} else {
this[key] = this[key] === void 0 ? default_val : this[key];
}
}
current_class = Object.getPrototypeOf(current_class);
}
}
/**
* Generates or retrieves a unique key for the item.
* Key syntax supports:
* - `[i]` for sequences
* - `/` for super-sources (groups, directories, clusters)
* - `#` for sub-sources (blocks)
* @returns {string} The unique key
*/
get_key() {
return create_uid4(this.data);
}
/**
* Updates the item data and returns true if changed.
* @param {Object} data
* @returns {boolean} True if data changed.
*/
update_data(data) {
const sanitized_data = this.sanitize_data(data);
const current_data = { ...this.data };
deep_merge4(current_data, sanitized_data);
const changed = !deep_equal4(this.data, current_data);
if (!changed) return false;
this.data = current_data;
return true;
}
/**
* Sanitizes data for saving. Ensures no circular references.
* @param {*} data
* @returns {*} Sanitized data.
*/
sanitize_data(data) {
if (data instanceof _CollectionItem) return data.ref;
if (Array.isArray(data)) return data.map((val) => this.sanitize_data(val));
if (typeof data === "object" && data !== null) {
return Object.keys(data).reduce((acc, key) => {
acc[key] = this.sanitize_data(data[key]);
return acc;
}, {});
}
return data;
}
/**
* Initializes the item. Override as needed.
* @param {Object} [input_data] - Additional data that might be provided on creation.
*/
init(input_data) {
}
/**
* Queues this item for saving.
*/
queue_save() {
this._queue_save = true;
}
/**
* Saves this item using its data adapter.
* @returns {Promise<void>}
*/
async save() {
try {
await this.data_adapter.save_item(this);
this.init();
} catch (err) {
this._queue_save = true;
console.error(err, err.stack);
}
}
/**
* Queues this item for loading.
*/
queue_load() {
this._queue_load = true;
}
/**
* Loads this item using its data adapter.
* @returns {Promise<void>}
*/
async load() {
try {
await this.data_adapter.load_item(this);
this.init();
} catch (err) {
this._load_error = err;
this.on_load_error(err);
}
}
/**
* Handles load errors by re-queuing for load.
* Override if needed.
* @param {Error} err
*/
on_load_error(err) {
this.queue_load();
}
/**
* Validates the item before saving. Checks for presence and validity of key.
* @deprecated should be better handled 2025-12-17 (wrong scope?)
* @returns {boolean}
*/
validate_save() {
if (!this.key) return false;
if (this.key.trim() === "") return false;
if (this.key === "undefined") return false;
return true;
}
/**
* Marks this item as deleted. This does not immediately remove it from memory,
* but queues a save that will result in the item being removed from persistent storage.
*/
delete() {
this.deleted = true;
this.queue_save();
}
/**
* Filters items in the collection based on provided options.
* functional filter (returns true or false) for filtering items in collection; called by collection class
* @param {Object} filter_opts - Filtering options.
* @param {string} [filter_opts.exclude_key] - A single key to exclude.
* @param {string[]} [filter_opts.exclude_keys] - An array of keys to exclude. If exclude_key is provided, it's added to this array.
* @param {string} [filter_opts.exclude_key_starts_with] - Exclude keys starting with this string.
* @param {string[]} [filter_opts.exclude_key_starts_with_any] - Exclude keys starting with any of these strings.
* @param {string} [filter_opts.exclude_key_includes] - Exclude keys that include this string.
* @param {string[]} [filter_opts.exclude_key_includes_any] - Exclude keys that include any of these strings.
* @param {string} [filter_opts.exclude_key_ends_with] - Exclude keys ending with this string.
* @param {string[]} [filter_opts.exclude_key_ends_with_any] - Exclude keys ending with any of these strings.
* @param {string} [filter_opts.key_ends_with] - Include only keys ending with this string.
* @param {string} [filter_opts.key_starts_with] - Include only keys starting with this string.
* @param {string[]} [filter_opts.key_starts_with_any] - Include only keys starting with any of these strings.
* @param {string} [filter_opts.key_includes] - Include only keys that include this string.
* @returns {boolean} True if the item passes the filter, false otherwise.
*/
filter(filter_opts = {}) {
const {
exclude_key,
exclude_keys = exclude_key ? [exclude_key] : [],
exclude_key_starts_with,
exclude_key_starts_with_any,
exclude_key_includes,
exclude_key_includes_any,
exclude_key_ends_with,
exclude_key_ends_with_any,
key_ends_with,
key_starts_with,
key_starts_with_any,
key_includes,
key_includes_any
} = filter_opts;
if (exclude_keys?.includes(this.key)) return false;
if (exclude_key_starts_with && this.key.startsWith(exclude_key_starts_with)) return false;
if (exclude_key_starts_with_any && exclude_key_starts_with_any.some((prefix) => this.key.startsWith(prefix))) return false;
if (exclude_key_includes && this.key.includes(exclude_key_includes)) return false;
if (exclude_key_includes_any && exclude_key_includes_any.some((include) => this.key.includes(include))) return false;
if (exclude_key_ends_with && this.key.endsWith(exclude_key_ends_with)) return false;
if (exclude_key_ends_with_any && exclude_key_ends_with_any.some((suffix) => this.key.endsWith(suffix))) return false;
if (key_ends_with && !this.key.endsWith(key_ends_with)) return false;
if (key_starts_with && !this.key.startsWith(key_starts_with)) return false;
if (key_starts_with_any && !key_starts_with_any.some((prefix) => this.key.startsWith(prefix))) return false;
if (key_includes && !this.key.includes(key_includes)) return false;
if (key_includes_any && !key_includes_any.some((include) => this.key.includes(include))) return false;
return true;
}
filter_and_score(params = {}) {
if (this.filter(params.filter) === false) return null;
return this.score(params);
}
score(params = {}) {
const score_action = this.actions[params.score_algo_key];
if (typeof score_action !== "function") throw new Error(`Missing score action: ${params.score_algo_key}`);
return {
...score_action(params) || {},
item: this
};
}
/**
* Parses item data for additional processing. Override as needed.
* @deprecated is this used anywhere?
*/
parse() {
}
get actions() {
if (!this._actions) {
this._actions = create_actions_proxy4(this, {
...this.env.config.actions || {},
...this.env.opts.items?.[this.item_type_key]?.actions || {}
});
}
return this._actions;
}
/**
* Derives the collection key from the class name.
* @returns {string}
*/
static get collection_key() {
let name = this.name;
if (name.match(/\d$/)) name = name.slice(0, -1);
return collection_instance_name_from4(name);
}
/**
* @returns {string} The collection key for this item.
*/
get collection_key() {
let name = this.constructor.name;
if (name.match(/\d$/)) name = name.slice(0, -1);
return collection_instance_name_from4(name);
}
/**
* Retrieves the parent collection from the environment.
* @returns {Collection}
*/
get collection() {
return this.env[this.collection_key];
}
/**
* @returns {string} The item's key.
*/
get key() {
return this.data?.key || this.get_key();
}
get item_type_key() {
let name = this.constructor.name;
if (name.match(/\d$/)) name = name.slice(0, -1);
return camel_case_to_snake_case4(name);
}
/**
* Emits an event with item metadata.
*
* @param {string} event_key
* @param {Object} [payload={}]
* @returns {void}
*/
emit_event(event_key, payload = {}) {
this.env.events?.emit(event_key, { collection_key: this.collection_key, item_key: this.key, ...payload });
}
on_event(event_key, callback) {
return this.env.events?.on(event_key, (payload) => {
if (payload?.item_key && payload.item_key !== this.key) return;
callback(payload);
});
}
once_event(event_key, callback) {
return this.env.events?.once(event_key, (payload) => {
if (payload?.item_key && payload.item_key !== this.key) return;
callback(payload);
});
}
/**
* @returns {Object} The data adapter for this item's collection.
*/
get data_adapter() {
return this.collection.data_adapter;
}
/**
* @returns {Object} The filesystem adapter.
*/
get data_fs() {
return this.collection.data_fs;
}
/**
* Access to collection-level settings.
* @returns {Object}
*/
get settings() {
if (!this.env.settings[this.collection_key]) this.env.settings[this.collection_key] = {};
return this.env.settings[this.collection_key];
}
set settings(settings) {
this.env.settings[this.collection_key] = settings;
this.env.smart_settings.save();
}
/**
* A simple reference object for this item.
* @deprecated 2025-11-11 lacks adoption
* @returns {{collection_key: string, key: string}}
*/
get ref() {
return { collection_key: this.collection_key, key: this.key };
}
/**
* @deprecated use env.smart_components~~env.smart_view~~ instead
*/
get smart_view() {
if (!this._smart_view) this._smart_view = this.env.init_module("smart_view");
return this._smart_view;
}
/**
* Retrieves the display name of the collection item.
* @readonly
* @deprecated Use `get_item_display_name(key, show_full_path)` instead (keep UI logic out of collections).
* @returns {string} The display name.
*/
get name() {
return get_item_display_name4(
this.key,
this.env.settings.smart_view_filter?.show_full_path
);
}
};

var AsyncFunction4 = Object.getPrototypeOf(async function() {
}).constructor;
var Collection4 = class {
static {
__name(this, "Collection");
}
static version = 1e-3;
/**
* Constructs a new Collection instance.
*
* @param {Object} env - The environment context containing configurations and adapters.
* @param {Object} [opts={}] - Optional configuration.
* @param {string} [opts.collection_key] - Custom key to override default collection name.
* @param {string} [opts.data_dir] - Custom data directory path.
*/
constructor(env, opts = {}) {
env.create_env_getter(this);
this.opts = opts;
if (opts.collection_key) this.collection_key = opts.collection_key;
this.env[this.collection_key] = this;
this.config = this.env.config;
this.items = {};
this.loaded = null;
this._loading = false;
this.load_time_ms = null;
this.settings_container = null;
}
/**
* Initializes a new collection in the environment. Override in subclass if needed.
*
* @param {Object} env
* @param {Object} [opts={}]
* @returns {Promise<void>}
*/
static async init(env, opts = {}) {
env[this.collection_key] = new this(env, opts);
await env[this.collection_key].init();
env.collections[this.collection_key] = "init";
}
/**
* The unique collection key derived from the class name.
* @returns {string}
*/
static get collection_key() {
let name = this.name;
if (name.match(/\d$/)) name = name.slice(0, -1);
return name.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
}
/**
* Instance-level init. Override in subclasses if necessary.
* @returns {Promise<void>}
*/
async init() {
}
/**
* Creates or updates an item in the collection.
* - If `data` includes a key that matches an existing item, that item is updated.
* - Otherwise, a new item is created.
* After updating or creating, the item is validated. If validation fails, the item is logged and returned without being saved.
* If validation succeeds for a new item, it is added to the collection and marked for saving.
*
* If the item’s `init()` method is async, a promise is returned that resolves once init completes.
*
* NOTE: wrapping in try/catch seems to fail to catch errors thrown in async init functions when awaiting create_or_update
*
* @param {Object} [data={}] - Data for creating/updating an item.
* @returns {Promise<Item>|Item} The created or updated item. May return a promise if `init()` is async.
*/
create_or_update(data = {}) {
const existing_item = this.find_by(data);
const item = existing_item ? existing_item : new this.item_type(this.env);
item._queue_save = !existing_item;
const data_changed = item.update_data(data);
if (!existing_item && !item.validate_save()) {
return item;
}
if (!existing_item) {
this.set(item);
}
if (existing_item && !data_changed) return existing_item;
if (item.init instanceof AsyncFunction4) {
return new Promise((resolve) => {
item.init(data).then(() => resolve(item));
});
}
item.init(data);
return item;
}
/**
* Finds an item by partial data match (first checks key). If `data.key` provided,
* returns the item with that key; otherwise attempts a match by merging data.
*
* @param {Object} data - Data to match against.
* @returns {Item|null}
*/
find_by(data) {
if (data.key) return this.get(data.key);
const temp = new this.item_type(this.env);
const temp_data = JSON.parse(JSON.stringify(data, temp.sanitize_data(data)));
deep_merge4(temp.data, temp_data);
return temp.key ? this.get(temp.key) : null;
}
/**
* Filters items based on provided filter options or a custom function.
*
* @param {Object|Function} [filter_opts={}] - Filter options or a predicate function.
* @returns {Item[]} Array of filtered items.
*/
filter(filter_opts = {}) {
if (typeof filter_opts === "function") {
return Object.values(this.items).filter(filter_opts);
}
const results = [];
const { first_n } = filter_opts;
for (const item of Object.values(this.items)) {
if (first_n && results.length >= first_n) break;
if (item.filter(filter_opts)) results.push(item);
}
return results;
}
/**
* Alias for `filter()`
* @param {Object|Function} filter_opts
* @returns {Item[]}
*/
list(filter_opts) {
return this.filter(filter_opts);
}
/**
* Retrieves an item by key.
* @param {string} key
* @returns {Item|undefined}
*/
get(key) {
return this.items[key];
}
/**
* Retrieves multiple items by an array of keys.
* @param {string[]} keys
* @returns {Item[]}
*/
get_many(keys = []) {
if (!Array.isArray(keys)) {
console.error("get_many called with non-array keys:", keys);
return [];
}
return keys.map((key) => this.get(key)).filter(Boolean);
}
/**
* Retrieves a random item from the collection, optionally filtered by options.
* @param {Object} [opts]
* @returns {Item|undefined}
*/
get_rand(opts = null) {
if (opts) {
const filtered = this.filter(opts);
return filtered[Math.floor(Math.random() * filtered.length)];
}
const keys = this.keys;
return this.items[keys[Math.floor(Math.random() * keys.length)]];
}
/**
* Adds or updates an item in the collection.
* @param {Item} item
*/
set(item) {
if (!item.key) throw new Error("Item must have a key property");
this.items[item.key] = item;
}
/**
* Updates multiple items by their keys.
* @param {string[]} keys
* @param {Object} data
*/
update_many(keys = [], data = {}) {
this.get_many(keys).forEach((item) => item.update_data(data));
}
/**
* Clears all items from the collection.
*/
clear() {
this.items = {};
}
/**
* @returns {string} The collection key, can be overridden by opts.collection_key
*/
get collection_key() {
return this._collection_key ? this._collection_key : this.constructor.collection_key;
}
set collection_key(key) {
this._collection_key = key;
}
/**
* Lazily initializes and returns the data adapter instance for this collection.
* @returns {Object} The data adapter instance.
*/
get data_adapter() {
if (!this._data_adapter) {
const AdapterClass = this.get_adapter_class("data");
this._data_adapter = new AdapterClass(this);
}
return this._data_adapter;
}
get_adapter_class(type) {
const config = this.env.opts.collections?.[this.collection_key];
const adapter_key = type + "_adapter";
const adapter_module = config?.[adapter_key] ?? this.env.opts.collections?.smart_collections?.[adapter_key];
if (typeof adapter_module === "function") return adapter_module;
if (typeof adapter_module?.collection === "function") return adapter_module.collection;
throw new Error(`No '${type}' adapter class found for ${this.collection_key} or smart_collections`);
}
/**
* Data directory strategy for this collection. Defaults to 'multi'.
* @deprecated should be handled in adapters (2025-12-09)
* @returns {string}
*/
get data_dir() {
return this.collection_key;
}
/**
* File system adapter from the environment.
* @returns {Object}
*/
get data_fs() {
return this.env.data_fs;
}
/**
* Derives the corresponding item class name based on this collection's class name.
* @returns {string}
*/
get item_class_name() {
let name = this.constructor.name;
if (name.match(/\d$/)) name = name.slice(0, -1);
if (name.endsWith("ies")) return name.slice(0, -3) + "y";
else if (name.endsWith("s")) return name.slice(0, -1);
return name + "Item";
}
/**
* Derives a readable item name from the item class name.
* @returns {string}
*/
get item_name() {
return this.item_class_name.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
}
/**
* Retrieves the item type (constructor) from the environment.
* @deprecated replace with item_class with strict adherence to conventions (2025-10-28)
* @returns {Function} Item constructor.
*/
get item_type() {
if (!this._item_type) this._item_type = this.resolve_item_type();
return this._item_type;
}
resolve_item_type() {
const available = [
this.env.config?.items?.[this.item_name],
this.opts.item_type,
this.env.item_types?.[this.item_class_name]
].filter(Boolean).sort((a, b) => {
const a_version = a?.class?.version || a.version || 0;
const b_version = b?.class?.version || b.version || 0;
return b_version - a_version;
});
if (available.length === 0) {
throw new Error(`No item_type found for collection '${this.collection_key}' with item_name '${this.item_name}' or class_name '${this.item_class_name}'`);
}
return available[0].class || available[0];
}
/**
* Returns an array of all keys in the collection.
* @returns {string[]}
*/
get keys() {
return Object.keys(this.items);
}
/**
* @deprecated use data_adapter instead (2024-09-14)
*/
get adapter() {
return this.data_adapter;
}
/**
* @method process_save_queue
* @description
* Saves items flagged for saving (_queue_save) back to AJSON or SQLite. This ensures persistent storage
* of any updates made since last load/import. This method also writes changes to disk (AJSON files or DB).
*/
async process_save_queue(opts = {}) {
if (opts.force) {
Object.values(this.items).forEach((item) => item._queue_save = true);
}
await this.data_adapter.process_save_queue(opts);
}
/**
* @alias process_save_queue
* @returns {Promise<void>}
*/
async save(opts = {}) {
await this.process_save_queue(opts);
}
/**
* @method process_load_queue
* @description
* Loads items that have been flagged for loading (_queue_load). This may involve
* reading from AJSON/SQLite or re-importing from markdown if needed.
* Called once initial environment is ready and collections are known.
*/
async process_load_queue() {
await this.data_adapter.process_load_queue();
}
/**
* Retrieves processed settings configuration.
* @returns {Object}
*/
get settings_config() {
return this.process_settings_config({});
}
/**
* Processes given settings config, adding prefixes and handling conditionals.
* @deprecated removing settings_config from collections (2025-11-24)
*
* @private
* @param {Object} _settings_config
* @param {string} [prefix='']
* @returns {Object}
*/
process_settings_config(_settings_config, prefix = "") {
const add_prefix = /* @__PURE__ */ __name((key) => prefix && !key.includes(`${prefix}.`) ? `${prefix}.${key}` : key, "add_prefix");
return Object.entries(_settings_config).reduce((acc, [key, val]) => {
let new_val = { ...val };
if (new_val.conditional) {
if (!new_val.conditional(this)) return acc;
delete new_val.conditional;
}
if (new_val.callback) new_val.callback = add_prefix(new_val.callback);
if (new_val.btn_callback) new_val.btn_callback = add_prefix(new_val.btn_callback);
if (new_val.options_callback) new_val.options_callback = add_prefix(new_val.options_callback);
const new_key = add_prefix(this.process_setting_key(key));
acc[new_key] = new_val;
return acc;
}, {});
}
/**
* Processes an individual setting key. Override if needed.
* @param {string} key
* @returns {string}
*/
process_setting_key(key) {
return key;
}
/**
* Default settings for this collection. Override in subclasses as needed.
* @returns {Object}
*/
get default_settings() {
return {};
}
/**
* Current settings for the collection.
* Initializes with default settings if none exist.
* @returns {Object}
*/
get settings() {
if (!this.env.settings[this.collection_key]) {
this.env.settings[this.collection_key] = this.default_settings;
}
return this.env.settings[this.collection_key];
}
/**
* Unloads collection data from memory.
*/
unload() {
this.clear();
this.unloaded = true;
this.env.collections[this.collection_key] = null;
}
/**
* Displays a process notice if the operation exceeds one second.
*
* @param {string} process - Identifier for the ongoing process.
* @param {Object} [opts={}] - Additional options passed to the notice.
*/
show_process_notice(process, opts = {}) {
if (!this.debounce_process_notice) this.debounce_process_notice = {};
this.debounce_process_notice[process] = setTimeout(() => {
this.debounce_process_notice[process] = null;
this.env.notices?.show(process, { collection_key: this.collection_key, ...opts });
}, 1e3);
}
/**
* Clears any pending process notice timers and removes active notices.
*
* @param {string} process - Identifier for the process notice to clear.
*/
clear_process_notice(process) {
if (this.debounce_process_notice?.[process]) {
clearTimeout(this.debounce_process_notice[process]);
this.debounce_process_notice[process] = null;
} else {
this.env.notices?.remove(process);
}
}
/**
* Emits an event with collection metadata.
*
* @param {string} event_key
* @param {Object} [payload={}]
* @returns {void}
*/
emit_event(event_key, payload = {}) {
this.env.events?.emit(event_key, { collection_key: this.collection_key, ...payload });
}
on_event(event_key, callback) {
return this.env.events?.on(event_key, (payload) => {
if (payload?.collection_key && payload.collection_key !== this.collection_key) return;
callback(payload);
});
}
/**
* Lazily binds action functions to the collection instance.
*
* @returns {Object} Bound action functions keyed by name.
*/
get actions() {
if (!this.constructor.key) this.constructor.key = this.collection_key;
if (!this._actions) {
const actions_modules = {
...this.env?.config?.actions || {},
...this.env?.config?.collections?.[this.collection_key]?.actions || {},
...this.env?.opts?.collections?.[this.collection_key]?.actions || {},
...this.opts?.actions || {}
};
this._actions = create_actions_proxy4(this, actions_modules);
}
return this._actions;
}
/**
* Clears cached actions proxy and rebuilds on next access.
* @returns {Object} Rebuilt proxy with latest source snapshot.
*/
refresh_actions() {
this._actions = null;
return this.actions;
}
queue_save() {
if (this._debounce_queue_save) clearTimeout(this._debounce_queue_save);
this._debounce_queue_save = setTimeout(() => {
this.process_save_queue();
}, 750);
}
/**
* @deprecated use env.smart_components~~env.smart_view~~ instead
* @returns {Object} smart_view instance
*/
get smart_view() {
if (!this._smart_view) this._smart_view = this.env.init_module("smart_view");
return this._smart_view;
}
/**
* Renders the settings for the collection into a given container.
* @deprecated use env.render_component('collection_settings', this) instead (2025-05-25: decouple UI from collections)
* @param {HTMLElement} [container=this.settings_container]
* @param {Object} opts
* @returns {Promise<HTMLElement>}
*/
async render_settings(container = this.settings_container, opts = {}) {
return await this.render_collection_settings(container, opts);
}
/**
* Helper function to render collection settings.
* @deprecated use env.render_component('collection_settings', this) instead (2025-05-25: decouple UI from collections)
* @param {HTMLElement} [container=this.settings_container]
* @param {Object} opts
* @returns {Promise<HTMLElement>}
*/
async render_collection_settings(container = this.settings_container, opts = {}) {
if (container && (!this.settings_container || this.settings_container !== container)) {
this.settings_container = container;
} else if (!container) {
container = this.env.smart_view.create_doc_fragment("<div></div>");
}
this.env.smart_view.safe_inner_html(container, `<div class="sc-loading">Loading ${this.collection_key} settings...</div>`);
const frag = await this.env.render_component("settings", this, opts);
this.env.smart_view.empty(container);
container.appendChild(frag);
return container;
}
};

function add_sequence_item(sequence, new_key) {
if (Object.keys(sequence.data.items).length === 0) {
sequence.data.items[new_key] = { _active: true };
sequence.data.items._active = new_key;
} else {
let current_node = sequence.data.items;
const active_key_at_level = "_active";
while (current_node[active_key_at_level] && current_node[current_node[active_key_at_level]]) {
current_node = current_node[current_node[active_key_at_level]];
}
const parent_node = current_node;
parent_node[new_key] = { _active: true };
parent_node._active = new_key;
}
}
__name(add_sequence_item, "add_sequence_item");
function add_sequence_item_variant(sequence, new_variant, adjacent_key) {
let parent_node = null;
let found_at_top = false;
if (sequence.data.items[adjacent_key]) {
parent_node = sequence.data.items;
found_at_top = true;
} else {
const find_parent = /* @__PURE__ */ __name((node) => {
for (const key in node) {
if (typeof node[key] === "object" && node[key] !== null && key !== "_active") {
if (node[key][adjacent_key]) {
parent_node = node[key];
return true;
}
if (find_parent(node[key])) return true;
}
}
return false;
}, "find_parent");
if (!find_parent(sequence.data.items)) return;
}
for (const key in parent_node) {
if (key !== "_active" && typeof parent_node[key] === "object") {
parent_node[key]._active = false;
}
}
parent_node[new_variant] = { _active: true };
parent_node._active = new_variant;
if (found_at_top) {
sequence.data.items._active = new_variant;
}
}
__name(add_sequence_item_variant, "add_sequence_item_variant");
function list_sequence_items(sequence) {
const active_keys = [];
let current_node = sequence.data.items;
while (current_node && current_node._active) {
const active_key = current_node._active;
if (typeof current_node[active_key] !== "object" || current_node[active_key] === null) break;
active_keys.push(active_key);
current_node = current_node[active_key];
}
return active_keys;
}
__name(list_sequence_items, "list_sequence_items");

var Sequence = class extends CollectionItem4 {
static {
__name(this, "Sequence");
}
static get defaults() {
return { data: { items: {} } };
}
/**
* Adds a key to the active path.
* @param {string} key - Item key to append.
*/
add_item(key) {
add_sequence_item(this, key);
}
/**
* Adds a variant alongside an existing item.
* @param {string} new_key - Key for the new variant item.
* @param {string} adjacent_key - Existing sibling item key.
*/
add_item_variant(new_key, adjacent_key) {
add_sequence_item_variant(this, new_key, adjacent_key);
}
get item_keys() {
return list_sequence_items(this);
}
/**
* Retrieves a key at a specific position.
* @param {number} [pos=-1] - Index in active path; negative values count from the end.
* @returns {string|null}
*/
get_item(pos = -1) {
const keys = this.item_keys;
if (pos < 0) pos = keys.length + pos;
return keys[pos] ?? null;
}
/**
* Last key in the active path.
* @returns {string|null}
*/
get last_item() {
return this.get_item(-1);
}
};
var Sequences = class extends Collection4 {
static {
__name(this, "Sequences");
}
};
var sequences_default = {};

var MIN_AGENCY = 1;
var CompletionSequences = class extends Sequences {
static {
__name(this, "CompletionSequences");
}
static get default_settings() {
return {
stream: true,
max_agency: MIN_AGENCY,
unlimited_agency: false,
chat_completion_model_key: "chat_completion#default"
};
}
/**
* Settings schema for the collection.
* @returns {object}
*/
get settings_config() {
return {
stream: {
name: "Stream responses",
type: "toggle",
description: "Display partial responses as they are generated."
}
};
}
/**
* Instantiates chat model module.
* @returns {object}
*/
get chat_model() {
if (this.env.chat_completion_models.default) {
return this.env.chat_completion_models.default.instance;
}
}
/**
* Placeholder for settings UI.
* @returns {Promise<void>}
*/
async open_settings() {
}
/**
* Flushes save queues for completions and contexts.
* @returns {Promise<void>}
*/
async process_save_queue() {
await super.process_save_queue();
await this.env.smart_completions.process_save_queue();
await this.env.smart_contexts.process_save_queue();
}
};
var completion_sequences_default = {};

var derive_agency_state = /* @__PURE__ */ __name((settings = {}, data = {}) => {
const base_max = Number.isFinite(settings.max_agency) ? settings.max_agency : MIN_AGENCY;
const override_max = Number.isFinite(data.max_agency) ? data.max_agency : null;
const max = Math.max(MIN_AGENCY, override_max ?? base_max);
const override_unlimited = typeof data.unlimited_agency === "boolean" ? data.unlimited_agency : void 0;
const unlimited = override_unlimited ?? Boolean(settings.unlimited_agency);
const confirmed = unlimited && data.unlimited_agency_confirmed === true;
return { max, unlimited, confirmed };
}, "derive_agency_state");
var within_agency_limit = /* @__PURE__ */ __name((max, count, unlimited) => unlimited || count < max, "within_agency_limit");
var CompletionSequence = class extends Sequence {
static {
__name(this, "CompletionSequence");
}
static get defaults() {
return {
data: {
name: "",
items: {},
actions_run: 0
}
};
}
/**
* Lazily generates a unique key for the sequence.
* @returns {string} sequence identifier
*/
get_key() {
if (!this.data.key) {
const now = /* @__PURE__ */ new Date();
const pad = /* @__PURE__ */ __name((n) => n.toString().padStart(2, "0"), "pad");
this.data.key = `seq-${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())}-${pad(now.getHours())}-${pad(now.getMinutes())}-${pad(now.getSeconds())}`;
}
return this.data.key;
}
/**
* Human readable name for the sequence.
* @returns {string}
*/
get name() {
return this.data.name || this.data.key;
}
/**
* Sets display name for the sequence.
* @param {string} val
*/
set name(val) {
this.data.name = val;
}
/**
* Thread-scoped settings proxy for components that read thread.settings
* @returns {object}
*/
get settings() {
return this.collection?.settings || {};
}
/**
* Chat model used for completions.
* @returns {object}
*/
get chat_model() {
return this.collection.chat_model;
}
/**
* Creates a new completion and appends its key to the sequence.
* Attaches a back-reference to this thread for component use.
* @param {object} [data]
* @returns {object} SmartCompletion instance
*/
init_completion(data = {}) {
const completion_data = {
key: `${this.key}-${Date.now()}`,
sequence_key: this.key,
stream: this.collection.settings.stream,
...data
};
const completion = new this.env.smart_completions.item_type(this.env, completion_data);
this.env.smart_completions.set(completion);
this._current_completion = completion;
this.add_item(completion.key);
return completion;
}
/**
* Updates context for the current completion.
* @param {import('smart-contexts').SmartContext} context
*/
update_current_context(context) {
this.current_completion.data.context_key = context?.key || null;
}
/**
* Current completion in progress.
* @returns {object}
*/
get current_completion() {
if (!this._current_completion || this._current_completion.data.completion.responses.length !== 0) {
this._current_completion = this.init_completion();
}
return this._current_completion;
}
/**
* Overrides current completion reference.
* @param {object} c
*/
set current_completion(c) {
this._current_completion = c;
}
/**
* Last completion that produced a response.
* @returns {object|undefined}
*/
get last_completion() {
return this.completions.findLast((c) => c.response);
}
/**
* Keys for completions in this sequence.
* @returns {string[]}
*/
get completion_keys() {
return this.item_keys;
}
/**
* Completion instances referenced by this sequence.
* @returns {object[]}
*/
get completions() {
const completions = this.completion_keys.map((k) => this.env.smart_completions.get(k)).filter(Boolean);
const last_completion_i = completions.length - 1;
const last_completion = completions[last_completion_i];
if (!last_completion || last_completion?.is_completed) {
completions.push(this.current_completion);
}
return completions;
}
/**
* Aggregated messages from all completions.
* @returns {any[]}
*/
get messages() {
return this.completions.map((c) => c.messages).flat();
}
/**
* Tracks agency usage for actions.
* @returns {boolean} true if action permitted
*/
consume_agency() {
const { max, unlimited, confirmed } = derive_agency_state(
this.collection.settings,
this.data
);
const has_capacity = within_agency_limit(max, this.data.actions_run, false);
if (has_capacity) {
this.data.unlimited_agency_confirmation_required = false;
this.data.actions_run++;
return true;
}
if (!unlimited) {
this.data.unlimited_agency_confirmation_required = false;
return false;
}
if (!confirmed) {
this.data.unlimited_agency_confirmation_required = true;
return false;
}
this.data.unlimited_agency_confirmation_required = false;
this.data.actions_run++;
return true;
}
/**
* Whether unlimited mode requires confirmation before continuing.
* @returns {boolean}
*/
get requires_unlimited_confirmation() {
return this.data.unlimited_agency_confirmation_required === true;
}
/**
* Marks unlimited agency as confirmed for current sequence run.
*/
confirm_unlimited_agency() {
this.data.unlimited_agency_confirmed = true;
this.data.unlimited_agency_confirmation_required = false;
}
/**
* Resets counters and confirmation state.
*/
reset_agency_usage() {
this.data.actions_run = 0;
this.data.unlimited_agency_confirmed = false;
this.data.unlimited_agency_confirmation_required = false;
}
};

var ChatThread = class extends CompletionSequence {
static {
__name(this, "ChatThread");
}
get name() {
return this.data.name || `Chat Thread ${this.key}`;
}
set name(val) {
this.data.name = val;
this.queue_save();
this.emit_event("chat_thread:renamed");
}
/**
* Creates a new completion and appends its key to the sequence.
* Attaches a back-reference to this thread for component use.
* @param {object} [data]
* @returns {object} SmartCompletion instance
*/
init_completion(data = {}) {
const completion_data = {
key: `${this.key}-${Date.now()}`,
chat_thread_key: this.key,
sequence_key: void 0,
stream: this.collection.settings.stream,
...data
};
return super.init_completion(completion_data);
}
get_custom_instructions(params = {}) {
const {
replace_vars = false
} = params;
let instructions = this.data.custom_instructions || this.collection.settings.default_custom_instructions;
if (replace_vars) {
}
return instructions || "";
}
};

var import_obsidian94 = require("obsidian");
function get_editor_text(el) {
let result = "";
const walk = /* @__PURE__ */ __name((node) => {
if (node.nodeType === Node.TEXT_NODE) {
result += node.nodeValue;
return;
}
if (node.nodeType !== Node.ELEMENT_NODE) return;
const element = (
/** @type {HTMLElement} */
node
);
const tag = element.tagName.toLowerCase();
if (tag === "br") {
result += "\n";
return;
}
if (tag === "div" || tag === "p" || tag === "li") {
if (result && !result.endsWith("\n")) {
result += "\n";
}
Array.from(element.childNodes).forEach(walk);
if (!result.endsWith("\n")) {
result += "\n";
}
return;
}
Array.from(element.childNodes).forEach(walk);
}, "walk");
Array.from(el.childNodes).forEach(walk);
result = result.replace(/\r\n?/g, "\n");
return result;
}
__name(get_editor_text, "get_editor_text");
var CustomInstructionsModal = class extends import_obsidian94.Modal {
static {
__name(this, "CustomInstructionsModal");
}
constructor(item_or_collection) {
const env = item_or_collection?.env;
if (!env) {
throw new Error("[smart-chat-early] Missing env in scope for CustomInstructionsModal");
}
const app = env.smart_chat_plugin?.app || window.app;
super(app);
this.env = env;
if (item_or_collection.data) {
this.item = item_or_collection;
} else {
this.collection = item_or_collection;
}
}
onOpen() {
const title = this.item ? "Custom Instructions for current chat" : "Default Custom Instructions";
this.setTitle(title);
this.contentEl.empty();
this.contentEl.addClass("smart-chat-custom-instructions-modal");
const editor_wrapper = this.contentEl.createDiv({
cls: "smart-chat-custom-instructions-editor-wrapper"
});
const editor = editor_wrapper.createDiv({
cls: "smart-chat-custom-instructions-editor"
});
editor.setAttribute("contenteditable", "true");
editor.setAttribute("placeholder", "Add custom instructions for this chat");
editor.style.maxHeight = "37rem";
editor.style.overflowY = "auto";
const instructions = this.item ? this.item.get_custom_instructions() : this.collection.settings.default_custom_instructions;
if (instructions) {
editor.innerText = instructions;
}
}
save() {
const editor = this.contentEl.querySelector(".smart-chat-custom-instructions-editor");
if (!editor) return;
const value = get_editor_text(editor);
if (this.collection) {
this.collection.settings.default_custom_instructions = value;
new import_obsidian94.Notice("Default custom instructions saved.");
this.collection.emit_event("settings:changed");
} else if (this.item) {
this.item.data.custom_instructions = value;
this.item.queue_save();
this.item.collection.process_save_queue();
new import_obsidian94.Notice("Custom instructions saved to current chat.");
this.item.emit_event("settings:changed");
} else {
this.env.events.emit("notification:error", {
message: "[smart-chat-early] No item or collection found to save custom instructions"
});
}
}
onClose() {
this.save();
}
};

var ChatThreads = class extends CompletionSequences {
static {
__name(this, "ChatThreads");
}
/**
* Default settings for chat threads.
* @returns {object}
*/
static get default_settings() {
return {
...super.default_settings,
think: true,
language: "en",
modifier_key_to_send: "shift",
actions: {
lookup_context: {
limit: 5,
results_collection_key: "smart_sources"
}
},
chat_completion_model_key: "chat_completion#default"
};
}
/**
* Settings schema for the collection.
* @returns {object}
*/
get settings_config() {
return {
default_custom_instructions: {
group: "Smart Chat",
name: "Custom instructions",
type: "button",
description: "Default custom instructions added to new chat threads. This can be edited per-thread.",
btn_text: "Edit custom instructions",
callback: /* @__PURE__ */ __name(() => this.open_default_custom_instructions_modal(), "callback")
},
modifier_key_to_send: {
group: "Smart Chat",
name: "Send modifier key",
type: "dropdown",
options: ["none", "shift", "mod", "alt", "meta"],
options_callback: /* @__PURE__ */ __name(() => {
return [
{ value: "none", label: "None" },
{ value: "shift", label: "Shift" },
{ value: "mod", label: "Ctrl (Windows) / Cmd (Mac)" },
{ value: "alt", label: "Alt" },
{ value: "meta", label: "Meta / Windows" }
];
}, "options_callback"),
description: "Keyboard modifier required to send a message."
},
stream: {
group: "Smart Chat",
name: "Stream responses",
type: "toggle",
description: "Display partial responses as they are generated."
},
"actions.lookup_context.limit": {
group: "Lookup context",
name: "Results limit",
type: "slider",
min: 1,
max: 20,
step: 1,
description: "Maximum number of context results to retrieve during context lookup action."
},
"actions.lookup_context.results_collection_key": {
group: "Lookup context",
name: "Result type",
type: "dropdown",
options_callback: /* @__PURE__ */ __name(() => {
return [
{ value: "smart_sources", label: "Sources" },
{ value: "smart_blocks", label: "Blocks" }
];
}, "options_callback")
}
};
}
open_default_custom_instructions_modal() {
const modal = new CustomInstructionsModal(this);
modal.open();
}
new_thread(data = {}, opts = {}) {
const item = new this.item_type(this.env, data);
this.set(item);
item.queue_save();
item.emit_event("chat_thread:created");
return item;
}
};
var chat_threads_default = {
class: ChatThreads,
collection_key: "chat_threads",
data_adapter: AjsonSingleFileCollectionDataAdapter4,
item_type: ChatThread
};

var SmartAction = class extends CollectionItem4 {
static {
__name(this, "SmartAction");
}
static collection_key = "smart_actions";
collection_key = "smart_actions";
async init() {
if (!this.action_adapter) {
delete this.collection.items[this.key];
return;
}
await this.action_adapter.load();
}
async run_action(params = {}) {
params = await this.pre_process(params);
let result = await this.action_adapter.run(params);
result = await this.post_process(params, result);
return result;
}
async pre_process(params) {
for (const pre_process3 of this.action_pre_processes) {
params = await pre_process3.call(this, params);
}
return params;
}
async post_process(params, result) {
for (const post_process66 of this.action_post_processes) {
result = await post_process66.call(this, params, result);
}
return result;
}
get action_adapters() {
return this.collection.opts.action_adapters;
}
get action_adapter() {
if (!this._action_adapter) {
const adapter = this.action_adapters[this.source_type] || this.action_adapters.default;
this._action_adapter = new adapter(this);
}
return this._action_adapter;
}
get action_post_processes() {
return Object.values(this.module?.post_processes || {});
}
get action_pre_processes() {
return Object.values(this.module?.pre_processes || {});
}
get active() {
return this.data.active !== false;
}
set active(val) {
this.data.active = !!val;
}
get endpoint() {
return Object.keys(this.module.openapi?.paths || {})[0] || `/${this.key}`;
}
get module() {
return this.action_adapter.module;
}
set module(module2) {
this.action_adapter.module = module2;
}
get openapi() {
return this.module.openapi;
}
get settings() {
if (!this.env.settings.smart_actions) this.env.settings.smart_actions = {};
if (!this.env.settings.smart_actions[this.key]) this.env.settings.smart_actions[this.key] = {};
return this.env.settings.smart_actions[this.key];
}
get source_type() {
return this.data.source_type;
}
/**
* OpenAI tool definition for this action.
* Delegates to the action adapter.
* @returns {object|null}
*/
get as_tool() {
return this.action_adapter.as_tool;
}
};

function convert_openapi_to_tools(openapi_spec) {
const tools = [];
for (const path in openapi_spec.paths || {}) {
const methods = openapi_spec.paths[path];
for (const method in methods) {
const endpoint = methods[method];
const parameters = endpoint.parameters || [];
const requestBody = endpoint.requestBody;
const properties = {};
const required = [];
parameters.forEach((param) => {
properties[param.name] = {
type: param.schema?.type,
description: param.description || ""
};
if (param.required) required.push(param.name);
});
if (requestBody) {
const schema = requestBody.content?.["application/json"]?.schema || {};
Object.assign(properties, schema.properties);
if (schema.required) required.push(...schema.required);
}
tools.push({
type: "function",
function: {
name: endpoint.operationId || `${method}_${path.replace(/\//g, "_").replace(/[{}]/g, "")}`,
description: endpoint.summary || endpoint.description || "",
parameters: {
type: "object",
properties,
required
}
}
});
}
}
return tools;
}
__name(convert_openapi_to_tools, "convert_openapi_to_tools");

function normalize_schema(schema) {
if (!schema) return null;
const properties = schema.properties || {};
const required = Array.isArray(schema.required) ? schema.required : [];
return {
type: schema.type || "object",
properties,
required
};
}
__name(normalize_schema, "normalize_schema");
function build_action_descriptor({ module: module2, action_key }) {
if (!module2 || typeof module2 !== "object") throw new Error("Smart Action module must be an object.");
if (!action_key) throw new Error("Smart Action module requires an action_key.");
const description = module2.description || module2.tool?.function?.description || "";
const instruction = module2.instruction || "";
const settings_config40 = module2.settings_config || {};
const descriptor = module2.descriptor || module2.mcp_descriptor || module2.mcp_tool_descriptor || null;
let input_schema = normalize_schema(module2.input_schema);
let tool2 = module2.tool;
if (!input_schema && module2.openapi) {
const [openapi_tool] = convert_openapi_to_tools(module2.openapi);
tool2 = tool2 || openapi_tool;
input_schema = normalize_schema(openapi_tool?.function?.parameters);
}
if (!input_schema && tool2?.function?.parameters) {
input_schema = normalize_schema(tool2.function.parameters);
}
if (!input_schema) {
throw new Error(`Smart Action module schema is required for ${action_key}`);
}
const normalized_tool = tool2 ? {
...tool2,
function: {
...tool2.function,
name: tool2.function?.name || action_key,
description: tool2.function?.description || description,
parameters: normalize_schema(tool2.function?.parameters) || input_schema
}
} : {
type: "function",
function: {
name: action_key,
description,
parameters: input_schema
}
};
return {
key: action_key,
description,
instruction,
input_schema,
output_schema: module2.output_schema || null,
settings_config: settings_config40,
descriptor,
tool: normalized_tool
};
}
__name(build_action_descriptor, "build_action_descriptor");

var SmartActionAdapter = class {
static {
__name(this, "SmartActionAdapter");
}
constructor(item) {
this.item = item;
this.module = null;
}
async load() {
}
/**
* Run the loaded module’s default (or named) function with given params.
* @param {Object} params
* @returns {Promise<any>}
*/
async run(params) {
if (!this.module) {
await this.load();
}
const fn = this.module.default || this.module[this.item.key];
if (typeof fn !== "function") {
throw new Error(`${this.constructor.name}: No callable export found for action ${this.item.key}`);
}
return await fn.call(this.item, params);
}
/**
* Generate an OpenAI-style tool definition for this action.
* By default it checks `module.tool` or converts `module.openapi`.
* @returns {object|null}
*/
get as_tool() {
if (!this.module) return null;
const descriptor = this.descriptor;
return descriptor?.tool || null;
}
/**
* Build the Smart Action descriptor, including schema and tool definition.
* @returns {object|null}
*/
get descriptor() {
if (!this.module) return null;
return build_action_descriptor({ module: this.module, action_key: this.item.key });
}
};

var SmartActions = class extends Collection4 {
static {
__name(this, "SmartActions");
}
collection_key = "smart_actions";
static collection_key = "smart_actions";
data_dir = "smart_actions";
async init() {
Object.entries(this.opts.default_actions).forEach(async ([action_key, module2]) => {
await this.register_included_module(action_key, module2);
});
}
async register_included_module(action_key, module2) {
const action = await this.create_or_update({
key: action_key,
source_type: "included"
});
action.module = module2;
return action;
}
};

var lookup_context_exports = {};
__export(lookup_context_exports, {
build_lookup_filter: () => build_lookup_filter,
lookup_context: () => lookup_context,
normalize_hypotheticals: () => normalize_hypotheticals,
tool: () => tool
});

function sort_by_score4(a, b) {
const epsilon = 1e-9;
const score_diff = a.score - b.score;
if (Math.abs(score_diff) < epsilon) return 0;
return score_diff > 0 ? -1 : 1;
}
__name(sort_by_score4, "sort_by_score");
function sort_by_score_descending4(a, b) {
return sort_by_score4(a, b);
}
__name(sort_by_score_descending4, "sort_by_score_descending");

var normalize_folder_prefix = /* @__PURE__ */ __name((folder_path) => {
const trimmed = (folder_path || "").trim();
if (!trimmed || trimmed === "/") return "";
return trimmed.endsWith("/") ? trimmed : `${trimmed}/`;
}, "normalize_folder_prefix");
var to_array4 = /* @__PURE__ */ __name((value) => {
if (Array.isArray(value)) return value;
if (value === void 0 || value === null) return [];
return [value];
}, "to_array");
var normalize_hypothetical_value = /* @__PURE__ */ __name((value) => {
if (typeof value !== "string") return to_array4(value);
const trimmed = value.trim();
if (!trimmed) return [];
if (trimmed.startsWith("[") && trimmed.endsWith("]")) {
try {
const parsed = JSON.parse(trimmed);
if (Array.isArray(parsed)) return parsed;
} catch {
}
}
return trimmed.includes("\n") ? trimmed.split("\n") : [trimmed];
}, "normalize_hypothetical_value");
var merge_exclude_keys = /* @__PURE__ */ __name((params = {}, exclude_keys = []) => {
const merged = [
...to_array4(params.filter?.exclude_keys),
...to_array4(params.exclude_keys),
...to_array4(exclude_keys)
].map((key) => `${key}`.trim()).filter(Boolean);
return [...new Set(merged)];
}, "merge_exclude_keys");
function normalize_hypotheticals(params = {}) {
const { hypotheticals = [], hypothetical_1, hypothetical_2, hypothetical_3 } = params;
const flattened = [
...normalize_hypothetical_value(hypotheticals),
...normalize_hypothetical_value(hypothetical_1),
...normalize_hypothetical_value(hypothetical_2),
...normalize_hypothetical_value(hypothetical_3)
];
const seen = /* @__PURE__ */ new Set();
return flattened.map((v) => (v || "").trim()).filter((v) => v.length > 0 && !seen.has(v) && (seen.add(v), true));
}
__name(normalize_hypotheticals, "normalize_hypotheticals");
function build_lookup_filter(env, params = {}, exclude_keys = []) {
const filter = { ...params.filter || {} };
const merged_exclude_keys = merge_exclude_keys(params, exclude_keys);
if (merged_exclude_keys.length) {
filter.exclude_keys = merged_exclude_keys;
}
const folder_prefix = normalize_folder_prefix(params.in_folder);
if (folder_prefix) {
filter.key_starts_with = folder_prefix;
}
return filter;
}
__name(build_lookup_filter, "build_lookup_filter");
async function lookup_context(params = {}) {
const {
limit = 10,
per_hypo_limit = 20
} = params;
console.log("lookup_context params:", params);
const env = this?.env || params?.env;
if (!env) return { error: "Missing env" };
const hypotheticals = normalize_hypotheticals(params);
console.log({ hypotheticals });
if (hypotheticals.length < 1) {
return { error: "At least one hypothetical is required" };
}
const results_collection_key = params.results_collection_key && env[params.results_collection_key] ? params.results_collection_key : env.lookup_lists.results_collection_key;
const smart_contexts = env.smart_contexts;
const context_key = params.context_key || params?.smart_context_key || smart_contexts.new_context()?.key;
const context = context_key ? smart_contexts.get(context_key) : null;
const filter = build_lookup_filter(
env,
params,
context?.data?.context_items ? Object.keys(context.data.context_items) : []
);
console.log({ filter });
const results_map = {};
for (const hypo of hypotheticals) {
const list = env.lookup_lists?.new_item?.({ query: hypo, filter }) || null;
if (!list) {
console.warn("lookup_context: unable to create Lookup List for hypothetical:", hypo);
continue;
}
const results = await list.get_results({
query: hypo,
filter,
limit: per_hypo_limit,
results_collection_key
});
console.log({ results });
for (const r of results) {
if (results_map[r.item.key]) {
results_map[r.item.key].score += r.score;
} else {
results_map[r.item.key] = r;
}
}
}
const final_top_k = Object.values(results_map).sort(sort_by_score_descending4).slice(0, limit);
console.log({ final_top_k });
context.add_items(Object.values(final_top_k).map((r) => ({ key: r.item.key, score: r.score })));
return context.key;
}
__name(lookup_context, "lookup_context");
var tool = {
type: "function",
function: {
name: "lookup_context",
description: "Runs semantic lookup using one Lookup List per hypothetical. Takes top K per hypothetical, then merges by summing scores and returns the global top K. Appends results to the provided SmartContext (context_key) or creates a new context when omitted.",
parameters: {
type: "object",
properties: {
hypothetical_1: {
type: "string",
description: "Markdown hypothetical starting with breadcrumbs (Folder > File > Heading: ...). Must be distinct from hypothetical_2."
},
hypothetical_2: {
type: "string",
description: "Second distinct hypothetical. Must not share breadcrumbs with hypothetical_1."
},
hypothetical_3: {
type: "string",
description: "Optional third distinct hypothetical."
},
in_folder: {
type: "string",
description: "Optional folder scope. Limits results to keys starting with this folder (trailing slash optional)."
}
},
required: ["hypothetical_1", "hypothetical_2"]
}
}
};

var smart_actions_default2 = {
class: SmartActions,
data_adapter: ajson_single_file_default4,
item_type: SmartAction,
action_adapters: {
default: SmartActionAdapter
},
default_actions: {
lookup_context: lookup_context_exports
}
};

var SmartCompletions = class extends Collection4 {
static {
__name(this, "SmartCompletions");
}
static version = 0.1;
/**
* Lazily instantiates and returns a chat_model. Similar to how
* @returns {Object|null} The chat model instance or null if not configured
*/
get chat_model() {
if (!this._chat_model) {
if (this.env.chat_completion_models?.default?.instance) {
return this.env.chat_completion_models.default.instance;
}
}
return this._chat_model;
}
/**
* Force unload & reload of chat model if user changes adapter or settings.
*/
reload_chat_model() {
if (this._chat_model?.unload) {
this._chat_model.unload();
}
this._chat_model = null;
}
get settings_config() {
return {};
}
get completion_adapters() {
if (!this._completion_adapters) {
this._completion_adapters = Object.values(this.opts.completion_adapters || {}).sort((a, b) => (a.order || 0) - (b.order || 0));
}
return this._completion_adapters;
}
};

function murmur_hash_324(input_string, seed = 0) {
let remainder = input_string.length & 3;
let bytes = input_string.length - remainder;
let h1 = seed;
let c1 = 3432918353;
let c2 = 461845907;
let i = 0;
let k1 = 0;
let chunk = 0;
while (i < bytes) {
chunk = input_string.charCodeAt(i) & 255 | (input_string.charCodeAt(i + 1) & 255) << 8 | (input_string.charCodeAt(i + 2) & 255) << 16 | (input_string.charCodeAt(i + 3) & 255) << 24;
i += 4;
k1 = chunk;
k1 = multiply_324(k1, c1);
k1 = rotate_left_324(k1, 15);
k1 = multiply_324(k1, c2);
h1 ^= k1;
h1 = rotate_left_324(h1, 13);
h1 = h1 * 5 + 3864292196 | 0;
}
k1 = 0;
switch (remainder) {
case 3:
k1 ^= (input_string.charCodeAt(i + 2) & 255) << 16;
case 2:
k1 ^= (input_string.charCodeAt(i + 1) & 255) << 8;
case 1:
k1 ^= input_string.charCodeAt(i) & 255;
k1 = multiply_324(k1, c1);
k1 = rotate_left_324(k1, 15);
k1 = multiply_324(k1, c2);
h1 ^= k1;
break;
}
h1 ^= input_string.length;
h1 = fmix_324(h1);
return h1 | 0;
}
__name(murmur_hash_324, "murmur_hash_32");
function murmur_hash_32_alphanumeric4(input_string, seed = 0) {
const signed_hash = murmur_hash_324(input_string, seed);
const unsigned_hash = signed_hash >>> 0;
return unsigned_hash.toString(36);
}
__name(murmur_hash_32_alphanumeric4, "murmur_hash_32_alphanumeric");
function multiply_324(a, b) {
return (a & 65535) * b + ((a >>> 16) * b << 16) | 0;
}
__name(multiply_324, "multiply_32");
function rotate_left_324(value, shift) {
return value << shift | value >>> 32 - shift;
}
__name(rotate_left_324, "rotate_left_32");
function fmix_324(h) {
h ^= h >>> 16;
h = multiply_324(h, 2246822507);
h ^= h >>> 13;
h = multiply_324(h, 3266489909);
h ^= h >>> 16;
return h | 0;
}
__name(fmix_324, "fmix_32");

function coerce_primitives(value) {
if (typeof value !== "string") {
return value;
}
const trimmed_value = value.trim();
if (trimmed_value === "true") {
return true;
}
if (trimmed_value === "false") {
return false;
}
const float_pattern = /^-?\d+\.\d+$/;
if (float_pattern.test(trimmed_value)) {
const num = parseFloat(trimmed_value);
if (num.toString() === trimmed_value) {
return num;
}
}
const int_pattern = /^-?(?:0|[1-9]\d*)$/;
if (int_pattern.test(trimmed_value)) {
return Number(trimmed_value);
}
return value;
}
__name(coerce_primitives, "coerce_primitives");

function strip_code_fence(raw_input) {
const fence_re = /^\s*```[a-z]*\n([\s\S]*?)\n```\s*$/i;
const m = fence_re.exec(raw_input);
return m ? m[1] : raw_input;
}
__name(strip_code_fence, "strip_code_fence");
function parse_xml_fragments(xml_input) {
if (typeof xml_input !== "string" || xml_input.trim() === "") {
return null;
}
const stripped_input = strip_code_fence(xml_input);
const VERBATIM_TAGS = /* @__PURE__ */ new Set(["think"]);
const compress_whitespace = /* @__PURE__ */ __name((str) => str.replace(/\s+/g, " ").trim(), "compress_whitespace");
const parse_attributes = /* @__PURE__ */ __name((str) => {
if (!str) return {};
const attrs = {};
const attr_re = /(\w[\w.\-]*)\s*=\s*(?:"([^"]*)"|'([^']*)')/g;
let m;
while ((m = attr_re.exec(str)) !== null) {
const [, key, val_dq, val_sq] = m;
const raw_val = val_dq ?? val_sq;
attrs[key] = coerce_primitives(raw_val);
}
return attrs;
}, "parse_attributes");
const attach_child = /* @__PURE__ */ __name((map, tag, node) => {
if (tag in map) {
const existing = map[tag];
map[tag] = Array.isArray(existing) ? [...existing, node] : [existing, node];
} else {
map[tag] = node;
}
}, "attach_child");
const finalize_node = /* @__PURE__ */ __name((ctx) => {
const text_raw = ctx.verbatim ? ctx.text.replace(/^\s*\n/, "").replace(/\s+$/, "") : compress_whitespace(ctx.text);
if (Object.keys(ctx.children_map).length) {
ctx.node.contents = ctx.children_map;
} else if (text_raw !== "") {
ctx.node.contents = ctx.verbatim ? text_raw : coerce_primitives(text_raw);
} else {
ctx.node.contents = null;
}
}, "finalize_node");
const cleaned = stripped_input.replace(/<!--[\s\S]*?-->/g, "");
const token_re = /<[^>]+>|[^<]+/g;
const root_map = {};
const stack = [];
let match;
while ((match = token_re.exec(cleaned)) !== null) {
const token = match[0];
if (stack.length) {
const top = stack[stack.length - 1];
if (top.verbatim) {
if (token.startsWith(`</${top.tag_name}`)) {
stack.pop();
finalize_node(top);
if (stack.length === 0) {
attach_child(root_map, top.tag_name, top.node);
} else {
attach_child(stack[stack.length - 1].children_map, top.tag_name, top.node);
}
continue;
}
top.text += token;
continue;
}
}
if (token.startsWith("<")) {
if (token.startsWith("</")) {
const tag_name = token.slice(2, -1).trim();
if (!stack.length) return null;
const ctx = stack.pop();
if (ctx.tag_name !== tag_name) return null;
finalize_node(ctx);
if (stack.length === 0) {
attach_child(root_map, tag_name, ctx.node);
} else {
attach_child(stack[stack.length - 1].children_map, tag_name, ctx.node);
}
} else {
const self_closing = token.endsWith("/>");
const body = self_closing ? token.slice(1, -2) : token.slice(1, -1);
const first_space = body.indexOf(" ");
const tag_name = first_space === -1 ? body : body.slice(0, first_space);
const attr_str = first_space === -1 ? "" : body.slice(first_space + 1);
const attributes = parse_attributes(attr_str);
const node = Object.keys(attributes).length ? { attributes } : {};
if (self_closing) {
node.contents = null;
if (stack.length === 0) {
attach_child(root_map, tag_name, node);
} else {
attach_child(stack[stack.length - 1].children_map, tag_name, node);
}
} else {
stack.push({
tag_name,
node,
text: "",
children_map: {},
verbatim: VERBATIM_TAGS.has(tag_name)
});
}
}
} else {
if (stack.length) stack[stack.length - 1].text += token;
}
}
while (stack.length) {
const ctx = stack.pop();
finalize_node(ctx);
if (stack.length === 0) {
attach_child(root_map, ctx.tag_name, ctx.node);
} else {
attach_child(stack[stack.length - 1].children_map, ctx.tag_name, ctx.node);
}
}
return Object.keys(root_map).length ? root_map : null;
}
__name(parse_xml_fragments, "parse_xml_fragments");

var SmartCompletion = class extends CollectionItem4 {
static {
__name(this, "SmartCompletion");
}
constructor(env, data = null) {
super(env, data);
this.run_adapter_item_constructors();
}
run_adapter_item_constructors() {
for (const [key, AdapterClass] of Object.entries(this.completion_adapters)) {
AdapterClass.item_constructor?.(this);
}
}
/**
* Default data structure for a new SmartCompletion item.
* @static
* @returns {Object}
*/
static get defaults() {
return {
response_i: 0,
data: {
completion: {
request: {},
responses: [],
chat_model: null,
error: null
}
}
};
}
/**
* get_key
* Overridden to produce a unique key based on a hash of this.data plus the current timestamp.
* @returns {string}
*/
get_key() {
const hash = murmur_hash_32_alphanumeric4(JSON.stringify(this.data));
const ts = Date.now();
return `${hash}-${ts}`;
}
/**
* Called automatically via create_or_update
* You can also call it manually if needed.
*/
async init(completion_opts = {}) {
await this.build_request();
await this.complete(completion_opts);
if (this.is_completed) {
await this.parse_response();
this.queue_save();
this.collection.process_save_queue();
}
}
get chat_completion_model() {
if (this.data.chat_completion_model_key && this.env.chat_completion_models.get(this.data.chat_completion_model_key)) {
const model = this.env.chat_completion_models.get(this.data.chat_completion_model_key);
return model;
} else {
return this.env.chat_completion_models.default;
}
}
/**
* @deprecated 2025-12-13 migrate to model_instance
*/
get chat_model() {
if (!this._chat_model) {
return this.chat_completion_model?.instance || null;
}
return this._chat_model;
}
/**
* @deprecated 2025-12-13 set data.chat_completion_model_key instead
*/
set chat_model(model_instance) {
if (model_instance.collection_key === "chat_completion_models") {
this.data.chat_completion_model_key = model_instance.key;
} else if (typeof model_instance.complete === "function" && typeof model_instance.stream === "function") {
this._chat_model = model_instance;
} else {
console.warn("Invalid chat model instance assigned to SmartCompletion");
}
}
get model_instance() {
return this.chat_completion_model?.instance || null;
}
get active_adapters() {
return this.completion_adapters.filter((AdapterClass) => AdapterClass.use_adapter(this));
}
/**
* Collects or transforms data into a final `completion.request` structure
* by running any applicable completion adapters.
* @returns {Promise<void>}
*/
async build_request() {
this.data.completion.request = {};
for (const AdapterClass of this.active_adapters) {
const adapter = new AdapterClass(this);
await adapter.to_request();
}
if (Object.keys(this.data.completion.request).length > 0) {
this.data.completion.request.messages = this.data.completion.request.messages.map((msg) => {
if (typeof msg.content === "string" && msg.content.trim().length === 0) return null;
if (Array.isArray(msg.content)) {
msg.content = msg.content.filter((part) => {
if (part.type !== "text") return true;
if (part.text && part.text.trim().length > 0) return true;
return false;
});
if (msg.content.length === 0) return null;
}
return msg;
}).filter((msg) => msg !== null);
;
}
return this.data.completion.request;
}
async parse_response() {
for (const AdapterClass of this.active_adapters) {
const adapter = new AdapterClass(this);
await adapter.from_response();
}
return this.data.completion.responses;
}
/**
* Calls the underlying chat model, stores the response in completion.responses.
* @returns {Promise<void>}
*/
async complete(opts = {}) {
this.emit_event("completion:completing", { raw: "" });
if (!this.data.completion || !this.data.completion.request) {
console.warn("No completion.request found, skipping complete().");
return;
}
if (!this.model_instance) {
console.warn("No chat model available for SmartCompletion. Check environment config.");
return;
}
this.data.completion.chat_model = {
platform_key: this.chat_completion_model?.data?.platform_key,
model_key: this.chat_completion_model?.data?.model_key,
chat_completion_model_key: this.chat_completion_model?.key
};
try {
const request_payload = this.data.completion.request;
const stream = opts.stream;
const result = stream ? await this.model_instance.stream(request_payload, this.stream_handlers(opts.stream_handlers)) : await this.model_instance.complete(request_payload);
if (!stream) {
if (result.error) return this.handle_error(result.error);
this.emit_event("completion:completed");
this.data.completion.responses.push({
timestamp: Date.now(),
...result
});
}
this.queue_save();
} catch (err) {
console.error("Error in SmartCompletion.complete():", err);
this.handle_error(err);
}
}
stream_handlers(stream_handlers = {}) {
return {
chunk: /* @__PURE__ */ __name(async (resp) => {
this.data.completion.responses[0] = {
timestamp: Date.now(),
...resp
};
const raw = resp.raw;
this.emit_event("completion:completing", { raw });
await stream_handlers.chunk?.(this);
}, "chunk"),
done: /* @__PURE__ */ __name(async (resp) => {
this.data.completion.responses[0] = {
timestamp: Date.now(),
...resp
};
this.emit_event("completion:completed");
await stream_handlers.done?.(this);
}, "done"),
error: /* @__PURE__ */ __name(async (err) => {
console.error("error", err);
await stream_handlers.error?.(err);
}, "error")
};
}
/**
* @method handle_error
* @param {Object} normalized_err - Normalized error object (normalized in SmartChatModel utility)
*/
handle_error(normalized_err) {
console.log("handling completion error", normalized_err);
this.data.completion.error = normalized_err;
if (this.data.completion.responses.length > 0) {
this.data.completion.error.responses = [...this.data.completion.responses];
this.data.completion.responses = [];
}
this.emit_event("completion:error", normalized_err);
this.queue_save();
}
/**
* Access the completion adapters from the parent collection, if any.
*/
get completion_adapters() {
return this.collection?.completion_adapters || {};
}
/**
* @returns {Object|undefined} Currently selected response based on `response_i`.
*/
get response() {
return this.data.completion.responses[this.response_i];
}
/**
* @method response_text
* @returns {string} The best guess at the main text from the model's first response.
*/
get response_text() {
const resp = this.response;
if (!resp) return "";
if (Array.isArray(resp.choices) && resp.choices[0]) {
const choice = resp.choices[0];
if (choice.message && choice.message.content) {
return choice.message.content;
}
if (choice.text) return choice.text;
}
if (resp.text) return resp.text;
return "";
}
/**
* @deprecated 2025-11-17 probably best handled in adapters
*/
get response_structured_output() {
if (!this.response) return null;
if (this.action_call) {
try {
const parsed2 = JSON.parse(this.action_call);
return parsed2;
} catch (e) {
console.log("failed to parse tool_call in response_structured_output");
}
}
if (!this.response_text) return null;
const parsed = parse_xml_fragments(this.response_text);
if (!parsed) return null;
return parsed;
}
get action_call() {
const resp = this.response;
if (!resp) return null;
return resp.choices?.[0]?.message?.tool_calls?.[0]?.function?.arguments;
}
get messages() {
const messages = [];
if (this.data.system_message) {
messages.push({
role: "system",
content: this.data.system_message
});
}
if (this.data.user_message) {
messages.push({
role: "user",
content: this.data.user_message
});
}
if (this.response_text) {
messages.push({
role: "assistant",
content: this.response_text
});
}
return messages;
}
get is_completed() {
return this.data.completion.responses.length > 0;
}
/**
* Toggle or force a Smart Action for this completion.
* Ensures only a single forced action is active at a time.
* @param {string} action_key
* @param {{active?: boolean, force?: boolean}} opts
*/
use_action(action_key, opts = {}) {
if (!action_key) return;
this.data.smart_actions ??= {};
const current_state = this.data.smart_actions[action_key] || {};
const next_state = {
active: true,
force: false,
...current_state,
...opts
};
if (next_state.force) {
for (const key of Object.keys(this.data.smart_actions)) {
if (key === action_key) continue;
if (this.data.smart_actions[key]?.force) {
this.data.smart_actions[key].force = false;
}
}
}
this.data.smart_actions[action_key] = next_state;
this.emit_event("completion:actions-updated", {
action_key,
active: Boolean(next_state.active),
force: Boolean(next_state.force)
});
this.queue_save();
this.collection?.process_save_queue?.();
}
/**
* Proxy getter to the smart_actions state (namespace-safe from 'actions').
*/
get smart_actions() {
return this.data.smart_actions || {};
}
};

function insert_user_message(request, user_message, opts = {}) {
if (!user_message) return;
const { position = "end", new_user_message = false } = opts;
if (!request.messages) {
request.messages = [];
}
const last_user_index = request.messages.findLastIndex((x) => x.role === "user");
if (last_user_index === -1 || new_user_message) {
const new_user_message2 = {
role: "user",
content: [{ type: "text", text: user_message }]
};
request.messages.push(new_user_message2);
return;
}
const last_user_message = request.messages[last_user_index];
if (!Array.isArray(last_user_message.content)) {
last_user_message.content = [
{
type: "text",
text: last_user_message.content
}
];
}
if (position === "start") {
last_user_message.content.unshift({
type: "text",
text: user_message
});
} else {
last_user_message.content.push({
type: "text",
text: user_message
});
}
}
__name(insert_user_message, "insert_user_message");

var SmartCompletionAdapter = class {
static {
__name(this, "SmartCompletionAdapter");
}
static adapter_type = "completion";
static use_adapter(completion) {
if (this.adapter_type !== "completion") return false;
if (this.property_name && !(this.property_name in completion.data)) return false;
return true;
}
constructor(completion) {
this.completion = completion;
}
get data() {
return this.completion.data;
}
get env() {
return this.completion.env;
}
get request() {
return this.data.completion.request;
}
get response() {
return this.completion.response;
}
insert_user_message(user_message, opts = {}) {
insert_user_message(this.request, user_message, opts);
}
static get property_name() {
return null;
}
/**
* @returns {Promise<void>}
*/
async to_request() {
}
/**
* @returns {Promise<void>}
*/
async from_response() {
}
/**
* @deprecated Use `this.completion` instead.
*/
get item() {
return this.completion;
}
};

var SmartCompletionUserAdapter = class extends SmartCompletionAdapter {
static {
__name(this, "SmartCompletionUserAdapter");
}
static order = 1;
/**
* @returns {string}
*/
static get property_name() {
return "user_message";
}
get request() {
return this.item.data.completion.request;
}
/**
* to_request: Checks `data.user`, adds a user message to `request.messages`.
* @returns {Promise<void>}
*/
async to_request() {
const user_message = this.data.user_message;
const new_user_message = this.data.new_user_message;
this.insert_user_message(user_message, {
position: "start",
new_user_message
});
}
/**
* from_response: No post-processing needed for default user message.
* @returns {Promise<void>}
*/
async from_response() {
}
};

var ActionCompletionAdapter = class extends SmartCompletionAdapter {
static {
__name(this, "ActionCompletionAdapter");
}
static get property_name() {
return "action_key";
}
/**
* @returns {Promise<void>}
*/
async to_request() {
const action_key = this.data.action_key;
if (!action_key) return;
const thread = this.item.thread;
if (thread && thread.current_completion !== this.item) return console.log("ActionCompletionAdapter: skipping tools, not the current completion");
const action_opts = this.data.action_opts;
const action_collection = this.item.env.smart_actions;
if (!action_collection) {
console.warn("No 'smart_actions' collection found; skipping action adapter.");
return;
}
const action_item = action_collection.get(action_key);
if (!action_item) {
console.warn(`SmartAction not found for key '${action_key}'`);
return;
}
let tools;
try {
const tool2 = action_item.as_tool;
tools = tool2 ? [tool2] : [];
} catch (err) {
console.warn("Error generating action tool", err);
return;
}
if (!tools.length) return;
if (!this.data.actions) this.data.actions = {};
this.data.actions[action_key] = true;
this.insert_tools(tools, { force: true });
}
get default_action_params() {
return this.data.action_opts || {};
}
/**
* @returns {Promise<void>}
*/
async from_response() {
console.log("ActionCompletionAdapter: from_response");
const tool_call = this.response.choices[0].message?.tool_calls?.[0];
if (!tool_call) return console.warn("No tool call found in response");
const action_key = tool_call?.function?.name;
const tool_arguments = tool_call?.function?.arguments;
if (!action_key) return;
const action_collection = this.item.env.smart_actions;
if (!action_collection) return;
const action_item = action_collection.get(action_key);
if (!action_item) return;
let parsed_args = tool_arguments;
if (typeof parsed_args === "string") {
try {
parsed_args = JSON.parse(parsed_args);
} catch (err) {
console.warn("Could not parse tool_call arguments", err);
return;
}
}
const action_params = {
...this.default_action_params,
...parsed_args
};
const result = await action_item.run_action(action_params);
if (result && typeof result === "object" && result.final) {
if (!this.item.data.completion.responses[0]) {
this.item.data.completion.responses[0] = { choices: [{ message: {} }] };
} else if (!this.item.data.completion.responses[0].choices?.[0]) {
this.item.data.completion.responses[0].choices = [{ message: {} }];
}
this.item.data.completion.responses[0].choices[0].message = {
...this.item.data.completion.responses[0].choices[0].message,
role: "assistant",
content: result.final
};
}
if (!this.data.actions) this.data.actions = {};
this.data.actions[action_key] = result;
}
/**
* Insert the ephemeral tools into the request
* @param {Array<object>} tools
* @param {object} opts
* @returns {void}
*/
insert_tools(tools, opts = {}) {
this.request.tools = tools;
if (opts.force) {
this.request.tool_choice = {
type: "function",
function: {
name: tools[0].function.name
}
};
}
}
};

function scaffold_xml(root_tag, root_desc, params) {
return [
`<${root_tag} instructions="${root_desc}">`,
...Object.entries(params).map(
([p, v]) => `  <${p} instructions="${v.description || ""}">VALUE</${p}>`
),
`</${root_tag}>`
].join("\n");
}
__name(scaffold_xml, "scaffold_xml");
function strip_instruction_attrs(xml) {
return xml.replace(/\s+instructions="[^"]*"/g, "");
}
__name(strip_instruction_attrs, "strip_instruction_attrs");
var ActionXmlCompletionAdapter = class extends ActionCompletionAdapter {
static {
__name(this, "ActionXmlCompletionAdapter");
}
static get property_name() {
return "action_xml_key";
}
/* ────────────────────────────────────────────────────────────────────────
REQUEST CONSTRUCTION
────────────────────────────────────────────────────────────────────── */
async to_request() {
const action_key = this.data.action_xml_key;
if (!action_key) return;
const thread = this.item.thread;
if (thread.current_completion !== this.item) return console.log("ActionXmlCompletionAdapter: skipping tools, not the current completion");
const action_item = this.env.smart_actions?.get(action_key);
if (!action_item) {
return console.warn(`SmartAction '${action_key}' not found`);
}
let tools;
try {
const tool2 = action_item.as_tool;
tools = tool2 ? [tool2] : [];
} catch (err) {
return console.warn("Unable to compile OpenAPI \u2192 tools", err);
}
if (!tools.length) return;
const func_def = tools[0].function;
const param_props = func_def.parameters?.properties || {};
const required_params = func_def.parameters?.required || [];
this._func_name = func_def.name;
this._required_params = required_params;
const action_instruction = [
"Important Instructions:",
`1. You must invoke the action '${func_def.name}' exactly once.`,
"2. You must respond *only* with XML in the exact structure provided below.",
"3. Replace VALUE with real arguments based on the property-specific instructions below.",
"4. Do not include any other text or instructions.",
"5. Follow these property-specific instructions for producing the XML response.",
"Action Instructions:",
`- ${func_def.description || ""}`,
"Property-Specific Instructions:",
...Object.entries(param_props).map(
([p, v]) => `- ${p}: ${v.description || ""}`
)
].join("\n");
const xml_scaffold = scaffold_xml(func_def.name, func_def.description, param_props);
const xml_template = strip_instruction_attrs(xml_scaffold);
const action_instruction_msg = [
action_instruction,
`You are ready to invoke the action '${func_def.name}'.`
].join("\n");
const xml_template_msg = [
`To invoke the action '${func_def.name}', respond *only* with XML in this exact structure (replace VALUE with real arguments based on the action and property-specific instructions above):`,
xml_template
].join("\n");
this.insert_user_message(action_instruction_msg);
this.insert_user_message(xml_template_msg);
this.data.actions ??= {};
this.data.actions[action_key] = true;
this.data.action_key = action_key;
}
/* ────────────────────────────────────────────────────────────────────────
RESPONSE PARSING
────────────────────────────────────────────────────────────────────── */
async from_response() {
const action_key = this.data.action_xml_key;
if (!action_key) return;
const assistant_msg = this.response?.choices?.[0]?.message;
if (!assistant_msg) {
return console.warn("ActionXmlCompletionAdapter: assistant message not found");
}
const func_name = this._func_name || action_key;
let parsed_xml = this.item?.response_structured_output;
let root_node = parsed_xml[func_name];
if (!root_node) {
const candidate = Object.keys(parsed_xml)[0];
console.warn(`ActionXmlCompletionAdapter: expected root <${func_name}>, found <${candidate}> \u2013 using candidate`);
root_node = parsed_xml[candidate];
}
if (!root_node) {
return console.warn(`ActionXmlCompletionAdapter: root tag '${func_name}' not found`);
}
const node_to_value = /* @__PURE__ */ __name((node) => {
if (!node || typeof node !== "object") return node;
const { attributes = {}, contents } = node;
if (contents === null || typeof contents !== "object") {
return Object.keys(attributes).length ? { ...attributes, value: contents } : contents;
}
const out = {};
for (const [k, v] of Object.entries(contents)) {
out[k] = Array.isArray(v) ? v.map(node_to_value) : node_to_value(v);
}
return Object.keys(attributes).length ? { ...attributes, ...out } : out;
}, "node_to_value");
const args = node_to_value(root_node);
const missing = (this._required_params || []).filter(
(p) => args[p] === void 0 || args[p] === "" || args[p] === null
);
if (missing.length) {
return console.warn(`ActionXmlCompletionAdapter: missing ${missing.join(", ")}`);
}
assistant_msg.tool_calls = [
{ function: { name: action_key, arguments: args } }
];
delete assistant_msg.content;
await super.from_response();
}
};

var SmartCompletionSystemAdapter = class extends SmartCompletionAdapter {
static {
__name(this, "SmartCompletionSystemAdapter");
}
/**
* Identifies the data property that triggers this adapter.
* @returns {string}
*/
static get property_name() {
return "system_message";
}
/**
* to_request: If `data.system_message` is present, prepends a system message to request.messages.
* @returns {Promise<void>}
*/
async to_request() {
const sys_msg = this.data.system_message;
if (!sys_msg) return;
if (!this.request.messages) {
this.request.messages = [];
}
this.request.messages.unshift({
role: "system",
content: sys_msg
});
}
/**
* from_response: No post-processing needed here.
* @returns {Promise<void>}
*/
async from_response() {
}
};

var SmartCompletionVariableAdapter = class extends SmartCompletionAdapter {
static {
__name(this, "SmartCompletionVariableAdapter");
}
static order = 100;
static registry = [];
static register(matcher_fx, replacement_fx, var_example) {
this.registry.push({ matcher_fx, replacement_fx, var_example });
}
static get available_vars() {
return this.registry.map(({ var_example }) => var_example);
}
static async replace_vars(env, text) {
for (const { matcher_fx, replacement_fx } of this.registry) {
if (await matcher_fx.call(env, text)) {
text = await replacement_fx.call(env, text);
}
}
return text;
}
async to_request() {
const messages = this.request.messages || [];
for (const msg of messages) {
if (typeof msg.content === "string") {
msg.content = await this.constructor.replace_vars(this.env, msg.content);
} else if (Array.isArray(msg.content)) {
for (const part of msg.content) {
if (part && typeof part.text === "string") {
part.text = await this.constructor.replace_vars(this.env, part.text);
}
}
}
}
}
async from_response() {
}
};

var ContextCompletionAdapter = class extends SmartCompletionAdapter {
static {
__name(this, "ContextCompletionAdapter");
}
static order = 10;
static get property_name() {
return "context_key";
}
static item_constructor(completion) {
Object.defineProperty(completion, "context", {
get() {
const key = completion.data.context_key;
const smart_contexts = completion.env.smart_contexts;
let context = smart_contexts.get(key);
if (!key || !context) {
context = smart_contexts.new_context();
completion.data.context_key = context.key;
}
return context;
}
});
}
async to_request() {
const chat_thread = this.completion.chat_thread;
const context = this.completion.context;
if (!context) {
console.warn(`[ContextCompletionAdapter] context not found for completion key '${this.completion.key}'; skipping context adapter.`);
return;
}
if (!context.has_context_items) {
console.warn(`[ContextCompletionAdapter] Context '${context.key}' has no context items; skipping context adapter.`);
return;
}
if (chat_thread) {
if (chat_thread.current_completion.key !== this.completion.key) return;
}
const text = await context.get_text();
const content = [{ type: "text", text }];
if (this.completion.data.user_message) {
content.unshift({ type: "text", text: this.completion.data.user_message });
}
const media = await context.get_media();
for (const item_base64 of media) {
if (item_base64.type === "image_url") {
content.push({
type: "image_url",
image_url: { url: item_base64.url }
});
} else if (item_base64.type === "pdf_url") {
content.push({
type: "file",
file: {
filename: item_base64.name,
file_data: item_base64.url
}
});
}
}
this.request.messages.unshift({
role: "user",
content
});
}
/**
* No special post-processing after we get model response.
*/
async from_response() {
}
};

var smart_completions_default_config = {
class: SmartCompletions,
data_adapter: AjsonSingleFileCollectionDataAdapter4,
item_type: SmartCompletion,
completion_adapters: {
ContextCompletionAdapter,
SmartCompletionUserAdapter,
ActionCompletionAdapter,
ActionXmlCompletionAdapter,
SmartCompletionSystemAdapter,
SmartCompletionVariableAdapter
}
};

var ChatThreadCompletionAdapter = class extends SmartCompletionAdapter {
static {
__name(this, "ChatThreadCompletionAdapter");
}
static version = 0.1;
static order = -1;
/**
* @returns {string}
*/
static get property_name() {
return "chat_thread_key";
}
static item_constructor(completion) {
Object.defineProperty(completion, "chat_thread", {
get() {
const key = completion.data.chat_thread_key;
if (!key) {
console.warn("No chat_thread_key defined on completion", { completion });
return null;
}
return completion.env.chat_threads.get(key);
}
});
}
/**
* to_request: Appends messages from the referenced thread.
* @returns {Promise<void>}
*/
async to_request() {
const chat_thread = this.completion.chat_thread;
if (!chat_thread || !Array.isArray(chat_thread.messages)) {
console.warn(`Thread item '${this.data.chat_thread_key}' not found or missing .data.messages array`);
return;
}
if (!this.request.messages) {
this.request.messages = [];
}
const thread_completions = chat_thread.completions.filter((c) => !c?.data?.exclude && c.key !== this.completion.key);
console.log({ prior_completions: thread_completions });
for (let i = 0; i < thread_completions.length; i++) {
const prior_completion = thread_completions[i];
if (prior_completion.data.user_message) {
this.request.messages.push({ role: "user", content: prior_completion.data.user_message });
}
if (prior_completion.response_text) {
this.request.messages.push({ role: "assistant", content: prior_completion.response_text });
}
}
const seen = /* @__PURE__ */ new Set();
this.request.messages = this.request.messages.filter((msg) => {
const contentKey = Array.isArray(msg.content) ? JSON.stringify(msg.content) : msg.content;
if (seen.has(contentKey)) return false;
seen.add(contentKey);
return true;
});
const system_message = chat_thread.get_custom_instructions({ replace_vars: true });
if (system_message) {
this.request.messages.unshift({ role: "system", content: system_message });
}
}
/**
* from_response: No post-processing needed for thread.
* @returns {Promise<void>}
*/
async from_response() {
const thread = this.item.chat_thread;
if (!thread) return console.warn("No thread found");
setTimeout(() => {
thread.queue_save();
thread.collection.process_save_queue();
}, 1e3);
}
};

var clone_message = /* @__PURE__ */ __name((message) => {
if (!message) return null;
const cloned = { ...message };
if (Array.isArray(message.content)) {
cloned.content = message.content.map((part) => ({ ...part }));
} else if (message.content && typeof message.content === "object") {
cloned.content = { ...message.content };
}
return cloned;
}, "clone_message");
var serialize_content = /* @__PURE__ */ __name((content) => {
if (Array.isArray(content)) {
return JSON.stringify(content);
}
if (content && typeof content === "object") {
return JSON.stringify(content);
}
return String(content ?? "");
}, "serialize_content");
var dedupe_messages = /* @__PURE__ */ __name((messages) => {
const seen = /* @__PURE__ */ new Set();
return messages.filter((message) => {
if (!message) return false;
const key = `${message.role}|${serialize_content(message.content)}`;
if (seen.has(key)) return false;
seen.add(key);
return true;
});
}, "dedupe_messages");
var extract_completion_history = /* @__PURE__ */ __name((completion) => {
if (!completion) return [];
const request_messages = completion.data?.completion?.request?.messages || [];
const history = request_messages.map(clone_message);
const response_text = completion.response_text?.trim?.() ? completion.response_text.trim() : "";
if (response_text) {
history.push({ role: "assistant", content: response_text });
}
return history;
}, "extract_completion_history");
var sequence_keys_from_record = /* @__PURE__ */ __name((sequence) => {
if (!sequence) return [];
if (Array.isArray(sequence.item_keys)) {
return sequence.item_keys;
}
if (typeof sequence.item_keys === "function") {
return sequence.item_keys();
}
if (Array.isArray(sequence.completion_keys)) {
return sequence.completion_keys;
}
if (typeof sequence.completion_keys === "function") {
return sequence.completion_keys();
}
return [];
}, "sequence_keys_from_record");
var is_excluded_completion = /* @__PURE__ */ __name((completion) => completion?.data?.exclude === true, "is_excluded_completion");
var gather_sequence_completions = /* @__PURE__ */ __name(({ env, sequence_key, current_key }) => {
const completions = [];
const sequence = env?.completion_sequences?.get?.(sequence_key) || null;
if (sequence) {
const keys = sequence_keys_from_record(sequence);
for (const key of keys) {
if (key === current_key) break;
const completion = env?.smart_completions?.get?.(key) || env?.smart_completions?.items?.[key] || null;
if (!completion || is_excluded_completion(completion)) continue;
completions.push(completion);
}
return completions;
}
const items = env?.smart_completions?.items;
if (!items) return completions;
return Object.values(items).filter((item) => item?.data?.sequence_key === sequence_key && item.key !== current_key && !is_excluded_completion(item)).sort((a, b) => {
const a_time = a.data?.created_at ?? 0;
const b_time = b.data?.created_at ?? 0;
return a_time - b_time;
});
}, "gather_sequence_completions");
var build_sequence_history = /* @__PURE__ */ __name(({ env, sequence_key, current_key }) => {
const completions = gather_sequence_completions({ env, sequence_key, current_key });
return completions.flatMap(extract_completion_history);
}, "build_sequence_history");
var SequenceCompletionAdapter = class extends SmartCompletionAdapter {
static {
__name(this, "SequenceCompletionAdapter");
}
static version = 0.1;
static order = -2;
/**
* @returns {string}
*/
static get property_name() {
return "sequence_key";
}
/**
* @param {import('smart-completions').SmartCompletionItem} completion
* @returns {void}
*/
static item_constructor(completion) {
Object.defineProperty(completion, "sequence", {
get() {
const key = completion.data?.sequence_key;
if (!key) return null;
return completion.env?.completion_sequences?.get?.(key) || null;
}
});
}
/**
* Prepends prior sequence history into the current request.
* @returns {Promise<void>}
*/
async to_request() {
const sequence_key = this.data?.sequence_key;
if (!sequence_key) return;
const history = build_sequence_history({
env: this.env,
sequence_key,
current_key: this.item.key
});
if (history.length === 0) return;
this.request.messages ??= [];
const deduped_history = dedupe_messages(history);
this.request.messages = [...deduped_history, ...this.request.messages];
}
};

var SmartActionsCompletionAdapter = class extends SmartCompletionAdapter {
static {
__name(this, "SmartActionsCompletionAdapter");
}
static get property_name() {
return "smart_actions";
}
static item_constructor(completion) {
}
/**
* @returns {Promise<void>}
*/
async to_request() {
const forced_action = Object.entries(this.data.smart_actions || {}).filter(([action_key, action_params]) => action_params.force).map(([action_key, action_params]) => ({ key: action_key, ...action_params }))[0];
const active_actions = forced_action ? [forced_action] : Object.entries(this.data.smart_actions || {}).filter(([action_key, action_params]) => action_params.active).map(([action_key, action_params]) => ({ key: action_key, ...action_params }));
if (active_actions.length === 0) {
console.log("No active or forced actions found; skipping action adapter.");
return;
}
const action_collection = this.env.smart_actions;
if (!action_collection) {
console.warn("No 'smart_actions' collection found; skipping action adapter.");
return;
}
const actions = active_actions.map((a) => action_collection.get(a.key)).filter(Boolean);
if (actions.length === 0) {
console.warn("No valid SmartAction items found; skipping action adapter.");
return;
}
const tools = actions.map((action_item) => action_item.as_tool).filter(Boolean);
if (!tools.length) {
console.warn("No tools could be generated from active SmartActions; skipping action adapter.");
return;
}
this.insert_tools(tools, { force: true });
}
/**
* @deprecated use smart_actions[action_key] = {...params} instead
*/
get default_action_params() {
return this.data.action_opts || {};
}
/**
* @returns {Promise<void>}
*/
async from_response() {
console.log("ActionCompletionAdapter: from_response");
const tool_call = this.response.choices[0].message?.tool_calls?.[0];
if (!tool_call) return console.warn("No tool call found in response");
const action_key = tool_call?.function?.name;
const tool_arguments = tool_call?.function?.arguments;
if (!action_key) return;
const action_collection = this.env.smart_actions;
if (!action_collection) return;
const action_item = action_collection.get(action_key);
if (!action_item) return;
let parsed_args = tool_arguments;
if (typeof parsed_args === "string") {
try {
parsed_args = JSON.parse(parsed_args);
} catch (err) {
console.warn("Could not parse tool_call arguments", err);
return;
}
}
const action_params = {
...this.data.smart_actions?.[action_key] || {},
...this.default_action_params,
...parsed_args
};
const result = await action_item.run_action(action_params);
if (result && typeof result === "object" && result.final) {
if (!this.data.completion.responses[0]) {
this.data.completion.responses[0] = { choices: [{ message: {} }] };
} else if (!this.data.completion.responses[0].choices?.[0]) {
this.data.completion.responses[0].choices = [{ message: {} }];
}
this.data.completion.responses[0].choices[0].message = {
...this.data.completion.responses[0].choices[0].message,
role: "assistant",
content: result.final
};
}
this.data.smart_actions[action_key] = {
...this.data.smart_actions?.[action_key] || {},
result
};
}
/**
* Insert the ephemeral tools into the request
* @param {Array<object>} tools
* @param {object} opts
* @returns {void}
*/
insert_tools(tools, opts = {}) {
this.request.tools = tools;
if (opts.force) {
this.request.tool_choice = {
type: "function",
function: {
name: tools[0].function.name
}
};
}
}
};

smart_completions_default_config.completion_adapters.ChatThreadCompletionAdapter = ChatThreadCompletionAdapter;
smart_completions_default_config.completion_adapters.SequenceCompletionAdapter = SequenceCompletionAdapter;
smart_completions_default_config.completion_adapters.SmartActionsCompletionAdapter = SmartActionsCompletionAdapter;
smart_completions_default_config.class.version = 0.3;
var smart_completions_default = smart_completions_default_config;

function build_html53(chat_thread) {
const name = (chat_thread?.name || chat_thread?.data?.name || "").trim();
return `<div>
<div class="smart-chat-top-bar-container">
<button title="New Chat" id="smart-chat-new-chat-button">${this.get_icon_html?.("plus") ?? "+"}</button>
<button title="Chat History" id="smart-chat-chat-history-button">${this.get_icon_html?.("history") ?? "H"}</button>
<button title="Chat Settings" id="smart-chat-chat-settings-button">${this.get_icon_html?.("settings") ?? "S"}</button>
<button title="Chat Help" id="smart-chat-help-button">${this.get_icon_html?.("help-circle") ?? "?"}</button>
</div>
<div class="smart-chat-thread-header">
<input class="smart-chat-thread-name-input" type="text" value="${name.replaceAll('"', "&quot;")}" placeholder="Add name to save this chat" />
</div>
</div>`;
}
__name(build_html53, "build_html");
async function render53(chat_thread, params = {}) {
const frag = this.create_doc_fragment(build_html53.call(this, chat_thread, params));
const container = frag.firstElementChild;
post_process51.call(this, chat_thread, container, params);
return container;
}
__name(render53, "render");
function post_process51(chat_thread, container, params = {}) {
const env = chat_thread?.env;
const disposers = [];
const emit = /* @__PURE__ */ __name((name, payload = {}) => env?.events?.emit?.(name, { thread_key: chat_thread?.key, ...payload }), "emit");
container.querySelector("#smart-chat-new-chat-button")?.addEventListener("click", (e) => {
e.preventDefault();
emit("smart-chat:new_chat");
});
container.querySelector("#smart-chat-chat-history-button")?.addEventListener("click", (e) => {
e.preventDefault();
emit("smart-chat:open_threads_list");
});
container.querySelector("#smart-chat-chat-settings-button")?.addEventListener("click", (e) => {
e.preventDefault();
emit("smart-chat:open_settings");
});
container.querySelector("#smart-chat-help-button")?.addEventListener("click", (e) => {
e.preventDefault();
emit("smart-chat:open_help");
});
const name_input = container.querySelector(".smart-chat-thread-name-input");
if (name_input) {
const save_name = /* @__PURE__ */ __name(() => {
const saved = save_thread_name_if_changed(chat_thread, name_input.value);
if (saved) {
name_input.classList.add("smart-chat-name-saved");
setTimeout(() => name_input.classList.remove("smart-chat-name-saved"), 1e3);
}
}, "save_name");
const on_blur = /* @__PURE__ */ __name(() => save_name(), "on_blur");
const on_keydown = /* @__PURE__ */ __name((event) => {
if (event.key === "Enter") {
event.preventDefault();
save_name();
name_input.blur();
}
}, "on_keydown");
name_input.addEventListener("blur", on_blur);
name_input.addEventListener("keydown", on_keydown);
disposers.push(() => {
name_input.removeEventListener("blur", on_blur);
name_input.removeEventListener("keydown", on_keydown);
});
}
this.attach_disposer(container, disposers);
return container;
}
__name(post_process51, "post_process");
var get_trimmed_name = /* @__PURE__ */ __name((raw_name) => (raw_name || "").trim(), "get_trimmed_name");
function save_thread_name_if_changed(thread, raw_name) {
if (!thread) return false;
const trimmed = get_trimmed_name(raw_name);
if (!trimmed || trimmed === thread.name) return false;
if (thread.data) thread.data.name = trimmed;
thread.name = trimmed;
if (typeof thread.queue_save === "function") thread.queue_save();
if (thread.collection && typeof thread.collection.process_save_queue === "function") {
thread.collection.process_save_queue();
}
return true;
}
__name(save_thread_name_if_changed, "save_thread_name_if_changed");

var layout_default = `/* Chat view layout and scroll behavior */\r
.smart-chat-chat-container {\r
/* Scoped Smart Chat palette (maps to Obsidian theme with fallbacks) */\r
--sc-bg: var(--background-primary, #111111);\r
--sc-bg-secondary: var(--background-secondary, #181818);\r
--sc-bg-secondary-alt: var(--background-secondary-alt, #151515);\r
--sc-bg-surface: var(--background-modifier-form-field, rgba(255, 255, 255, 0.03));\r
\r
--sc-border-subtle: var(--background-modifier-border, rgba(255, 255, 255, 0.12));\r
--sc-border-width: var(--border-width, 1px);\r
\r
--sc-text: var(--text-normal, #dadada);\r
--sc-text-muted: var(--text-muted, #a0a0a0);\r
--sc-text-faint: var(--text-faint, #7a7a7a);\r
--sc-text-on-accent: var(--text-on-accent, #ffffff);\r
\r
--sc-accent: var(--interactive-accent, #7b6cff);\r
--sc-accent-hover: var(--interactive-accent-hover, #9b88ff);\r
--sc-accent-disabled: var(--interactive-accent-disabled, rgba(123, 108, 255, 0.55));\r
\r
--sc-icon-color: var(--icon-color, var(--sc-text-muted));\r
--sc-icon-color-hover: var(--icon-color-hover, var(--sc-accent));\r
--sc-icon-opacity-hover: var(--icon-opacity-hover, 0.9);\r
\r
--sc-font-smaller: var(--font-smaller, 11px);\r
--sc-font-small: var(--font-small, 12px);\r
--sc-font-md: var(--font-medium, 13px);\r
--sc-font-text-size: var(--font-text-size, 14px);\r
--sc-font-text: var(--font-text, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif);\r
\r
--sc-radius-s: var(--radius-s, 4px);\r
--sc-radius-m: var(--radius-m, 8px);\r
\r
--sc-shadow-subtle: var(--shadow-s, 0 1px 2px rgba(0, 0, 0, 0.35));\r
--sc-shadow-elevated: var(--shadow-m, 0 4px 12px rgba(0, 0, 0, 0.5));\r
\r
--sc-anim-fast: var(--anim-duration-fast, 120ms);\r
--sc-anim-med: var(--anim-duration-moderate, 160ms);\r
--sc-anim-slow: var(--anim-duration-slow, 260ms);\r
--sc-anim-ease: var(--anim-motion-smooth, ease-out);\r
--sc-anim-bounce: var(--anim-motion-swing, ease-in-out);\r
\r
/* Spacing tokens derived from Obsidian layout scale */\r
--sc-space-xs: var(--size-2-2, 0.25rem);\r
--sc-space-sm: var(--size-4-2, 0.5rem);\r
--sc-space-md: var(--size-4-3, 0.75rem);\r
--sc-space-lg: var(--size-4-4, 1rem);\r
--sc-space-xl: var(--size-4-6, 1.5rem);\r
\r
display: flex;\r
flex: 1 1 auto;\r
flex-direction: column;\r
height: 100%;\r
max-height: 100%;\r
background: var(--sc-bg);\r
color: var(--sc-text);\r
transition: background var(--sc-anim-med) var(--sc-anim-ease);\r
margin: 0;\r
padding: 0;\r
}\r
\r
/* Container for the active thread */\r
.smart-chat-threads-container {\r
display: flex;\r
flex: 1 1 auto;\r
overflow-y: auto;\r
min-height: 0; /* nested flex + scroll fix */\r
}\r
\r
/* Single chat thread */\r
.smart-chat-thread {\r
display: flex;\r
flex-direction: column;\r
flex-grow: 1;\r
position: relative;\r
overflow: hidden;\r
max-height: 100%;\r
background-color: transparent;\r
background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120' viewBox='0 0 24 24' fill='none' stroke='rgba(255, 255, 255, 0.07)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M2 4c0-1.1.9-2 2-2h16c1.1 0 2 .9 2 2v11c0 1.1-.9 2-2 2h-8l-5 4v-4H4c-1.1 0-2-.9-2-2Z'/%3E%3Cpath d='M7 8c.5.3 1.3.3 1.8 0'/%3E%3Cpath d='M15.2 8c.5.3 1.3.3 1.8 0'/%3E%3Cpath d='M8 11.5c1 .8 2.5 1.2 4 1.2s3-.4 4-1.2'/%3E%3C/svg%3E");\r
background-repeat: no-repeat;\r
background-position: center;\r
background-size: 13% auto;\r
}\r
\r
/* Scrollable column that holds all completions */\r
.sc-completions-container {\r
min-height: 0;\r
overflow-y: auto;\r
padding: var(--sc-space-lg, var(--size-4-4, 1rem));\r
scroll-behavior: smooth;\r
display: flex;\r
flex-direction: column;\r
height: 100%;\r
}\r
\r
/* Each completion slot expands to consume remaining vertical space */\r
.sc-completion-slot {\r
flex: 1 1 auto;\r
display: flex;\r
flex-direction: column;\r
justify-content: flex-end;\r
}`;

var styles_default3 = "/* Thread header + name input */\r\n.smart-chat-thread-header {\r\n  flex: 0 0 auto;\r\n  padding:\r\n    var(--sc-space-md, var(--size-4-3, 0.75rem))\r\n    var(--sc-space-lg, var(--size-4-4, 1rem))\r\n    var(--sc-space-sm, var(--size-4-2, 0.5rem));\r\n  border-bottom: var(--sc-border-width) solid var(--sc-border-subtle);\r\n  background: var(--sc-bg);\r\n}\r\n\r\n.smart-chat-thread-name-input {\r\n  width: 100%;\r\n  background: var(--sc-bg-surface);\r\n  border: var(--sc-border-width) solid var(--sc-border-subtle);\r\n  padding:\r\n    var(--sc-space-sm, var(--size-4-2, 0.5rem))\r\n    var(--sc-space-md, var(--size-4-3, 0.75rem));\r\n  border-radius: var(--sc-radius-s);\r\n  color: var(--sc-text);\r\n  font: inherit;\r\n  font-size: var(--sc-font-md);\r\n  transition:\r\n    border-color var(--sc-anim-fast) var(--sc-anim-ease),\r\n    box-shadow var(--sc-anim-fast) var(--sc-anim-ease),\r\n    background-color var(--sc-anim-fast) var(--sc-anim-ease);\r\n\r\n  &::placeholder {\r\n    color: var(--sc-text-muted);\r\n  }\r\n\r\n  &:focus {\r\n    outline: none;\r\n    border-color: var(--sc-accent-hover);\r\n    box-shadow: 0 0 0 1px var(--sc-accent);\r\n    background-color: var(--sc-bg-surface);\r\n  }\r\n}\r\n\r\n/* transient saved-state ring */\r\n.smart-chat-name-saved {\r\n  box-shadow: 0 0 0 1px var(--sc-accent);\r\n  transition: box-shadow var(--sc-anim-fast) var(--sc-anim-ease);\r\n}\r\n\r\n/* Default helper message visibility */\r\n.sc-msg-content.default {\r\n  display: flex;\r\n  align-items: center;\r\n  flex-direction: column;\r\n  color: var(--sc-text-muted);\r\n  font-size: var(--sc-font-md);\r\n  margin-top: auto;\r\n  margin-bottom: auto;\r\n  opacity: 0.7;\r\n  text-align: center;\r\n  padding: var(--sc-space-xl, var(--size-4-6, 1.5rem));\r\n\r\n  &[data-state='hidden'] {\r\n    display: none;\r\n  }\r\n}\r\n\r\n.sc-completions-container[data-helper-state='hidden'] .sc-msg-content.default {\r\n  display: none;\r\n}\r\n\r\n/* Action bar mount below the list */\r\n.smart-chat-action-bar {\r\n  padding: 0\r\n    var(--sc-space-lg, var(--size-4-4, 1rem))\r\n    var(--sc-space-md, var(--size-4-3, 0.75rem));\r\n  color: var(--sc-text-faint);\r\n  font-size: var(--sc-font-sm);\r\n}\r\n\r\n/* Footer status bar mount */\r\n.smart-chat-status-bar-mount {\r\n  flex: 0 0 auto;\r\n  background: var(--sc-bg);\r\n}\r\n\r\n/* Top toolbar row (new chat, history, settings, help) */\r\n.smart-chat-top-bar-container {\r\n  flex: 0 0 auto;\r\n  display: flex;\r\n  align-items: center;\r\n  gap: var(--sc-space-sm, var(--size-4-2, 0.5rem));\r\n  padding:\r\n    var(--sc-space-md, var(--size-4-3, 0.75rem))\r\n    var(--sc-space-lg, var(--size-4-4, 1rem));\r\n  background: linear-gradient(\r\n    135deg,\r\n    var(--sc-bg-secondary-alt),\r\n    var(--sc-bg-secondary)\r\n  );\r\n  border-bottom: var(--sc-border-width) solid var(--sc-border-subtle);\r\n  position: sticky;\r\n  top: 0;\r\n  z-index: var(--layer-menu, 30);\r\n  backdrop-filter: blur(6px);\r\n\r\n  button {\r\n    background: none;\r\n    border: none;\r\n    color: var(--sc-icon-color);\r\n    cursor: pointer;\r\n    display: flex;\r\n    align-items: center;\r\n    line-height: 1;\r\n    transition:\r\n      color var(--sc-anim-fast) var(--sc-anim-ease),\r\n      opacity var(--sc-anim-fast) var(--sc-anim-ease),\r\n      transform var(--sc-anim-fast) var(--sc-anim-ease);\r\n\r\n    &:hover {\r\n      color: var(--sc-icon-color-hover);\r\n      opacity: var(--sc-icon-opacity-hover);\r\n      transform: translateY(-1px);\r\n    }\r\n\r\n    &:focus-visible {\r\n      outline: 2px solid var(--sc-accent);\r\n      outline-offset: 2px;\r\n    }\r\n  }\r\n}\r\n\r\n/* Status bar at bottom of thread */\r\n.smart-chat-status-bar {\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: space-between;\r\n  gap: var(--sc-space-md, var(--size-4-3, 0.75rem));\r\n  padding:\r\n    var(--sc-space-sm, var(--size-4-2, 0.5rem))\r\n    var(--sc-space-lg, var(--size-4-4, 1rem));\r\n  border-top: var(--sc-border-width) solid var(--sc-border-subtle);\r\n  background: var(--sc-bg);\r\n  color: var(--sc-text-muted);\r\n  font-size: var(--sc-font-sm);\r\n\r\n  .sc-status-left {\r\n    display: inline-flex;\r\n    align-items: center;\r\n    gap: var(--sc-space-sm, var(--size-4-2, 0.5rem));\r\n    min-width: 0;\r\n  }\r\n\r\n  .sc-status-indicator {\r\n    display: inline-flex;\r\n    align-items: center;\r\n    gap: var(--sc-space-xs, var(--size-2-2, 0.25rem));\r\n  }\r\n\r\n  .sc-status-badge {\r\n    display: inline-flex;\r\n    align-items: center;\r\n    padding: 0 var(--sc-space-xs, var(--size-4-1, 0.25rem));\r\n    height: calc(var(--sc-font-sm) * 1.6);\r\n    border-radius: var(--sc-radius-s);\r\n    background: var(--sc-bg-surface);\r\n    color: var(--sc-text-muted);\r\n  }\r\n\r\n  .sc-status-text {\r\n    white-space: nowrap;\r\n    overflow: hidden;\r\n    text-overflow: ellipsis;\r\n  }\r\n\r\n  .sc-status-right {\r\n    display: inline-flex;\r\n    align-items: center;\r\n    gap: var(--sc-space-sm, var(--size-4-2, 0.5rem));\r\n    white-space: nowrap;\r\n  }\r\n\r\n  .sc-status-typing-dots {\r\n    display: none;\r\n    gap: 4px;\r\n    margin-left: var(--sc-space-xs, var(--size-2-2, 0.25rem));\r\n  }\r\n\r\n  .sc-status-typing-dot {\r\n    width: 6px;\r\n    height: 6px;\r\n    border-radius: 50%;\r\n    background: var(--sc-text-faint);\r\n    animation: scbounce var(--sc-anim-slow) infinite var(--sc-anim-bounce);\r\n\r\n    &:nth-child(2) {\r\n      animation-delay: var(--sc-anim-fast);\r\n    }\r\n\r\n    &:nth-child(3) {\r\n      animation-delay: calc(var(--sc-anim-fast) * 2);\r\n    }\r\n  }\r\n\r\n  &[data-state='typing'] {\r\n    .sc-status-badge {\r\n      background: var(--sc-accent);\r\n      color: var(--sc-text-on-accent);\r\n    }\r\n\r\n    .sc-status-typing-dots {\r\n      display: inline-flex;\r\n    }\r\n  }\r\n\r\n  &[data-state='error'] .sc-status-badge {\r\n    background: var(--background-modifier-error, #8b0000);\r\n    color: var(--sc-text-on-accent);\r\n  }\r\n}\r\n\r\n@keyframes scbounce {\r\n  0%,\r\n  80%,\r\n  100% {\r\n    transform: scale(0);\r\n  }\r\n  40% {\r\n    transform: scale(1);\r\n  }\r\n}\r\n\r\n.smart-chat-thread .custom-instructions {\r\n  display: flex;\r\n  align-items: center;\r\n  gap: 1rem;\r\n}";

var ScTranslations_default = {
en: {
name: "English",
pronouns: ["my", "I", "me", "mine", "our", "ours", "us", "we"],
context_prefix_prompt: "Context from lookup:",
context_suffix_prompt: 'Use the provided context to respond like "Based on your notes..."',
initial_message: "Hi there, welcome to the Smart Chat. Ask me a question about your notes and I'll try to answer it."
},
es: {
name: "Espa\xF1ol",
pronouns: ["mi", "yo", "m\xED", "t\xFA", "mis"],
context_prefix_prompt: "Contexto de b\xFAsqueda:",
context_suffix_prompt: 'Usa el contexto proporcionado para responder como "Bas\xE1ndote en tus notas..."',
initial_message: "Hola, bienvenido al Smart Chat. Hazme una pregunta sobre tus apuntes y tratar\xE9 de responderla."
},
fr: {
name: "Fran\xE7ais",
pronouns: ["me", "mon", "ma", "mes", "moi", "nous", "notre", "nos", "je", "j'", "m'"],
context_prefix_prompt: "Contexte de recherche :",
context_suffix_prompt: `Utilisez le contexte fourni pour r\xE9pondre comme "D'apr\xE8s vos notes..."`,
initial_message: "Bonjour, bienvenue dans le Smart Chat. Posez-moi une question sur vos notes et j'essaierai d'y r\xE9pondre."
},
de: {
name: "Deutsch",
pronouns: ["mein", "meine", "meinen", "meiner", "meines", "mir", "uns", "unser", "unseren", "unserer", "unseres"],
context_prefix_prompt: "Kontext aus Suche:",
context_suffix_prompt: 'Verwenden Sie den bereitgestellten Kontext, um zu antworten wie "Basierend auf Ihren Notizen..."',
initial_message: "Hallo, willkommen beim Smart Chat. Stellen Sie mir eine Frage zu Ihren Notizen, und ich werde versuchen, sie zu beantworten."
},
it: {
name: "Italiano",
pronouns: ["mio", "mia", "miei", "mie", "noi", "nostro", "nostri", "nostra", "nostre"],
context_prefix_prompt: "Contesto dalla ricerca:",
context_suffix_prompt: 'Usa il contesto fornito per rispondere come "Basandoti sui tuoi appunti..."',
initial_message: "Ciao, benvenuto al Smart Chat. Fai una domanda sui tuoi appunti e cercher\xF2 di risponderti."
},
pt: {
name: "Portugu\xEAs",
pronouns: ["meu", "eu", "mim", "minha", "nosso", "nossa", "n\xF3s"],
context_prefix_prompt: "Contexto da pesquisa:",
context_suffix_prompt: 'Use o contexto fornecido para responder como "Com base em suas anota\xE7\xF5es..."',
initial_message: "Ol\xE1, bem-vindo ao Smart Chat. Fa\xE7a-me uma pergunta sobre suas anota\xE7\xF5es e tentarei respond\xEA-la."
},
"pt-br": {
name: "Portugu\xEAs (Brasil)",
pronouns: ["eu", "me", "mim", "meu", "meus", "minha", "minhas", "nosso", "nossos", "nossa", "nossas", "n\xF3s", "nos", "a gente"],
context_prefix_prompt: "Contexto da pesquisa:",
context_suffix_prompt: 'Use o contexto fornecido para responder como "Com base nas suas notas..."',
initial_message: "Ol\xE1, bem-vindo ao Smart Chat. Fa\xE7a-me uma pergunta sobre suas notas e tentarei respond\xEA-la."
},
ja: {
name: "\u65E5\u672C\u8A9E",
pronouns: ["\u79C1", "\u81EA\u5206", "\u50D5", "\u4FFA", "\u79C1\u9054", "\u3053\u306E"],
context_prefix_prompt: "\u691C\u7D22\u304B\u3089\u306E\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\uFF1A",
context_suffix_prompt: "\u63D0\u4F9B\u3055\u308C\u305F\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\u3092\u4F7F\u7528\u3057\u3066\u300C\u3053\u306E\u30CE\u30FC\u30C8\u306B\u57FA\u3065\u3044\u3066...\u300D\u306E\u3088\u3046\u306B\u5FDC\u7B54\u3057\u3066\u304F\u3060\u3055\u3044",
initial_message: "\u3053\u3093\u306B\u3061\u306F\u3001Smart Chat\u3078\u3088\u3046\u3053\u305D\u3002\u3042\u306A\u305F\u306E\u30CE\u30FC\u30C8\u306B\u95A2\u3059\u308B\u8CEA\u554F\u3092\u3057\u3066\u304F\u3060\u3055\u3044\u3002\u304A\u7B54\u3048\u3057\u307E\u3059\u3002"
},
ko: {
name: "\uD55C\uAD6D\uC5B4",
pronouns: ["\uB098", "\uB0B4", "\uB098\uC758", "\uC800", "\uC81C", "\uC6B0\uB9AC", "\uC800\uD76C"],
context_prefix_prompt: "\uAC80\uC0C9\uC5D0\uC11C\uC758 \uCEE8\uD14D\uC2A4\uD2B8:",
context_suffix_prompt: '\uC81C\uACF5\uB41C \uCEE8\uD14D\uC2A4\uD2B8\uB97C \uC0AC\uC6A9\uD558\uC5EC "\uB2F9\uC2E0\uC758 \uB178\uD2B8\uC5D0 \uAE30\uBC18\uD558\uC5EC..."\uC640 \uAC19\uC774 \uB2F5\uBCC0\uD558\uC138\uC694',
initial_message: "\uC548\uB155\uD558\uC138\uC694, Smart Chat\uC5D0 \uC624\uC2E0 \uAC83\uC744 \uD658\uC601\uD569\uB2C8\uB2E4. \uB178\uD2B8\uC5D0 \uAD00\uD55C \uC9C8\uBB38\uC774 \uC788\uC73C\uC2DC\uBA74 \uB9D0\uC500\uD574 \uC8FC\uC138\uC694. \uC81C\uAC00 \uB2F5\uBCC0\uD574 \uB4DC\uB9AC\uACA0\uC2B5\uB2C8\uB2E4."
},
zh: {
name: "\u4E2D\u6587\uFF08\u7B80\u4F53\uFF09",
pronouns: ["\u6211", "\u6211\u7684", "\u6211\u4EEC", "\u6211\u4EEC\u7684"],
context_prefix_prompt: "\u67E5\u627E\u7684\u4E0A\u4E0B\u6587\uFF1A",
context_suffix_prompt: "\u4F7F\u7528\u63D0\u4F9B\u7684\u4E0A\u4E0B\u6587\uFF0C\u4EE5\u201C\u6839\u636E\u4F60\u7684\u7B14\u8BB0...\u201D\u7684\u65B9\u5F0F\u56DE\u7B54",
initial_message: "\u4F60\u597D\uFF0C\u6B22\u8FCE\u4F7F\u7528 Smart Chat\u3002\u8BF7\u95EE\u6211\u5173\u4E8E\u4F60\u7684\u7B14\u8BB0\u7684\u95EE\u9898\uFF0C\u6211\u4F1A\u5C3D\u529B\u56DE\u7B54\u3002"
},
"zh-TW": {
name: "\u4E2D\u6587\uFF08\u7E41\u4F53\uFF09",
pronouns: ["\u6211", "\u6211\u7684", "\u6211\u5011", "\u6211\u5011\u7684"],
context_prefix_prompt: "\u67E5\u627E\u7684\u4E0A\u4E0B\u6587\uFF1A",
context_suffix_prompt: "\u4F7F\u7528\u63D0\u4F9B\u7684\u4E0A\u4E0B\u6587\uFF0C\u4EE5\u300C\u6839\u64DA\u60A8\u7684\u7B46\u8A18...\u300D\u7684\u65B9\u5F0F\u56DE\u7B54",
initial_message: "\u55E8\uFF0C\u6B61\u8FCE\u4F86\u5230 Smart Chat\u3002\u8ACB\u554F\u6211\u95DC\u65BC\u60A8\u7684\u7B46\u8A18\u7684\u554F\u984C\uFF0C\u6211\u6703\u76E1\u529B\u56DE\u7B54\u3002"
},
hi: {
name: "\u0939\u093F\u0928\u094D\u0926\u0940",
pronouns: ["\u092E\u0948\u0902", "\u092E\u0941\u091D\u0947", "\u092E\u0947\u0930\u093E", "\u092E\u0947\u0930\u0947", "\u092E\u0947\u0930\u0940", "\u0939\u092E", "\u0939\u092E\u0947\u0902", "\u0939\u092E\u093E\u0930\u093E", "\u0939\u092E\u093E\u0930\u0947", "\u0939\u092E\u093E\u0930\u0940"],
context_prefix_prompt: "\u0916\u094B\u091C \u0938\u0947 \u0938\u0902\u0926\u0930\u094D\u092D:",
context_suffix_prompt: '\u092A\u094D\u0930\u0926\u093E\u0928 \u0915\u093F\u090F \u0917\u090F \u0938\u0902\u0926\u0930\u094D\u092D \u0915\u093E \u0909\u092A\u092F\u094B\u0917 \u0915\u0930\u0915\u0947 "\u0906\u092A\u0915\u0947 \u0928\u094B\u091F\u094D\u0938 \u0915\u0947 \u0906\u0927\u093E\u0930 \u092A\u0930..." \u0915\u0940 \u0924\u0930\u0939 \u0909\u0924\u094D\u0924\u0930 \u0926\u0947\u0902',
initial_message: "\u0928\u092E\u0938\u094D\u0924\u0947, Smart Chat \u092E\u0947\u0902 \u0906\u092A\u0915\u093E \u0938\u094D\u0935\u093E\u0917\u0924 \u0939\u0948\u0964 \u0905\u092A\u0928\u0947 \u0928\u094B\u091F\u094D\u0938 \u0915\u0947 \u092C\u093E\u0930\u0947 \u092E\u0947\u0902 \u092E\u0941\u091D\u0938\u0947 \u0915\u094B\u0908 \u092A\u094D\u0930\u0936\u094D\u0928 \u092A\u0942\u091B\u0947\u0902 \u0914\u0930 \u092E\u0948\u0902 \u0909\u0924\u094D\u0924\u0930 \u0926\u0947\u0928\u0947 \u0915\u093E \u092A\u094D\u0930\u092F\u093E\u0938 \u0915\u0930\u0942\u0902\u0917\u093E\u0964"
},
ar: {
name: "\u0627\u0644\u0639\u0631\u0628\u064A\u0629",
pronouns: ["\u0623\u0646\u0627", "\u0644\u064A", "\u0646\u062D\u0646", "\u0644\u0646\u0627", "\u064A", "\u0646\u0627"],
context_prefix_prompt: "\u0633\u064A\u0627\u0642 \u0645\u0646 \u0627\u0644\u0628\u062D\u062B:",
context_suffix_prompt: '\u0627\u0633\u062A\u062E\u062F\u0645 \u0627\u0644\u0633\u064A\u0627\u0642 \u0627\u0644\u0645\u0642\u062F\u0645 \u0644\u0644\u0631\u062F \u0645\u062B\u0644 "\u0628\u0646\u0627\u0621\u064B \u0639\u0644\u0649 \u0645\u0644\u0627\u062D\u0638\u0627\u062A\u0643..."',
initial_message: "\u0645\u0631\u062D\u0628\u0627\u064B \u0628\u0643 \u0641\u064A Smart Chat. \u0627\u0633\u0623\u0644\u0646\u064A \u0633\u0624\u0627\u0644\u0627\u064B \u062D\u0648\u0644 \u0645\u0644\u0627\u062D\u0638\u0627\u062A\u0643 \u0648\u0633\u0623\u062D\u0627\u0648\u0644 \u0627\u0644\u0625\u062C\u0627\u0628\u0629 \u0639\u0644\u064A\u0647."
},
bn: {
name: "\u09AC\u09BE\u0982\u09B2\u09BE",
pronouns: ["\u0986\u09AE\u09BF", "\u0986\u09AE\u09BE\u09B0", "\u0986\u09AE\u09BE\u0995\u09C7", "\u0986\u09AE\u09B0\u09BE", "\u0986\u09AE\u09BE\u09A6\u09C7\u09B0", "\u0986\u09AE\u09BE\u09A6\u09C7\u09B0\u0995\u09C7"],
context_prefix_prompt: "\u0985\u09A8\u09C1\u09B8\u09A8\u09CD\u09A7\u09BE\u09A8 \u09A5\u09C7\u0995\u09C7 \u09AA\u09CD\u09B0\u09C7\u0995\u09CD\u09B7\u09BE\u09AA\u099F:",
context_suffix_prompt: '\u09AA\u09CD\u09B0\u09A6\u09A4\u09CD\u09A4 \u09AA\u09CD\u09B0\u09B8\u0999\u09CD\u0997 \u09AC\u09CD\u09AF\u09AC\u09B9\u09BE\u09B0 \u0995\u09B0\u09C7 "\u0986\u09AA\u09A8\u09BE\u09B0 \u09A8\u09CB\u099F\u09C7\u09B0 \u09AD\u09BF\u09A4\u09CD\u09A4\u09BF\u09A4\u09C7..." \u098F\u09B0 \u09AE\u09A4\u09CB \u0995\u09B0\u09C7 \u0989\u09A4\u09CD\u09A4\u09B0 \u09A6\u09BF\u09A8',
initial_message: "\u09B9\u09CD\u09AF\u09BE\u09B2\u09CB, Smart Chat-\u098F \u0986\u09AA\u09A8\u09BE\u0995\u09C7 \u09B8\u09CD\u09AC\u09BE\u0997\u09A4\u09AE\u0964 \u0986\u09AA\u09A8\u09BE\u09B0 \u09A8\u09CB\u099F \u09B8\u09AE\u09CD\u09AA\u09B0\u09CD\u0995\u09C7 \u0986\u09AE\u09BE\u0995\u09C7 \u09AA\u09CD\u09B0\u09B6\u09CD\u09A8 \u0995\u09B0\u09C1\u09A8, \u0986\u09AE\u09BF \u0989\u09A4\u09CD\u09A4\u09B0 \u09A6\u09C7\u0993\u09AF\u09BC\u09BE\u09B0 \u099A\u09C7\u09B7\u09CD\u099F\u09BE \u0995\u09B0\u09AC\u0964"
},
ur: {
name: "\u0627\u0631\u062F\u0648",
pronouns: ["\u0645\u06CC\u06BA", "\u0645\u062C\u06BE\u06D2", "\u0645\u06CC\u0631\u0627", "\u06C1\u0645", "\u06C1\u0645\u06CC\u06BA", "\u06C1\u0645\u0627\u0631\u0627"],
context_prefix_prompt: "\u062A\u0644\u0627\u0634 \u0938\u0947 \u0633\u06CC\u0627\u0642 \u0648 \u0633\u0628\u0627\u0642:",
context_suffix_prompt: '\u0641\u0631\u0627\u06C1\u0645 \u06A9\u0631\u062F\u06C1 \u0633\u06CC\u0627\u0642 \u0648 \u0633\u0628\u0627\u0642 \u06A9\u0627 \u0627\u0633\u062A\u0639\u0645\u0627\u0644 \u06A9\u0631\u062A\u06D2 \u06C1\u0648\u0626\u06D2 \u0627\u06CC\u0633\u06D2 \u062C\u0648\u0627\u0628 \u062F\u06CC\u06BA \u062C\u06CC\u0633\u06D2 "\u0622\u067E \u06A9\u06D2 \u0646\u0648\u0679\u0633 \u0915\u0940 \u0628\u0646\u06CC\u0627\u062F \u067E\u0631..."',
initial_message: "\u062E\u0648\u0634 \u0622\u0645\u062F\u06CC\u062F\u060C Smart Chat \u0645\u06CC\u06BA\u06D4 \u0627\u067E\u0646\u06D2 \u0646\u0648\u0679\u0633 \u06A9\u06D2 \u0628\u0627\u0631\u06D2 \u0645\u06CC\u06BA \u0645\u062C\u06BE \u0633\u06D2 \u06A9\u0648\u0626\u06CC \u0633\u0648\u0627\u0644 \u067E\u0648\u0686\u06BE\u06CC\u06BA \u0627\u0648\u0631 \u0645\u06CC\u06BA \u062C\u0648\u0627\u0628 \u062F\u06CC\u0646\u06D2 \u06A9\u06CC \u06A9\u0648\u0634\u0634 \u06A9\u0631\u0648\u06BA \u06AF\u0627\u06D4"
},
sw: {
name: "Kiswahili",
pronouns: ["mimi", "yangu", "sisi", "yetu"],
context_prefix_prompt: "Muktadha kutoka utafutaji:",
context_suffix_prompt: 'Tumia muktadha uliotolewa kujibu kama "Kulingana na maelezo yako..."',
initial_message: "Hujambo, karibu kwenye Smart Chat. Niulize swali kuhusu maelezo yako na nitajaribu kujibu."
},
pl: {
name: "Polski",
pronouns: ["ja", "mnie", "m\xF3j", "moja", "moje", "my", "nas", "nasz", "nasza", "nasze"],
context_prefix_prompt: "Kontekst z wyszukiwania:",
context_suffix_prompt: 'U\u017Cyj podanego kontekstu, aby odpowiedzie\u0107 jak "Na podstawie twoich notatek..."',
initial_message: "Cze\u015B\u0107, witaj w Smart Chat. Zadaj mi pytanie dotycz\u0105ce twoich notatek, a postaram si\u0119 odpowiedzie\u0107."
},
uk: {
name: "\u0423\u043A\u0440\u0430\u0457\u043D\u0441\u044C\u043A\u0430",
pronouns: ["\u044F", "\u043C\u0435\u043D\u0456", "\u043C\u0456\u0439", "\u043C\u043E\u044F", "\u043C\u043E\u0454", "\u043C\u0438", "\u043D\u0430\u0441", "\u043D\u0430\u0448", "\u043D\u0430\u0448\u0430", "\u043D\u0430\u0448\u0435"],
context_prefix_prompt: "\u041A\u043E\u043D\u0442\u0435\u043A\u0441\u0442 \u0437 \u043F\u043E\u0448\u0443\u043A\u0443:",
context_suffix_prompt: '\u0412\u0438\u043A\u043E\u0440\u0438\u0441\u0442\u043E\u0432\u0443\u0439\u0442\u0435 \u043D\u0430\u0434\u0430\u043D\u0438\u0439 \u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442, \u0449\u043E\u0431 \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0441\u0442\u0438 \u044F\u043A "\u041D\u0430 \u043E\u0441\u043D\u043E\u0432\u0456 \u0432\u0430\u0448\u0438\u0445 \u043D\u043E\u0442\u0430\u0442\u043E\u043A..."',
initial_message: "\u041F\u0440\u0438\u0432\u0456\u0442, \u043B\u0430\u0441\u043A\u0430\u0432\u043E \u043F\u0440\u043E\u0441\u0438\u043C\u043E \u0434\u043E Smart Chat. \u0417\u0430\u0434\u0430\u0439\u0442\u0435 \u043C\u0435\u043D\u0456 \u043F\u0438\u0442\u0430\u043D\u043D\u044F \u043F\u0440\u043E \u0432\u0430\u0448\u0456 \u043D\u043E\u0442\u0430\u0442\u043A\u0438, \u0456 \u044F \u0441\u043F\u0440\u043E\u0431\u0443\u044E \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0441\u0442\u0438."
},
nl: {
name: "Nederlands",
pronouns: ["ik", "mij", "me", "mijn", "wij", "we", "ons", "onze"],
context_prefix_prompt: "Context van zoekopdracht:",
context_suffix_prompt: 'Gebruik de verstrekte context om te reageren als "Gebaseerd op uw notities..."',
initial_message: "Hallo, welkom bij Smart Chat. Stel me een vraag over uw notities en ik zal proberen deze te beantwoorden."
},
sv: {
name: "Svenska",
pronouns: ["jag", "mig", "min", "mitt", "mina", "vi", "oss", "v\xE5r", "v\xE5rt", "v\xE5ra"],
context_prefix_prompt: "Kontext fr\xE5n s\xF6kning:",
context_suffix_prompt: 'Anv\xE4nd den tillhandah\xE5llna kontexten f\xF6r att svara som "Baserat p\xE5 dina anteckningar..."',
initial_message: "Hej, v\xE4lkommen till Smart Chat. St\xE4ll en fr\xE5ga om dina anteckningar s\xE5 ska jag f\xF6rs\xF6ka svara."
},
tr: {
name: "T\xFCrk\xE7e",
pronouns: ["ben", "bana", "benim", "biz", "bize", "bizim"],
context_prefix_prompt: "Arama ba\u011Flam\u0131:",
context_suffix_prompt: 'Verilen ba\u011Flam\u0131 kullanarak "Notlar\u0131n\u0131za dayanarak..." \u015Feklinde cevap verin',
initial_message: "Merhaba, Smart Chat'e ho\u015F geldiniz. Notlar\u0131n\u0131z hakk\u0131nda bana bir soru sorun, yan\u0131tlamaya \xE7al\u0131\u015Faca\u011F\u0131m."
},
ru: {
name: "\u0420\u0443\u0441\u0441\u043A\u0438\u0439",
pronouns: ["\u044F", "\u043C\u043E\u0451", "\u043C\u043E\u0435", "\u043C\u043E\u0439", "\u043C\u043D\u0435", "\u043C\u043E\u0438\u0445", "\u043C\u043E\u0438", "\u043C\u043E\u0451\u043C", "\u043C\u043E\u0435\u043C", "\u043D\u0430\u0448", "\u043D\u0430\u0448\u0435", "\u043D\u0430\u0448\u0435\u043C", "\u043D\u0430\u0448\u0435\u043C\u0443", "\u043D\u0430\u0448\u0438\u043C", "\u043D\u0430\u0448\u0438", "\u043C\u044B"],
context_prefix_prompt: "\u041A\u043E\u043D\u0442\u0435\u043A\u0441\u0442 \u0438\u0437 \u043F\u043E\u0438\u0441\u043A\u0430:",
context_suffix_prompt: '\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0439\u0442\u0435 \u043F\u0440\u0435\u0434\u043E\u0441\u0442\u0430\u0432\u043B\u0435\u043D\u043D\u044B\u0439 \u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442, \u0447\u0442\u043E\u0431\u044B \u043E\u0442\u0432\u0435\u0442\u0438\u0442\u044C \u043A\u0430\u043A "\u041D\u0430 \u043E\u0441\u043D\u043E\u0432\u0435 \u0432\u0430\u0448\u0438\u0445 \u0437\u0430\u043F\u0438\u0441\u0435\u0439..."',
initial_message: "\u041F\u0440\u0438\u0432\u0435\u0442, \u0434\u043E\u0431\u0440\u043E \u043F\u043E\u0436\u0430\u043B\u043E\u0432\u0430\u0442\u044C \u0432 Smart Chat. \u0417\u0430\u0434\u0430\u0439\u0442\u0435 \u043C\u043D\u0435 \u0432\u043E\u043F\u0440\u043E\u0441 \u043E \u0432\u0430\u0448\u0438\u0445 \u0437\u0430\u043F\u0438\u0441\u044F\u0445, \u0438 \u044F \u043F\u043E\u0441\u0442\u0430\u0440\u0430\u044E\u0441\u044C \u043E\u0442\u0432\u0435\u0442\u0438\u0442\u044C."
}
};

function get_initial_message(language) {
const language_settings = ScTranslations_default[language];
return language_settings.initial_message;
}
__name(get_initial_message, "get_initial_message");

function parse_dropped_data(dt) {
const out = /* @__PURE__ */ new Set();
if (dt?.files?.length) {
[...dt.files].forEach((f) => {
const p = f.path || f.name;
if (p) out.add(p);
});
}
const split_lines = /* @__PURE__ */ __name((str) => (str ?? "").split(/\r?\n/u).map((s) => s.trim()).filter(Boolean), "split_lines");
let rows = [
...split_lines(dt?.getData("text/uri-list")),
...split_lines(dt?.getData("text/plain"))
];
const flatten_obsidian_uris = /* @__PURE__ */ __name((arr) => arr.flatMap((row) => {
if (row.startsWith("obsidian://")) {
return row.split(/(?=obsidian:\/\/)/g).map((s) => s.trim()).filter(Boolean);
}
return [row];
}), "flatten_obsidian_uris");
const mergedRows = [];
for (let i = 0; i < rows.length; i++) {
if (rows[i].startsWith("obsidian:") && !rows[i].startsWith("obsidian://") && i + 1 < rows.length && rows[i + 1].startsWith("/")) {
mergedRows.push(rows[i] + rows[i + 1]);
i++;
} else {
mergedRows.push(rows[i]);
}
}
rows = flatten_obsidian_uris(mergedRows);
rows.forEach((row) => {
if (row.startsWith("obsidian://")) {
try {
const url = new URL(row);
let file = url.searchParams.get("file");
if (file) {
if (!/\.[^./\\]+$/.test(file)) file += ".md";
out.add(file);
return;
}
} catch (_) {
}
const match = row.match(/file=([^&\s]+)/u);
if (match) {
let file = decodeURIComponent(match[1]);
if (!/\.[^./\\]+$/.test(file)) file += ".md";
out.add(file);
}
return;
}
let val = row;
if (val && !/[./\\]/.test(val.slice(-4)) && // crude: no .ext or / at end
!/\.[^./\\]+$/.test(val)) {
val += ".md";
}
out.add(val);
});
return out;
}
__name(parse_dropped_data, "parse_dropped_data");

function build_html54(chat_thread) {
const initial_message = get_initial_message(chat_thread.settings.language);
const completion_slots = chat_thread.completions.map((completion) => `<div class="sc-completion-slot" data-completion-key="${completion.key}"></div>`).join("");
return `<div>
<div class="smart-chat-thread v3" data-thread-key="${chat_thread.key}">
<div class="smart-chat-thread-actions-mount"></div>
<div class="sc-completions-container">
<div class="custom-instructions">
<button>Edit custom instructions</button>
<div class="custom-instructions-content"></div>
</div>
<div class="sc-msg-content default">${initial_message}</div>
${completion_slots}
</div>
<div class="smart-chat-status-bar-mount"></div>
<div class="smart-chat-action-bar"></div>
</div>
</div>`;
}
__name(build_html54, "build_html");
async function render54(chat_thread, opts = {}) {
const frag = this.create_doc_fragment(build_html54(chat_thread));
this.apply_style_sheet(layout_default);
this.apply_style_sheet(styles_default3);
const container = frag.querySelector(".smart-chat-thread");
await post_process52.call(this, chat_thread, container, opts);
return container;
}
__name(render54, "render");
async function post_process52(chat_thread, container, params = {}) {
const env = chat_thread?.env;
const disposers = [];
const custom_instructions_container = container.querySelector(".custom-instructions");
const completions_container = container.querySelector(".sc-completions-container");
const actions_mount = container.querySelector(".smart-chat-thread-actions-mount");
const status_mount = container.querySelector(".smart-chat-status-bar-mount");
const actions = await env.smart_components.render_component("chat_thread_actions", chat_thread, params);
this.empty(actions_mount);
actions_mount.appendChild(actions);
if (container && !container._scDropHandlersBound) {
const on_dragover = /* @__PURE__ */ __name((event) => event.preventDefault(), "on_dragover");
const on_drop = /* @__PURE__ */ __name(async (event) => {
event.preventDefault();
const paths = [...parse_dropped_data(event.dataTransfer)];
if (!paths.length) return;
const current_ctx = env.smart_contexts.get(chat_thread.current_completion.data.context_key);
current_ctx.add_items(paths);
}, "on_drop");
container.addEventListener("dragover", on_dragover);
container.addEventListener("drop", on_drop);
container._scDropHandlersBound = true;
disposers.push(() => {
container.removeEventListener("dragover", on_dragover);
container.removeEventListener("drop", on_drop);
container._scDropHandlersBound = false;
});
}
for (const completion of chat_thread.completions) {
const selector = `[data-completion-key="${completion.key}"]`;
const completion_container = completions_container.querySelector(selector);
if (!completion_container) {
console.warn(`[smart-chat-early] Completion container not found for key ${completion.key}`);
continue;
}
const rendered_completion = await completion.env.smart_components.render_component("completion_item", completion, params);
this.empty(completion_container);
completion_container.appendChild(rendered_completion);
}
const status_component = await env.smart_components.render_component("chat_thread_status_bar", chat_thread, params);
this.empty(status_mount);
status_mount.appendChild(status_component);
const render_custom_instructions = /* @__PURE__ */ __name(async () => {
const ci_btn = custom_instructions_container.querySelector("button");
if (!ci_btn._open_handler) {
ci_btn.addEventListener("click", (event) => {
event.preventDefault();
new CustomInstructionsModal(chat_thread).open();
});
ci_btn._open_handler = true;
}
const ci_content = custom_instructions_container.querySelector(".custom-instructions-content");
const custom_instructions = chat_thread.get_custom_instructions();
const ci_length = custom_instructions.length;
const ci_tokens = ci_length / 3.7;
ci_content.innerText = `Characters: ${ci_length} | Tokens: ~${Math.ceil(ci_tokens)}`;
}, "render_custom_instructions");
await render_custom_instructions();
disposers.push(env.events.on("settings:changed", () => render_custom_instructions()));
this.attach_disposer(container, disposers);
return container;
}
__name(post_process52, "post_process");

var import_obsidian95 = require("obsidian");
function build_html55(chat_thread) {
const { model_key, provider_key } = chat_thread.env.chat_completion_models.default.data;
return `<div>
<div class="smart-chat-status-bar" role="status" aria-live="polite" data-state="idle">
<div class="sc-status-left">
<span class="sc-status-indicator">
<span class="sc-status-badge">Idle</span>
</span>
<span class="sc-status-text">
Ready
<span class="sc-status-typing-dots" aria-hidden="true">
<span class="sc-status-typing-dot"></span>
<span class="sc-status-typing-dot"></span>
<span class="sc-status-typing-dot"></span>
</span>
</span>
</div>
<div class="sc-status-right">
<span class="sc-model" title="Model used for new completions">
<code class="sc-model-key">${model_key || "MISSING MODEL"}</code> (<code class="sc-platform-key">${provider_key || "MISSING PROVIDER"}</code>)
</span>
</div>
</div>
</div>`;
}
__name(build_html55, "build_html");
async function render55(chat_thread, opts = {}) {
const frag = this.create_doc_fragment(build_html55(chat_thread));
const container = frag.querySelector(".smart-chat-status-bar");
post_process53.call(this, chat_thread, container, opts);
return container;
}
__name(render55, "render");
function post_process53(chat_thread, container, opts = {}) {
const env = chat_thread?.env;
const disposers = [];
const status_badge = container.querySelector(".sc-status-badge");
const status_text = container.querySelector(".sc-status-text");
const typing_dots = container.querySelector(".sc-status-typing-dots");
const model_key_el = container.querySelector(".sc-model-key");
const platform_el = container.querySelector(".sc-platform-key");
const truncate = /* @__PURE__ */ __name((text, limit = 140) => {
if (!text) return "";
return text.length <= limit ? text : `${text.slice(0, limit - 1)}\u2026`;
}, "truncate");
const is_event_for_thread = /* @__PURE__ */ __name((event) => {
if (event?.item_key && Array.isArray(chat_thread?.completion_keys)) {
return chat_thread.completion_keys.includes(event.item_key);
}
if (event?.thread_key) return event.thread_key === chat_thread?.key;
return true;
}, "is_event_for_thread");
const set_state = /* @__PURE__ */ __name((state, msg = "") => {
container.dataset.state = state;
if (state === "typing") {
status_badge.textContent = "Typing";
status_text.firstChild && (status_text.firstChild.textContent = "Generating\u2026 ");
if (typing_dots) typing_dots.style.display = "inline-flex";
} else if (state === "error") {
status_badge.textContent = "Error";
status_text.firstChild && (status_text.firstChild.textContent = truncate(msg || "Something went wrong"));
if (typing_dots) typing_dots.style.display = "none";
} else {
status_badge.textContent = "Idle";
status_text.firstChild && (status_text.firstChild.textContent = "Ready ");
if (typing_dots) typing_dots.style.display = "none";
}
}, "set_state");
const update_model_display = /* @__PURE__ */ __name(() => {
const { model_key, provider_key } = chat_thread.env.chat_completion_models.default.data;
model_key_el.textContent = model_key || "MISSING MODEL";
platform_el.textContent = provider_key || "MISSING PROVIDER";
}, "update_model_display");
const model_context_menu = /* @__PURE__ */ __name(async (e) => {
e.preventDefault();
const menu = new import_obsidian95.Menu();
const models = await chat_thread.env.chat_completion_models.default.get_model_key_options();
models.forEach((model_opt) => {
menu.addItem((item) => {
item.setTitle(model_opt.label);
item.onClick(() => {
const model = chat_thread.env.chat_completion_models.default;
model.data.model_key = model_opt.value;
model.queue_save();
model.collection.process_save_queue();
model.emit_event("model:changed");
});
});
});
menu.showAtMouseEvent(e);
}, "model_context_menu");
const model_display_el = container.querySelector(".sc-model");
model_display_el.addEventListener("contextmenu", model_context_menu);
model_display_el.addEventListener("click", model_context_menu);
set_state("idle");
update_model_display();
const bind = /* @__PURE__ */ __name((name, fn) => {
const off = env?.events?.on?.(name, (evt) => {
try {
fn(evt);
} catch (e) {
console.warn("[status_bar] handler error", e);
}
});
if (typeof off === "function") disposers.push(off);
}, "bind");
bind("completion:completing", (evt) => {
if (!is_event_for_thread(evt)) return;
set_state("typing");
update_model_display();
});
bind("completion:completed", (evt) => {
if (!is_event_for_thread(evt)) return;
set_state("idle");
update_model_display();
});
bind("completion:error", (evt) => {
if (!is_event_for_thread(evt)) return;
set_state("error", evt?.error || "");
update_model_display();
});
bind("model:changed", (payload) => {
if (payload.collection_key !== "chat_completion_models") return;
update_model_display();
});
["chat_thread:renamed", "smart-chat:new_chat"].forEach((event_name) => {
bind(event_name, () => update_model_display());
});
this.attach_disposer(container, disposers);
return container;
}
__name(post_process53, "post_process");

function build_html56(completion, params = {}) {
const name_for_radio = `force-action-${completion.key}`;
return `<div>
<div class="sc-msg action-selector">
<div class="sc-msg-content">
<div class="sc-actions-header" style="display:flex;align-items:center;gap:.5rem;">
<strong>Actions</strong>
<label class="sc-force-option sc-force-option-auto" style="display:flex;align-items:center;gap:.25rem;">
<input type="radio" name="${name_for_radio}" class="sc-action-force-auto" />
Auto
</label>
</div>
<div class="sc-actions-list"></div>
</div>
</div>
</div>`;
}
__name(build_html56, "build_html");
async function render56(completion, params = {}) {
const html = build_html56(completion, params);
const frag = this.create_doc_fragment(html);
const container = frag.querySelector(".sc-msg.action-selector");
post_process54.call(this, completion, container, params);
return container;
}
__name(render56, "render");
async function post_process54(completion, container, params = {}) {
const env = completion.env;
const list = container.querySelector(".sc-actions-list");
const auto_radio = container.querySelector(".sc-action-force-auto");
const disposers = [];
const name_for_radio = `force-action-${completion.key}`;
const get_state = /* @__PURE__ */ __name(() => completion.data.smart_actions || {}, "get_state");
const get_all_actions = /* @__PURE__ */ __name(() => {
const collection = env.smart_actions;
if (!collection) return [];
return Object.values(collection.items || {});
}, "get_all_actions");
const any_forced_action = /* @__PURE__ */ __name((state) => {
for (const k of Object.keys(state)) if (state[k]?.force) return true;
return false;
}, "any_forced_action");
const render_list = /* @__PURE__ */ __name(() => {
list.innerHTML = "";
const actions = get_all_actions();
if (actions.length === 0) {
list.innerHTML = `<div style="color:var(--text-faint);">No actions available.</div>`;
if (auto_radio) auto_radio.checked = true;
return;
}
const state = get_state();
if (auto_radio) auto_radio.checked = !any_forced_action(state);
for (const action of actions) {
const entry_state = state[action.key] || {};
const row = document.createElement("div");
row.className = "sc-action-row";
row.style.display = "flex";
row.style.alignItems = "center";
row.style.gap = "0.5rem";
row.innerHTML = `
<label style="display:flex;align-items:center;gap:.25rem;">
<input type="checkbox" class="sc-action-active" ${entry_state.active ? "checked" : ""} />
<code>${action.key}</code>
</label>
<label title="Force this action">
<input type="radio" name="${name_for_radio}" class="sc-action-force" ${entry_state.force ? "checked" : ""} />
Force
</label>
`;
const active_box = row.querySelector(".sc-action-active");
const force_radio = row.querySelector(".sc-action-force");
active_box?.addEventListener("change", () => {
completion.use_action(action.key, { active: active_box.checked });
});
force_radio?.addEventListener("change", () => {
if (force_radio.checked) completion.use_action(action.key, { force: true, active: true });
});
list.appendChild(row);
}
}, "render_list");
if (auto_radio) {
const handle_auto_change = /* @__PURE__ */ __name(() => {
if (!auto_radio.checked) return;
const state = get_state();
for (const key of Object.keys(state)) {
if (state[key]?.force) {
completion.use_action(key, { force: false });
}
}
}, "handle_auto_change");
auto_radio.addEventListener("change", handle_auto_change);
disposers.push(() => auto_radio.removeEventListener("change", handle_auto_change));
}
render_list();
const rerender = /* @__PURE__ */ __name(() => render_list(), "rerender");
disposers.push(env.events.on("completion:actions-updated", (event) => {
if (event?.item_key !== completion.key) return;
rerender();
}));
this.attach_disposer(container, disposers);
return container;
}
__name(post_process54, "post_process");

function build_html57(completion) {
return `<div>
<div class="completion-completed">
<div class="message-header">
<div class="model-info"></div>
<button class="completion-exclude-toggle" type="button"></button>
</div>
<div class="context-included"></div>
<div class="message-user"></div>
<div class="message-action"></div>
<div class="message-assistant"></div>
</div>
</div>`;
}
__name(build_html57, "build_html");
async function render57(completion, params = {}) {
const frag = this.create_doc_fragment(build_html57(completion));
const container = frag.querySelector(".completion-completed");
post_process55.call(this, completion, container, params);
return container;
}
__name(render57, "render");
async function post_process55(completion, container, params = {}) {
const env = completion.env;
let toggle = container.querySelector(".completion-exclude-toggle");
if (toggle) {
const sync = /* @__PURE__ */ __name(() => {
const excluded = derive_exclude_flag(completion);
toggle.textContent = excluded ? "Include" : "Exclude";
toggle.setAttribute("aria-pressed", excluded ? "true" : "false");
toggle.setAttribute("aria-label", excluded ? "Include message pair in context" : "Exclude message pair from context");
}, "sync");
if (!toggle._scExcludeBound) {
toggle.addEventListener("click", () => {
const next = compute_exclude_flag(completion);
completion.data = { ...completion.data, exclude: next };
completion.queue_save();
completion.collection?.process_save_queue?.();
sync();
});
toggle._scExcludeBound = true;
}
toggle.updateState = sync;
sync();
}
const model_info = container.querySelector(".model-info");
const context_included = container.querySelector(".context-included");
const message_user = container.querySelector(".message-user");
const message_action = container.querySelector(".message-action");
const message_assistant = container.querySelector(".message-assistant");
if (model_info) {
model_info.appendChild(
await env.smart_components.render_component("completion_model_info", completion, params)
);
}
if (context_included) {
context_included.appendChild(
await env.smart_components.render_component("completion_context_included", completion, params)
);
}
if (message_user) {
message_user.appendChild(
await env.smart_components.render_component("completion_message_user", completion, params)
);
}
const has_action_call = completion.is_action_call;
if (message_action && has_action_call) {
message_action.appendChild(
await env.smart_components.render_component("completion_message_action", completion, params)
);
}
if (message_assistant) {
message_assistant.appendChild(
await env.smart_components.render_component("completion_message_assistant", completion, params)
);
}
}
__name(post_process55, "post_process");
var derive_exclude_flag = /* @__PURE__ */ __name((completion) => Boolean(completion?.data?.exclude), "derive_exclude_flag");
var compute_exclude_flag = /* @__PURE__ */ __name((completion, params = {}) => {
if (typeof params.exclude === "boolean") return params.exclude;
return !derive_exclude_flag(completion);
}, "compute_exclude_flag");

var import_obsidian97 = require("obsidian");

var import_obsidian96 = require("obsidian");

var DEFAULT_NEAR_BOTTOM_THRESHOLD_PX = 24;
function get_scroll_state(scroller, params = {}) {
if (!scroller) return null;
const {
near_bottom_threshold_px = DEFAULT_NEAR_BOTTOM_THRESHOLD_PX
} = params;
const scroll_top = scroller.scrollTop;
const client_height = scroller.clientHeight;
const scroll_height = scroller.scrollHeight;
const distance_from_bottom = scroll_height - (scroll_top + client_height);
const is_near_bottom = distance_from_bottom <= near_bottom_threshold_px;
return {
scroll_top,
scroll_height,
client_height,
is_near_bottom
};
}
__name(get_scroll_state, "get_scroll_state");
function calculate_scroll_top_after_render(params = {}) {
const { scroll_state, next_scroll_height } = params;
if (!scroll_state || typeof next_scroll_height !== "number") return null;
const { scroll_top, client_height, is_near_bottom } = scroll_state;
const max_scroll_top = Math.max(0, next_scroll_height - client_height);
if (is_near_bottom) return max_scroll_top;
return Math.min(scroll_top, max_scroll_top);
}
__name(calculate_scroll_top_after_render, "calculate_scroll_top_after_render");
function restore_scroll_position(scroller, params = {}) {
if (!scroller) return;
const { scroll_state } = params;
if (!scroll_state) return;
const next_scroll_height = scroller.scrollHeight;
const next_scroll_top = calculate_scroll_top_after_render({
scroll_state,
next_scroll_height
});
if (typeof next_scroll_top === "number") {
scroller.scrollTop = next_scroll_top;
}
}
__name(restore_scroll_position, "restore_scroll_position");

var SmartChatItemView = class _SmartChatItemView extends import_obsidian97.ItemView {
static {
__name(this, "SmartChatItemView");
}
key = "smart_chat";
/**
* @param {WorkspaceLeaf} leaf
* @param {Plugin} plugin
*/
constructor(leaf, plugin) {
super(leaf);
this.plugin = plugin;
this.plugin.env.create_env_getter(this);
this._disposers = [];
}
static last_plugin = null;
static view_type = "smart-chat-view";
/**
* Unique identifier for the view type.
* @returns {string}
*/
getViewType() {
return this.constructor.view_type;
}
static view_name = "Smart Chat";
/**
* Display text for the workspace tab.
* @returns {string}
*/
getDisplayText() {
return this.constructor.view_name;
}
static icon = "smart-chat";
/**
* Icon for the view.
* @returns {string}
*/
getIcon() {
return this.constructor.icon;
}
/**
* Backing element inside the Obsidian view content area.
* Getter falls back to the default content pane when unset.
* @returns {HTMLElement}
*/
get container() {
return this.containerEl;
}
set container(el) {
this.containerEl.empty();
this.containerEl.appendChild(el);
}
/**
* Called by Obsidian when the view is opened.
*/
onOpen() {
this.render();
}
/**
* Called by Obsidian when the view is closed.
*/
onClose() {
try {
this.containerEl.empty();
} catch {
}
}
/**
* Render the chat component into the view.
*/
async render() {
await wait_for_env_to_load(this);
const env = this.env;
const chat_threads = env.chat_threads;
const root = document.createElement("div");
root.className = "smart-chat-chat-container v3";
const threads_container = document.createElement("div");
threads_container.className = "smart-chat-threads-container";
root.appendChild(threads_container);
const render_thread = /* @__PURE__ */ __name(async () => {
if (!threads_container) return;
const previous_scroller = threads_container.querySelector(".sc-completions-container");
const scroll_state = get_scroll_state(previous_scroller);
env.smart_view?.empty?.(threads_container);
threads_container.appendChild(
await env.smart_components.render_component("chat_thread_item", this.active_thread, { item_view: this })
);
const next_scroller = threads_container.querySelector(".sc-completions-container");
restore_scroll_position(next_scroller, { scroll_state });
}, "render_thread");
await render_thread();
this.container = root;
this._dispose_all();
const off_new_chat = env.events?.on?.("smart-chat:new_chat", async () => {
const new_thread = await chat_threads.create_or_update();
this.active_thread = new_thread;
await render_thread();
});
const off_open_settings = env.events?.on?.("smart-chat:open_settings", async () => {
await this.open_settings();
});
const off_open_history = env.events?.on?.("smart-chat:open_threads_list", async (event) => {
const active_thread = this.active_thread;
env.events?.emit?.("chat_history:open", {
collection_key: "chat_threads",
item_key: active_thread?.key || event?.thread_key || ""
});
});
const off_open_help = env.events?.on?.("smart-chat:open_help", () => {
window.open("https://smartconnections.app/smart-chat/api-integration/?utm_source=smart-chat-help", "_external");
});
const off_completion_completed = env.events?.on?.("completion:completed", async (event) => {
const relevant = this?.active_thread?.completion_keys?.includes?.(event.item_key);
if (!relevant) return;
await render_thread();
});
const off_open_thread = env.events?.on?.("smart-chat:open_thread", async (event) => {
const thread_key = event?.thread_key;
if (!thread_key) return;
const thread = env.chat_threads?.items?.[thread_key];
if (!thread) return;
this.active_thread = thread;
await render_thread();
});
this._disposers.push(
off_new_chat,
off_open_settings,
off_open_history,
off_open_help,
off_completion_completed,
off_open_thread
);
}
_dispose_all() {
while (this._disposers.length) {
try {
this._disposers.pop()?.();
} catch {
}
}
}
static open(plugin = this.last_plugin) {
const existing = plugin.app.workspace.getLeavesOfType(this.view_type)[0];
if (existing) {
existing.setViewState({ type: this.view_type, active: true });
existing.view?.render();
return;
}
const root_leaf = plugin.app.workspace.getLeaf(true);
root_leaf.setViewState({ type: this.view_type, active: true });
}
/**
* Registers the Smart Chat view with the plugin.
* @param {import('obsidian').Plugin} plugin - Obsidian plugin instance.
*/
static register_view(plugin) {
if (plugin.app.plugins.enabledPlugins.has("smart-chat") && plugin.manifest.id !== "smart-chat") {
console.log(`Skipping Smart Chat registration for plugin ${plugin.manifest.id} since dedicated Smart Chat plugin is enabled.`);
return;
}
this.last_plugin = plugin;
plugin.registerView(this.view_type, (leaf) => new this(leaf, plugin));
plugin.addRibbonIcon(this.icon, "Open: " + this.view_name, () => {
this.open(plugin);
});
plugin.addCommand({
id: "open-" + this.view_type,
name: "Open " + this.view_name,
callback: /* @__PURE__ */ __name(() => this.open(plugin), "callback")
});
Object.defineProperty(plugin, "smart_chat_view", {
get: /* @__PURE__ */ __name(() => _SmartChatItemView.get_view(plugin.app.workspace), "get")
});
}
/**
* Open Smart Chat settings in Obsidian.
* @returns {Promise<void>}
*/
async open_settings() {
const app = this.env?.smart_chat_plugin?.app || window.app;
try {
await app?.setting?.open();
await app?.setting?.openTabById?.("smart-chat");
} catch (err) {
console.warn("Failed to open Smart Chat settings", err);
}
}
/**
* Retrieves the Leaf instance for this view type if it exists.
* @param {import("obsidian").Workspace} workspace
* @returns {import("obsidian").WorkspaceLeaf | undefined}
*/
static get_leaf(workspace) {
return workspace.getLeavesOfType(this.view_type)[0];
}
/**
* Retrieves the view instance if it exists.
* @param {import("obsidian").Workspace} workspace
* @returns {SmartObsidianView | undefined}
*/
static get_view(workspace) {
const leaf = this.get_leaf(workspace);
return leaf ? leaf.view : void 0;
}
get active_thread() {
if (!this._active_thread) {
const active_key = this.env?.settings?.active_chat_thread_key;
if (active_key) {
const thread = this.env?.chat_threads?.items?.[active_key];
if (thread) {
this._active_thread = thread;
return this._active_thread;
}
}
const all_threads = Object.values(this.env?.chat_threads?.items || {}).filter((t) => !t.deleted).sort((a, b) => b.key.localeCompare(a.key));
this._active_thread = all_threads[0] || this.env?.chat_threads?.new_thread();
}
return this._active_thread;
}
set active_thread(thread) {
this._active_thread = thread;
if (this.env?.settings) {
this.env.settings.active_chat_thread_key = thread?.key || "";
}
}
};

function build_html58() {
return `
<div class="smart-chat-confirm-delete-overlay" style="
position: absolute; top: 0; left: 0; right: 0; bottom: 0;
background-color: rgba(0,0,0,0.6);
display: flex; flex-direction: column;
align-items: center; justify-content: center; z-index: 9999;">
<div class="smart-chat-confirm-delete-dialog" style="
background: var(--background-primary); border: 1px solid var(--background-modifier-border);
padding: 16px; border-radius: 6px; max-width: 400px; text-align: center;">
<p style="margin-bottom: 12px; font-size: var(--font-ui-medium);">
Are you sure you want to delete this chat thread?
</p>
<div style="display: flex; gap: 12px; justify-content: center;">
<button class="smart-chat-confirm-delete-confirm">Confirm</button>
<button class="smart-chat-confirm-delete-cancel">Cancel</button>
</div>
</div>
</div>
`;
}
__name(build_html58, "build_html");
async function render58(chat_thread) {
const html = build_html58();
const frag = this.create_doc_fragment(html);
post_process56.call(this, chat_thread, frag);
return frag;
}
__name(render58, "render");
function post_process56(chat_thread, frag) {
const overlay = frag.querySelector(".smart-chat-confirm-delete-overlay");
const confirm_btn = overlay?.querySelector(".smart-chat-confirm-delete-confirm");
const cancel_btn = overlay?.querySelector(".smart-chat-confirm-delete-cancel");
confirm_btn?.addEventListener("click", async (e) => {
e.preventDefault();
chat_thread.delete();
await chat_thread.collection.process_save_queue();
SmartChatItemView.open();
});
cancel_btn?.addEventListener("click", (e) => {
e.preventDefault();
chat_thread.confirm_deletion = false;
SmartChatItemView.open();
});
return frag;
}
__name(post_process56, "post_process");

function build_html59(completion, params = {}) {
return `<div>
<div class="smart-chat-confirm-overlay" style="
position:absolute;inset:0;z-index:9999;
background-color:rgba(0,0,0,0.6);
display:flex;align-items:center;justify-content:center;">
<div class="smart-chat-confirm-dialog"
role="dialog" aria-modal="true" aria-label="Submit without context"
style="
background:var(--background-primary);
border:1px solid var(--background-modifier-border);
border-radius:8px;max-width:520px;width:92%;
box-shadow:var(--shadow-l);">
<div style="padding:16px 16px 8px 16px;">
<h4 style="margin:0 0 8px 0;font-size:var(--font-ui-medium);color:var(--text-normal);">
Submit without context?
</h4>
<p style="margin:0;color:var(--text-muted);font-size:var(--font-ui-small);">
This message doesn't have any context items attached.
You can look up relevant notes, select items manually, or continue without context.
</p>
</div>
<div style="
display:flex;gap:8px;justify-content:flex-end;align-items:center;
padding:12px 16px 16px 16px;border-top:1px solid var(--background-modifier-border);
flex-wrap:wrap;">
<button class="sc-confirm-lookup primary" type="button"
style="padding:6px 10px;border-radius:6px;border:1px solid var(--interactive-accent);
background:var(--interactive-accent);color:var(--text-on-accent);font-weight:600;">
Lookup context
</button>
<button class="sc-confirm-select secondary" type="button"
style="padding:6px 10px;border-radius:6px;border:1px solid var(--background-modifier-border);
background:var(--background-modifier-form-field);color:var(--text-normal);">
Select context
</button>
<button class="sc-confirm-continue secondary" type="button"
style="padding:6px 10px;border-radius:6px;border:1px solid var(--background-modifier-border);
background:var(--background-modifier-form-field);color:var(--text-normal);">
Continue without context
</button>
<button class="sc-confirm-cancel ghost" type="button"
style="margin-left:auto;padding:6px 10px;border-radius:6px;border:none;
background:transparent;color:var(--text-faint);">
Cancel
</button>
</div>
</div>
</div>
</div>`;
}
__name(build_html59, "build_html");
async function render59(completion, params = {}) {
const frag = this.create_doc_fragment(build_html59(completion, params));
const overlay = frag.querySelector(".smart-chat-confirm-overlay");
post_process57.call(this, completion, overlay, params);
return overlay;
}
__name(render59, "render");
function post_process57(completion, overlay, params = {}) {
const on_choice = typeof params.on_choice === "function" ? params.on_choice : () => {
};
const close = /* @__PURE__ */ __name(() => overlay?.remove(), "close");
const btn_lookup = overlay.querySelector(".sc-confirm-lookup");
const btn_select = overlay.querySelector(".sc-confirm-select");
const btn_continue = overlay.querySelector(".sc-confirm-continue");
const btn_cancel = overlay.querySelector(".sc-confirm-cancel");
btn_lookup?.addEventListener("click", () => {
on_choice("lookup");
close();
});
btn_select?.addEventListener("click", () => {
on_choice("select");
close();
});
btn_continue?.addEventListener("click", () => {
on_choice("continue");
close();
});
btn_cancel?.addEventListener("click", () => {
on_choice("cancel");
close();
});
const on_key = /* @__PURE__ */ __name((e) => {
if (e.key === "Escape") {
on_choice("cancel");
close();
}
}, "on_key");
document.addEventListener("keydown", on_key, { once: true });
return overlay;
}
__name(post_process57, "post_process");

function build_html60(completion, params = {}) {
const context = completion.context;
const keys = Object.keys(context.data?.context_items || {});
const count = keys.length;
return `<div>
<div class="sc-msg context-included">
<div class="sc-msg-content">
<div style="display:flex;align-items:center;gap:.5rem;flex-wrap:wrap;">
<strong>Context included</strong>
<span>(${count} item${count === 1 ? "" : "s"})</span>
${keys.length ? `<span style="color:var(--text-faint);">eg ${keys.slice(0, 5).join(", ")}</span>` : ""}
</div>
</div>
</div>
</div>`;
}
__name(build_html60, "build_html");
async function render60(completion, params = {}) {
const html = build_html60.call(this, completion, params);
const frag = this.create_doc_fragment(html);
const container = frag.querySelector(".sc-msg.context-included");
post_process58.call(this, completion, container, params);
return container;
}
__name(render60, "render");
async function post_process58(completion, container, params = {}) {
const env = completion.env;
const content = container.querySelector(".sc-msg-content");
const context = completion.context;
if (!context) {
content.textContent = "Context: (not found)";
return;
}
container?.addEventListener("click", async () => {
const context_tree = await env.smart_components.render_component("smart_context_tree", context);
this.empty(content);
content.appendChild(context_tree);
});
}
__name(post_process58, "post_process");

async function render61(completion) {
const frag = this.create_doc_fragment(`
<div class="context-item-container">
</div>
`);
const container = frag.firstElementChild;
post_process59.call(this, completion, container);
return container;
}
__name(render61, "render");
async function post_process59(completion, container, params = {}) {
const env = completion.env;
const context = env?.smart_contexts?.get(completion.data.context_key);
const disposers = [];
const render_item = /* @__PURE__ */ __name(async () => {
const context_item_view = await env.smart_components.render_component(
"smart_context_item",
context,
params
);
this.empty(container);
container.appendChild(context_item_view);
}, "render_item");
render_item();
disposers.push(
env.events.on("context_selector:closed", render_item)
);
this.attach_disposer(container, disposers);
return container;
}
__name(post_process59, "post_process");

var styles_default4 = `/* Completion container */\r
.completion-item {\r
display: flex;\r
flex-direction: column;\r
gap: var(--sc-space-md, var(--size-4-3, 0.75rem));\r
user-select: text;\r
container-type: inline-size;\r
\r
&:has(.completion-exclude-toggle[aria-pressed='true']) {\r
.sc-msg, .model-info {\r
opacity: 0.65;\r
outline: 1px dashed var(--sc-border-subtle);\r
filter: blur(1px);\r
}\r
}\r
/* hide context name input in smart_context_item component */\r
.sc-context-name-input {\r
display: none;\r
}\r
\r
/* When no messages yet, allow the slot to grow to fill the column */\r
&:not(:has(.sc-msg)) {\r
flex-grow: 1;\r
}\r
\r
&-toolbar {\r
display: flex;\r
justify-content: flex-end;\r
gap: var(--sc-space-sm, var(--size-4-2, 0.5rem));\r
\r
/* When there are no toolbar controls (eg new/incomplete completion),\r
collapse the toolbar row entirely so no empty bar is visible. */\r
&:empty {\r
display: none;\r
}\r
}\r
\r
&-body {\r
display: flex;\r
flex-direction: column;\r
gap: var(--sc-space-md, var(--size-4-3, 0.75rem));\r
}\r
\r
/* hide context name input in smart_context_item component */\r
.sc-context-name-input {\r
display: none;\r
}\r
}\r
\r
/* Model row + inline exclude toggle */\r
.completion-completed .message-header {\r
display: flex;\r
justify-content: space-between;\r
gap: var(--sc-space-sm, var(--size-4-2, 0.5rem));\r
border-bottom: var(--sc-border-width) solid var(--sc-border-subtle);\r
padding-bottom: var(--sc-space-sm, var(--size-4-2, 0.5rem));\r
}\r
\r
/* Exclude toggle in toolbar or inline with model */\r
.completion-exclude-toggle {\r
transition:\r
background-color var(--sc-anim-fast) var(--sc-anim-ease),\r
border-color var(--sc-anim-fast) var(--sc-anim-ease),\r
color var(--sc-anim-fast) var(--sc-anim-ease),\r
box-shadow var(--sc-anim-fast) var(--sc-anim-ease);\r
\r
&[aria-pressed='true'] {\r
background: var(--sc-accent);\r
border-color: var(--sc-accent);\r
color: var(--sc-text-on-accent);\r
}\r
\r
&:focus-visible {\r
outline: 2px solid var(--sc-accent);\r
outline-offset: 2px;\r
}\r
}\r
\r
/* Message base styles */\r
@keyframes sc-message-entry {\r
from {\r
transform: translateY(10px);\r
opacity: 0;\r
}\r
to {\r
transform: translateY(0);\r
opacity: 1;\r
}\r
}\r
\r
.sc-msg {\r
display: flex;\r
flex-direction: column;\r
position: relative;\r
border-radius: var(--sc-radius-m);\r
padding: var(--sc-space-md, var(--size-4-3, 0.75rem));\r
line-height: var(--line-height-normal, 1.5);\r
font-size: var(--sc-font-text-size);\r
animation: sc-message-entry var(--sc-anim-fast) var(--sc-anim-ease);\r
box-shadow: var(--sc-shadow-subtle);\r
overflow-wrap: anywhere;\r
\r
&.assistant {\r
justify-self: flex-start;\r
background-color: var(--sc-bg);\r
color: var(--sc-text);\r
}\r
\r
&.user {\r
justify-self: flex-end;\r
background-color: var(--sc-accent);\r
color: var(--sc-text-on-accent);\r
\r
&> * p {\r
margin: 0;\r
}\r
}\r
\r
/* System and action meta blocks are intentionally de-bubbled */\r
&.system,\r
&.action {\r
display: block !important;\r
background: none !important;\r
box-shadow: none !important;\r
border: none !important;\r
margin: 0 0 var(--sc-space-md, var(--size-4-3, 0.75rem)) 0;\r
padding: 0 !important;\r
color: var(--sc-text-faint);\r
font-size: var(--sc-font-sm);\r
}\r
\r
&.system::before,\r
&.action::before {\r
font-weight: bold;\r
font-size: var(--sc-font-smaller);\r
}\r
\r
&.system::before {\r
content: "System: ";\r
}\r
\r
&.action::before {\r
content: "Action: ";\r
}\r
}\r
\r
/* Constrain bubble width relative to container width */\r
@container (min-width: 600px) {\r
.sc-msg {\r
max-width: 70%;\r
\r
&.assistant {\r
max-width: 80%;\r
}\r
}\r
}\r
\r
/* System message editor (incomplete completion) */\r
.smart-chat-system-message-container {\r
display: flex;\r
flex-direction: row;\r
gap: var(--size-4-1, 0.25rem);\r
justify-content: space-between;\r
\r
[contenteditable] {\r
position: relative;\r
flex-grow: 1;\r
\r
&:empty::before {\r
content: attr(placeholder);\r
color: var(--sc-text-muted);\r
pointer-events: none;\r
overflow: visible;\r
}\r
}\r
}\r
\r
.smart-chat-system-message-label {\r
cursor: pointer;\r
color: var(--sc-text-faint);\r
font-size: var(--sc-font-smaller);\r
user-select: none;\r
}\r
\r
.smart-chat-system-message {\r
display: none;\r
color: var(--sc-text-muted);\r
font-size: var(--sc-font-sm);\r
background: none;\r
border: var(--sc-border-width) solid var(--sc-border-subtle);\r
padding: var(--sc-space-sm, var(--size-4-2, 0.5rem));\r
border-radius: var(--sc-radius-s);\r
outline: none;\r
min-height: 1.5em;\r
}\r
\r
.smart-chat-add-variable {\r
background: var(--sc-bg-surface);\r
border: var(--sc-border-width) solid var(--sc-border-subtle);\r
border-radius: var(--sc-radius-s);\r
color: var(--sc-text-muted);\r
cursor: pointer;\r
padding: 0 var(--sc-space-sm, var(--size-4-2, 0.5rem));\r
height: var(--size-4-5, 1.25rem);\r
}\r
\r
/* Chat input + lookup row */\r
.smart-chat-chat-input-row {\r
display: flex;\r
flex-direction: column;\r
align-items: stretch;\r
gap: var(--sc-space-sm, var(--size-4-2, 0.5rem));\r
}\r
\r
.smart-chat-lookup-row {\r
display: flex;\r
justify-content: flex-end;\r
}\r
\r
.smart-chat-chat-input-wrapper {\r
position: relative;\r
width: 100%;\r
display: flex;\r
align-items: center;\r
}\r
\r
/* Main chat input */\r
.smart-chat-chat-input[contenteditable='true'] {\r
width: 100%;\r
min-height: var(--size-4-5, 1.25rem);\r
background: var(--sc-bg-surface);\r
border: var(--sc-border-width) solid var(--sc-border-subtle);\r
color: var(--sc-text);\r
border-radius: var(--sc-radius-s);\r
padding: var(--sc-space-md, var(--size-4-3, 0.75rem));\r
padding-right: 8rem; /* space for inline controls */\r
transition:\r
border-color var(--sc-anim-fast) var(--sc-anim-ease),\r
box-shadow var(--sc-anim-fast) var(--sc-anim-ease),\r
background-color var(--sc-anim-fast) var(--sc-anim-ease);\r
font-family: var(--sc-font-text);\r
font-size: var(--sc-font-text-size);\r
outline: none;\r
\r
&:empty::before {\r
content: attr(placeholder);\r
color: var(--sc-text-muted);\r
pointer-events: none;\r
opacity: 0.7;\r
}\r
\r
&:focus {\r
border-color: var(--sc-accent-hover);\r
box-shadow: 0 0 0 1px var(--sc-accent);\r
}\r
}\r
\r
/* Inline controls inside the input box (send button) */\r
.smart-chat-inline-controls {\r
position: absolute;\r
right: var(--sc-space-md, var(--size-4-3, 0.75rem));\r
display: inline-flex;\r
align-items: center;\r
gap: var(--sc-space-xs, var(--size-2-2, 0.25rem));\r
margin-left: 0;\r
\r
&[contenteditable='false'] {\r
pointer-events: auto;\r
}\r
\r
button {\r
display: inline-flex;\r
align-items: center;\r
gap: var(--sc-space-xs, var(--size-2-1, 0.2rem));\r
font-size: var(--sc-font-small);\r
border: none;\r
cursor: pointer;\r
background: transparent;\r
padding: 0;\r
transition:\r
background-color var(--sc-anim-fast) var(--sc-anim-ease),\r
color var(--sc-anim-fast) var(--sc-anim-ease),\r
transform var(--sc-anim-fast) var(--sc-anim-ease);\r
}\r
\r
.send-button {\r
background-color: var(--sc-accent);\r
color: var(--sc-text-on-accent);\r
border-radius: var(--sc-radius-s);\r
padding: var(--size-2-3, 0.375rem);\r
\r
svg {\r
pointer-events: none;\r
}\r
\r
&:hover:not(:disabled) {\r
background-color: var(--sc-accent-hover);\r
transform: translateY(-1px);\r
}\r
\r
&:disabled {\r
background-color: var(--sc-accent-disabled);\r
color: var(--sc-text-on-accent);\r
cursor: not-allowed;\r
}\r
}\r
}\r
\r
/* Lookup context button (row above input) */\r
.lookup-context-button {\r
transition:\r
background-color var(--sc-anim-fast) var(--sc-anim-ease),\r
color var(--sc-anim-fast) var(--sc-anim-ease),\r
border-color var(--sc-anim-fast) var(--sc-anim-ease),\r
opacity var(--sc-anim-fast) var(--sc-anim-ease);\r
\r
.spinner {\r
display: none;\r
width: var(--size-4-1, 0.25rem);\r
height: var(--size-4-1, 0.25rem);\r
border-radius: 50%;\r
border: var(--sc-border-width) solid transparent;\r
border-top-color: currentColor;\r
animation: sc-inline-spinner 0.8s linear infinite;\r
}\r
\r
&.is-loading {\r
.spinner {\r
display: inline-block;\r
}\r
\r
.label {\r
opacity: 0.75;\r
}\r
}\r
\r
&:disabled {\r
opacity: 0.7;\r
cursor: not-allowed;\r
\r
&.is-loading {\r
cursor: progress;\r
}\r
}\r
\r
&:not(:disabled):hover {\r
color: var(--sc-text);\r
border-color: var(--sc-accent-hover);\r
}\r
}\r
\r
@keyframes sc-inline-spinner {\r
from {\r
transform: rotate(0deg);\r
}\r
to {\r
transform: rotate(360deg);\r
}\r
}\r
\r
/* Assistant message actions (copy button) */\r
.sc-msg-actions {\r
display: flex;\r
align-items: center;\r
height: 100%;\r
justify-content: flex-end;\r
}\r
\r
.sc-msg-copy-button {\r
position: relative;\r
display: inline-flex;\r
align-items: center;\r
justify-content: center;\r
color: var(--sc-text-on-accent);\r
border: none;\r
border-radius: var(--sc-radius-s);\r
padding: 0.35rem 0.6rem;\r
font-size: var(--sc-font-small);\r
font-weight: 600;\r
background-color: var(--sc-accent);\r
transition:\r
background-color var(--sc-anim-fast) var(--sc-anim-ease),\r
box-shadow var(--sc-anim-fast) var(--sc-anim-ease),\r
transform var(--sc-anim-fast) var(--sc-anim-ease);\r
cursor: pointer;\r
\r
&:hover {\r
transform: translateY(-1px);\r
box-shadow: var(--sc-shadow-elevated);\r
background-color: var(--sc-accent-hover);\r
}\r
}\r
\r
/* Error display on incomplete completion */\r
.completion-error pre {\r
background-color: var(--background-modifier-error, #8b0000);\r
color: var(--sc-text-on-accent);\r
border-radius: var(--sc-radius-s);\r
padding: var(--sc-space-sm, var(--size-4-2, 0.5rem));\r
margin-bottom: var(--sc-space-sm, var(--size-4-2, 0.5rem));\r
font-size: var(--sc-font-sm);\r
white-space: pre-wrap;\r
max-height: 200px;\r
overflow: auto;\r
}\r
\r
/* hide remove context item from leaf */\r
.sc-msg.context-included {\r
.sc-context-item-remove {\r
display: none;\r
}\r
}\r
\r
/* BEGIN Copied from earlier version: review and remvoe unused parts */\r
.expandable-system-message {\r
transition: max-height 0.2s cubic-bezier(.4,0,.2,1), background 0.15s;\r
}\r
.expandable-system-message.collapsed {\r
cursor: pointer;\r
}\r
.expandable-system-message.collapsed:hover,\r
.expandable-system-message.collapsed:focus {\r
background: var(--background-modifier-hover);\r
/* Removed outline/border */\r
}\r
.expandable-system-message:focus {\r
outline: 1.5px solid var(--background-modifier-border-focus, #888);\r
}\r
\r
/* Gradient overlay and indicator bar for collapsed state */\r
.expand-indicator-bar {\r
position: absolute;\r
left: 0; right: 0; bottom: 0;\r
height: 2.5em;\r
pointer-events: none;\r
background: linear-gradient(\r
to bottom,\r
/* Use background-primary with alpha for both stops */\r
rgba(var(--background-primary), 0) 0%,\r
rgba(var(--background-primary), 0.95) 80%\r
);\r
display: flex;\r
align-items: flex-end;\r
justify-content: center;\r
z-index: 1;\r
}\r
\r
.expand-indicator-bar .expand-indicator {\r
pointer-events: auto;\r
background: var(--background-primary, #fff);\r
border-radius: 0.7em;\r
font-size: 0.95em;\r
padding: 0.1em 0.7em;\r
margin-bottom: 0.3em;\r
font-weight: 500;\r
box-shadow: 0 1px 4px rgba(0,0,0,0.04);\r
cursor: pointer;\r
border: none;\r
transition: background 0.15s, color 0.15s;\r
}\r
\r
.expandable-system-message.collapsed + .expand-indicator-bar .expand-indicator:hover,\r
.expandable-system-message.collapsed + .expand-indicator-bar .expand-indicator:focus {\r
background: var(--background-modifier-hover, #f0f0f0);\r
color: var(--text-normal, #333);\r
}\r
/* END Copied from earlier version: review and remvoe unused parts */\r
\r
\r
/* BEGIN context selector */\r
.context-item-container .sc-context-view {\r
border-radius: var(--sc-radius-s);\r
padding: var(--size-4-2);\r
margin: var(--size-4-2) 0;\r
&:has(.sc-context-item-leaf) {\r
background-color: var(--background-primary-alt);\r
}\r
\r
.sc-context-actions {\r
display: flex;\r
justify-content: space-between;\r
flex-direction: row-reverse;\r
}\r
.sc-context-actions-right {\r
display: flex;\r
gap: var(--size-4-2);\r
}\r
\r
.sc-context-view-body {\r
/* padding: var(--size-4-2); */\r
}\r
\r
&:not(:has(.sc-context-item-leaf)) {\r
.sc-context-view-footer {\r
display: none;\r
}\r
}\r
}\r
/* END context selector */`;

var import_obsidian98 = require("obsidian");
function build_html61(completion) {
return `<div>
<div class="completion-item" data-completion-key="${completion.key}">
<div class="completion-item-toolbar"></div>
<div class="completion-item-body"></div>
</div>
</div>`;
}
__name(build_html61, "build_html");
async function render62(completion, params = {}) {
const frag = this.create_doc_fragment(build_html61(completion));
const container = frag.querySelector(".completion-item");
this.apply_style_sheet(styles_default4);
post_process60.call(this, completion, container, params);
return container;
}
__name(render62, "render");
async function post_process60(completion, container, params = {}) {
const env = completion.env;
const disposers = [];
const body = container.querySelector(".completion-item-body");
const toolbar = container.querySelector(".completion-item-toolbar");
container.dataset.excluded = completion.data?.exclude ? "true" : "false";
const context = completion.context;
if (context.item_count === 0) {
const last_context = completion.chat_thread?.last_completion?.context;
if (last_context) {
context.data = { ...context.data, context_items: { ...last_context.data.context_items } };
context.queue_save();
context.collection.queue_save();
context.emit_event("context:updated", { cloned: last_context.key });
}
}
const render_sub_components = /* @__PURE__ */ __name(async () => {
if (!body) return;
this.empty(body);
if (!completion.is_completed) {
body.appendChild(
await env.smart_components.render_component("completion_new", completion, params)
);
} else {
body.appendChild(
await env.smart_components.render_component("completion_completed", completion, params)
);
}
}, "render_sub_components");
render_sub_components();
const re_render_if_needed = /* @__PURE__ */ __name(async (force = false) => {
const has_completed = !!body?.querySelector(".completion-completed");
if (force || !has_completed) {
if (!body) return;
this.empty(body);
body.appendChild(
await completion.env.smart_components.render_component("completion_completed", completion, params)
);
}
}, "re_render_if_needed");
const handle_completing = /* @__PURE__ */ __name(async (event) => {
await re_render_if_needed();
const msg_elm = container.querySelector(".message-assistant .sc-msg-content");
if (msg_elm) msg_elm.textContent += event.raw || "";
}, "handle_completing");
const handle_completed = /* @__PURE__ */ __name(async () => {
await re_render_if_needed(true);
}, "handle_completed");
const handle_error = /* @__PURE__ */ __name(() => {
render_sub_components();
}, "handle_error");
const on_context_menu = /* @__PURE__ */ __name((e) => {
e.preventDefault();
const app = (env.smart_chat_plugin || env.smart_connections_plugin)?.app;
const menu = new import_obsidian98.Menu(app);
const set_exclude = /* @__PURE__ */ __name((val) => {
const excluded = Boolean(val);
completion.data = { ...completion.data, exclude: excluded };
completion.queue_save();
completion.collection?.process_save_queue?.();
container.dataset.excluded = excluded ? "true" : "false";
const toggle = container.querySelector(".completion-exclude-toggle");
toggle?.updateState?.();
}, "set_exclude");
const set_exclude_for_previous = /* @__PURE__ */ __name((val) => {
const thread = completion.chat_thread;
if (!thread) return;
const keys = thread.completion_keys || [];
const idx = keys.indexOf(completion.key);
const prev_keys = idx > 0 ? keys.slice(0, idx) : [];
for (const k of prev_keys) {
const c = env.smart_completions.get(k);
if (c) {
c.data.exclude = Boolean(val);
c.queue_save();
}
}
completion.collection?.process_save_queue?.();
}, "set_exclude_for_previous");
if (completion.data.exclude) {
menu.addItem(
(i) => i.setTitle("Include message in context").onClick(() => set_exclude(false))
);
} else {
menu.addItem(
(i) => i.setTitle("Exclude message from context").onClick(() => set_exclude(true))
);
}
menu.addItem(
(i) => i.setTitle("Exclude all prior messages").onClick(() => set_exclude_for_previous(true))
);
menu.addItem(
(i) => i.setTitle("Include all prior messages").onClick(() => set_exclude_for_previous(false))
);
menu.showAtMouseEvent(e);
}, "on_context_menu");
container.addEventListener("contextmenu", on_context_menu);
disposers.push(() => container.removeEventListener("contextmenu", on_context_menu));
disposers.push(
completion.on_event("completion:completing", handle_completing),
completion.on_event("completion:completed", handle_completed),
completion.on_event("completion:error", handle_error)
);
this.attach_disposer(container, disposers);
return container;
}
__name(post_process60, "post_process");

function build_html62(completion) {
const action = completion.data.action_key;
let action_data = completion.action_call;
if (typeof action_data === "string") {
if (action_data.endsWith('"}')) {
} else if (action_data.endsWith('",')) action_data = action_data.slice(0, -1) + "}";
else if (action_data.endsWith('","')) action_data = action_data.slice(0, -2) + '"}';
else if (action_data.endsWith('"')) action_data = action_data + "}";
else if (action_data.endsWith("{")) action_data = action_data + "}";
else if (action_data.endsWith('":')) action_data = action_data + '""}';
else if (!action_data.endsWith("]}")) action_data = action_data + '"}';
if (action_data.includes("[") && !action_data.includes("]")) action_data = action_data.slice(0, -1) + "]}";
try {
const parsed = JSON.parse(action_data);
if (parsed.final) delete parsed.final;
action_data = JSON.stringify(parsed, null, 2);
} catch (e) {
console.warn("Failed to parse action_data as JSON:", e, completion.action_call, action_data);
const last_good_i = action_data.lastIndexOf('",');
if (last_good_i !== -1) {
action_data = action_data.slice(0, last_good_i) + '"}';
try {
action_data = JSON.stringify(JSON.parse(action_data), null, 2);
} catch {
action_data = "Failed to parse action call.";
}
}
}
} else if (action_data && typeof action_data === "object") {
action_data = JSON.stringify(action_data, null, 2);
} else {
action_data = "...";
}
return `<div>
<div class="sc-msg action">
<div class="sc-msg-content">${action}${action_data ? `<pre style="white-space: pre-wrap;">${action_data}</pre>` : ""}</div>
</div>
</div>`;
}
__name(build_html62, "build_html");
async function render63(completion, opts = {}) {
const html = build_html62(completion);
const frag = this.create_doc_fragment(html);
return frag;
}
__name(render63, "render");

var import_obsidian100 = require("obsidian");

var import_obsidian99 = require("obsidian");
async function open_note(plugin, target_path, event = null, opts = {}) {
const { new_tab = false } = opts;
const env = plugin.env;
if (target_path.endsWith("#")) target_path = target_path.slice(0, -1);
let target_file;
let block = null;
if (target_path.includes("#")) {
const [file_path] = target_path.split("#");
target_file = plugin.app.metadataCache.getFirstLinkpathDest(file_path, "");
block = env.smart_blocks.get(target_path);
} else {
target_file = plugin.app.metadataCache.getFirstLinkpathDest(target_path, "");
}
if (!target_file) {
console.warn(`[open_note] Unable to resolve file for ${target_path}`);
return;
}
let leaf;
if (event) {
const is_mod = import_obsidian99.Keymap.isModEvent(event);
const is_alt = import_obsidian99.Keymap.isModifier(event, "Alt");
if (is_mod && is_alt) {
leaf = plugin.app.workspace.splitActiveLeaf("vertical");
} else if (is_mod || new_tab) {
leaf = plugin.app.workspace.getLeaf(true);
} else {
leaf = plugin.app.workspace.getMostRecentLeaf();
}
} else {
leaf = plugin.app.workspace.getMostRecentLeaf();
}
await leaf.openFile(target_file);
if (typeof block?.line_start === "number") {
const { editor } = leaf.view;
const pos = { line: block.line_start, ch: 0 };
editor.setCursor(pos);
editor.scrollIntoView({ to: pos, from: pos }, true);
}
}
__name(open_note, "open_note");

async function build_html63(completion) {
return `
<div class="sc-msg assistant">
<div class="sc-msg-content"></div>
<div class="sc-msg-actions">
<span class="sc-msg-copy-button" title="Copy raw markdown" aria-label="Copy raw markdown to clipboard">
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"
viewBox="0 0 24 24" stroke="currentColor" fill="none" stroke-width="2"
stroke-linecap="round" stroke-linejoin="round">
<path d="M8 17L8 5C8 3.89543 8.89543 3 10 3H18C19.1046 3 20 3.89543 20 5V17" stroke="currentColor" />
<rect x="4" y="7" width="14" height="14" rx="2" stroke="currentColor" />
</svg>
</span>
</div>
</div>
`;
}
__name(build_html63, "build_html");
async function render64(completion, opts = {}) {
const html = await build_html63.call(this, completion, opts);
const frag = this.create_doc_fragment(html);
if (opts.await_post_process) return await post_process61.call(this, completion, frag, opts);
else post_process61.call(this, completion, frag, opts);
return frag;
}
__name(render64, "render");
async function post_process61(completion, frag) {
const container = frag.querySelector(".sc-msg-content");
const copy_button = frag.querySelector(".sc-msg-copy-button");
this.empty(container);
const plugin = completion.env.smart_chat_plugin || completion.env.smart_connections_plugin;
await import_obsidian100.MarkdownRenderer.render(plugin.app, completion.response_text, container, "", new import_obsidian100.Component());
copy_button?.addEventListener("click", async () => {
try {
await navigator.clipboard.writeText(completion.response_text || "");
new import_obsidian100.Notice("Copied to clipboard");
} catch (err) {
console.error("Failed to copy raw markdown:", err);
}
});
container.querySelectorAll("a[href]").forEach((a) => {
const href = a.getAttribute("href");
if (!href) return;
a.addEventListener("click", (e) => {
e.preventDefault();
if (/^(https?:|obsidian:)/i.test(href)) {
if (href.startsWith("http")) window.open(href, "external");
else plugin.app.workspace.openLinkText(href, "/");
return;
}
open_note(plugin, href, e);
});
});
return frag;
}
__name(post_process61, "post_process");

var import_obsidian101 = require("obsidian");
function build_html64(completion) {
const text = completion.data.user_message || "";
return `<div>
<div class="sc-msg user">
<div class="sc-msg-content">${text}</div>
</div>
</div>`;
}
__name(build_html64, "build_html");
async function render65(completion) {
const html = build_html64(completion);
const frag = this.create_doc_fragment(html);
await post_process62.call(this, completion, frag);
return frag;
}
__name(render65, "render");
async function post_process62(completion, frag) {
const content = frag.querySelector(".sc-msg-content");
this.empty(content);
const plugin = completion.env.smart_chat_plugin || completion.env.smart_connections_plugin;
await import_obsidian101.MarkdownRenderer.render(plugin.app, completion.data.user_message, content, "", new import_obsidian101.Component());
return frag;
}
__name(post_process62, "post_process");

function build_html65(completion) {
const { model_key, provider_key } = completion.env.chat_completion_models.default.data;
return `<div class="wrapper">
<div class="model-info" data-model-key="${model_key}" data-platform-key="${provider_key}">
<div class="sc-msg-content">
Model: <code>${model_key}</code> (<code>${provider_key}</code>)
</div>
</div>
</div>`;
}
__name(build_html65, "build_html");
async function render66(completion) {
const html = build_html65(completion);
const frag = this.create_doc_fragment(html);
const container = frag.querySelector(".model-info");
return container;
}
__name(render66, "render");

function build_html66(completion) {
return `<div>
<div class="completion-new">
<div class="context-selector"></div>
<div class="action-selector"></div>
<div class="user-input"></div>
</div>
</div>`;
}
__name(build_html66, "build_html");
async function render67(completion, params = {}) {
const frag = this.create_doc_fragment(build_html66(completion));
const container = frag.querySelector(".completion-new");
post_process63.call(this, completion, container, params);
return container;
}
__name(render67, "render");
async function post_process63(completion, container, params = {}) {
const env = completion.env;
const context_selector = container.querySelector(".context-selector");
const action_selector = container.querySelector(".action-selector");
const user_input = container.querySelector(".user-input");
context_selector?.appendChild(
await env.smart_components.render_component("completion_context_selector", completion, params)
);
user_input?.appendChild(
await env.smart_components.render_component("completion_user_input", completion, params)
);
return container;
}
__name(post_process63, "post_process");

function build_html67(opts = {}) {
return `
<div class="smart-chat-confirm-missing-config-overlay" style="
position: absolute; top: 0; left: 0; right: 0; bottom: 0;
background-color: rgba(0,0,0,0.6);
display: flex; flex-direction: column;
align-items: center; justify-content: center; z-index: 9999;">
<div class="smart-chat-confirm-missing-config-dialog" style="
background: var(--background-primary); border: 1px solid var(--background-modifier-border);
padding: 16px; border-radius: 6px; max-width: 420px; text-align: center;">
<p style="margin-bottom: 12px; font-size: var(--font-ui-medium);">
${opts?.message || "No chat model configured or missing API key. Please update your Smart Chat settings."}
</p>
<div style="display: flex; gap: 12px; justify-content: center;">
<button class="smart-chat-open-settings">Open Settings</button>
</div>
</div>
</div>
`;
}
__name(build_html67, "build_html");
async function render68(chat_thread, opts = {}) {
const html = build_html67(opts);
const frag = this.create_doc_fragment(html);
post_process64.call(this, chat_thread, frag, opts);
return frag;
}
__name(render68, "render");
function post_process64(chat_thread, frag) {
const overlay = frag.querySelector(".smart-chat-confirm-missing-config-overlay");
const btn = overlay?.querySelector(".smart-chat-open-settings");
btn?.addEventListener("click", (e) => {
e.preventDefault();
chat_thread.collection.open_settings();
overlay.remove();
});
return frag;
}
__name(post_process64, "post_process");

function split_into_chunks(text, size = 1024) {
const out = [];
for (let i = 0; i < text.length; i += size) {
out.push(text.slice(i, i + size));
}
return out;
}
__name(split_into_chunks, "split_into_chunks");
function insert_text_in_chunks(el, text, opts = {}) {
const { chunk_size = 1024 } = opts;
const chunks = split_into_chunks(text, chunk_size);
if (!chunks.length) return;
const sel = window.getSelection();
const base_range = sel && sel.rangeCount ? sel.getRangeAt(0).cloneRange() : null;
let idx = 0;
const step = /* @__PURE__ */ __name(() => {
const chunk = chunks[idx++];
if (!chunk) return;
if (base_range) {
const temp_container = document.createDocumentFragment();
text_to_nodes(chunk).forEach((n) => temp_container.appendChild(n));
base_range.insertNode(temp_container);
base_range.collapse(false);
sel.removeAllRanges();
sel.addRange(base_range);
} else {
const temp_container = document.createDocumentFragment();
text_to_nodes(chunk).forEach((n) => temp_container.appendChild(n));
el.appendChild(temp_container);
}
window.requestAnimationFrame(step);
}, "step");
window.requestAnimationFrame(step);
}
__name(insert_text_in_chunks, "insert_text_in_chunks");
function text_to_nodes(txt) {
return txt.split("\n").flatMap((part, i, arr) => {
const nodes = [document.createTextNode(part)];
if (i < arr.length - 1) nodes.push(document.createElement("br"));
return nodes;
});
}
__name(text_to_nodes, "text_to_nodes");

var MIN_WORDS_FOR_LOOKUP = 3;
var MIN_CHARS_FOR_LOOKUP = 10;
var normalize_modifier_key = /* @__PURE__ */ __name((key = "") => key.toLowerCase(), "normalize_modifier_key");
var is_modifier_pressed = /* @__PURE__ */ __name((event, key) => {
if (!event) return false;
const normalized = normalize_modifier_key(key);
if (normalized === "shift") return Boolean(event.shiftKey);
if (normalized === "mod") return Boolean(event.ctrlKey || event.metaKey);
if (normalized === "alt") return Boolean(event.altKey);
if (normalized === "meta") return Boolean(event.metaKey);
return false;
}, "is_modifier_pressed");
var is_contenteditable_false = /* @__PURE__ */ __name((node) => {
if (!node) return false;
if (typeof node.getAttribute === "function") {
const attr = node.getAttribute("contenteditable");
if (attr === "false") return true;
}
if (typeof HTMLElement !== "undefined" && node instanceof HTMLElement) {
return node.contentEditable === "false";
}
return false;
}, "is_contenteditable_false");
var collect_editable_text = /* @__PURE__ */ __name((root) => {
if (!root) return "";
const doc = root.ownerDocument || document;
const win = doc.defaultView || window;
const NodeFilterRef = win.NodeFilter || NodeFilter;
const walker = doc.createTreeWalker(
root,
NodeFilterRef.SHOW_TEXT,
{
acceptNode(node) {
let el = node.parentElement;
while (el) {
if (is_contenteditable_false(el)) return NodeFilterRef.FILTER_REJECT;
el = el.parentElement;
}
return NodeFilterRef.FILTER_ACCEPT;
}
}
);
let text = "";
while (walker.nextNode()) {
text += walker.currentNode.textContent ?? "";
}
return text;
}, "collect_editable_text");
var count_words_from_text = /* @__PURE__ */ __name((text = "") => {
const trimmed = text.trim();
if (!trimmed) return 0;
return trimmed.split(/\s+/).filter(Boolean).length;
}, "count_words_from_text");
var extract_user_text = /* @__PURE__ */ __name((input_el) => collect_editable_text(input_el).trim(), "extract_user_text");
var has_prior_completed_completions = /* @__PURE__ */ __name((completion) => {
return completion.chat_thread?.last_completion?.is_completed;
}, "has_prior_completed_completions");
var create_inline_controls = /* @__PURE__ */ __name((doc) => {
const controls = doc.createElement("span");
controls.className = "smart-chat-inline-controls";
controls.setAttribute("contenteditable", "false");
const send_button = doc.createElement("button");
send_button.className = "send-button";
send_button.type = "button";
send_button.title = "Send";
send_button.setAttribute("aria-label", "Send message");
send_button.innerHTML = `
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
fill="none" viewBox="0 0 24 24" stroke="currentColor"
stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
<path d="M22 2 11 13 3 9l19-7z"></path>
<path d="M22 2 15 22l-4-9-8-4z"></path>
</svg>
`;
controls.appendChild(send_button);
return { controls, send_button };
}, "create_inline_controls");
function build_html68() {
return `<div>
<div class="completion-error" style="display:none;"></div>
<div class="smart-chat-chat-input-row new">
<div class="smart-chat-lookup-row">
<button
type="button"
class="lookup-context-button"
aria-label="Lookup context"
disabled
>
<span class="label">Lookup context</span>
<span class="spinner" aria-hidden="true"></span>
</button>
</div>
<div class="smart-chat-chat-input-wrapper">
<div
contenteditable="true"
class="smart-chat-chat-input"
placeholder="Use @ to add context. eg Based on my notes"
></div>
</div>
</div>
</div>`;
}
__name(build_html68, "build_html");
function should_send_message(e, required_modifier) {
const normalized = normalize_modifier_key(required_modifier);
if (normalized === "none") {
return !is_modifier_pressed(e, "shift") && !is_modifier_pressed(e, "mod") && !is_modifier_pressed(e, "alt") && !is_modifier_pressed(e, "meta");
}
if (normalized === "shift") return is_modifier_pressed(e, "shift");
if (normalized === "mod") return is_modifier_pressed(e, "mod");
if (normalized === "alt") return is_modifier_pressed(e, "alt");
if (normalized === "meta") return is_modifier_pressed(e, "meta");
return false;
}
__name(should_send_message, "should_send_message");
var has_context_items = /* @__PURE__ */ __name((completion) => {
try {
const ctx = completion?.env?.smart_contexts?.get?.(completion?.data?.context_key);
const items = ctx?.data?.context_items || {};
return Object.keys(items).length > 0;
} catch {
return false;
}
}, "has_context_items");
var open_no_context_dialog = /* @__PURE__ */ __name((completion, mount) => new Promise(async (resolve) => {
const overlay = await completion.env.smart_components.render_component(
"completion_confirm_send_without_context",
completion,
{
on_choice: /* @__PURE__ */ __name((choice) => resolve(choice), "on_choice")
}
);
(mount || document.body).appendChild(overlay);
}), "open_no_context_dialog");
async function render69(completion, opts = {}) {
const frag = this.create_doc_fragment(build_html68());
const container = frag.firstElementChild;
post_process65.call(this, completion, container, opts);
return container;
}
__name(render69, "render");
function post_process65(completion, container, opts = {}) {
const env = completion.env;
const error_el = container.querySelector(".completion-error");
if (completion.data.completion?.error) {
const error_pre = document.createElement("pre");
error_el.appendChild(error_pre);
error_el.style.display = "block";
error_pre.textContent = JSON.stringify(completion.data.completion.error, null, 2);
const input_el2 = container.querySelector(".smart-chat-chat-input");
input_el2.textContent = completion.data.user_message || "";
}
const input_el = container.querySelector(".smart-chat-chat-input");
const lookup_button = container.querySelector(".lookup-context-button");
const wrapper_el = container.querySelector(".smart-chat-chat-input-wrapper");
const { controls, send_button } = create_inline_controls(container.ownerDocument || document);
if (wrapper_el) wrapper_el.appendChild(controls);
let lookup_pending = false;
const disposers = [];
const refresh_input_state = /* @__PURE__ */ __name(() => {
const user_text = extract_user_text(input_el);
const has_text = user_text.length > 0;
const word_count = count_words_from_text(user_text);
const meets_threshold = word_count >= MIN_WORDS_FOR_LOOKUP || user_text.length > MIN_CHARS_FOR_LOOKUP;
const has_prior = has_prior_completed_completions(completion);
send_button.disabled = !has_text;
if (!lookup_pending) {
const should_disable_lookup = !has_prior && !meets_threshold;
lookup_button.disabled = should_disable_lookup;
lookup_button.classList.toggle("is-disabled", should_disable_lookup);
}
}, "refresh_input_state");
const set_lookup_loading = /* @__PURE__ */ __name((loading) => {
lookup_pending = loading;
lookup_button.disabled = true;
lookup_button.classList.toggle("is-loading", loading);
lookup_button.setAttribute("aria-busy", loading ? "true" : "false");
}, "set_lookup_loading");
const perform_send = /* @__PURE__ */ __name(async () => {
const user_text = extract_user_text(input_el);
if (!user_text) return;
const completion_item_el = container.closest(".completion-item");
const sys_editor = completion_item_el?.querySelector(".smart-chat-system-message");
const sys_text = sys_editor?.textContent?.trim();
const data_patch = { user_message: user_text, new_user_message: true };
if (sys_text) {
data_patch.system_message = completion.chat_thread.get_system_prompt({ system_message: sys_text });
}
completion.data = { ...completion.data, ...data_patch };
completion.init({ stream: env.chat_threads.settings.stream });
}, "perform_send");
const guarded_send = /* @__PURE__ */ __name(async () => {
const user_text = extract_user_text(input_el);
if (!user_text) return;
if (!has_context_items(completion)) {
const thread_mount = container.closest(".smart-chat-thread");
const choice = await open_no_context_dialog(completion, thread_mount);
if (choice === "lookup") {
set_lookup_loading(true);
try {
await completion.actions.completion_context_lookup_hyde();
} catch (err) {
console.warn("Lookup context failed", err);
completion.data.completion.error = err?.message || String(err);
completion.emit_event("completion:error");
set_lookup_loading(false);
refresh_input_state();
}
return;
}
if (choice === "select") {
env.events.emit("context_selector:open", {
collection_key: "smart_contexts",
item_key: completion.data.context_key
});
return;
}
if (choice !== "continue") {
return;
}
}
await perform_send();
}, "guarded_send");
send_button.addEventListener("click", (e) => {
e.preventDefault();
void guarded_send();
});
const handle_context_updated = /* @__PURE__ */ __name(() => {
if (!lookup_pending) return;
set_lookup_loading(false);
refresh_input_state();
}, "handle_context_updated");
if (completion.context?.on_event) {
const off = completion.context.on_event("context:updated", handle_context_updated);
disposers.push(off);
}
lookup_button.addEventListener("click", async () => {
if (lookup_pending || lookup_button.disabled) return;
set_lookup_loading(true);
try {
await completion.actions.completion_context_lookup_hyde();
} catch (err) {
console.warn("Lookup context failed", err);
completion.data.completion.error = err?.message || String(err);
completion.emit_event("completion:error", { error: err });
set_lookup_loading(false);
refresh_input_state();
}
});
input_el.addEventListener("keydown", (e) => {
if (e.key === "@") {
e.preventDefault();
const context = env?.smart_contexts?.get(completion.data.context_key);
context?.emit_event?.("context_selector:open");
return;
}
if (e.key !== "Enter") return;
const mod_key_setting = completion.chat_thread.settings.modifier_key_to_send || "shift";
if (should_send_message(e, mod_key_setting)) {
e.preventDefault();
void guarded_send();
} else {
e.preventDefault();
document.execCommand("insertHTML", false, "<br><br>");
}
});
let persist_timeout;
const persist_user_text = /* @__PURE__ */ __name(() => {
const user_text = extract_user_text(input_el);
if (persist_timeout) clearTimeout(persist_timeout);
persist_timeout = setTimeout(() => {
completion.data.user_message = user_text;
}, 500);
}, "persist_user_text");
const handle_input_change = /* @__PURE__ */ __name(() => {
refresh_input_state();
persist_user_text();
}, "handle_input_change");
input_el.addEventListener("input", handle_input_change);
input_el.addEventListener("keyup", handle_input_change);
function handle_paste(e) {
e.preventDefault();
const text = e.clipboardData?.getData("text/plain");
if (text) {
insert_text_in_chunks(e.currentTarget, text, { chunk_size: 2048 });
refresh_input_state();
persist_user_text();
}
}
__name(handle_paste, "handle_paste");
if (!input_el._scPasteHandler) {
input_el._scPasteHandler = handle_paste;
input_el.addEventListener("paste", input_el._scPasteHandler);
}
refresh_input_state();
this.attach_disposer(container, disposers);
}
__name(post_process65, "post_process");

function chat_suggest_completions(params = {}) {
const env = this?.env || params?.env;
if (!env?.smart_completions) return [];
const completions = Object.values(env.smart_completions.items || {}).filter((c) => c?.data?.chat_thread_key && c.response_text);
if (!completions.length) return [];
const sorted = completions.slice().sort((a, b) => {
const a_time = a.data?.created_at ?? 0;
const b_time = b.data?.created_at ?? 0;
if (a_time !== b_time) return b_time - a_time;
return b.key.localeCompare(a.key);
});
return sorted.map((completion) => {
const thread_key = completion.data?.chat_thread_key;
const thread = env.chat_threads?.items?.[thread_key];
const thread_name = (thread?.data?.name || "").trim() || `Chat ${thread_key}`;
const user_text = (completion.data?.user_message || "").trim();
const words = user_text ? user_text.split(/\s+/).filter(Boolean) : [];
const excerpt_words = words.slice(0, 16).join(" ");
const has_more = words.length > 16;
const excerpt = excerpt_words ? excerpt_words + (has_more ? "\u2026" : "") : "(no user message)";
const display = `${thread_name} \u2014 ${excerpt}`;
return {
key: completion.key,
display,
icon: "message-circle",
select_action: /* @__PURE__ */ __name(({ modal }) => {
if (!thread_key) return;
modal.prevent_close = false;
env.settings = env.settings || {};
env.settings.active_chat_thread_key = thread_key;
env.events?.emit?.("smart-chat:open_thread", {
thread_key,
completion_key: completion.key
});
if (modal && typeof modal.close === "function") {
modal.close();
}
}, "select_action")
};
});
}
__name(chat_suggest_completions, "chat_suggest_completions");
var display_name7 = "Messages";

function chat_suggest_threads(params = {}) {
const env = this?.env || params?.env;
if (!env?.chat_threads) return [];
const active_key = env.settings?.active_chat_thread_key || "";
const threads = Object.values(env.chat_threads.items || {}).filter((t) => !t.deleted);
if (!threads.length) return [];
const sorted = threads.slice().sort((a, b) => {
const a_time = a.data?.created_at ?? 0;
const b_time = b.data?.created_at ?? 0;
if (a_time !== b_time) return b_time - a_time;
return b.key.localeCompare(a.key);
});
return sorted.map((thread) => {
const name = (thread.data?.name || "").trim() || `Chat ${thread.key}`;
const preview_source = thread.last_completion?.data?.user_message || thread.current_completion?.data?.user_message || "";
const preview_raw = (preview_source || "").trim();
const preview = preview_raw.length > 0 ? preview_raw.slice(0, 80) + (preview_raw.length > 80 ? "\u2026" : "") : "";
const is_active = thread.key === active_key;
const label = is_active ? `${name} (current)` : name;
const display = preview ? `${label} \u2014 ${preview}` : label;
return {
key: thread.key,
display,
icon: "messages-square",
select_action: /* @__PURE__ */ __name(({ modal }) => {
modal.prevent_close = false;
env.settings = env.settings || {};
env.settings.active_chat_thread_key = thread.key;
env.events?.emit?.("smart-chat:open_thread", {
thread_key: thread.key
});
if (modal && typeof modal.close === "function") {
modal.close();
}
}, "select_action"),
mod_select_action: /* @__PURE__ */ __name(({ modal }) => delete_chat_thread_action(thread, { env, modal }), "mod_select_action")
};
});
}
__name(chat_suggest_threads, "chat_suggest_threads");
var display_name8 = "Chat threads";
async function delete_chat_thread_action(thread, params = {}) {
if (!thread) return [];
const { env, modal } = params;
const confirm_fn = params.confirm_fn || globalThis.confirm;
const thread_name = (thread.data?.name || "").trim() || `Chat ${thread.key}`;
const allow_delete = confirm_fn?.(`Delete "${thread_name}"? This cannot be undone.`);
if (!allow_delete) return [];
if (typeof thread.delete === "function") {
thread.delete();
} else {
thread.deleted = true;
}
if (thread.collection && typeof thread.collection.process_save_queue === "function") {
await thread.collection.process_save_queue();
}
if (env?.settings?.active_chat_thread_key === thread.key) {
env.settings.active_chat_thread_key = "";
}
return chat_suggest_threads({ env });
}
__name(delete_chat_thread_action, "delete_chat_thread_action");

async function completion_context_lookup_hyde(params = {}) {
const completion = this;
const smart_context = this.context;
if (!smart_context) {
return { error: "Missing ContextCompletionAdapter" };
}
const env = this.env;
const CompletionItem = env.smart_completions.item_type;
const thread_action_settings = completion.chat_thread?.settings?.actions?.lookup_context || {};
const hyde_completion = new CompletionItem(env, {
...JSON.parse(JSON.stringify(completion.data)),
key: this.key + "-context-lookup-hyde-" + Date.now(),
smart_actions: {
lookup_context: {
...thread_action_settings,
active: true,
force: true,
context_key: completion.data.context_key
}
},
user_message: null
});
env.smart_completions.set(hyde_completion);
console.log("Starting HYDE completion for context lookup:", hyde_completion);
await hyde_completion.init();
if (hyde_completion.data.completion?.error) {
throw new Error("Lookup completion error: " + JSON.stringify(hyde_completion.data.completion.error, null, 2));
}
}
__name(completion_context_lookup_hyde, "completion_context_lookup_hyde");

async function think(params = {}) {
return {
white_hat: params.white_hat || "",
red_hat: params.red_hat || "",
black_hat: params.black_hat || "",
yellow_hat: params.yellow_hat || "",
green_hat: params.green_hat || "",
blue_hat: params.blue_hat || "",
final: params.final || "(No final conclusion provided)"
};
}
__name(think, "think");

var smart_env_config8 = {
collections: {
chat_threads: chat_threads_default,
completion_sequences: completion_sequences_default,
sequences: sequences_default,
smart_actions: smart_actions_default2,
smart_completions: smart_completions_default
},
item_types: {
ChatThread,
CompletionSequence,
SmartAction
},
items: {
chat_thread: { class: ChatThread },
completion_sequence: { class: CompletionSequence },
smart_action: { class: SmartAction }
},
modules: {},
components: {
chat_thread_actions: { render: render53 },
chat_thread_item: { render: render54 },
chat_thread_status_bar: { render: render55 },
completion_action_selector: { render: render56 },
completion_completed: { render: render57 },
completion_confirm_delete: { render: render58 },
completion_confirm_send_without_context: { render: render59 },
completion_context_included: { render: render60 },
completion_context_selector: { render: render61 },
completion_item: { render: render62 },
completion_message_action: { render: render63 },
completion_message_assistant: { render: render64 },
completion_message_user: { render: render65 },
completion_model_info: { render: render66 },
completion_new: { render: render67 },
completion_overlay_requires_settings: { render: render68 },
completion_user_input: { render: render69 }
},
actions: {
chat_suggest_completions: { action: chat_suggest_completions, display_name: display_name7 },
chat_suggest_threads: { action: chat_suggest_threads, display_name: display_name8 },
completion_context_lookup_hyde: { action: completion_context_lookup_hyde },
lookup_context: { action: lookup_context },
think: { action: think }
}
};

var import_obsidian102 = require("obsidian");
var ChatHistoryModal = class extends SmartFuzzySuggestModal {
static {
__name(this, "ChatHistoryModal");
}
/** Modal identity */
static get modal_type() {
return "chat_history";
}
static get display_text() {
return "Chat History";
}
static get event_domain() {
return "chat_history";
}
static get command_id() {
return this.modal_type;
}
static get modal_key() {
return "chat_history";
}
get modal_key() {
return "chat_history";
}
/**
* @param {Object} item_or_collection - any env-backed object (eg ChatThread)
* @param {Object} [params]
* @param {string[]} [params.default_suggest_action_keys] overrides for suggestion scopes
*/
constructor(item_or_collection, params = {}) {
super(item_or_collection);
this.params = params;
this.emptyStateText = "No chat history found";
const mod_label = import_obsidian102.Platform.isMacOS ? "Cmd+Enter" : "Ctrl+Enter";
this.setInstructions?.([
{ command: "Enter", purpose: "Open chat" },
{ command: mod_label, purpose: "Delete chat" },
{ command: "Esc", purpose: "Close" }
]);
}
};

var default_config = {
modals: {
chat_history: {
class: ChatHistoryModal,
default_suggest_action_keys: [
"chat_suggest_threads"
]
}
}
};
var smart_env_config9 = merge_env_config(
smart_env_config6,
merge_env_config(
smart_env_config3,
default_config
)
);

var SmartChatPlugin = class extends SmartPlugin {
static {
__name(this, "SmartChatPlugin");
}
SmartEnv = SmartEnv5;
compiled_smart_env_config = merge_env_config(smart_env_config8, smart_env_config9);
onload() {
this.SmartEnv.create(this, this.compiled_smart_env_config);
this.app.workspace.onLayoutReady(this.initialize.bind(this));
}
async initialize() {
console.log("Loading Smart Chat plugin...");
await this.SmartEnv.wait_for({ loaded: true });
SmartChatItemView.register_view(this);
this.addSettingTab(new SmartChatSettingTab(this.app, this));
this.env.config.modals.chat_history.class.register_modal(this);
}
};

const smart_hash_id='b2733ca5b6f933e6d9270fdb1236c755672735a5f45434f868109ef5865bd421';